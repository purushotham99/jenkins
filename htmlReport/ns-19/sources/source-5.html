


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Search</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.search</a>
</div>

<h1>Coverage Summary for Class: Search (hudson.search)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Search</td>
<td class="coverageStat">
  <span class="percent">
    43.8%
  </span>
  <span class="absValue">
    (7/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.1%
  </span>
  <span class="absValue">
    (53/115)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Search$1Tag</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$Item</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$Mode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$Mode$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$Mode$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$Result</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$SearchResultImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$TokenList</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Search$TokenList$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (21/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50.7%
  </span>
  <span class="absValue">
    (77/152)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Yahoo!, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.search;
&nbsp;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.Util;
&nbsp;import hudson.util.EditDistance;
&nbsp;import java.io.IOException;
&nbsp;import java.util.AbstractList;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import javax.servlet.ServletException;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.util.MemoryReductionUtil;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.Ancestor;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.StaplerProxy;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.export.DataWriter;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.export.Flavor;
&nbsp;
&nbsp;/**
&nbsp; * Web-bound object that provides search/navigation capability.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This object is bound to &quot;./search&quot; of a model object via {@link SearchableModelObject} and serves
&nbsp; * HTTP requests coming from JavaScript to provide search result and auto-completion.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see SearchableModelObject
&nbsp; */
<b class="nc">&nbsp;public class Search implements StaplerProxy {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Limits the maximum number of search results.
&nbsp;     */
<b class="fc">&nbsp;    private static /* nonfinal for Jenkins script console */ int MAX_SEARCH_SIZE = Integer.getInteger(Search.class.getName() + &quot;.MAX_SEARCH_SIZE&quot;, 500);</b>
&nbsp;
&nbsp;    public void doIndex(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        List&lt;Ancestor&gt; l = req.getAncestors();</b>
<b class="nc">&nbsp;        for (int i = l.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            Ancestor a = l.get(i);</b>
<b class="nc">&nbsp;            if (a.getObject() instanceof SearchableModelObject) {</b>
<b class="nc">&nbsp;                SearchableModelObject smo = (SearchableModelObject) a.getObject();</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                    LOGGER.fine(String.format(&quot;smo.displayName=%s, searchName=%s&quot;, smo.getDisplayName(), smo.getSearchName()));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                SearchIndex index = smo.getSearchIndex();</b>
<b class="nc">&nbsp;                String query = req.getParameter(&quot;q&quot;);</b>
<b class="nc">&nbsp;                if (query != null) {</b>
<b class="nc">&nbsp;                    SuggestedItem target = find(index, query, smo);</b>
<b class="nc">&nbsp;                    if (target != null) {</b>
&nbsp;                        // found
<b class="nc">&nbsp;                        rsp.sendRedirect2(req.getContextPath() + target.getUrl());</b>
&nbsp;                        return;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // no exact match. show the suggestions
<b class="nc">&nbsp;        rsp.setStatus(SC_NOT_FOUND);</b>
<b class="nc">&nbsp;        req.getView(this, &quot;search-failed.jelly&quot;).forward(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used by OpenSearch auto-completion. Returns JSON array of the form:
&nbsp;     *
&nbsp;     * &lt;pre&gt;
&nbsp;     * [&quot;queryString&quot;,[&quot;comp1&quot;,&quot;comp2&quot;,...]]
&nbsp;     * &lt;/pre&gt;
&nbsp;     *
&nbsp;     * See http://developer.mozilla.org/en/docs/Supporting_search_suggestions_in_search_plugins
&nbsp;     */
&nbsp;    public void doSuggestOpenSearch(StaplerRequest req, StaplerResponse rsp, @QueryParameter String q) throws IOException, ServletException {
<b class="nc">&nbsp;        rsp.setContentType(Flavor.JSON.contentType);</b>
<b class="nc">&nbsp;        DataWriter w = Flavor.JSON.createDataWriter(null, rsp);</b>
<b class="nc">&nbsp;        w.startArray();</b>
<b class="nc">&nbsp;        w.value(q);</b>
&nbsp;
<b class="nc">&nbsp;        w.startArray();</b>
<b class="nc">&nbsp;        for (SuggestedItem item : getSuggestions(req, q))</b>
<b class="nc">&nbsp;            w.value(item.getPath());</b>
<b class="nc">&nbsp;        w.endArray();</b>
<b class="nc">&nbsp;        w.endArray();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used by search box auto-completion. Returns JSON array.
&nbsp;     */
&nbsp;    public void doSuggest(StaplerRequest req, StaplerResponse rsp, @QueryParameter String query) throws IOException, ServletException {
<b class="nc">&nbsp;        Result r = new Result();</b>
<b class="nc">&nbsp;        for (SuggestedItem item : getSuggestions(req, query))</b>
<b class="nc">&nbsp;            r.suggestions.add(new Item(item.getPath()));</b>
&nbsp;
<b class="nc">&nbsp;        rsp.serveExposedBean(req, r, Flavor.JSON);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the list of suggestions that match the given query.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      can be empty but never null. The size of the list is always smaller than
&nbsp;     *      a certain threshold to avoid showing too many options.
&nbsp;     */
&nbsp;    public SearchResult getSuggestions(StaplerRequest req, String query) {
<b class="nc">&nbsp;        Set&lt;String&gt; paths = new HashSet&lt;&gt;();  // paths already added, to control duplicates</b>
<b class="nc">&nbsp;        SearchResultImpl r = new SearchResultImpl();</b>
<b class="nc">&nbsp;        int max = Math.min(</b>
<b class="nc">&nbsp;                req.hasParameter(&quot;max&quot;) ? Integer.parseInt(req.getParameter(&quot;max&quot;)) : 100,</b>
&nbsp;                MAX_SEARCH_SIZE
&nbsp;        );
<b class="nc">&nbsp;        SearchableModelObject smo = findClosestSearchableModelObject(req);</b>
<b class="nc">&nbsp;        for (SuggestedItem i : suggest(makeSuggestIndex(req), query, smo)) {</b>
<b class="nc">&nbsp;            if (r.size() &gt;= max) {</b>
<b class="nc">&nbsp;                r.hasMoreResults = true;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (paths.add(i.getPath()))</b>
<b class="nc">&nbsp;                r.add(i);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getMaxSearchSize() {
<b class="nc">&nbsp;        return MAX_SEARCH_SIZE;</b>
&nbsp;    }
&nbsp;
&nbsp;    private @CheckForNull SearchableModelObject findClosestSearchableModelObject(StaplerRequest req) {
<b class="nc">&nbsp;        List&lt;Ancestor&gt; l = req.getAncestors();</b>
<b class="nc">&nbsp;        for (int i = l.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;            Ancestor a = l.get(i);</b>
<b class="nc">&nbsp;            if (a.getObject() instanceof SearchableModelObject) {</b>
<b class="nc">&nbsp;                return (SearchableModelObject) a.getObject();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates merged search index for suggestion.
&nbsp;     */
&nbsp;    private SearchIndex makeSuggestIndex(StaplerRequest req) {
<b class="nc">&nbsp;        SearchIndexBuilder builder = new SearchIndexBuilder();</b>
<b class="nc">&nbsp;        for (Ancestor a : req.getAncestors()) {</b>
<b class="nc">&nbsp;            if (a.getObject() instanceof SearchableModelObject) {</b>
<b class="nc">&nbsp;                SearchableModelObject smo = (SearchableModelObject) a.getObject();</b>
<b class="nc">&nbsp;                builder.add(smo.getSearchIndex());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return builder.make();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class SearchResultImpl extends ArrayList&lt;SuggestedItem&gt; implements SearchResult {</b>
&nbsp;
<b class="nc">&nbsp;        private boolean hasMoreResults = false;</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasMoreResults() {
<b class="nc">&nbsp;            return hasMoreResults;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @ExportedBean
<b class="nc">&nbsp;    public static class Result {</b>
<b class="nc">&nbsp;        @Exported</b>
&nbsp;        public List&lt;Item&gt; suggestions = new ArrayList&lt;&gt;();
&nbsp;    }
&nbsp;
&nbsp;    @ExportedBean(defaultVisibility = 999)
&nbsp;    public static class Item {
&nbsp;        @Exported
&nbsp;        @SuppressFBWarnings(value = &quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, justification = &quot;read by Stapler&quot;)
&nbsp;        public String name;
&nbsp;
<b class="nc">&nbsp;        public Item(String name) {</b>
<b class="nc">&nbsp;            this.name = name;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private enum Mode {</b>
<b class="fc">&nbsp;        FIND {</b>
&nbsp;            @Override
&nbsp;            void find(SearchIndex index, String token, List&lt;SearchItem&gt; result) {
<b class="fc">&nbsp;                index.find(token, result);</b>
&nbsp;            }
&nbsp;        },
<b class="fc">&nbsp;        SUGGEST {</b>
&nbsp;            @Override
&nbsp;            void find(SearchIndex index, String token, List&lt;SearchItem&gt; result) {
<b class="fc">&nbsp;                index.suggest(token, result);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        abstract void find(SearchIndex index, String token, List&lt;SearchItem&gt; result);
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When there are multiple suggested items, this method can narrow down the resultset
&nbsp;     * to the SuggestedItem that has a url that contains the query. This is useful is one
&nbsp;     * job has a display name that matches another job&#39;s project name.
&nbsp;     * @param r A list of Suggested items. It is assumed that there is at least one
&nbsp;     * SuggestedItem in r.
&nbsp;     * @param query A query string
&nbsp;     * @return Returns the SuggestedItem which has a search url that contains the query.
&nbsp;     * If no SuggestedItems have a search url which contains the query, then the first
&nbsp;     * SuggestedItem in the List is returned.
&nbsp;     */
&nbsp;    static SuggestedItem findClosestSuggestedItem(List&lt;SuggestedItem&gt; r, String query) {
<b class="fc">&nbsp;        for (SuggestedItem curItem : r) {</b>
<b class="fc">&nbsp;            if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                LOGGER.fine(String.format(&quot;item&#39;s searchUrl:%s;query=%s&quot;, curItem.item.getSearchUrl(), query));</b>
&nbsp;            }
<b class="fc">&nbsp;            if (curItem.item.getSearchUrl().contains(Util.rawEncode(query))) {</b>
<b class="fc">&nbsp;                return curItem;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // couldn&#39;t find an item with the query in the url so just
&nbsp;        // return the first one
<b class="fc">&nbsp;        return r.get(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Use {@link Search#find(SearchIndex, String, SearchableModelObject)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static SuggestedItem find(SearchIndex index, String query) {
<b class="fc">&nbsp;        return find(index, query, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs a search and returns the match, or null if no match was found
&nbsp;     * or more than one match was found.
&nbsp;     * @since 1.527
&nbsp;     */
&nbsp;    public static SuggestedItem find(SearchIndex index, String query, SearchableModelObject searchContext) {
<b class="fc">&nbsp;        List&lt;SuggestedItem&gt; r = find(Mode.FIND, index, query, searchContext);</b>
<b class="fc">&nbsp;        if (r.isEmpty()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        else if (1 == r.size()) {</b>
<b class="fc">&nbsp;            return r.get(0);</b>
&nbsp;        }
&nbsp;        else  {
&nbsp;            // we have more than one suggested item, so return the item who&#39;s url
&nbsp;            // contains the query as this is probably the job&#39;s name
<b class="nc">&nbsp;            return findClosestSuggestedItem(r, query);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated use {@link Search#suggest(SearchIndex, String, SearchableModelObject)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static List&lt;SuggestedItem&gt; suggest(SearchIndex index, final String tokenList) {
<b class="fc">&nbsp;        return suggest(index, tokenList, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.527
&nbsp;     */
&nbsp;    public static List&lt;SuggestedItem&gt; suggest(SearchIndex index, final String tokenList, SearchableModelObject searchContext) {
&nbsp;
&nbsp;        class Tag implements Comparable&lt;Tag&gt; {
&nbsp;            final SuggestedItem item;
&nbsp;            final int distance;
&nbsp;            /** If the path to this suggestion starts with the token list, 1. Otherwise 0. */
&nbsp;            final int prefixMatch;
&nbsp;
<b class="fc">&nbsp;            Tag(SuggestedItem i) {</b>
<b class="fc">&nbsp;                item = i;</b>
<b class="fc">&nbsp;                distance = EditDistance.editDistance(i.getPath(), tokenList);</b>
<b class="fc">&nbsp;                prefixMatch = i.getPath().startsWith(tokenList) ? 1 : 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int compareTo(Tag that) {
<b class="fc">&nbsp;                int r = this.prefixMatch - that.prefixMatch;</b>
<b class="fc">&nbsp;                if (r != 0)    return -r;  // ones with head match should show up earlier</b>
<b class="fc">&nbsp;                return this.distance - that.distance;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        List&lt;Tag&gt; buf = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;SuggestedItem&gt; items = find(Mode.SUGGEST, index, tokenList, searchContext);</b>
&nbsp;
&nbsp;        // sort them
<b class="fc">&nbsp;        for (SuggestedItem i : items)</b>
<b class="fc">&nbsp;            buf.add(new Tag(i));</b>
<b class="fc">&nbsp;        Collections.sort(buf);</b>
<b class="fc">&nbsp;        items.clear();</b>
<b class="fc">&nbsp;        for (Tag t : buf)</b>
<b class="fc">&nbsp;            items.add(t.item);</b>
&nbsp;
<b class="fc">&nbsp;        return items;</b>
&nbsp;    }
&nbsp;
&nbsp;    static final class TokenList {
&nbsp;        private final String[] tokens;
&nbsp;
<b class="fc">&nbsp;        TokenList(String tokenList) {</b>
<b class="fc">&nbsp;            tokens = tokenList != null ? tokenList.split(&quot;(?&lt;=\\s)(?=\\S)&quot;) : MemoryReductionUtil.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public int length() { return tokens.length; }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@link List} such that its {@code get(end)}
&nbsp;         * returns the concatenation of [token_start,...,token_end]
&nbsp;         * (both end inclusive.)
&nbsp;         */
&nbsp;        public List&lt;String&gt; subSequence(final int start) {
<b class="fc">&nbsp;            return new AbstractList&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public String get(int index) {
<b class="fc">&nbsp;                    StringBuilder buf = new StringBuilder();</b>
<b class="fc">&nbsp;                    for (int i = start; i &lt;= start + index; i++)</b>
<b class="fc">&nbsp;                        buf.append(tokens[i]);</b>
<b class="fc">&nbsp;                    return buf.toString().trim();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int size() {
<b class="fc">&nbsp;                    return tokens.length - start;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder s = new StringBuilder(&quot;TokenList{&quot;);</b>
<b class="nc">&nbsp;            for (String token : tokens) {</b>
<b class="nc">&nbsp;                s.append(token);</b>
<b class="nc">&nbsp;                s.append(&quot;,&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            s.append(&#39;}&#39;);</b>
&nbsp;
<b class="nc">&nbsp;            return s.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;SuggestedItem&gt; find(Mode m, SearchIndex index, String tokenList, SearchableModelObject searchContext) {
<b class="fc">&nbsp;        TokenList tokens = new TokenList(tokenList);</b>
<b class="fc">&nbsp;        if (tokens.length() == 0) return Collections.emptyList();   // no tokens given</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;SuggestedItem&gt;[] paths = new List[tokens.length() + 1]; // we won&#39;t use [0].</b>
<b class="fc">&nbsp;        for (int i = 1; i &lt;= tokens.length(); i++)</b>
<b class="fc">&nbsp;            paths[i] = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;SearchItem&gt; items = new ArrayList&lt;&gt;(); // items found in 1 step</b>
&nbsp;
<b class="fc">&nbsp;        LOGGER.log(Level.FINE, &quot;tokens={0}&quot;, tokens);</b>
&nbsp;
&nbsp;        // first token
<b class="fc">&nbsp;        int w = 1;    // width of token</b>
<b class="fc">&nbsp;        for (String token : tokens.subSequence(0)) {</b>
<b class="fc">&nbsp;            items.clear();</b>
<b class="fc">&nbsp;            m.find(index, token, items);</b>
<b class="fc">&nbsp;            for (SearchItem si : items) {</b>
<b class="fc">&nbsp;                paths[w].add(SuggestedItem.build(searchContext, si));</b>
<b class="fc">&nbsp;                LOGGER.log(Level.FINE, &quot;found search item: {0}&quot;, si.getSearchName());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            w++;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // successive tokens
<b class="fc">&nbsp;        for (int j = 1; j &lt; tokens.length(); j++) {</b>
&nbsp;            // for each length
<b class="fc">&nbsp;            w = 1;</b>
<b class="fc">&nbsp;            for (String token : tokens.subSequence(j)) {</b>
&nbsp;                // for each candidate
<b class="fc">&nbsp;                for (SuggestedItem r : paths[j]) {</b>
<b class="fc">&nbsp;                    items.clear();</b>
<b class="fc">&nbsp;                    m.find(r.item.getSearchIndex(), token, items);</b>
<b class="fc">&nbsp;                    for (SearchItem i : items)</b>
<b class="fc">&nbsp;                        paths[j + w].add(new SuggestedItem(r, i));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                w++;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return paths[tokens.length()];</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Object getTarget() {
<b class="nc">&nbsp;        if (!SKIP_PERMISSION_CHECK) {</b>
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.READ);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Escape hatch for StaplerProxy-based access control
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
&nbsp;    @Restricted(NoExternalUse.class)
<b class="fc">&nbsp;    public static /* Script Console modifiable */ boolean SKIP_PERMISSION_CHECK = SystemProperties.getBoolean(Search.class.getName() + &quot;.skipPermissionCheck&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Search.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
