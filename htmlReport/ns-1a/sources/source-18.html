


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > HudsonPrivateSecurityRealm</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.security</a>
</div>

<h1>Coverage Summary for Class: HudsonPrivateSecurityRealm (hudson.security)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HudsonPrivateSecurityRealm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/181)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$DescriptorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$Details</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$Details$ConverterImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$Details$DescriptorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$Details$UserDetailsImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$JBCryptEncoder</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (5/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$ManageUserLinks</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$MultiPasswordEncoder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$PBKDF2PasswordEncoder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HudsonPrivateSecurityRealm$SignupInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    13.1%
  </span>
  <span class="absValue">
    (14/107)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (38/341)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, David Calavera, Seiji Sogabe
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.security;
&nbsp;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;
&nbsp;
&nbsp;import com.thoughtworks.xstream.converters.UnmarshallingContext;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionList;
&nbsp;import hudson.Util;
&nbsp;import hudson.diagnosis.OldDataMonitor;
&nbsp;import hudson.model.Descriptor;
&nbsp;import hudson.model.ManagementLink;
&nbsp;import hudson.model.ModelObject;
&nbsp;import hudson.model.User;
&nbsp;import hudson.model.UserProperty;
&nbsp;import hudson.model.UserPropertyDescriptor;
&nbsp;import hudson.security.FederatedLoginService.FederatedIdentity;
&nbsp;import hudson.security.captcha.CaptchaSupport;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.PluginServletFilter;
&nbsp;import hudson.util.Protector;
&nbsp;import hudson.util.Scrambler;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.security.MessageDigest;
&nbsp;import java.security.NoSuchAlgorithmException;
&nbsp;import java.security.SecureRandom;
&nbsp;import java.security.spec.InvalidKeySpecException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Random;
&nbsp;import java.util.Set;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import javax.crypto.SecretKeyFactory;
&nbsp;import javax.crypto.spec.PBEKeySpec;
&nbsp;import javax.servlet.Filter;
&nbsp;import javax.servlet.FilterChain;
&nbsp;import javax.servlet.FilterConfig;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.servlet.ServletRequest;
&nbsp;import javax.servlet.ServletResponse;
&nbsp;import javax.servlet.http.HttpServletRequest;
&nbsp;import javax.servlet.http.HttpServletResponse;
&nbsp;import javax.servlet.http.HttpSession;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.security.FIPS140;
&nbsp;import jenkins.security.SecurityListener;
&nbsp;import jenkins.security.seed.UserSeedProperty;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.jenkinsci.Symbol;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.DataBoundConstructor;
&nbsp;import org.kohsuke.stapler.ForwardToView;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.mindrot.jbcrypt.BCrypt;
&nbsp;import org.springframework.security.authentication.BadCredentialsException;
&nbsp;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;import org.springframework.security.core.AuthenticationException;
&nbsp;import org.springframework.security.core.GrantedAuthority;
&nbsp;import org.springframework.security.core.context.SecurityContextHolder;
&nbsp;import org.springframework.security.core.userdetails.UserDetails;
&nbsp;import org.springframework.security.core.userdetails.UsernameNotFoundException;
&nbsp;import org.springframework.security.crypto.password.PasswordEncoder;
&nbsp;
&nbsp;/**
&nbsp; * {@link SecurityRealm} that performs authentication by looking up {@link User}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Implements {@link AccessControlled} to satisfy view rendering, but in reality the access control
&nbsp; * is done against the {@link jenkins.model.Jenkins} object.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;public class HudsonPrivateSecurityRealm extends AbstractPasswordBasedSecurityRealm implements ModelObject, AccessControlled {
&nbsp;    private static final int FIPS_PASSWORD_LENGTH = 14;
<b class="nc">&nbsp;    private static /* not final */ String ID_REGEX = System.getProperty(HudsonPrivateSecurityRealm.class.getName() + &quot;.ID_REGEX&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Default REGEX for the user ID check in case the ID_REGEX is not set
&nbsp;     * It allows A-Za-z0-9 + &quot;_-&quot;
&nbsp;     * in Java {@code \w} is equivalent to {@code [A-Za-z0-9_]} (take care of &quot;_&quot;)
&nbsp;     */
&nbsp;    private static final String DEFAULT_ID_REGEX = &quot;^[\\w-]+$&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * If true, sign up is not allowed.
&nbsp;     * &lt;p&gt;
&nbsp;     * This is a negative switch so that the default value &#39;false&#39; remains compatible with older installations.
&nbsp;     */
&nbsp;    private final boolean disableSignup;
&nbsp;
&nbsp;    /**
&nbsp;     * If true, captcha will be enabled.
&nbsp;     */
&nbsp;    private final boolean enableCaptcha;
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public HudsonPrivateSecurityRealm(boolean allowsSignup) {
<b class="nc">&nbsp;        this(allowsSignup, false, (CaptchaSupport) null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundConstructor
<b class="nc">&nbsp;    public HudsonPrivateSecurityRealm(boolean allowsSignup, boolean enableCaptcha, CaptchaSupport captchaSupport) {</b>
<b class="nc">&nbsp;        this.disableSignup = !allowsSignup;</b>
<b class="nc">&nbsp;        this.enableCaptcha = enableCaptcha;</b>
<b class="nc">&nbsp;        setCaptchaSupport(captchaSupport);</b>
<b class="nc">&nbsp;        if (!allowsSignup &amp;&amp; !hasSomeUser()) {</b>
&nbsp;            // if Hudson is newly set up with the security realm and there&#39;s no user account created yet,
&nbsp;            // insert a filter that asks the user to create one
&nbsp;            try {
<b class="nc">&nbsp;                PluginServletFilter.addFilter(CREATE_FIRST_USER_FILTER);</b>
<b class="nc">&nbsp;            } catch (ServletException e) {</b>
<b class="nc">&nbsp;                throw new AssertionError(e); // never happen because our Filter.init is no-op</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean allowsSignup() {
<b class="nc">&nbsp;        return !disableSignup;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class) // Jelly
&nbsp;    public boolean getAllowsSignup() {
<b class="nc">&nbsp;        return allowsSignup();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if captcha is enabled on user signup.
&nbsp;     *
&nbsp;     * @return true if captcha is enabled on signup.
&nbsp;     */
&nbsp;    public boolean isEnableCaptcha() {
<b class="nc">&nbsp;        return enableCaptcha;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes if this Hudson has some user accounts configured.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is used to check for the initial
&nbsp;     */
&nbsp;    private static boolean hasSomeUser() {
<b class="nc">&nbsp;        for (User u : User.getAll())</b>
<b class="nc">&nbsp;            if (u.getProperty(Details.class) != null)</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This implementation doesn&#39;t support groups.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public GroupDetails loadGroupByGroupname2(String groupname, boolean fetchMembers) throws UsernameNotFoundException {
<b class="nc">&nbsp;        throw new UsernameNotFoundException(groupname);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public UserDetails loadUserByUsername2(String username) throws UsernameNotFoundException {
<b class="nc">&nbsp;        return load(username).asUserDetails();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Details load(String username) throws UsernameNotFoundException {
<b class="nc">&nbsp;        User u = User.getById(username, false);</b>
<b class="nc">&nbsp;        Details p = u != null ? u.getProperty(Details.class) : null;</b>
<b class="nc">&nbsp;        if (p == null)</b>
<b class="nc">&nbsp;            throw new UsernameNotFoundException(&quot;Password is not set: &quot; + username);</b>
<b class="nc">&nbsp;        if (p.getUser() == null)</b>
<b class="nc">&nbsp;            throw new AssertionError();</b>
<b class="nc">&nbsp;        return p;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected UserDetails authenticate2(String username, String password) throws AuthenticationException {
&nbsp;        Details u;
&nbsp;        try {
<b class="nc">&nbsp;            u = load(username);</b>
<b class="nc">&nbsp;        } catch (UsernameNotFoundException ex) {</b>
&nbsp;            // Waste time to prevent timing attacks distinguishing existing and non-existing user
<b class="nc">&nbsp;            PASSWORD_ENCODER.matches(password, ENCODED_INVALID_USER_PASSWORD);</b>
<b class="nc">&nbsp;            throw ex;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (!u.isPasswordCorrect(password)) {</b>
<b class="nc">&nbsp;            throw new BadCredentialsException(&quot;Bad credentials&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return u.asUserDetails();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Show the sign up page with the data from the identity.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public HttpResponse commenceSignup(final FederatedIdentity identity) {
&nbsp;        // store the identity in the session so that we can use this later
<b class="nc">&nbsp;        Stapler.getCurrentRequest().getSession().setAttribute(FEDERATED_IDENTITY_SESSION_KEY, identity);</b>
<b class="nc">&nbsp;        return new ForwardToView(this, &quot;signupWithFederatedIdentity.jelly&quot;) {</b>
&nbsp;            @Override
&nbsp;            public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {
<b class="nc">&nbsp;                SignupInfo si = new SignupInfo(identity);</b>
<b class="nc">&nbsp;                si.errorMessage = Messages.HudsonPrivateSecurityRealm_WouldYouLikeToSignUp(identity.getPronoun(), identity.getIdentifier());</b>
<b class="nc">&nbsp;                req.setAttribute(&quot;data&quot;, si);</b>
<b class="nc">&nbsp;                super.generateResponse(req, rsp, node);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an account and associates that with the given identity. Used in conjunction
&nbsp;     * with {@link #commenceSignup}.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public User doCreateAccountWithFederatedIdentity(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        User u = _doCreateAccount(req, rsp, &quot;signupWithFederatedIdentity.jelly&quot;);</b>
<b class="nc">&nbsp;        if (u != null)</b>
<b class="nc">&nbsp;            ((FederatedIdentity) req.getSession().getAttribute(FEDERATED_IDENTITY_SESSION_KEY)).addTo(u);</b>
<b class="nc">&nbsp;        return u;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final String FEDERATED_IDENTITY_SESSION_KEY = HudsonPrivateSecurityRealm.class.getName() + &quot;.federatedIdentity&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an user account. Used for self-registration.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public User doCreateAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        return _doCreateAccount(req, rsp, &quot;signup.jelly&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private User _doCreateAccount(StaplerRequest req, StaplerResponse rsp, String formView) throws ServletException, IOException {
<b class="nc">&nbsp;        if (!allowsSignup())</b>
<b class="nc">&nbsp;            throw HttpResponses.errorWithoutStack(SC_UNAUTHORIZED, &quot;User sign up is prohibited&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        boolean firstUser = !hasSomeUser();</b>
<b class="nc">&nbsp;        User u = createAccount(req, rsp, enableCaptcha, formView);</b>
<b class="nc">&nbsp;        if (u != null) {</b>
<b class="nc">&nbsp;            if (firstUser)</b>
<b class="nc">&nbsp;                tryToMakeAdmin(u);  // the first user should be admin, or else there&#39;s a risk of lock out</b>
<b class="nc">&nbsp;            loginAndTakeBack(req, rsp, u);</b>
&nbsp;        }
<b class="nc">&nbsp;        return u;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Lets the current user silently login as the given user and report back accordingly.
&nbsp;     */
&nbsp;    private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {
<b class="nc">&nbsp;        HttpSession session = req.getSession(false);</b>
<b class="nc">&nbsp;        if (session != null) {</b>
&nbsp;            // avoid session fixation
<b class="nc">&nbsp;            session.invalidate();</b>
&nbsp;        }
<b class="nc">&nbsp;        req.getSession(true);</b>
&nbsp;
&nbsp;        // ... and let him login
<b class="nc">&nbsp;        Authentication a = new UsernamePasswordAuthenticationToken(u.getId(), req.getParameter(&quot;password1&quot;));</b>
<b class="nc">&nbsp;        a = this.getSecurityComponents().manager2.authenticate(a);</b>
<b class="nc">&nbsp;        SecurityContextHolder.getContext().setAuthentication(a);</b>
&nbsp;
<b class="nc">&nbsp;        SecurityListener.fireLoggedIn(u.getId());</b>
&nbsp;
&nbsp;        // then back to top
<b class="nc">&nbsp;        req.getView(this, &quot;success.jelly&quot;).forward(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a user account. Used by admins.
&nbsp;     *
&nbsp;     * This version behaves differently from {@link #doCreateAccount(StaplerRequest, StaplerResponse)} in that
&nbsp;     * this is someone creating another user.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doCreateAccountByAdmin(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        createAccountByAdmin(req, rsp, &quot;addUser.jelly&quot;, &quot;.&quot;); // send the user back to the listing page on success</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a user account. Requires {@link Jenkins#ADMINISTER}
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public User createAccountByAdmin(StaplerRequest req, StaplerResponse rsp, String addUserView, String successView) throws IOException, ServletException {
<b class="nc">&nbsp;        checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        User u = createAccount(req, rsp, false, addUserView);</b>
<b class="nc">&nbsp;        if (u != null &amp;&amp; successView != null) {</b>
<b class="nc">&nbsp;            rsp.sendRedirect(successView);</b>
&nbsp;        }
<b class="nc">&nbsp;        return u;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a user account. Intended to be called from the setup wizard.
&nbsp;     * Note that this method does not check whether it is actually called from
&nbsp;     * the setup wizard. This requires the {@link Jenkins#ADMINISTER} permission.
&nbsp;     *
&nbsp;     * @param req the request to retrieve input data from
&nbsp;     * @return the created user account, never null
&nbsp;     * @throws AccountCreationFailedException if account creation failed due to invalid form input
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public User createAccountFromSetupWizard(StaplerRequest req) throws IOException, AccountCreationFailedException {
<b class="nc">&nbsp;        checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        SignupInfo si = validateAccountCreationForm(req, false);</b>
<b class="nc">&nbsp;        if (!si.errors.isEmpty()) {</b>
<b class="nc">&nbsp;            String messages = getErrorMessages(si);</b>
<b class="nc">&nbsp;            throw new AccountCreationFailedException(messages);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return createAccount(si);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String getErrorMessages(SignupInfo si) {
<b class="nc">&nbsp;        StringBuilder messages = new StringBuilder();</b>
<b class="nc">&nbsp;        for (String message : si.errors.values()) {</b>
<b class="nc">&nbsp;            messages.append(message).append(&quot; | &quot;);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return messages.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a first admin user account.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This can be run by anyone, but only to create the very first user account.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doCreateFirstAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        if (hasSomeUser()) {</b>
<b class="nc">&nbsp;            rsp.sendError(SC_UNAUTHORIZED, &quot;First user was already created&quot;);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        User u = createAccount(req, rsp, false, &quot;firstUser.jelly&quot;);</b>
<b class="nc">&nbsp;        if (u != null) {</b>
<b class="nc">&nbsp;            tryToMakeAdmin(u);</b>
<b class="nc">&nbsp;            loginAndTakeBack(req, rsp, u);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Try to make this user a super-user
&nbsp;     */
&nbsp;    private void tryToMakeAdmin(User u) {
<b class="nc">&nbsp;        AuthorizationStrategy as = Jenkins.get().getAuthorizationStrategy();</b>
<b class="nc">&nbsp;        for (PermissionAdder adder : ExtensionList.lookup(PermissionAdder.class)) {</b>
<b class="nc">&nbsp;            if (adder.add(as, u, Jenkins.ADMINISTER)) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param req the request to get the form data from (is also used for redirection)
&nbsp;     * @param rsp the response to use for forwarding if the creation fails
&nbsp;     * @param validateCaptcha whether to attempt to validate a captcha in the request
&nbsp;     * @param formView the view to redirect to if creation fails
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      null if failed. The browser is already redirected to retry by the time this method returns.
&nbsp;     *      a valid {@link User} object if the user creation was successful.
&nbsp;     */
&nbsp;    private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean validateCaptcha, String formView) throws ServletException, IOException {
<b class="nc">&nbsp;        SignupInfo si = validateAccountCreationForm(req, validateCaptcha);</b>
&nbsp;
<b class="nc">&nbsp;        if (!si.errors.isEmpty()) {</b>
&nbsp;            // failed. ask the user to try again.
<b class="nc">&nbsp;            req.getView(this, formView).forward(req, rsp);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return createAccount(si);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param req              the request to process
&nbsp;     * @param validateCaptcha  whether to attempt to validate a captcha in the request
&nbsp;     *
&nbsp;     * @return a {@link SignupInfo#SignupInfo(StaplerRequest) SignupInfo from given request}, with {@link
&nbsp;     * SignupInfo#errors} containing errors (keyed by field name), if any of the supported fields are invalid
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD&quot;, justification = &quot;written to by Stapler&quot;)
&nbsp;    private SignupInfo validateAccountCreationForm(StaplerRequest req, boolean validateCaptcha) {
&nbsp;        // form field validation
&nbsp;        // this pattern needs to be generalized and moved to stapler
<b class="nc">&nbsp;        SignupInfo si = new SignupInfo(req);</b>
&nbsp;
<b class="nc">&nbsp;        if (validateCaptcha &amp;&amp; !validateCaptcha(si.captcha)) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;captcha&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (si.username == null || si.username.isEmpty()) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;username&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired());</b>
<b class="nc">&nbsp;        } else if (!containsOnlyAcceptableCharacters(si.username)) {</b>
<b class="nc">&nbsp;            if (ID_REGEX == null) {</b>
<b class="nc">&nbsp;                si.errors.put(&quot;username&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharacters());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                si.errors.put(&quot;username&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharactersCustom(ID_REGEX));</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // do not create the user - we just want to check if the user already exists but is not a &quot;login&quot; user.
<b class="nc">&nbsp;            User user = User.getById(si.username, false);</b>
<b class="nc">&nbsp;            if (null != user)</b>
&nbsp;                // Allow sign up. SCM people has no such property.
<b class="nc">&nbsp;                if (user.getProperty(Details.class) != null)</b>
<b class="nc">&nbsp;                    si.errors.put(&quot;username&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (si.password1 != null &amp;&amp; !si.password1.equals(si.password2)) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;password1&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!(si.password1 != null &amp;&amp; si.password1.length() != 0)) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;password1&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (FIPS140.useCompliantAlgorithms()) {</b>
<b class="nc">&nbsp;            if (si.password1.length() &lt; FIPS_PASSWORD_LENGTH) {</b>
<b class="nc">&nbsp;                si.errors.put(&quot;password1&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_FIPS_PasswordLengthInvalid());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (si.fullname == null || si.fullname.isEmpty()) {</b>
<b class="nc">&nbsp;            si.fullname = si.username;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (isMailerPluginPresent() &amp;&amp; (si.email == null || !si.email.contains(&quot;@&quot;))) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;email&quot;, Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!User.isIdOrFullnameAllowed(si.username)) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;username&quot;, hudson.model.Messages.User_IllegalUsername(si.username));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!User.isIdOrFullnameAllowed(si.fullname)) {</b>
<b class="nc">&nbsp;            si.errors.put(&quot;fullname&quot;, hudson.model.Messages.User_IllegalFullname(si.fullname));</b>
&nbsp;        }
<b class="nc">&nbsp;        req.setAttribute(&quot;data&quot;, si); // for error messages in the view</b>
<b class="nc">&nbsp;        return si;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new account from a valid signup info. A signup info is valid if its {@link SignupInfo#errors}
&nbsp;     * field is empty.
&nbsp;     *
&nbsp;     * @param si the valid signup info to create an account from
&nbsp;     * @return a valid {@link User} object created from given signup info
&nbsp;     * @throws IllegalArgumentException if an invalid signup info is passed
&nbsp;     */
&nbsp;    private User createAccount(SignupInfo si) throws IOException {
<b class="nc">&nbsp;        if (!si.errors.isEmpty()) {</b>
<b class="nc">&nbsp;            String messages = getErrorMessages(si);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;invalid signup info passed to createAccount(si): &quot; + messages);</b>
&nbsp;        }
&nbsp;        // register the user
<b class="nc">&nbsp;        User user = createAccount(si.username, si.password1);</b>
<b class="nc">&nbsp;        user.setFullName(si.fullname);</b>
<b class="nc">&nbsp;        if (isMailerPluginPresent()) {</b>
&nbsp;            try {
&nbsp;                // legacy hack. mail support has moved out to a separate plugin
<b class="nc">&nbsp;                Class&lt;?&gt; up = Jenkins.get().pluginManager.uberClassLoader.loadClass(&quot;hudson.tasks.Mailer$UserProperty&quot;);</b>
<b class="nc">&nbsp;                Constructor&lt;?&gt; c = up.getDeclaredConstructor(String.class);</b>
<b class="nc">&nbsp;                user.addProperty((UserProperty) c.newInstance(si.email));</b>
<b class="nc">&nbsp;            } catch (ReflectiveOperationException e) {</b>
<b class="nc">&nbsp;                throw new RuntimeException(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        user.save();</b>
<b class="nc">&nbsp;        return user;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean containsOnlyAcceptableCharacters(@NonNull String value) {
<b class="nc">&nbsp;        if (ID_REGEX == null) {</b>
<b class="nc">&nbsp;            return value.matches(DEFAULT_ID_REGEX);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return value.matches(ID_REGEX);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class) // _entryForm.jelly and signup.jelly
&nbsp;    public boolean isMailerPluginPresent() {
&nbsp;        try {
&nbsp;            // mail support has moved to a separate plugin
<b class="nc">&nbsp;            return null != Jenkins.get().pluginManager.uberClassLoader.loadClass(&quot;hudson.tasks.Mailer$UserProperty&quot;);</b>
<b class="nc">&nbsp;        } catch (ClassNotFoundException e) {</b>
<b class="nc">&nbsp;            LOGGER.finer(&quot;Mailer plugin not present&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new user account by registering a password to the user.
&nbsp;     */
&nbsp;    public User createAccount(String userName, String password) throws IOException {
<b class="nc">&nbsp;        User user = User.getById(userName, true);</b>
<b class="nc">&nbsp;        user.addProperty(Details.fromPlainPassword(password));</b>
<b class="nc">&nbsp;        SecurityListener.fireUserCreated(user.getId());</b>
<b class="nc">&nbsp;        return user;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new user account by registering a Hashed password with the user.
&nbsp;     *
&nbsp;     * @param userName The user&#39;s name
&nbsp;     * @param hashedPassword A hashed password, must begin with {@code getPasswordHeader()}
&nbsp;     * @see #getPasswordHeader()
&nbsp;     */
&nbsp;    public User createAccountWithHashedPassword(String userName, String hashedPassword) throws IOException {
<b class="nc">&nbsp;        if (!PASSWORD_ENCODER.isPasswordHashed(hashedPassword)) {</b>
&nbsp;            final String message;
<b class="nc">&nbsp;            if (hashedPassword == null) {</b>
<b class="nc">&nbsp;                message = &quot;The hashed password cannot be null&quot;;</b>
<b class="nc">&nbsp;            } else if (hashedPassword.startsWith(getPasswordHeader())) {</b>
<b class="nc">&nbsp;                message = &quot;The hashed password was hashed with the correct algorithm, but the format was not correct&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                message = &quot;The hashed password was hashed with an incorrect algorithm. Jenkins is expecting &quot; + getPasswordHeader();</b>
&nbsp;            }
<b class="nc">&nbsp;            throw new IllegalArgumentException(message);</b>
&nbsp;        }
<b class="nc">&nbsp;        User user = User.getById(userName, true);</b>
<b class="nc">&nbsp;        user.addProperty(Details.fromHashedPassword(hashedPassword));</b>
<b class="nc">&nbsp;        SecurityListener.fireUserCreated(user.getId());</b>
<b class="nc">&nbsp;        return user;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * This is used primarily when the object is listed in the breadcrumb, in the user management screen.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="nc">&nbsp;        return Messages.HudsonPrivateSecurityRealm_DisplayName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ACL getACL() {
<b class="nc">&nbsp;        return Jenkins.get().getACL();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void checkPermission(Permission permission) {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(permission);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean hasPermission(Permission permission) {
<b class="nc">&nbsp;        return Jenkins.get().hasPermission(permission);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * All users who can login to the system.
&nbsp;     */
&nbsp;    public List&lt;User&gt; getAllUsers() {
<b class="nc">&nbsp;        List&lt;User&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (User u : User.getAll()) {</b>
<b class="nc">&nbsp;            if (u.getProperty(Details.class) != null)</b>
<b class="nc">&nbsp;                r.add(u);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Collections.sort(r);</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This is to map users under the security realm URL.
&nbsp;     * This in turn helps us set up the right navigation breadcrumb.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public User getUser(String id) {
<b class="nc">&nbsp;        return User.getById(id, User.ALLOW_USER_CREATION_VIA_URL &amp;&amp; hasPermission(Jenkins.ADMINISTER));</b>
&nbsp;    }
&nbsp;
&nbsp;    // TODO
<b class="nc">&nbsp;    private static final Collection&lt;? extends GrantedAuthority&gt; TEST_AUTHORITY = Set.of(AUTHENTICATED_AUTHORITY2);</b>
&nbsp;
&nbsp;    public static final class SignupInfo {
&nbsp;        public String username, password1, password2, fullname, email, captcha;
&nbsp;
&nbsp;        /**
&nbsp;         * To display a general error message, set it here.
&nbsp;         *
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, justification = &quot;read by Stapler&quot;)
&nbsp;        public String errorMessage;
&nbsp;
&nbsp;        /**
&nbsp;         * Add field-specific error messages here.
&nbsp;         * Keys are field names (e.g. {@code password2}), values are the messages.
&nbsp;         */
&nbsp;        // TODO i18n?
<b class="nc">&nbsp;        public HashMap&lt;String, String&gt; errors = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        public SignupInfo() {</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SignupInfo(StaplerRequest req) {</b>
<b class="nc">&nbsp;            req.bindParameters(this);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public SignupInfo(FederatedIdentity i) {</b>
<b class="nc">&nbsp;            this.username = i.getNickname();</b>
<b class="nc">&nbsp;            this.fullname = i.getFullName();</b>
<b class="nc">&nbsp;            this.email = i.getEmailAddress();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link UserProperty} that provides the {@link UserDetails} view of the User object.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When a {@link User} object has this property on it, it means the user is configured
&nbsp;     * for log-in.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When a {@link User} object is re-configured via the UI, the password
&nbsp;     * is sent to the hidden input field by using {@link Protector}, so that
&nbsp;     * the same password can be retained but without leaking information to the browser.
&nbsp;     */
&nbsp;    public static final class Details extends UserProperty {
&nbsp;        /**
&nbsp;         * Hashed password.
&nbsp;         */
&nbsp;        private /*almost final*/ String passwordHash;
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated Scrambled password.
&nbsp;         * Field kept here to load old (pre 1.283) user records,
&nbsp;         * but now marked transient so field is no longer saved.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        private transient String password;
&nbsp;
<b class="nc">&nbsp;        private Details(String passwordHash) {</b>
<b class="nc">&nbsp;            this.passwordHash = passwordHash;</b>
&nbsp;        }
&nbsp;
&nbsp;        static Details fromHashedPassword(String hashed) {
<b class="nc">&nbsp;            return new Details(hashed);</b>
&nbsp;        }
&nbsp;
&nbsp;        static Details fromPlainPassword(String rawPassword) {
<b class="nc">&nbsp;            return new Details(PASSWORD_ENCODER.encode(rawPassword));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @since 2.266
&nbsp;         */
&nbsp;        public Collection&lt;? extends GrantedAuthority&gt; getAuthorities2() {
&nbsp;            // TODO
<b class="nc">&nbsp;            return TEST_AUTHORITY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #getAuthorities2}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public org.acegisecurity.GrantedAuthority[] getAuthorities() {
<b class="nc">&nbsp;            return org.acegisecurity.GrantedAuthority.fromSpring(getAuthorities2());</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getPassword() {
<b class="nc">&nbsp;            return passwordHash;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPasswordCorrect(String candidate) {
<b class="nc">&nbsp;            return PASSWORD_ENCODER.matches(candidate, getPassword());</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getProtectedPassword() {
&nbsp;            // put session Id in it to prevent a replay attack.
<b class="nc">&nbsp;            return Protector.protect(Stapler.getCurrentRequest().getSession().getId() + &#39;:&#39; + getPassword());</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getUsername() {
<b class="nc">&nbsp;            return user.getId();</b>
&nbsp;        }
&nbsp;
&nbsp;        /*package*/ User getUser() {
<b class="nc">&nbsp;            return user;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAccountNonExpired() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAccountNonLocked() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isCredentialsNonExpired() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isEnabled() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        UserDetails asUserDetails() {
<b class="nc">&nbsp;            return new UserDetailsImpl(getAuthorities2(), getPassword(), getUsername(), isAccountNonExpired(), isAccountNonLocked(), isCredentialsNonExpired(), isEnabled());</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final class UserDetailsImpl implements UserDetails {
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;            private final Collection&lt;? extends GrantedAuthority&gt; authorities;
&nbsp;            private final String password;
&nbsp;            private final String username;
&nbsp;            private final boolean accountNonExpired;
&nbsp;            private final boolean accountNonLocked;
&nbsp;            private final boolean credentialsNonExpired;
&nbsp;            private final boolean enabled;
&nbsp;
<b class="nc">&nbsp;            UserDetailsImpl(Collection&lt;? extends GrantedAuthority&gt; authorities, String password, String username, boolean accountNonExpired, boolean accountNonLocked, boolean credentialsNonExpired, boolean enabled) {</b>
<b class="nc">&nbsp;                this.authorities = authorities;</b>
<b class="nc">&nbsp;                this.password = password;</b>
<b class="nc">&nbsp;                this.username = username;</b>
<b class="nc">&nbsp;                this.accountNonExpired = accountNonExpired;</b>
<b class="nc">&nbsp;                this.accountNonLocked = accountNonLocked;</b>
<b class="nc">&nbsp;                this.credentialsNonExpired = credentialsNonExpired;</b>
<b class="nc">&nbsp;                this.enabled = enabled;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
<b class="nc">&nbsp;                return authorities;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getPassword() {
<b class="nc">&nbsp;                return password;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getUsername() {
<b class="nc">&nbsp;                return username;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isAccountNonExpired() {
<b class="nc">&nbsp;                return accountNonExpired;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isAccountNonLocked() {
<b class="nc">&nbsp;                return accountNonLocked;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isCredentialsNonExpired() {
<b class="nc">&nbsp;                return credentialsNonExpired;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled() {
<b class="nc">&nbsp;                return enabled;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(Object o) {
<b class="nc">&nbsp;                return o instanceof UserDetailsImpl &amp;&amp; ((UserDetailsImpl) o).getUsername().equals(getUsername());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="nc">&nbsp;                return getUsername().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        public static class ConverterImpl extends XStream2.PassthruConverter&lt;Details&gt; {
<b class="nc">&nbsp;            public ConverterImpl(XStream2 xstream) { super(xstream); }</b>
&nbsp;
&nbsp;            @Override protected void callback(Details d, UnmarshallingContext context) {
&nbsp;                // Convert to hashed password and report to monitor if we load old data
<b class="nc">&nbsp;                if (d.password != null &amp;&amp; d.passwordHash == null) {</b>
<b class="nc">&nbsp;                    d.passwordHash = PASSWORD_ENCODER.encode(Scrambler.descramble(d.password));</b>
<b class="nc">&nbsp;                    OldDataMonitor.report(context, &quot;1.283&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Extension @Symbol(&quot;password&quot;)
<b class="nc">&nbsp;        public static final class DescriptorImpl extends UserPropertyDescriptor {</b>
&nbsp;            @NonNull
&nbsp;            @Override
&nbsp;            public String getDisplayName() {
<b class="nc">&nbsp;                return Messages.HudsonPrivateSecurityRealm_Details_DisplayName();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Details newInstance(StaplerRequest req, JSONObject formData) throws FormException {
<b class="nc">&nbsp;                if (req == null) {</b>
&nbsp;                    // Should never happen, see newInstance() Javadoc
<b class="nc">&nbsp;                    throw new FormException(&quot;Stapler request is missing in the call&quot;, &quot;staplerRequest&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                String pwd = Util.fixEmpty(req.getParameter(&quot;user.password&quot;));</b>
<b class="nc">&nbsp;                String pwd2 = Util.fixEmpty(req.getParameter(&quot;user.password2&quot;));</b>
&nbsp;
<b class="nc">&nbsp;                if (pwd == null || pwd2 == null) {</b>
&nbsp;                    // one of the fields is empty
<b class="nc">&nbsp;                    throw new FormException(&quot;Please confirm the password by typing it twice&quot;, &quot;user.password2&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                // will be null if it wasn&#39;t encrypted
<b class="nc">&nbsp;                String data = Protector.unprotect(pwd);</b>
<b class="nc">&nbsp;                String data2 = Protector.unprotect(pwd2);</b>
&nbsp;
<b class="nc">&nbsp;                if (data == null != (data2 == null)) {</b>
&nbsp;                    // Require that both values are protected or unprotected; do not allow user to change just one text field
<b class="nc">&nbsp;                    throw new FormException(&quot;Please confirm the password by typing it twice&quot;, &quot;user.password2&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (data != null /* &amp;&amp; data2 != null */ &amp;&amp; !MessageDigest.isEqual(data.getBytes(StandardCharsets.UTF_8), data2.getBytes(StandardCharsets.UTF_8))) {</b>
&nbsp;                    // passwords are different encrypted values
<b class="nc">&nbsp;                    throw new FormException(&quot;Please confirm the password by typing it twice&quot;, &quot;user.password2&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (data == null /* &amp;&amp; data2 == null */ &amp;&amp; !pwd.equals(pwd2)) {</b>
&nbsp;                    // passwords are different plain values
<b class="nc">&nbsp;                    throw new FormException(&quot;Please confirm the password by typing it twice&quot;, &quot;user.password2&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (data != null) {</b>
<b class="nc">&nbsp;                    String prefix = Stapler.getCurrentRequest().getSession().getId() + &#39;:&#39;;</b>
<b class="nc">&nbsp;                    if (data.startsWith(prefix)) {</b>
<b class="nc">&nbsp;                        return Details.fromHashedPassword(data.substring(prefix.length()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                User user = Util.getNearestAncestorOfTypeOrThrow(req, User.class);</b>
&nbsp;                // the UserSeedProperty is not touched by the configure page
<b class="nc">&nbsp;                UserSeedProperty userSeedProperty = user.getProperty(UserSeedProperty.class);</b>
<b class="nc">&nbsp;                if (userSeedProperty != null) {</b>
<b class="nc">&nbsp;                    userSeedProperty.renewSeed();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return Details.fromPlainPassword(Util.fixNull(pwd));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isEnabled() {
&nbsp;                // this feature is only when HudsonPrivateSecurityRealm is enabled
<b class="nc">&nbsp;                return Jenkins.get().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public UserProperty newInstance(User user) {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Displays &quot;manage users&quot; link in the system config if {@link HudsonPrivateSecurityRealm}
&nbsp;     * is in effect.
&nbsp;     */
&nbsp;    @Extension @Symbol(&quot;localUsers&quot;)
<b class="nc">&nbsp;    public static final class ManageUserLinks extends ManagementLink {</b>
&nbsp;        @Override
&nbsp;        public String getIconFileName() {
<b class="nc">&nbsp;            if (Jenkins.get().getSecurityRealm() instanceof HudsonPrivateSecurityRealm)</b>
<b class="nc">&nbsp;                return &quot;symbol-people&quot;;</b>
&nbsp;            else
<b class="nc">&nbsp;                return null;    // not applicable now</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getUrlName() {
<b class="nc">&nbsp;            return &quot;securityRealm/&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDescription() {
<b class="nc">&nbsp;            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_Description();</b>
&nbsp;        }
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public Category getCategory() {
<b class="nc">&nbsp;            return Category.SECURITY;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // TODO can we instead use BCryptPasswordEncoder from Spring Security, which has its own copy of BCrypt so we could drop the special library?
&nbsp;    /**
&nbsp;     * {@link PasswordHashEncoder} that uses jBCrypt.
&nbsp;     */
<b class="fc">&nbsp;    static class JBCryptEncoder implements PasswordHashEncoder {</b>
&nbsp;        // in jBCrypt the maximum is 30, which takes ~22h with laptop late-2017
&nbsp;        // and for 18, it&#39;s &quot;only&quot; 20s
&nbsp;        @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;Accessible via System Groovy Scripts&quot;)
&nbsp;        @Restricted(NoExternalUse.class)
<b class="fc">&nbsp;        private static int MAXIMUM_BCRYPT_LOG_ROUND = SystemProperties.getInteger(HudsonPrivateSecurityRealm.class.getName() + &quot;.maximumBCryptLogRound&quot;, 18);</b>
&nbsp;
<b class="fc">&nbsp;        private static final Pattern BCRYPT_PATTERN = Pattern.compile(&quot;^\\$2a\\$([0-9]{2})\\$.{53}$&quot;);</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public String encode(CharSequence rawPassword) {
<b class="fc">&nbsp;            return BCrypt.hashpw(rawPassword.toString(), BCrypt.gensalt());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean matches(CharSequence rawPassword, String encodedPassword) {
<b class="fc">&nbsp;            return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if the supplied hash looks like a bcrypt encoded hash value, based off of the
&nbsp;         * implementation defined in jBCrypt and &lt;a href=&quot;https://en.wikipedia.org/wiki/Bcrypt&quot;&gt;the Wikipedia page&lt;/a&gt;.
&nbsp;         *
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean isHashValid(String hash) {
<b class="nc">&nbsp;            Matcher matcher = BCRYPT_PATTERN.matcher(hash);</b>
<b class="nc">&nbsp;            if (matcher.matches()) {</b>
<b class="nc">&nbsp;                String logNumOfRound = matcher.group(1);</b>
&nbsp;                // no number format exception due to the expression
<b class="nc">&nbsp;                int logNumOfRoundInt = Integer.parseInt(logNumOfRound);</b>
<b class="nc">&nbsp;                if (logNumOfRoundInt &gt; 0 &amp;&amp; logNumOfRoundInt &lt;= MAXIMUM_BCRYPT_LOG_ROUND) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;     static class PBKDF2PasswordEncoder implements PasswordHashEncoder {</b>
&nbsp;
&nbsp;        private static final String STRING_SEPARATION = &quot;:&quot;;
&nbsp;        private static final int KEY_LENGTH_BITS = 512;
&nbsp;        private static final int SALT_LENGTH_BYTES = 16;
&nbsp;        // https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2
&nbsp;        // ~230ms on an Intel i7-10875H CPU (JBCryptEncoder is ~57ms)
&nbsp;        private static final int ITTERATIONS = 210_000;
&nbsp;        private static final String PBKDF2_ALGORITHM = &quot;PBKDF2WithHmacSHA512&quot;;
&nbsp;
&nbsp;        private volatile SecureRandom random; // defer construction until we need to use it to not delay startup in the case of lack of entropy.
&nbsp;
&nbsp;        // $PBDKF2 is already checked before we get here.
&nbsp;        // $algorithm(HMACSHA512) : rounds : salt_in_hex $ mac_in_hex
<b class="fc">&nbsp;        private static final Pattern PBKDF2_PATTERN =</b>
<b class="fc">&nbsp;                Pattern.compile(&quot;^\\$HMACSHA512\\:&quot; + ITTERATIONS + &quot;\\:[a-f0-9]{&quot; + (SALT_LENGTH_BYTES * 2) + &quot;}\\$[a-f0-9]{&quot; + ((KEY_LENGTH_BITS / 8) * 2) + &quot;}$&quot;);</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public String encode(CharSequence rawPassword) {
&nbsp;            try {
<b class="fc">&nbsp;                return generatePasswordHashWithPBKDF2(rawPassword);</b>
<b class="fc">&nbsp;            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {</b>
<b class="fc">&nbsp;                throw new RuntimeException(&quot;Unable to generate password with PBKDF2WithHmacSHA512&quot;, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean matches(CharSequence rawPassword, String encodedPassword) {
&nbsp;            try {
<b class="fc">&nbsp;                return validatePassword(rawPassword.toString(), encodedPassword);</b>
<b class="fc">&nbsp;            } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {</b>
<b class="fc">&nbsp;                throw new RuntimeException(&quot;Unable to check password with PBKDF2WithHmacSHA512&quot;, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private String generatePasswordHashWithPBKDF2(CharSequence password) throws NoSuchAlgorithmException, InvalidKeySpecException {
<b class="fc">&nbsp;            byte[] salt = generateSalt();</b>
<b class="fc">&nbsp;            PBEKeySpec spec = new PBEKeySpec(password.toString().toCharArray(), salt, ITTERATIONS, KEY_LENGTH_BITS);</b>
<b class="fc">&nbsp;            byte[] hash = generateSecretKey(spec);</b>
<b class="fc">&nbsp;            return &quot;$HMACSHA512:&quot; + ITTERATIONS + STRING_SEPARATION + Util.toHexString(salt) + &quot;$&quot; + Util.toHexString(hash);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static byte[] generateSecretKey(PBEKeySpec spec) throws NoSuchAlgorithmException, InvalidKeySpecException {
<b class="fc">&nbsp;            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);</b>
<b class="fc">&nbsp;            return secretKeyFactory.generateSecret(spec).getEncoded();</b>
&nbsp;        }
&nbsp;
&nbsp;        private SecureRandom secureRandom() {
&nbsp;            // lazy initialisation so that we do not block startup due to entropy
<b class="fc">&nbsp;            if (random == null) {</b>
<b class="fc">&nbsp;                synchronized (this) {</b>
<b class="fc">&nbsp;                    if (random == null) {</b>
<b class="fc">&nbsp;                        random = new SecureRandom();</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return random;</b>
&nbsp;        }
&nbsp;
&nbsp;        private byte[] generateSalt() {
<b class="fc">&nbsp;            byte[] salt = new byte[SALT_LENGTH_BYTES];</b>
<b class="fc">&nbsp;            secureRandom().nextBytes(salt);</b>
<b class="fc">&nbsp;            return salt;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isHashValid(String hash) {
<b class="fc">&nbsp;            Matcher matcher = PBKDF2_PATTERN.matcher(hash);</b>
<b class="fc">&nbsp;            return matcher.matches();</b>
&nbsp;        }
&nbsp;
&nbsp;        private static boolean validatePassword(String password, String storedPassword) throws NoSuchAlgorithmException, InvalidKeySpecException {
<b class="fc">&nbsp;            String[] parts = storedPassword.split(&quot;[:$]&quot;);</b>
<b class="fc">&nbsp;            int iterations = Integer.parseInt(parts[2]);</b>
&nbsp;
<b class="fc">&nbsp;            byte[] salt = Util.fromHexString(parts[3]);</b>
<b class="fc">&nbsp;            byte[] hash = Util.fromHexString(parts[4]);</b>
&nbsp;
<b class="fc">&nbsp;            PBEKeySpec spec = new PBEKeySpec(password.toCharArray(),</b>
&nbsp;                    salt, iterations, hash.length * 8 /* bits in a byte */);
&nbsp;
<b class="fc">&nbsp;            byte[] generatedHashValue = generateSecretKey(spec);</b>
&nbsp;
<b class="fc">&nbsp;            return MessageDigest.isEqual(hash, generatedHashValue);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    /* package */ static final PasswordHashEncoder PASSWORD_HASH_ENCODER =  FIPS140.useCompliantAlgorithms() ? new PBKDF2PasswordEncoder() : new JBCryptEncoder();</b>
&nbsp;
&nbsp;
&nbsp;    private static final String PBKDF2 = &quot;$PBKDF2&quot;;
&nbsp;    private static final String JBCRYPT = &quot;#jbcrypt:&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Magic header used to detect if a password is hashed.
&nbsp;     */
&nbsp;    private static String getPasswordHeader() {
<b class="nc">&nbsp;        return FIPS140.useCompliantAlgorithms() ? PBKDF2 : JBCRYPT;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    // TODO check if DelegatingPasswordEncoder can be used
&nbsp;    /**
&nbsp;     * Wraps {@link #PASSWORD_HASH_ENCODER}.
&nbsp;     * There used to be a SHA-256-based encoder but this is long deprecated, and insecure anyway.
&nbsp;     */
<b class="nc">&nbsp;    /* package */ static class MultiPasswordEncoder implements PasswordEncoder {</b>
&nbsp;
&nbsp;        /*
&nbsp;            CLASSIC encoder outputs &quot;salt:hash&quot; where salt is [a-z]+, so we use unique prefix &#39;#jbcyrpt&quot;
&nbsp;            to designate JBCRYPT-format hash and $PBKDF2 to designate PBKDF2 format hash.
&nbsp;
&nbsp;            &#39;#&#39; is neither in base64 nor hex, which makes it a good choice.
&nbsp;         */
&nbsp;
&nbsp;        @Override
&nbsp;        public String encode(CharSequence rawPassword) {
<b class="nc">&nbsp;            return getPasswordHeader() + PASSWORD_HASH_ENCODER.encode(rawPassword);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean matches(CharSequence rawPassword, String encPass) {
<b class="nc">&nbsp;            if (isPasswordHashed(encPass)) {</b>
<b class="nc">&nbsp;                return PASSWORD_HASH_ENCODER.matches(rawPassword, encPass.substring(getPasswordHeader().length()));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if the supplied password starts with a prefix indicating it is already hashed.
&nbsp;         */
&nbsp;        public boolean isPasswordHashed(String password) {
<b class="nc">&nbsp;            if (password == null) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (password.startsWith(getPasswordHeader())) {</b>
<b class="nc">&nbsp;                return PASSWORD_HASH_ENCODER.isHashValid(password.substring(getPasswordHeader().length()));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (password.startsWith(FIPS140.useCompliantAlgorithms() ? JBCRYPT : PBKDF2)) {</b>
&nbsp;                // switch the header to see if this is using a different encryption
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;A password appears to be stored (or is attempting to be stored) that was created with a different&quot;</b>
&nbsp;                        + &quot; hashing/encryption algorithm, check the FIPS-140 state of the system has not changed inadvertently&quot;);
&nbsp;            } else {
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;A password appears to be stored (or is attempting to be stored) that is not hashed/encrypted.&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static final MultiPasswordEncoder PASSWORD_ENCODER = new MultiPasswordEncoder();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This value is used to prevent timing discrepancies when trying to authenticate with an invalid username
&nbsp;     * compared to just a wrong password. If the user doesn&#39;t exist, compare the provided password with this value.
&nbsp;     */
<b class="nc">&nbsp;    private static final String ENCODED_INVALID_USER_PASSWORD = PASSWORD_ENCODER.encode(generatePassword());</b>
&nbsp;
&nbsp;    @SuppressFBWarnings(value = {&quot;DMI_RANDOM_USED_ONLY_ONCE&quot;, &quot;PREDICTABLE_RANDOM&quot;}, justification = &quot;https://github.com/spotbugs/spotbugs/issues/1539 and doesn&#39;t need to be secure, we&#39;re just not hardcoding a &#39;wrong&#39; password&quot;)
&nbsp;    private static String generatePassword() {
<b class="nc">&nbsp;        String password = new Random().ints(20, 33, 127).mapToObj(i -&gt; (char) i)</b>
<b class="nc">&nbsp;                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();</b>
<b class="nc">&nbsp;        return password;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Extension @Symbol(&quot;local&quot;)
<b class="nc">&nbsp;    public static final class DescriptorImpl extends Descriptor&lt;SecurityRealm&gt; {</b>
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.HudsonPrivateSecurityRealm_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        public FormValidation doCheckAllowsSignup(@QueryParameter boolean value) {
<b class="nc">&nbsp;            if (value) {</b>
<b class="nc">&nbsp;                return FormValidation.warning(Messages.HudsonPrivateSecurityRealm_SignupWarning());</b>
&nbsp;            }
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final Filter CREATE_FIRST_USER_FILTER = new Filter() {</b>
&nbsp;        @Override
&nbsp;        public void init(FilterConfig config) throws ServletException {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
<b class="nc">&nbsp;            HttpServletRequest req = (HttpServletRequest) request;</b>
&nbsp;
&nbsp;            /* allow signup from the Jenkins home page, or /manage, which is where a /configureSecurity form redirects to */
<b class="nc">&nbsp;            if (req.getRequestURI().equals(req.getContextPath() + &quot;/&quot;) || req.getRequestURI().equals(req.getContextPath() + &quot;/manage&quot;)) {</b>
<b class="nc">&nbsp;                if (needsToCreateFirstUser()) {</b>
<b class="nc">&nbsp;                    ((HttpServletResponse) response).sendRedirect(&quot;securityRealm/firstUser&quot;);</b>
&nbsp;                } else { // the first user already created. the role of this filter is over.
<b class="nc">&nbsp;                    PluginServletFilter.removeFilter(this);</b>
<b class="nc">&nbsp;                    chain.doFilter(request, response);</b>
&nbsp;                }
&nbsp;            } else
<b class="nc">&nbsp;                chain.doFilter(request, response);</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean needsToCreateFirstUser() {
<b class="nc">&nbsp;            return !hasSomeUser()</b>
<b class="nc">&nbsp;                &amp;&amp; Jenkins.get().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void destroy() {
<b class="nc">&nbsp;        }</b>
&nbsp;    };
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(HudsonPrivateSecurityRealm.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
