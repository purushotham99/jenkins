


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > PluginManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson</a>
</div>

<h1>Coverage Summary for Class: PluginManager (hudson)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PluginManager</td>
<td class="coverageStat">
  <span class="percent">
    11.2%
  </span>
  <span class="absValue">
    (9/80)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.4%
  </span>
  <span class="absValue">
    (103/828)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PluginManager$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$1$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$1$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$1$3$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$1$3$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$1$3$2$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$2$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$2$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$2$1$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$2$1$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$2$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$7</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$FailedPlugin</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$FileUploadPluginCopier</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$MetadataCache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$MockitoMock$vLoVwCIC</td>
  </tr>
  <tr>
    <td class="name">PluginManager$MockitoMock$vLoVwCIC$auxiliary$BWewtcDY</td>
  </tr>
  <tr>
    <td class="name">PluginManager$MockitoMock$vLoVwCIC$auxiliary$LznQalh2</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PluginCopier</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PluginCycleDependenciesMonitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PluginDeprecationMonitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PluginInstanceStore</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PluginUpdateMonitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PluginUpdateMonitor$PluginUpdateInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PMConstructor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PMConstructor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PMConstructor$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$PMConstructor$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$UberClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.9%
  </span>
  <span class="absValue">
    (4/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$UpdateCenterProxy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PluginManager$UrlPluginCopier</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    7.9%
  </span>
  <span class="absValue">
    (13/165)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10.8%
  </span>
  <span class="absValue">
    (117/1085)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, Stephen Connolly, Tom Huybrechts
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson;
&nbsp;
&nbsp;import static hudson.init.InitMilestone.COMPLETED;
&nbsp;import static hudson.init.InitMilestone.PLUGINS_LISTED;
&nbsp;import static hudson.init.InitMilestone.PLUGINS_PREPARED;
&nbsp;import static hudson.init.InitMilestone.PLUGINS_STARTED;
&nbsp;import static java.util.logging.Level.FINE;
&nbsp;import static java.util.logging.Level.INFO;
&nbsp;import static java.util.logging.Level.WARNING;
&nbsp;import static java.util.stream.Collectors.toList;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.Nullable;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.PluginWrapper.Dependency;
&nbsp;import hudson.init.InitMilestone;
&nbsp;import hudson.init.InitStrategy;
&nbsp;import hudson.init.InitializerFinder;
&nbsp;import hudson.model.AbstractItem;
&nbsp;import hudson.model.AbstractModelObject;
&nbsp;import hudson.model.AdministrativeMonitor;
&nbsp;import hudson.model.Api;
&nbsp;import hudson.model.Descriptor;
&nbsp;import hudson.model.DownloadService;
&nbsp;import hudson.model.Failure;
&nbsp;import hudson.model.ItemGroupMixIn;
&nbsp;import hudson.model.UpdateCenter;
&nbsp;import hudson.model.UpdateCenter.DownloadJob;
&nbsp;import hudson.model.UpdateCenter.InstallationJob;
&nbsp;import hudson.model.UpdateSite;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.security.Permission;
&nbsp;import hudson.security.PermissionScope;
&nbsp;import hudson.util.CyclicGraphDetector;
&nbsp;import hudson.util.CyclicGraphDetector.CycleDetectedException;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.PersistedList;
&nbsp;import hudson.util.Retrier;
&nbsp;import hudson.util.Service;
&nbsp;import hudson.util.VersionNumber;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.FilenameFilter;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.UncheckedIOException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.JarURLConnection;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.net.URLConnection;
&nbsp;import java.net.http.HttpClient;
&nbsp;import java.net.http.HttpRequest;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.nio.file.attribute.FileTime;
&nbsp;import java.security.CodeSource;
&nbsp;import java.time.Duration;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.ServiceLoader;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.CopyOnWriteArrayList;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Supplier;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import javax.servlet.ServletContext;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.xml.XMLConstants;
&nbsp;import javax.xml.parsers.ParserConfigurationException;
&nbsp;import javax.xml.parsers.SAXParserFactory;
&nbsp;import jenkins.ClassLoaderReflectionToolkit;
&nbsp;import jenkins.ExtensionRefreshException;
&nbsp;import jenkins.InitReactorRunner;
&nbsp;import jenkins.MissingDependencyException;
&nbsp;import jenkins.RestartRequiredException;
&nbsp;import jenkins.YesNoMaybe;
&nbsp;import jenkins.install.InstallState;
&nbsp;import jenkins.install.InstallUtil;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.plugins.DetachedPluginsUtil;
&nbsp;import jenkins.security.CustomClassFilter;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.io.OnMaster;
&nbsp;import jenkins.util.xml.RestrictiveEntityResolver;
&nbsp;import net.sf.json.JSONArray;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.fileupload.FileItem;
&nbsp;import org.apache.commons.fileupload.FileUploadException;
&nbsp;import org.apache.commons.fileupload.disk.DiskFileItemFactory;
&nbsp;import org.apache.commons.fileupload.servlet.ServletFileUpload;
&nbsp;import org.apache.commons.io.FileUtils;
&nbsp;import org.apache.commons.io.FilenameUtils;
&nbsp;import org.apache.commons.io.IOUtils;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.apache.commons.logging.LogFactory;
&nbsp;import org.jenkinsci.Symbol;
&nbsp;import org.jvnet.hudson.reactor.Executable;
&nbsp;import org.jvnet.hudson.reactor.Reactor;
&nbsp;import org.jvnet.hudson.reactor.TaskBuilder;
&nbsp;import org.jvnet.hudson.reactor.TaskGraphBuilder;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.HttpRedirect;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.StaplerFallback;
&nbsp;import org.kohsuke.stapler.StaplerOverridable;
&nbsp;import org.kohsuke.stapler.StaplerProxy;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.kohsuke.stapler.verb.POST;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;import org.xml.sax.Attributes;
&nbsp;import org.xml.sax.InputSource;
&nbsp;import org.xml.sax.SAXException;
&nbsp;import org.xml.sax.helpers.DefaultHandler;
&nbsp;
&nbsp;/**
&nbsp; * Manages {@link PluginWrapper}s.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Setting default Plugin Managers&lt;/b&gt;. The default plugin manager in {@code Jenkins} can be replaced by defining a
&nbsp; * System Property ({@code hudson.PluginManager.className}). See {@link #createDefault(Jenkins)}.
&nbsp; * This className should be available on early startup, so it cannot come only from a library
&nbsp; * (e.g. Jenkins module or Extra library dependency in the WAR file project).
&nbsp; * Plugins cannot be used for such purpose.
&nbsp; * In order to be correctly instantiated, the class definition must have at least one constructor with the same
&nbsp; * signature as the following ones:
&nbsp; * &lt;ol&gt;
&nbsp; *     &lt;li&gt;{@link LocalPluginManager#LocalPluginManager(Jenkins)} &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link LocalPluginManager#LocalPluginManager(ServletContext, File)} &lt;/li&gt;
&nbsp; *     &lt;li&gt;{@link LocalPluginManager#LocalPluginManager(File)} &lt;/li&gt;
&nbsp; * &lt;/ol&gt;
&nbsp; * Constructors are searched in the order provided above and only the first found suitable constructor is
&nbsp; * tried to build an instance. In the last two cases the {@link File} argument refers to the &lt;i&gt;Jenkins home directory&lt;/i&gt;.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public abstract class PluginManager extends AbstractModelObject implements OnMaster, StaplerOverridable, StaplerProxy {
&nbsp;    /** Custom plugin manager system property or context param. */
<b class="fc">&nbsp;    public static final String CUSTOM_PLUGIN_MANAGER = PluginManager.class.getName() + &quot;.className&quot;;</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(PluginManager.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Time elapsed between retries to check the updates sites. It&#39;s kind of constant, but let it so for tests
&nbsp;     */
&nbsp;    /* private final */ static int CHECK_UPDATE_SLEEP_TIME_MILLIS;
&nbsp;
&nbsp;    /**
&nbsp;     * Number of attempts to check the updates sites. It&#39;s kind of constant, but let it so for tests
&nbsp;     */
&nbsp;    /* private final */ static int CHECK_UPDATE_ATTEMPTS;
&nbsp;
&nbsp;    static {
&nbsp;        try {
&nbsp;            // Secure initialization
<b class="fc">&nbsp;            CHECK_UPDATE_SLEEP_TIME_MILLIS = SystemProperties.getInteger(PluginManager.class.getName() + &quot;.checkUpdateSleepTimeMillis&quot;, 1000);</b>
<b class="fc">&nbsp;            CHECK_UPDATE_ATTEMPTS = SystemProperties.getInteger(PluginManager.class.getName() + &quot;.checkUpdateAttempts&quot;, 1);</b>
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            LOGGER.warning(String.format(&quot;There was an error initializing the PluginManager. Exception: %s&quot;, e));</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            CHECK_UPDATE_ATTEMPTS = CHECK_UPDATE_ATTEMPTS &gt; 0 ? CHECK_UPDATE_ATTEMPTS : 1;</b>
<b class="fc">&nbsp;            CHECK_UPDATE_SLEEP_TIME_MILLIS = CHECK_UPDATE_SLEEP_TIME_MILLIS &gt; 0 ? CHECK_UPDATE_SLEEP_TIME_MILLIS : 1000;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Accepted constructors for custom plugin manager, in the order they are tried. */
<b class="nc">&nbsp;    private enum PMConstructor {</b>
<b class="nc">&nbsp;        JENKINS {</b>
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            PluginManager doCreate(@NonNull Class&lt;? extends PluginManager&gt; klass,
&nbsp;                                   @NonNull Jenkins jenkins) throws ReflectiveOperationException {
<b class="nc">&nbsp;                return klass.getConstructor(Jenkins.class).newInstance(jenkins);</b>
&nbsp;            }
&nbsp;        },
<b class="nc">&nbsp;        SC_FILE {</b>
&nbsp;            @Override
&nbsp;            @NonNull PluginManager doCreate(@NonNull Class&lt;? extends PluginManager&gt; klass,
&nbsp;                                            @NonNull Jenkins jenkins) throws ReflectiveOperationException {
<b class="nc">&nbsp;                return klass.getConstructor(ServletContext.class, File.class).newInstance(jenkins.servletContext, jenkins.getRootDir());</b>
&nbsp;            }
&nbsp;        },
<b class="nc">&nbsp;        FILE {</b>
&nbsp;            @Override
&nbsp;            @NonNull PluginManager doCreate(@NonNull Class&lt;? extends PluginManager&gt; klass,
&nbsp;                                            @NonNull Jenkins jenkins) throws ReflectiveOperationException {
<b class="nc">&nbsp;                return klass.getConstructor(File.class).newInstance(jenkins.getRootDir());</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        final @CheckForNull PluginManager create(@NonNull Class&lt;? extends PluginManager&gt; klass,
&nbsp;                                                 @NonNull Jenkins jenkins) throws ReflectiveOperationException {
&nbsp;            try {
<b class="nc">&nbsp;                return doCreate(klass, jenkins);</b>
<b class="nc">&nbsp;            } catch (NoSuchMethodException e) {</b>
&nbsp;                // Constructor not found. Will try the remaining ones.
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        abstract @NonNull PluginManager doCreate(@NonNull Class&lt;? extends PluginManager&gt; klass,
&nbsp;                                                 @NonNull Jenkins jenkins) throws ReflectiveOperationException;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates the {@link PluginManager} to use if no one is provided to a {@link Jenkins} object.
&nbsp;     * This method will be called after creation of {@link Jenkins} object, but before it is fully initialized.
&nbsp;     * @param jenkins Jenkins Instance.
&nbsp;     * @return Plugin manager to use. If no custom class is configured or in case of any error, the default
&nbsp;     * {@link LocalPluginManager} is returned.
&nbsp;     */
&nbsp;    public static @NonNull PluginManager createDefault(@NonNull Jenkins jenkins) {
<b class="nc">&nbsp;        String pmClassName = SystemProperties.getString(CUSTOM_PLUGIN_MANAGER);</b>
<b class="nc">&nbsp;        if (!StringUtils.isBlank(pmClassName)) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, String.format(&quot;Use of custom plugin manager [%s] requested.&quot;, pmClassName));</b>
&nbsp;            try {
<b class="nc">&nbsp;                final Class&lt;? extends PluginManager&gt; klass = Class.forName(pmClassName).asSubclass(PluginManager.class);</b>
&nbsp;                // Iteration is in declaration order
<b class="nc">&nbsp;                for (PMConstructor c : PMConstructor.values()) {</b>
<b class="nc">&nbsp;                    PluginManager pm = c.create(klass, jenkins);</b>
<b class="nc">&nbsp;                    if (pm != null) {</b>
<b class="nc">&nbsp;                        return pm;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                LOGGER.log(WARNING, String.format(&quot;Provided custom plugin manager [%s] does not provide any of the suitable constructors. Using default.&quot;, pmClassName));</b>
<b class="nc">&nbsp;            } catch (ClassCastException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, String.format(&quot;Provided class [%s] does not extend PluginManager. Using default.&quot;, pmClassName));</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, String.format(&quot;Unable to instantiate custom plugin manager [%s]. Using default.&quot;, pmClassName), e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return new LocalPluginManager(jenkins);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * All discovered plugins.
&nbsp;     */
<b class="fc">&nbsp;    protected final List&lt;PluginWrapper&gt; plugins = new CopyOnWriteArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * All active plugins, topologically sorted so that when X depends on Y, Y appears in the list before X does.
&nbsp;     */
<b class="fc">&nbsp;    protected final List&lt;PluginWrapper&gt; activePlugins = new CopyOnWriteArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    protected final List&lt;FailedPlugin&gt; failedPlugins = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Plug-in root directory.
&nbsp;     */
&nbsp;    public final File rootDir;
&nbsp;
&nbsp;    /**
&nbsp;     * Hold the status of the last try to check update centers. Consumed from the check.jelly to show an
&nbsp;     * error message if the last attempt failed.
&nbsp;     */
<b class="fc">&nbsp;    private String lastErrorCheckUpdateCenters = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * If non-null, the base directory for all exploded .hpi/.jpi plugins. Controlled by the system property / servlet
&nbsp;     * context parameter {@literal hudson.PluginManager.workDir}.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    private final File workDir;
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.355
&nbsp;     *      {@link PluginManager} can now live longer than {@link jenkins.model.Jenkins} instance, so
&nbsp;     *      use {@code Hudson.getInstance().servletContext} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final ServletContext context;
&nbsp;
&nbsp;    /**
&nbsp;     * {@link ClassLoader} that can load all the publicly visible classes from plugins
&nbsp;     * (and including the classloader that loads Hudson itself.)
&nbsp;     *
&nbsp;     */
&nbsp;    // implementation is minimal --- just enough to run XStream
&nbsp;    // and load plugin-contributed classes.
<b class="fc">&nbsp;    public final ClassLoader uberClassLoader = new UberClassLoader(activePlugins);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Once plugin is uploaded, this flag becomes true.
&nbsp;     * This is used to report a message that Jenkins needs to be restarted
&nbsp;     * for new plugins to take effect.
&nbsp;     */
<b class="fc">&nbsp;    public volatile boolean pluginUploaded = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The initialization of {@link PluginManager} splits into two parts;
&nbsp;     * one is the part about listing them, extracting them, and preparing classloader for them.
&nbsp;     * The 2nd part is about creating instances. Once the former completes this flags become true,
&nbsp;     * as the 2nd part can be repeated for each Hudson instance.
&nbsp;     */
<b class="fc">&nbsp;    private boolean pluginListed = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Strategy for creating and initializing plugins
&nbsp;     */
&nbsp;    private final PluginStrategy strategy;
&nbsp;
<b class="fc">&nbsp;    protected PluginManager(ServletContext context, File rootDir) {</b>
<b class="fc">&nbsp;        this.context = context;</b>
&nbsp;
<b class="fc">&nbsp;        this.rootDir = rootDir;</b>
&nbsp;        try {
<b class="fc">&nbsp;            Util.createDirectories(rootDir.toPath());</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new UncheckedIOException(e);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        String workDir = SystemProperties.getString(PluginManager.class.getName() + &quot;.workDir&quot;);</b>
<b class="fc">&nbsp;        this.workDir = StringUtils.isBlank(workDir) ? null : new File(workDir);</b>
&nbsp;
<b class="fc">&nbsp;        strategy = createPluginStrategy();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);</b>
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If non-null, the base directory for all exploded .hpi/.jpi plugins.
&nbsp;     * @return the base directory for all exploded .hpi/.jpi plugins or {@code null} to leave this up to the strategy.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public File getWorkDir() {
<b class="nc">&nbsp;        return workDir;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Find all registered overrides (intended to allow overriding/adding views)
&nbsp;     * @return List of extensions
&nbsp;     * @since 1.627
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Collection&lt;PluginManagerStaplerOverride&gt; getOverrides() {
<b class="nc">&nbsp;        return PluginManagerStaplerOverride.all();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called immediately after the construction.
&nbsp;     * This is a separate method so that code executed from here will see a valid value in
&nbsp;     * {@link jenkins.model.Jenkins#pluginManager}.
&nbsp;     */
&nbsp;    public TaskBuilder initTasks(final InitStrategy initStrategy) {
&nbsp;        TaskBuilder builder;
<b class="nc">&nbsp;        if (!pluginListed) {</b>
<b class="nc">&nbsp;            builder = new TaskGraphBuilder() {</b>
&nbsp;                List&lt;File&gt; archives;
&nbsp;                Collection&lt;String&gt; bundledPlugins;
&nbsp;
&nbsp;                {
<b class="nc">&nbsp;                    Handle loadBundledPlugins = add(&quot;Loading bundled plugins&quot;, new Executable() {</b>
&nbsp;                        @Override
&nbsp;                        public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                            bundledPlugins = loadBundledPlugins();</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;
<b class="nc">&nbsp;                    Handle listUpPlugins = requires(loadBundledPlugins).add(&quot;Listing up plugins&quot;, new Executable() {</b>
&nbsp;                        @Override
&nbsp;                        public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                            archives = initStrategy.listPluginArchives(PluginManager.this);</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;
<b class="nc">&nbsp;                    requires(listUpPlugins).attains(PLUGINS_LISTED).add(&quot;Preparing plugins&quot;, new Executable() {</b>
&nbsp;                        @Override
&nbsp;                        public void run(Reactor session) throws Exception {
&nbsp;                            // once we&#39;ve listed plugins, we can fill in the reactor with plugin-specific initialization tasks
<b class="nc">&nbsp;                            TaskGraphBuilder g = new TaskGraphBuilder();</b>
&nbsp;
<b class="nc">&nbsp;                            final Map&lt;String, File&gt; inspectedShortNames = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;                            for (final File arc : archives) {</b>
<b class="nc">&nbsp;                                g.followedBy().notFatal().attains(PLUGINS_LISTED).add(&quot;Inspecting plugin &quot; + arc, new Executable() {</b>
&nbsp;                                    @Override
&nbsp;                                    public void run(Reactor session1) throws Exception {
&nbsp;                                        try {
<b class="nc">&nbsp;                                            PluginWrapper p = strategy.createPluginWrapper(arc);</b>
<b class="nc">&nbsp;                                            if (isDuplicate(p)) return;</b>
&nbsp;
<b class="nc">&nbsp;                                            p.isBundled = containsHpiJpi(bundledPlugins, arc.getName());</b>
<b class="nc">&nbsp;                                            plugins.add(p);</b>
<b class="nc">&nbsp;                                        } catch (IOException e) {</b>
<b class="nc">&nbsp;                                            failedPlugins.add(new FailedPlugin(arc.getName(), e));</b>
<b class="nc">&nbsp;                                            throw e;</b>
<b class="nc">&nbsp;                                        }</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Inspects duplication. this happens when you run hpi:run on a bundled plugin,
&nbsp;                                     * as well as putting numbered jpi files, like &quot;cobertura-1.0.jpi&quot; and &quot;cobertura-1.1.jpi&quot;
&nbsp;                                     */
&nbsp;                                    private boolean isDuplicate(PluginWrapper p) {
<b class="nc">&nbsp;                                        String shortName = p.getShortName();</b>
<b class="nc">&nbsp;                                        if (inspectedShortNames.containsKey(shortName)) {</b>
<b class="nc">&nbsp;                                            LOGGER.info(&quot;Ignoring &quot; + arc + &quot; because &quot; + inspectedShortNames.get(shortName) + &quot; is already loaded&quot;);</b>
<b class="nc">&nbsp;                                            return true;</b>
&nbsp;                                        }
&nbsp;
<b class="nc">&nbsp;                                        inspectedShortNames.put(shortName, arc);</b>
<b class="nc">&nbsp;                                        return false;</b>
&nbsp;                                    }
&nbsp;                                });
<b class="nc">&nbsp;                            }</b>
&nbsp;
<b class="nc">&nbsp;                            g.followedBy().attains(PLUGINS_LISTED).add(&quot;Checking cyclic dependencies&quot;, new Executable() {</b>
&nbsp;                                /**
&nbsp;                                 * Makes sure there&#39;s no cycle in dependencies.
&nbsp;                                 */
&nbsp;                                @Override
&nbsp;                                public void run(Reactor reactor) throws Exception {
&nbsp;                                    try {
<b class="nc">&nbsp;                                        CyclicGraphDetector&lt;PluginWrapper&gt; cgd = new CyclicGraphDetector&lt;&gt;() {</b>
&nbsp;                                            @Override
&nbsp;                                            protected List&lt;PluginWrapper&gt; getEdges(PluginWrapper p) {
<b class="nc">&nbsp;                                                List&lt;PluginWrapper&gt; next = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                                                addTo(p.getDependencies(), next);</b>
<b class="nc">&nbsp;                                                addTo(p.getOptionalDependencies(), next);</b>
<b class="nc">&nbsp;                                                return next;</b>
&nbsp;                                            }
&nbsp;
&nbsp;                                            private void addTo(List&lt;Dependency&gt; dependencies, List&lt;PluginWrapper&gt; r) {
<b class="nc">&nbsp;                                                for (Dependency d : dependencies) {</b>
<b class="nc">&nbsp;                                                    PluginWrapper p = getPlugin(d.shortName);</b>
<b class="nc">&nbsp;                                                    if (p != null)</b>
<b class="nc">&nbsp;                                                        r.add(p);</b>
<b class="nc">&nbsp;                                                }</b>
&nbsp;                                            }
&nbsp;
&nbsp;                                            @Override
&nbsp;                                            protected void reactOnCycle(PluginWrapper q, List&lt;PluginWrapper&gt; cycle) {
&nbsp;
<b class="nc">&nbsp;                                                LOGGER.log(Level.SEVERE, &quot;found cycle in plugin dependencies: (root=&quot; + q + &quot;, deactivating all involved) &quot; + cycle.stream().map(Object::toString).collect(Collectors.joining(&quot; -&gt; &quot;)));</b>
<b class="nc">&nbsp;                                                for (PluginWrapper pluginWrapper : cycle) {</b>
<b class="nc">&nbsp;                                                    pluginWrapper.setHasCycleDependency(true);</b>
<b class="nc">&nbsp;                                                    failedPlugins.add(new FailedPlugin(pluginWrapper, new CycleDetectedException(cycle)));</b>
<b class="nc">&nbsp;                                                }</b>
&nbsp;                                            }
&nbsp;
&nbsp;                                        };
<b class="nc">&nbsp;                                        cgd.run(getPlugins());</b>
&nbsp;
&nbsp;                                        // obtain topologically sorted list and overwrite the list
<b class="nc">&nbsp;                                        for (PluginWrapper p : cgd.getSorted()) {</b>
<b class="nc">&nbsp;                                            if (p.isActive()) {</b>
<b class="nc">&nbsp;                                                activePlugins.add(p);</b>
<b class="nc">&nbsp;                                                ((UberClassLoader) uberClassLoader).clearCacheMisses();</b>
&nbsp;                                            }
<b class="nc">&nbsp;                                        }</b>
<b class="nc">&nbsp;                                    } catch (CycleDetectedException e) { // TODO this should be impossible, since we override reactOnCycle to not throw the exception</b>
<b class="nc">&nbsp;                                        stop(); // disable all plugins since classloading from them can lead to StackOverflow</b>
<b class="nc">&nbsp;                                        throw e;    // let Hudson fail</b>
<b class="nc">&nbsp;                                    }</b>
&nbsp;                                }
&nbsp;                            });
&nbsp;
<b class="nc">&nbsp;                            session.addAll(g.discoverTasks(session));</b>
&nbsp;
<b class="nc">&nbsp;                            pluginListed = true; // technically speaking this is still too early, as at this point tasks are merely scheduled, not necessarily executed.</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;                }
&nbsp;            };
&nbsp;        } else {
<b class="nc">&nbsp;            builder = TaskBuilder.EMPTY_BUILDER;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final InitializerFinder initializerFinder = new InitializerFinder(uberClassLoader);        // misc. stuff</b>
&nbsp;
&nbsp;        // lists up initialization tasks about loading plugins.
<b class="nc">&nbsp;        return TaskBuilder.union(initializerFinder, // this scans @Initializer in the core once</b>
<b class="nc">&nbsp;                builder, new TaskGraphBuilder() {{</b>
<b class="nc">&nbsp;            requires(PLUGINS_LISTED).attains(PLUGINS_PREPARED).add(&quot;Loading plugins&quot;, new Executable() {</b>
&nbsp;                /**
&nbsp;                 * Once the plugins are listed, schedule their initialization.
&nbsp;                 */
&nbsp;                @Override
&nbsp;                public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                    Jenkins.get().lookup.set(PluginInstanceStore.class, new PluginInstanceStore());</b>
<b class="nc">&nbsp;                    TaskGraphBuilder g = new TaskGraphBuilder();</b>
&nbsp;
&nbsp;                    // schedule execution of loading plugins
<b class="nc">&nbsp;                    for (final PluginWrapper p : activePlugins.toArray(new PluginWrapper[0])) {</b>
<b class="nc">&nbsp;                        g.followedBy().notFatal().attains(PLUGINS_PREPARED).add(String.format(&quot;Loading plugin %s v%s (%s)&quot;, p.getLongName(), p.getVersion(), p.getShortName()), new Executable() {</b>
&nbsp;                            @Override
&nbsp;                            public void run(Reactor session) throws Exception {
&nbsp;                                try {
<b class="nc">&nbsp;                                    p.resolvePluginDependencies();</b>
<b class="nc">&nbsp;                                    strategy.load(p);</b>
<b class="nc">&nbsp;                                } catch (MissingDependencyException e) {</b>
<b class="nc">&nbsp;                                    failedPlugins.add(new FailedPlugin(p, e));</b>
<b class="nc">&nbsp;                                    activePlugins.remove(p);</b>
<b class="nc">&nbsp;                                    plugins.remove(p);</b>
<b class="nc">&nbsp;                                    p.releaseClassLoader();</b>
<b class="nc">&nbsp;                                    LOGGER.log(Level.SEVERE, &quot;Failed to install {0}: {1}&quot;, new Object[] { p.getShortName(), e.getMessage() });</b>
<b class="nc">&nbsp;                                } catch (IOException e) {</b>
<b class="nc">&nbsp;                                    failedPlugins.add(new FailedPlugin(p, e));</b>
<b class="nc">&nbsp;                                    activePlugins.remove(p);</b>
<b class="nc">&nbsp;                                    plugins.remove(p);</b>
<b class="nc">&nbsp;                                    p.releaseClassLoader();</b>
<b class="nc">&nbsp;                                    throw e;</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        });
&nbsp;                    }
&nbsp;
&nbsp;                    // schedule execution of initializing plugins
<b class="nc">&nbsp;                    for (final PluginWrapper p : activePlugins.toArray(new PluginWrapper[0])) {</b>
<b class="nc">&nbsp;                        g.followedBy().notFatal().attains(PLUGINS_STARTED).add(&quot;Initializing plugin &quot; + p.getShortName(), new Executable() {</b>
&nbsp;                            @Override
&nbsp;                            public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                                if (!activePlugins.contains(p)) {</b>
&nbsp;                                    return;
&nbsp;                                }
&nbsp;                                try {
<b class="nc">&nbsp;                                    p.getPluginOrFail().postInitialize();</b>
<b class="nc">&nbsp;                                } catch (Exception e) {</b>
<b class="nc">&nbsp;                                    failedPlugins.add(new FailedPlugin(p, e));</b>
<b class="nc">&nbsp;                                    activePlugins.remove(p);</b>
<b class="nc">&nbsp;                                    plugins.remove(p);</b>
<b class="nc">&nbsp;                                    p.releaseClassLoader();</b>
<b class="nc">&nbsp;                                    throw e;</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        });
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    g.followedBy().attains(PLUGINS_STARTED).add(&quot;Discovering plugin initialization tasks&quot;, new Executable() {</b>
&nbsp;                        @Override
&nbsp;                        public void run(Reactor reactor) throws Exception {
&nbsp;                            // rescan to find plugin-contributed @Initializer
<b class="nc">&nbsp;                            reactor.addAll(initializerFinder.discoverTasks(reactor));</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;
&nbsp;                    // register them all
<b class="nc">&nbsp;                    session.addAll(g.discoverTasks(session));</b>
&nbsp;                }
&nbsp;            });
&nbsp;
&nbsp;            // All plugins are loaded. Now we can figure out who depends on who.
<b class="nc">&nbsp;            requires(PLUGINS_PREPARED).attains(COMPLETED).add(&quot;Resolving Dependent Plugins Graph&quot;, new Executable() {</b>
&nbsp;                @Override
&nbsp;                public void run(Reactor reactor) throws Exception {
<b class="nc">&nbsp;                    resolveDependentPlugins();</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }});
&nbsp;    }
&nbsp;
&nbsp;    void considerDetachedPlugin(String shortName) {
<b class="nc">&nbsp;        if (new File(rootDir, shortName + &quot;.jpi&quot;).isFile() ||</b>
<b class="nc">&nbsp;            new File(rootDir, shortName + &quot;.hpi&quot;).isFile() ||</b>
<b class="nc">&nbsp;            new File(rootDir, shortName + &quot;.jpl&quot;).isFile() ||</b>
<b class="nc">&nbsp;            new File(rootDir, shortName + &quot;.hpl&quot;).isFile()) {</b>
<b class="nc">&nbsp;            LOGGER.fine(() -&gt; &quot;not considering loading a detached dependency &quot; + shortName + &quot; as it is already on disk&quot;);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        LOGGER.fine(() -&gt; &quot;considering loading a detached dependency &quot; + shortName);</b>
<b class="nc">&nbsp;        for (String loadedFile : loadPluginsFromWar(getDetachedLocation(), (dir, name) -&gt; normalisePluginName(name).equals(shortName))) {</b>
<b class="nc">&nbsp;            String loaded = normalisePluginName(loadedFile);</b>
<b class="nc">&nbsp;            File arc = new File(rootDir, loaded + &quot;.jpi&quot;);</b>
<b class="nc">&nbsp;            LOGGER.info(() -&gt; &quot;Loading a detached plugin as a dependency: &quot; + arc);</b>
&nbsp;            try {
<b class="nc">&nbsp;                plugins.add(strategy.createPluginWrapper(arc));</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                failedPlugins.add(new FailedPlugin(arc.getName(), e));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the location of the detached plugins in the WAR.
&nbsp;     * @return by default, {@code /WEB-INF/detached-plugins}
&nbsp;     * @since 2.377
&nbsp;     */
&nbsp;    protected @NonNull String getDetachedLocation() {
<b class="nc">&nbsp;        return &quot;/WEB-INF/detached-plugins&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected @NonNull Set&lt;String&gt; loadPluginsFromWar(@NonNull String fromPath) {
<b class="nc">&nbsp;        return loadPluginsFromWar(fromPath, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    //TODO: Consider refactoring in order to avoid DMI_COLLECTION_OF_URLS
&nbsp;    @SuppressFBWarnings(value = &quot;DMI_COLLECTION_OF_URLS&quot;, justification = &quot;Plugin loading happens only once on Jenkins startup&quot;)
&nbsp;    protected @NonNull Set&lt;String&gt; loadPluginsFromWar(@NonNull String fromPath, @CheckForNull FilenameFilter filter) {
<b class="nc">&nbsp;        Set&lt;String&gt; names = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        ServletContext context = Jenkins.get().servletContext;</b>
<b class="nc">&nbsp;        Set&lt;String&gt; plugins = Util.fixNull(context.getResourcePaths(fromPath));</b>
<b class="nc">&nbsp;        Set&lt;URL&gt; copiedPlugins = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;URL&gt; dependencies = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (String pluginPath : plugins) {</b>
<b class="nc">&nbsp;            String fileName = pluginPath.substring(pluginPath.lastIndexOf(&#39;/&#39;) + 1);</b>
<b class="nc">&nbsp;            if (fileName.isEmpty()) {</b>
&nbsp;                // see http://www.nabble.com/404-Not-Found-error-when-clicking-on-help-td24508544.html
&nbsp;                // I suspect some containers are returning directory names.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                URL url = context.getResource(pluginPath);</b>
<b class="nc">&nbsp;                if (filter != null &amp;&amp; url != null) {</b>
<b class="nc">&nbsp;                    if (!filter.accept(new File(url.getFile()).getParentFile(), fileName)) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                names.add(fileName);</b>
<b class="nc">&nbsp;                copyBundledPlugin(Objects.requireNonNull(url), fileName);</b>
<b class="nc">&nbsp;                copiedPlugins.add(url);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    addDependencies(url, fromPath, dependencies);</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.SEVERE, &quot;Failed to resolve dependencies for the bundled plugin &quot; + fileName, e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to extract the bundled plugin &quot; + fileName, e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Copy dependencies. These are not detached plugins, but are required by them.
<b class="nc">&nbsp;        for (URL dependency : dependencies) {</b>
<b class="nc">&nbsp;            if (copiedPlugins.contains(dependency)) {</b>
&nbsp;                // Ignore. Already copied.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String fileName = new File(dependency.getFile()).getName();</b>
&nbsp;            try {
<b class="nc">&nbsp;                names.add(fileName);</b>
<b class="nc">&nbsp;                copyBundledPlugin(dependency, fileName);</b>
<b class="nc">&nbsp;                copiedPlugins.add(dependency);</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to extract the bundled dependency plugin &quot; + fileName, e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return names;</b>
&nbsp;    }
&nbsp;
&nbsp;    //TODO: Consider refactoring in order to avoid DMI_COLLECTION_OF_URLS
&nbsp;    @SuppressFBWarnings(value = &quot;DMI_COLLECTION_OF_URLS&quot;, justification = &quot;Plugin loading happens only once on Jenkins startup&quot;)
&nbsp;    protected static void addDependencies(URL hpiResUrl, String fromPath, Set&lt;URL&gt; dependencySet) throws URISyntaxException, MalformedURLException {
<b class="nc">&nbsp;        if (dependencySet.contains(hpiResUrl)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        Manifest manifest = parsePluginManifest(hpiResUrl);</b>
<b class="nc">&nbsp;        String dependencySpec = manifest.getMainAttributes().getValue(&quot;Plugin-Dependencies&quot;);</b>
<b class="nc">&nbsp;        if (dependencySpec != null) {</b>
<b class="nc">&nbsp;            String[] dependencyTokens = dependencySpec.split(&quot;,&quot;);</b>
<b class="nc">&nbsp;            ServletContext context = Jenkins.get().servletContext;</b>
&nbsp;
<b class="nc">&nbsp;            for (String dependencyToken : dependencyTokens) {</b>
<b class="nc">&nbsp;                if (dependencyToken.endsWith(&quot;;resolution:=optional&quot;)) {</b>
&nbsp;                    // ignore optional dependencies
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                String[] artifactIdVersionPair = dependencyToken.split(&quot;:&quot;);</b>
<b class="nc">&nbsp;                String artifactId = artifactIdVersionPair[0];</b>
<b class="nc">&nbsp;                VersionNumber dependencyVersion = new VersionNumber(artifactIdVersionPair[1]);</b>
&nbsp;
<b class="nc">&nbsp;                PluginManager manager = Jenkins.get().getPluginManager();</b>
<b class="nc">&nbsp;                VersionNumber installedVersion = manager.getPluginVersion(manager.rootDir, artifactId);</b>
<b class="nc">&nbsp;                if (installedVersion != null &amp;&amp; !installedVersion.isOlderThan(dependencyVersion)) {</b>
&nbsp;                    // Do not downgrade dependencies that are already installed.
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                URL dependencyURL = context.getResource(fromPath + &quot;/&quot; + artifactId + &quot;.hpi&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                if (dependencyURL == null) {</b>
&nbsp;                    // Maybe bundling has changed .jpi files
<b class="nc">&nbsp;                    dependencyURL = context.getResource(fromPath + &quot;/&quot; + artifactId + &quot;.jpi&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (dependencyURL != null) {</b>
&nbsp;                    // And transitive deps...
<b class="nc">&nbsp;                    addDependencies(dependencyURL, fromPath, dependencySet);</b>
&nbsp;                    // And then add the current plugin
<b class="nc">&nbsp;                    dependencySet.add(dependencyURL);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Load detached plugins and their dependencies.
&nbsp;     * &lt;p&gt;
&nbsp;     * Only loads plugins that:
&nbsp;     * &lt;ul&gt;
&nbsp;     *     &lt;li&gt;Have been detached since the last running version.&lt;/li&gt;
&nbsp;     *     &lt;li&gt;Are already installed and need to be upgraded. This can be the case if this Jenkins install has been running since before plugins were &quot;unbundled&quot;.&lt;/li&gt;
&nbsp;     *     &lt;li&gt;Are dependencies of one of the above e.g. script-security is not one of the detached plugins but it must be loaded if matrix-project is loaded.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     */
&nbsp;    protected void loadDetachedPlugins() {
<b class="nc">&nbsp;        VersionNumber lastExecVersion = new VersionNumber(InstallUtil.getLastExecVersion());</b>
<b class="nc">&nbsp;        if (lastExecVersion.isNewerThan(InstallUtil.NEW_INSTALL_VERSION) &amp;&amp; lastExecVersion.isOlderThan(Jenkins.getVersion())) {</b>
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(INFO, &quot;Upgrading Jenkins. The last running version was {0}. This Jenkins is version {1}.&quot;,</b>
&nbsp;                    new Object[] {lastExecVersion, Jenkins.VERSION});
&nbsp;
<b class="nc">&nbsp;            final List&lt;DetachedPluginsUtil.DetachedPlugin&gt; detachedPlugins = DetachedPluginsUtil.getDetachedPlugins(lastExecVersion);</b>
&nbsp;
<b class="nc">&nbsp;            Set&lt;String&gt; loadedDetached = loadPluginsFromWar(getDetachedLocation(), new FilenameFilter() {</b>
&nbsp;                @Override
&nbsp;                public boolean accept(File dir, String name) {
<b class="nc">&nbsp;                    name = normalisePluginName(name);</b>
&nbsp;
&nbsp;                    // If this was a plugin that was detached some time in the past i.e. not just one of the
&nbsp;                    // plugins that was bundled &quot;for fun&quot;.
<b class="nc">&nbsp;                    if (DetachedPluginsUtil.isDetachedPlugin(name)) {</b>
<b class="nc">&nbsp;                        VersionNumber installedVersion = getPluginVersion(rootDir, name);</b>
<b class="nc">&nbsp;                        VersionNumber bundledVersion = getPluginVersion(dir, name);</b>
&nbsp;                        // If the plugin is already installed, we need to decide whether to replace it with the bundled version.
<b class="nc">&nbsp;                        if (installedVersion != null &amp;&amp; bundledVersion != null) {</b>
&nbsp;                            // If the installed version is older than the bundled version, then it MUST be upgraded.
&nbsp;                            // If the installed version is newer than the bundled version, then it MUST NOT be upgraded.
&nbsp;                            // If the versions are equal we just keep the installed version.
<b class="nc">&nbsp;                            return installedVersion.isOlderThan(bundledVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    // If it&#39;s a plugin that was detached since the last running version.
<b class="nc">&nbsp;                    for (DetachedPluginsUtil.DetachedPlugin detachedPlugin : detachedPlugins) {</b>
<b class="nc">&nbsp;                        if (detachedPlugin.getShortName().equals(name)) {</b>
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    // Otherwise skip this and do not install.
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            });
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(INFO, &quot;Upgraded Jenkins from version {0} to version {1}. Loaded detached plugins (and dependencies): {2}&quot;,</b>
&nbsp;                    new Object[] {lastExecVersion, Jenkins.VERSION, loadedDetached});
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            final Set&lt;DetachedPluginsUtil.DetachedPlugin&gt; forceUpgrade = new HashSet&lt;&gt;();</b>
&nbsp;            // TODO using getDetachedPlugins here seems wrong; should be forcing an upgrade when the installed version is older than that in getDetachedLocation()
<b class="nc">&nbsp;            for (DetachedPluginsUtil.DetachedPlugin p : DetachedPluginsUtil.getDetachedPlugins()) {</b>
<b class="nc">&nbsp;                VersionNumber installedVersion = getPluginVersion(rootDir, p.getShortName());</b>
<b class="nc">&nbsp;                VersionNumber requiredVersion = p.getRequiredVersion();</b>
<b class="nc">&nbsp;                if (installedVersion != null &amp;&amp; installedVersion.isOlderThan(requiredVersion)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING,</b>
&nbsp;                            &quot;Detached plugin {0} found at version {1}, required minimum version is {2}&quot;,
<b class="nc">&nbsp;                            new Object[]{p.getShortName(), installedVersion, requiredVersion});</b>
<b class="nc">&nbsp;                    forceUpgrade.add(p);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!forceUpgrade.isEmpty()) {</b>
<b class="nc">&nbsp;                Set&lt;String&gt; loadedDetached = loadPluginsFromWar(getDetachedLocation(), new FilenameFilter() {</b>
&nbsp;                    @Override
&nbsp;                    public boolean accept(File dir, String name) {
<b class="nc">&nbsp;                        name = normalisePluginName(name);</b>
<b class="nc">&nbsp;                        for (DetachedPluginsUtil.DetachedPlugin detachedPlugin : forceUpgrade) {</b>
<b class="nc">&nbsp;                            if (detachedPlugin.getShortName().equals(name)) {</b>
<b class="nc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                });
<b class="nc">&nbsp;                LOGGER.log(INFO, &quot;Upgraded detached plugins (and dependencies): {0}&quot;,</b>
&nbsp;                        new Object[]{loadedDetached});
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String normalisePluginName(@NonNull String name) {
&nbsp;        // Normalise the name by stripping off the file extension (if present)...
<b class="nc">&nbsp;        return name.replace(&quot;.jpi&quot;, &quot;&quot;).replace(&quot;.hpi&quot;, &quot;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private @CheckForNull VersionNumber getPluginVersion(@NonNull File dir, @NonNull String pluginId) {
<b class="nc">&nbsp;        VersionNumber version = getPluginVersion(new File(dir, pluginId + &quot;.jpi&quot;));</b>
<b class="nc">&nbsp;        if (version == null) {</b>
<b class="nc">&nbsp;            version = getPluginVersion(new File(dir, pluginId + &quot;.hpi&quot;));</b>
&nbsp;        }
<b class="nc">&nbsp;        return version;</b>
&nbsp;    }
&nbsp;
&nbsp;    private @CheckForNull VersionNumber getPluginVersion(@NonNull File pluginFile) {
<b class="nc">&nbsp;        if (!pluginFile.exists()) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            return getPluginVersion(pluginFile.toURI().toURL());</b>
<b class="nc">&nbsp;        } catch (MalformedURLException e) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private @CheckForNull VersionNumber getPluginVersion(@NonNull URL pluginURL) {
<b class="nc">&nbsp;        Manifest manifest = parsePluginManifest(pluginURL);</b>
<b class="nc">&nbsp;        if (manifest == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        String versionSpec = manifest.getMainAttributes().getValue(&quot;Plugin-Version&quot;);</b>
<b class="nc">&nbsp;        return new VersionNumber(versionSpec);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * contains operation that considers xxx.hpi and xxx.jpi as equal
&nbsp;     * this is necessary since the bundled plugins are still called *.hpi
&nbsp;     */
&nbsp;    private boolean containsHpiJpi(Collection&lt;String&gt; bundledPlugins, String name) {
<b class="nc">&nbsp;        return bundledPlugins.contains(name.replaceAll(&quot;\\.hpi&quot;, &quot;.jpi&quot;))</b>
<b class="nc">&nbsp;                || bundledPlugins.contains(name.replaceAll(&quot;\\.jpi&quot;, &quot;.hpi&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the manifest of a bundled but not-extracted plugin.
&nbsp;     * @deprecated removed without replacement
&nbsp;     */
&nbsp;    @Deprecated // See https://groups.google.com/d/msg/jenkinsci-dev/kRobm-cxFw8/6V66uhibAwAJ
&nbsp;    public @CheckForNull Manifest getBundledPluginManifest(String shortName) {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * TODO: revisit where/how to expose this. This is an experiment.
&nbsp;     */
&nbsp;    public void dynamicLoad(File arc) throws IOException, InterruptedException, RestartRequiredException {
<b class="nc">&nbsp;        dynamicLoad(arc, false, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Try the dynamicLoad, removeExisting to attempt to dynamic load disabled plugins
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void dynamicLoad(File arc, boolean removeExisting, @CheckForNull List&lt;PluginWrapper&gt; batch) throws IOException, InterruptedException, RestartRequiredException {
<b class="nc">&nbsp;        try (ACLContext context = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, &quot;Attempting to dynamic load {0}&quot;, arc);</b>
<b class="nc">&nbsp;            PluginWrapper p = null;</b>
&nbsp;            String sn;
&nbsp;            try {
<b class="nc">&nbsp;                sn = strategy.getShortName(arc);</b>
<b class="nc">&nbsp;            } catch (AbstractMethodError x) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, &quot;JENKINS-12753 fix not active: {0}&quot;, x.getMessage());</b>
<b class="nc">&nbsp;                p = strategy.createPluginWrapper(arc);</b>
<b class="nc">&nbsp;                sn = p.getShortName();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            PluginWrapper pw = getPlugin(sn);</b>
<b class="nc">&nbsp;            if (pw != null) {</b>
<b class="nc">&nbsp;                if (removeExisting) { // try to load disabled plugins</b>
<b class="nc">&nbsp;                    for (Iterator&lt;PluginWrapper&gt; i = plugins.iterator(); i.hasNext();) {</b>
<b class="nc">&nbsp;                        pw = i.next();</b>
<b class="nc">&nbsp;                        if (sn.equals(pw.getShortName())) {</b>
<b class="nc">&nbsp;                            i.remove();</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new RestartRequiredException(Messages._PluginManager_PluginIsAlreadyInstalled_RestartRequired(sn));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (p == null) {</b>
<b class="nc">&nbsp;                p = strategy.createPluginWrapper(arc);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (p.supportsDynamicLoad() == YesNoMaybe.NO)</b>
<b class="nc">&nbsp;                throw new RestartRequiredException(Messages._PluginManager_PluginDoesntSupportDynamicLoad_RestartRequired(sn));</b>
&nbsp;
&nbsp;            // there&#39;s no need to do cyclic dependency check, because we are deploying one at a time,
&nbsp;            // so existing plugins can&#39;t be depending on this newly deployed one.
&nbsp;
<b class="nc">&nbsp;            plugins.add(p);</b>
<b class="nc">&nbsp;            if (p.isActive()) {</b>
<b class="nc">&nbsp;                activePlugins.add(p);</b>
<b class="nc">&nbsp;                ((UberClassLoader) uberClassLoader).clearCacheMisses();</b>
&nbsp;            }
&nbsp;
&nbsp;            // TODO antimodular; perhaps should have a PluginListener to complement ExtensionListListener?
<b class="nc">&nbsp;            CustomClassFilter.Contributed.load();</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                p.resolvePluginDependencies();</b>
<b class="nc">&nbsp;                strategy.load(p);</b>
&nbsp;
<b class="nc">&nbsp;                if (batch != null) {</b>
<b class="nc">&nbsp;                    batch.add(p);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    start(List.of(p));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                failedPlugins.add(new FailedPlugin(p, e));</b>
<b class="nc">&nbsp;                activePlugins.remove(p);</b>
<b class="nc">&nbsp;                plugins.remove(p);</b>
<b class="nc">&nbsp;                p.releaseClassLoader();</b>
<b class="nc">&nbsp;                throw new IOException(&quot;Failed to install &quot; + sn + &quot; plugin&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(FINE, &quot;Plugin {0}:{1} dynamically {2}&quot;, new Object[] {p.getShortName(), p.getVersion(), batch != null ? &quot;loaded but not yet started&quot; : &quot;installed&quot;});</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void start(List&lt;PluginWrapper&gt; plugins) throws Exception {
<b class="nc">&nbsp;      try (ACLContext context = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;        Map&lt;String, PluginWrapper&gt; pluginsByName = plugins.stream().collect(Collectors.toMap(PluginWrapper::getShortName, p -&gt; p));</b>
&nbsp;
&nbsp;        // recalculate dependencies of plugins optionally depending the newly deployed ones.
<b class="nc">&nbsp;        for (PluginWrapper depender : this.plugins) {</b>
<b class="nc">&nbsp;            if (plugins.contains(depender)) {</b>
&nbsp;                // skip itself.
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (Dependency d : depender.getOptionalDependencies()) {</b>
<b class="nc">&nbsp;                PluginWrapper dependee = pluginsByName.get(d.shortName);</b>
<b class="nc">&nbsp;                if (dependee != null) {</b>
&nbsp;                    // this plugin depends on the newly loaded one!
&nbsp;                    // recalculate dependencies!
<b class="nc">&nbsp;                    getPluginStrategy().updateDependency(depender, dependee);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Redo who depends on who.
<b class="nc">&nbsp;        resolveDependentPlugins();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            Jenkins.get().refreshExtensions();</b>
<b class="nc">&nbsp;        } catch (ExtensionRefreshException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to refresh extensions after installing some plugins&quot;, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (PluginWrapper p : plugins) {</b>
&nbsp;            //TODO:According to the postInitialize() documentation, one may expect that
&nbsp;            //p.getPluginOrFail() NPE will continue the initialization. Keeping the original behavior ATM
<b class="nc">&nbsp;          p.getPluginOrFail().postInitialize();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // run initializers in the added plugins
<b class="nc">&nbsp;        Reactor r = new Reactor(InitMilestone.ordering());</b>
<b class="nc">&nbsp;        Set&lt;ClassLoader&gt; loaders = plugins.stream().map(p -&gt; p.classLoader).collect(Collectors.toSet());</b>
<b class="nc">&nbsp;        r.addAll(new InitializerFinder(uberClassLoader) {</b>
&nbsp;          @Override
&nbsp;          protected boolean filter(Method e) {
<b class="nc">&nbsp;            return !loaders.contains(e.getDeclaringClass().getClassLoader()) || super.filter(e);</b>
&nbsp;          }
<b class="nc">&nbsp;        }.discoverTasks(r));</b>
<b class="nc">&nbsp;        new InitReactorRunner().run(r);</b>
<b class="nc">&nbsp;      }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public synchronized void resolveDependentPlugins() {
<b class="nc">&nbsp;        for (PluginWrapper plugin : plugins) {</b>
&nbsp;            // Set of optional dependents plugins of plugin
<b class="nc">&nbsp;            Set&lt;String&gt; optionalDependents = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            Set&lt;String&gt; dependents = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (PluginWrapper possibleDependent : plugins) {</b>
&nbsp;                // No need to check if plugin is dependent of itself
<b class="nc">&nbsp;                if (possibleDependent.getShortName().equals(plugin.getShortName())) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // The plugin could have just been deleted. If so, it doesn&#39;t
&nbsp;                // count as a dependent.
<b class="nc">&nbsp;                if (possibleDependent.isDeleted()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                List&lt;Dependency&gt; dependencies = possibleDependent.getDependencies();</b>
<b class="nc">&nbsp;                for (Dependency dependency : dependencies) {</b>
<b class="nc">&nbsp;                    if (dependency.shortName.equals(plugin.getShortName())) {</b>
<b class="nc">&nbsp;                        dependents.add(possibleDependent.getShortName());</b>
&nbsp;
&nbsp;                        // If, in addition, the dependency is optional, add to the optionalDependents list
<b class="nc">&nbsp;                        if (dependency.optional) {</b>
<b class="nc">&nbsp;                            optionalDependents.add(possibleDependent.getShortName());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        // already know possibleDependent depends on plugin, no need to continue with the rest of
&nbsp;                        // dependencies. We continue with the next possibleDependent
&nbsp;                        break;
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            plugin.setDependents(dependents);</b>
<b class="nc">&nbsp;            plugin.setOptionalDependents(optionalDependents);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If the war file has any &quot;/WEB-INF/plugins/[*.jpi | *.hpi]&quot;, extract them into the plugin directory.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      File names of the bundled plugins. Normally empty (not to be confused with {@link #loadDetachedPlugins}) but OEM WARs may have some.
&nbsp;     * @throws Exception
&nbsp;     *      Any exception will be reported and halt the startup.
&nbsp;     */
&nbsp;    protected abstract Collection&lt;String&gt; loadBundledPlugins() throws Exception;
&nbsp;
&nbsp;    /**
&nbsp;     * Copies the plugin from the given URL to the given destination.
&nbsp;     * Despite the name, this is used also from {@link #loadDetachedPlugins}.
&nbsp;     * Includes a reasonable up-to-date check.
&nbsp;     * A convenience method to be used by {@link #loadBundledPlugins()}.
&nbsp;     * @param fileName like {@code abc.jpi}
&nbsp;     */
&nbsp;    protected void copyBundledPlugin(URL src, String fileName) throws IOException {
<b class="nc">&nbsp;        LOGGER.log(FINE, &quot;Copying {0}&quot;, src);</b>
<b class="nc">&nbsp;        fileName = fileName.replace(&quot;.hpi&quot;, &quot;.jpi&quot;); // normalize fileNames to have the correct suffix</b>
<b class="nc">&nbsp;        String legacyName = fileName.replace(&quot;.jpi&quot;, &quot;.hpi&quot;);</b>
<b class="nc">&nbsp;        long lastModified = getModificationDate(src);</b>
<b class="nc">&nbsp;        File file = new File(rootDir, fileName);</b>
&nbsp;
&nbsp;        // normalization first, if the old file exists.
<b class="nc">&nbsp;        rename(new File(rootDir, legacyName), file);</b>
&nbsp;
&nbsp;        // update file if:
&nbsp;        //  - no file exists today
&nbsp;        //  - bundled version and current version differs (by timestamp).
<b class="nc">&nbsp;        if (!file.exists() || file.lastModified() != lastModified) {</b>
<b class="nc">&nbsp;            FileUtils.copyURLToFile(src, file);</b>
<b class="nc">&nbsp;            Files.setLastModifiedTime(Util.fileToPath(file), FileTime.fromMillis(getModificationDate(src)));</b>
&nbsp;            // lastModified is set for two reasons:
&nbsp;            // - to avoid unpacking as much as possible, but still do it on both upgrade and downgrade
&nbsp;            // - to make sure the value is not changed after each restart, so we can avoid
&nbsp;            // unpacking the plugin itself in ClassicPluginStrategy.explode
&nbsp;        }
&nbsp;
&nbsp;        // Plugin pinning has been deprecated.
&nbsp;        // See https://groups.google.com/d/msg/jenkinsci-dev/kRobm-cxFw8/6V66uhibAwAJ
&nbsp;    }
&nbsp;
&nbsp;    /*package*/ static @CheckForNull Manifest parsePluginManifest(URL bundledJpi) {
<b class="fc">&nbsp;        try (URLClassLoader cl = new URLClassLoader(new URL[]{bundledJpi})) {</b>
<b class="fc">&nbsp;            InputStream in = null;</b>
&nbsp;            try {
<b class="fc">&nbsp;                URL res = cl.findResource(PluginWrapper.MANIFEST_FILENAME);</b>
<b class="fc">&nbsp;                if (res != null) {</b>
<b class="fc">&nbsp;                    in = getBundledJpiManifestStream(res);</b>
<b class="fc">&nbsp;                    return new Manifest(in);</b>
&nbsp;                }
&nbsp;            } finally {
<b class="fc">&nbsp;                Util.closeAndLogFailures(in, LOGGER, PluginWrapper.MANIFEST_FILENAME, bundledJpi.toString());</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;Failed to parse manifest of &quot; + bundledJpi, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves input stream for the Manifest url.
&nbsp;     * The method intelligently handles the case of {@link JarURLConnection} pointing to files within JAR.
&nbsp;     * @param url Url of the manifest file
&nbsp;     * @return Input stream, which allows to retrieve manifest. This stream must be closed outside
&nbsp;     * @throws IOException Operation error
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    /*package*/ static InputStream getBundledJpiManifestStream(@NonNull URL url) throws IOException {
<b class="fc">&nbsp;        URLConnection uc = url.openConnection();</b>
<b class="fc">&nbsp;        InputStream in = null;</b>
&nbsp;        // Magic, which allows to avoid using stream generated for JarURLConnection.
&nbsp;        // It prevents getting into JENKINS-37332 due to the file descriptor leak
<b class="fc">&nbsp;        if (uc instanceof JarURLConnection) {</b>
<b class="fc">&nbsp;            final JarURLConnection jarURLConnection = (JarURLConnection) uc;</b>
<b class="fc">&nbsp;            final String entryName = jarURLConnection.getEntryName();</b>
&nbsp;
<b class="fc">&nbsp;            try (JarFile jarFile = jarURLConnection.getJarFile()) {</b>
<b class="fc">&nbsp;                final JarEntry entry = entryName != null &amp;&amp; jarFile != null ? jarFile.getJarEntry(entryName) : null;</b>
<b class="fc">&nbsp;                if (entry != null) {</b>
<b class="fc">&nbsp;                    try (InputStream i = jarFile.getInputStream(entry)) {</b>
<b class="fc">&nbsp;                        byte[] manifestBytes = i.readAllBytes();</b>
<b class="fc">&nbsp;                        in = new ByteArrayInputStream(manifestBytes);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to locate the JAR file for {0}&quot;</b>
&nbsp;                            + &quot;The default URLConnection stream access will be used, file descriptor may be leaked.&quot;,
&nbsp;                               url);
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // If input stream is undefined, use the default implementation
<b class="fc">&nbsp;        if (in == null) {</b>
<b class="nc">&nbsp;            in = url.openStream();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return in;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves modification date of the specified file.
&nbsp;     * The method intelligently handles the case of {@link JarURLConnection} pointing to files within JAR.
&nbsp;     * @param url Url of the file
&nbsp;     * @return Modification date
&nbsp;     * @throws IOException Operation error
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    /*package*/ static long getModificationDate(@NonNull URL url) throws IOException {
<b class="fc">&nbsp;        URLConnection uc = url.openConnection();</b>
&nbsp;
&nbsp;        // It prevents file descriptor leak if the URL references a file within JAR
&nbsp;        // See JENKINS-37332  for more info
&nbsp;        // The code idea is taken from https://github.com/jknack/handlebars.java/pull/394
<b class="fc">&nbsp;        if (uc instanceof JarURLConnection) {</b>
<b class="fc">&nbsp;            final JarURLConnection connection = (JarURLConnection) uc;</b>
<b class="fc">&nbsp;            final URL jarURL = connection.getJarFileURL();</b>
<b class="fc">&nbsp;            if (jarURL.getProtocol().equals(&quot;file&quot;)) {</b>
<b class="fc">&nbsp;                String file = jarURL.getFile();</b>
<b class="fc">&nbsp;                return new File(file).lastModified();</b>
&nbsp;            } else {
&nbsp;                // We access the data without file protocol
<b class="nc">&nbsp;                if (connection.getEntryName() != null) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;Accessing modification date of {0} file, which is an entry in JAR file. &quot;</b>
&nbsp;                        + &quot;The access protocol is not file:, falling back to the default logic (risk of file descriptor leak).&quot;,
&nbsp;                            url);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Fallbak to the default implementation
<b class="nc">&nbsp;        return uc.getLastModified();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rename a legacy file to a new name, with care to Windows where {@link File#renameTo(File)}
&nbsp;     * doesn&#39;t work if the destination already exists.
&nbsp;     */
&nbsp;    private void rename(File legacyFile, File newFile) throws IOException {
<b class="nc">&nbsp;        if (!legacyFile.exists())   return;</b>
<b class="nc">&nbsp;        if (newFile.exists()) {</b>
<b class="nc">&nbsp;            Util.deleteFile(newFile);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!legacyFile.renameTo(newFile)) {</b>
<b class="nc">&nbsp;            LOGGER.warning(&quot;Failed to rename &quot; + legacyFile + &quot; to &quot; + newFile);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a hudson.PluginStrategy, looking at the corresponding system property.
&nbsp;     */
&nbsp;    protected PluginStrategy createPluginStrategy() {
<b class="fc">&nbsp;        String strategyName = SystemProperties.getString(PluginStrategy.class.getName());</b>
<b class="fc">&nbsp;        if (strategyName != null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                Class&lt;?&gt; klazz = getClass().getClassLoader().loadClass(strategyName);</b>
<b class="nc">&nbsp;                Object strategy = klazz.getConstructor(PluginManager.class)</b>
<b class="nc">&nbsp;                        .newInstance(this);</b>
<b class="nc">&nbsp;                if (strategy instanceof PluginStrategy) {</b>
<b class="nc">&nbsp;                    LOGGER.info(&quot;Plugin strategy: &quot; + strategyName);</b>
<b class="nc">&nbsp;                    return (PluginStrategy) strategy;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    LOGGER.warning(&quot;Plugin strategy (&quot; + strategyName +</b>
&nbsp;                            &quot;) is not an instance of hudson.PluginStrategy&quot;);
&nbsp;                }
<b class="nc">&nbsp;            } catch (ClassNotFoundException e) {</b>
<b class="nc">&nbsp;                LOGGER.warning(&quot;Plugin strategy class not found: &quot;</b>
&nbsp;                        + strategyName);
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, &quot;Could not instantiate plugin strategy: &quot;</b>
&nbsp;                        + strategyName + &quot;. Falling back to ClassicPluginStrategy&quot;, e);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            LOGGER.info(&quot;Falling back to ClassicPluginStrategy&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // default and fallback
<b class="fc">&nbsp;        return new ClassicPluginStrategy(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    public PluginStrategy getPluginStrategy() {
<b class="nc">&nbsp;        return strategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if any new plugin was added.
&nbsp;     */
&nbsp;    public boolean isPluginUploaded() {
<b class="nc">&nbsp;        return pluginUploaded;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * All discovered plugins.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public List&lt;PluginWrapper&gt; getPlugins() {
<b class="nc">&nbsp;        return Collections.unmodifiableList(plugins);</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;FailedPlugin&gt; getFailedPlugins() {
<b class="nc">&nbsp;        return failedPlugins;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the plugin instance with the given short name.
&nbsp;     * @param shortName the short name of the plugin
&nbsp;     * @return The plugin singleton or {@code null} if a plugin with the given short name does not exist.
&nbsp;     *         The fact the plugin is loaded does not mean it is enabled and fully initialized for the current Jenkins session.
&nbsp;     *         Use {@link PluginWrapper#isActive()} to check it.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public PluginWrapper getPlugin(String shortName) {
<b class="nc">&nbsp;        for (PluginWrapper p : getPlugins()) {</b>
<b class="nc">&nbsp;            if (p.getShortName().equals(shortName))</b>
<b class="nc">&nbsp;                return p;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the plugin instance that implements a specific class, use to find your plugin singleton.
&nbsp;     * Note: beware the classloader fun.
&nbsp;     * @param pluginClazz The class that your plugin implements.
&nbsp;     * @return The plugin singleton or {@code null} if for some reason the plugin is not loaded.
&nbsp;     *         The fact the plugin is loaded does not mean it is enabled and fully initialized for the current Jenkins session.
&nbsp;     *         Use {@link Plugin#getWrapper()} and then {@link PluginWrapper#isActive()} to check it.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public PluginWrapper getPlugin(Class&lt;? extends Plugin&gt; pluginClazz) {
<b class="nc">&nbsp;        for (PluginWrapper p : getPlugins()) {</b>
<b class="nc">&nbsp;            if (pluginClazz.isInstance(p.getPlugin()))</b>
<b class="nc">&nbsp;                return p;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the plugin instances that extend a specific class, use to find similar plugins.
&nbsp;     * Note: beware the classloader fun.
&nbsp;     * @param pluginSuperclass The class that your plugin is derived from.
&nbsp;     * @return The list of plugins implementing the specified class.
&nbsp;     */
&nbsp;    public List&lt;PluginWrapper&gt; getPlugins(Class&lt;? extends Plugin&gt; pluginSuperclass) {
<b class="nc">&nbsp;        List&lt;PluginWrapper&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (PluginWrapper p : getPlugins()) {</b>
<b class="nc">&nbsp;            if (pluginSuperclass.isInstance(p.getPlugin()))</b>
<b class="nc">&nbsp;                result.add(p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return Collections.unmodifiableList(result);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="nc">&nbsp;        return Messages.PluginManager_DisplayName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSearchUrl() {
<b class="nc">&nbsp;        return &quot;pluginManager&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Discover all the service provider implementations of the given class,
&nbsp;     * via {@code META-INF/services}.
&nbsp;     * @deprecated Use {@link ServiceLoader} instead, or (more commonly) {@link ExtensionList}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public &lt;T&gt; Collection&lt;Class&lt;? extends T&gt;&gt; discover(Class&lt;T&gt; spi) {
<b class="nc">&nbsp;        Set&lt;Class&lt;? extends T&gt;&gt; result = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (PluginWrapper p : activePlugins) {</b>
<b class="nc">&nbsp;            Service.load(spi, p.classLoader, result);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the {@link PluginWrapper} that loaded the given class &#39;c&#39;.
&nbsp;     *
&nbsp;     * @since 1.402.
&nbsp;     */
&nbsp;    public PluginWrapper whichPlugin(Class c) {
<b class="nc">&nbsp;        PluginWrapper oneAndOnly = null;</b>
<b class="nc">&nbsp;        ClassLoader cl = c.getClassLoader();</b>
<b class="nc">&nbsp;        for (PluginWrapper p : activePlugins) {</b>
<b class="nc">&nbsp;            if (p.classLoader == cl) {</b>
<b class="nc">&nbsp;                if (oneAndOnly != null)</b>
<b class="nc">&nbsp;                    return null;    // ambiguous</b>
<b class="nc">&nbsp;                oneAndOnly = p;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (oneAndOnly == null &amp;&amp; Main.isUnitTest) {</b>
&nbsp;            // compare jenkins.security.ClassFilterImpl
<b class="nc">&nbsp;            CodeSource cs = c.getProtectionDomain().getCodeSource();</b>
<b class="nc">&nbsp;            if (cs != null) {</b>
<b class="nc">&nbsp;                URL loc = cs.getLocation();</b>
<b class="nc">&nbsp;                if (loc != null) {</b>
<b class="nc">&nbsp;                    if (&quot;file&quot;.equals(loc.getProtocol())) {</b>
&nbsp;                        File file;
&nbsp;                        try {
<b class="nc">&nbsp;                            file = Paths.get(loc.toURI()).toFile();</b>
<b class="nc">&nbsp;                        } catch (InvalidPathException | URISyntaxException e) {</b>
<b class="nc">&nbsp;                            LOGGER.log(Level.WARNING, &quot;could not inspect &quot; + loc, e);</b>
<b class="nc">&nbsp;                            return null;</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if (file.isFile()) { // ignore directories</b>
<b class="nc">&nbsp;                            try (JarFile jf = new JarFile(file)) {</b>
<b class="nc">&nbsp;                                Manifest mf = jf.getManifest();</b>
<b class="nc">&nbsp;                                if (mf != null) {</b>
<b class="nc">&nbsp;                                    java.util.jar.Attributes attr = mf.getMainAttributes();</b>
<b class="nc">&nbsp;                                    if (attr.getValue(&quot;Plugin-Version&quot;) != null) {</b>
<b class="nc">&nbsp;                                        String shortName = attr.getValue(&quot;Short-Name&quot;);</b>
<b class="nc">&nbsp;                                        LOGGER.fine(() -&gt; &quot;found &quot; + shortName + &quot; for &quot; + c);</b>
<b class="nc">&nbsp;                                        return getPlugin(shortName);</b>
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                            } catch (IOException e) {</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.WARNING, &quot;could not inspect &quot; + loc, e);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return oneAndOnly;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Orderly terminates all the plugins.
&nbsp;     */
&nbsp;    public synchronized void stop() {
<b class="fc">&nbsp;        for (PluginWrapper p : activePlugins) {</b>
<b class="nc">&nbsp;            p.stop();</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        List&lt;PluginWrapper&gt; pluginsCopy = new ArrayList&lt;&gt;(plugins);</b>
<b class="fc">&nbsp;        for (PluginWrapper p : pluginsCopy) {</b>
<b class="nc">&nbsp;            activePlugins.remove(p);</b>
<b class="nc">&nbsp;            plugins.remove(p);</b>
<b class="nc">&nbsp;            p.releaseClassLoader();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        // Work around a bug in commons-logging.
&nbsp;        // See http://www.szegedi.org/articles/memleak.html
<b class="fc">&nbsp;        LogFactory.release(uberClassLoader);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static boolean isNonMetaLabel(String label) {
<b class="nc">&nbsp;        return !(&quot;adopt-this-plugin&quot;.equals(label) || &quot;deprecated&quot;.equals(label));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This allows &quot;Update Center&quot; to live at the URL
&nbsp;     * {@code /pluginManager/updates/} in addition to its {@code /updateCenter/}
&nbsp;     * URL which is provided by {@link jenkins.model.Jenkins#getUpdateCenter()}.
&nbsp;     * For purposes of Stapler, this object is the current item serving the
&nbsp;     * view, and since this is not a {@link hudson.model.ModelObject}, it does
&nbsp;     * not appear as an additional breadcrumb and only the &quot;Plugin Manager&quot;
&nbsp;     * breadcrumb is shown.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
<b class="nc">&nbsp;    public static class UpdateCenterProxy implements StaplerFallback {</b>
&nbsp;        @Override
&nbsp;        public Object getStaplerFallback() {
<b class="nc">&nbsp;            return Jenkins.get().getUpdateCenter();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public UpdateCenterProxy getUpdates() {
<b class="nc">&nbsp;        return new UpdateCenterProxy();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public HttpResponse doPluginsSearch(@QueryParameter String query, @QueryParameter Integer limit) {
<b class="nc">&nbsp;        List&lt;JSONObject&gt; plugins = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSiteList()) {</b>
<b class="nc">&nbsp;            List&lt;JSONObject&gt; sitePlugins = site.getAvailables().stream()</b>
<b class="nc">&nbsp;                .filter(plugin -&gt; {</b>
<b class="nc">&nbsp;                    if (StringUtils.isBlank(query)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return StringUtils.containsIgnoreCase(plugin.name, query) ||</b>
<b class="nc">&nbsp;                        StringUtils.containsIgnoreCase(plugin.title, query) ||</b>
<b class="nc">&nbsp;                        StringUtils.containsIgnoreCase(plugin.excerpt, query) ||</b>
<b class="nc">&nbsp;                        plugin.hasCategory(query) ||</b>
<b class="nc">&nbsp;                        plugin.getCategoriesStream()</b>
<b class="nc">&nbsp;                            .map(UpdateCenter::getCategoryDisplayName)</b>
<b class="nc">&nbsp;                            .anyMatch(category -&gt; StringUtils.containsIgnoreCase(category, query)) ||</b>
<b class="nc">&nbsp;                        plugin.hasWarnings() &amp;&amp; query.equalsIgnoreCase(&quot;warning:&quot;);</b>
&nbsp;                })
<b class="nc">&nbsp;                .limit(Math.max(limit - plugins.size(), 1))</b>
<b class="nc">&nbsp;                .sorted((o1, o2) -&gt; {</b>
<b class="nc">&nbsp;                    String o1DisplayName = o1.getDisplayName();</b>
<b class="nc">&nbsp;                    if (o1.name.equalsIgnoreCase(query) ||</b>
<b class="nc">&nbsp;                        o1DisplayName.equalsIgnoreCase(query)) {</b>
<b class="nc">&nbsp;                        return -1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    String o2DisplayName = o2.getDisplayName();</b>
<b class="nc">&nbsp;                    if (o2.name.equalsIgnoreCase(query) || o2DisplayName.equalsIgnoreCase(query)) {</b>
<b class="nc">&nbsp;                        return 1;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (o1.name.equals(o2.name)) {</b>
<b class="nc">&nbsp;                        return 0;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final int pop = Double.compare(o2.popularity, o1.popularity);</b>
<b class="nc">&nbsp;                    if (pop != 0) {</b>
<b class="nc">&nbsp;                        return pop; // highest popularity first</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return o1DisplayName.compareTo(o2DisplayName);</b>
&nbsp;                })
<b class="nc">&nbsp;                .map(plugin -&gt; {</b>
<b class="nc">&nbsp;                    JSONObject jsonObject = new JSONObject();</b>
<b class="nc">&nbsp;                    jsonObject.put(&quot;name&quot;, plugin.name);</b>
<b class="nc">&nbsp;                    jsonObject.put(&quot;sourceId&quot;, plugin.sourceId);</b>
<b class="nc">&nbsp;                    jsonObject.put(&quot;title&quot;, plugin.title);</b>
<b class="nc">&nbsp;                    jsonObject.put(&quot;displayName&quot;, plugin.getDisplayName());</b>
<b class="nc">&nbsp;                    if (plugin.wiki == null || !(plugin.wiki.startsWith(&quot;https://&quot;) || plugin.wiki.startsWith(&quot;http://&quot;))) {</b>
<b class="nc">&nbsp;                        jsonObject.put(&quot;wiki&quot;, StringUtils.EMPTY);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        jsonObject.put(&quot;wiki&quot;, plugin.wiki);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    jsonObject.put(&quot;categories&quot;, plugin.getCategoriesStream()</b>
<b class="nc">&nbsp;                        .filter(PluginManager::isNonMetaLabel)</b>
<b class="nc">&nbsp;                        .map(UpdateCenter::getCategoryDisplayName)</b>
<b class="nc">&nbsp;                        .collect(toList())</b>
&nbsp;                    );
&nbsp;
<b class="nc">&nbsp;                    if (hasAdoptThisPluginLabel(plugin)) {</b>
<b class="nc">&nbsp;                        jsonObject.put(&quot;adoptMe&quot;, Messages.PluginManager_adoptThisPlugin());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (plugin.isDeprecated()) {</b>
<b class="nc">&nbsp;                        jsonObject.put(&quot;deprecated&quot;, Messages.PluginManager_deprecationWarning(plugin.getDeprecation().url));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    jsonObject.put(&quot;excerpt&quot;, plugin.excerpt);</b>
<b class="nc">&nbsp;                    jsonObject.put(&quot;version&quot;, plugin.version);</b>
<b class="nc">&nbsp;                    jsonObject.put(&quot;popularity&quot;, plugin.popularity);</b>
<b class="nc">&nbsp;                    if (plugin.isForNewerHudson()) {</b>
<b class="nc">&nbsp;                        jsonObject.put(&quot;newerCoreRequired&quot;, Messages.PluginManager_coreWarning(Util.xmlEscape(plugin.requiredCore)));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (plugin.hasWarnings()) {</b>
<b class="nc">&nbsp;                        JSONObject unresolvedSecurityWarnings = new JSONObject();</b>
<b class="nc">&nbsp;                        unresolvedSecurityWarnings.put(&quot;text&quot;, Messages.PluginManager_securityWarning());</b>
<b class="nc">&nbsp;                        Set&lt;UpdateSite.Warning&gt; pluginWarnings = plugin.getWarnings();</b>
<b class="nc">&nbsp;                        if (pluginWarnings == null) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;warnings cannot be null here&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        List&lt;JSONObject&gt; warnings = pluginWarnings.stream()</b>
<b class="nc">&nbsp;                            .map(warning -&gt; {</b>
<b class="nc">&nbsp;                                JSONObject jsonWarning = new JSONObject();</b>
<b class="nc">&nbsp;                                jsonWarning.put(&quot;url&quot;, warning.url);</b>
<b class="nc">&nbsp;                                jsonWarning.put(&quot;message&quot;, warning.message);</b>
<b class="nc">&nbsp;                                return jsonWarning;</b>
<b class="nc">&nbsp;                            }).collect(toList());</b>
<b class="nc">&nbsp;                        unresolvedSecurityWarnings.put(&quot;warnings&quot;, warnings);</b>
<b class="nc">&nbsp;                        jsonObject.put(&quot;unresolvedSecurityWarnings&quot;, unresolvedSecurityWarnings);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (plugin.releaseTimestamp != null) {</b>
<b class="nc">&nbsp;                        JSONObject releaseTimestamp = new JSONObject();</b>
<b class="nc">&nbsp;                        releaseTimestamp.put(&quot;iso8601&quot;, Functions.iso8601DateTime(plugin.releaseTimestamp));</b>
<b class="nc">&nbsp;                        releaseTimestamp.put(&quot;displayValue&quot;, Messages.PluginManager_ago(Functions.getTimeSpanString(plugin.releaseTimestamp)));</b>
<b class="nc">&nbsp;                        jsonObject.put(&quot;releaseTimestamp&quot;, releaseTimestamp);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return jsonObject;</b>
&nbsp;                })
<b class="nc">&nbsp;                .collect(toList());</b>
<b class="nc">&nbsp;            plugins.addAll(sitePlugins);</b>
<b class="nc">&nbsp;            if (plugins.size() &gt;= limit) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        JSONArray mappedPlugins = new JSONArray();</b>
<b class="nc">&nbsp;        mappedPlugins.addAll(plugins);</b>
&nbsp;
<b class="nc">&nbsp;        return hudson.util.HttpResponses.okJSON(mappedPlugins);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the list of all plugins - available and installed.
&nbsp;     * @return The list of all plugins - available and installed.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class) // WebOnly
&nbsp;    public HttpResponse doPlugins() {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        JSONArray response = new JSONArray();</b>
<b class="nc">&nbsp;        Map&lt;String, JSONObject&gt; allPlugins = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (PluginWrapper plugin : plugins) {</b>
<b class="nc">&nbsp;            JSONObject pluginInfo = new JSONObject();</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;installed&quot;, true);</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;name&quot;, plugin.getShortName());</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;title&quot;, plugin.getDisplayName());</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;active&quot;, plugin.isActive());</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;enabled&quot;, plugin.isEnabled());</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;bundled&quot;, plugin.isBundled);</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;deleted&quot;, plugin.isDeleted());</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;downgradable&quot;, plugin.isDowngradable());</b>
<b class="nc">&nbsp;            pluginInfo.put(&quot;website&quot;, plugin.getUrl());</b>
<b class="nc">&nbsp;            List&lt;Dependency&gt; dependencies = plugin.getDependencies();</b>
<b class="nc">&nbsp;            if (dependencies != null &amp;&amp; !dependencies.isEmpty()) {</b>
<b class="nc">&nbsp;                Map&lt;String, String&gt; dependencyMap = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Dependency dependency : dependencies) {</b>
<b class="nc">&nbsp;                    dependencyMap.put(dependency.shortName, dependency.version);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;dependencies&quot;, dependencyMap);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;dependencies&quot;, Collections.emptyMap());</b>
&nbsp;            }
<b class="nc">&nbsp;            response.add(pluginInfo);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSiteList()) {</b>
<b class="nc">&nbsp;            for (UpdateSite.Plugin plugin : site.getAvailables()) {</b>
<b class="nc">&nbsp;                JSONObject pluginInfo = allPlugins.get(plugin.name);</b>
<b class="nc">&nbsp;                if (pluginInfo == null) {</b>
<b class="nc">&nbsp;                    pluginInfo = new JSONObject();</b>
<b class="nc">&nbsp;                    pluginInfo.put(&quot;installed&quot;, false);</b>
&nbsp;                }
<b class="nc">&nbsp;                pluginInfo.put(&quot;name&quot;, plugin.name);</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;title&quot;, plugin.getDisplayName());</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;excerpt&quot;, plugin.excerpt);</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;site&quot;, site.getId());</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;dependencies&quot;, plugin.dependencies);</b>
<b class="nc">&nbsp;                pluginInfo.put(&quot;website&quot;, plugin.wiki);</b>
<b class="nc">&nbsp;                response.add(pluginInfo);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return hudson.util.HttpResponses.okJSON(response);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doUpdateSources(StaplerRequest req) throws IOException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;        if (req.hasParameter(&quot;remove&quot;)) {</b>
<b class="nc">&nbsp;            UpdateCenter uc = Jenkins.get().getUpdateCenter();</b>
<b class="nc">&nbsp;            BulkChange bc = new BulkChange(uc);</b>
&nbsp;            try {
<b class="nc">&nbsp;                for (String id : req.getParameterValues(&quot;sources&quot;))</b>
<b class="nc">&nbsp;                    uc.getSites().remove(uc.getById(id));</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                bc.commit();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else</b>
<b class="nc">&nbsp;        if (req.hasParameter(&quot;add&quot;))</b>
<b class="nc">&nbsp;            return new HttpRedirect(&quot;addSite&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        return new HttpRedirect(&quot;./sites&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called to progress status beyond installing plugins, e.g. if
&nbsp;     * there were failures that prevented installation from naturally proceeding
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @Restricted(DoNotUse.class) // WebOnly
&nbsp;    public void doInstallPluginsDone() {
<b class="nc">&nbsp;        Jenkins j = Jenkins.get();</b>
<b class="nc">&nbsp;        j.checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        InstallUtil.proceedToNextStateFrom(InstallState.INITIAL_PLUGINS_INSTALLING);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the installation of the plugins.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doInstall(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        Set&lt;String&gt; plugins = new LinkedHashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        Enumeration&lt;String&gt; en = req.getParameterNames();</b>
<b class="nc">&nbsp;        while (en.hasMoreElements()) {</b>
<b class="nc">&nbsp;            String n =  en.nextElement();</b>
<b class="nc">&nbsp;            if (n.startsWith(&quot;plugin.&quot;)) {</b>
<b class="nc">&nbsp;                n = n.substring(7);</b>
<b class="nc">&nbsp;                plugins.add(n);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        boolean dynamicLoad = req.getParameter(&quot;dynamicLoad&quot;) != null;</b>
<b class="nc">&nbsp;        install(plugins, dynamicLoad);</b>
&nbsp;
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;updates/&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Installs a list of plugins from a JSON POST.
&nbsp;     * @param req The request object.
&nbsp;     * @return A JSON response that includes a &quot;correlationId&quot; in the &quot;data&quot; element.
&nbsp;     * That &quot;correlationId&quot; can then be used in calls to
&nbsp;     * {@link UpdateCenter#doInstallStatus(org.kohsuke.stapler.StaplerRequest)}.
&nbsp;     * @throws IOException Error reading JSON payload fro request.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @Restricted(DoNotUse.class) // WebOnly
&nbsp;    public HttpResponse doInstallPlugins(StaplerRequest req) throws IOException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        String payload = IOUtils.toString(req.getInputStream(), req.getCharacterEncoding());</b>
<b class="nc">&nbsp;        JSONObject request = JSONObject.fromObject(payload);</b>
<b class="nc">&nbsp;        JSONArray pluginListJSON = request.getJSONArray(&quot;plugins&quot;);</b>
<b class="nc">&nbsp;        List&lt;String&gt; plugins = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; pluginListJSON.size(); i++) {</b>
<b class="nc">&nbsp;            plugins.add(pluginListJSON.getString(i));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        UUID correlationId = UUID.randomUUID();</b>
&nbsp;        try {
<b class="nc">&nbsp;            boolean dynamicLoad = request.getBoolean(&quot;dynamicLoad&quot;);</b>
<b class="nc">&nbsp;            install(plugins, dynamicLoad, correlationId);</b>
&nbsp;
<b class="nc">&nbsp;            JSONObject responseData = new JSONObject();</b>
<b class="nc">&nbsp;            responseData.put(&quot;correlationId&quot;, correlationId.toString());</b>
&nbsp;
<b class="nc">&nbsp;            return hudson.util.HttpResponses.okJSON(responseData);</b>
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            return hudson.util.HttpResponses.errorJSON(e.getMessage());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the installation of the plugins.
&nbsp;     * @param plugins The collection of plugins to install.
&nbsp;     * @param dynamicLoad If true, the plugin will be dynamically loaded into this Jenkins. If false,
&nbsp;     *                    the plugin will only take effect after the reboot.
&nbsp;     *                    See {@link UpdateCenter#isRestartRequiredForCompletion()}
&nbsp;     * @return The install job list.
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public List&lt;Future&lt;UpdateCenter.UpdateCenterJob&gt;&gt; install(@NonNull Collection&lt;String&gt; plugins, boolean dynamicLoad) {
<b class="nc">&nbsp;        return install(plugins, dynamicLoad, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Future&lt;UpdateCenter.UpdateCenterJob&gt;&gt; install(@NonNull Collection&lt;String&gt; plugins, boolean dynamicLoad, @CheckForNull UUID correlationId) {
<b class="nc">&nbsp;        List&lt;Future&lt;UpdateCenter.UpdateCenterJob&gt;&gt; installJobs = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        LOGGER.log(INFO, &quot;Starting installation of a batch of {0} plugins plus their dependencies&quot;, plugins.size());</b>
<b class="nc">&nbsp;        long start = System.nanoTime();</b>
<b class="nc">&nbsp;        List&lt;PluginWrapper&gt; batch = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (String n : plugins) {</b>
&nbsp;            // JENKINS-22080 plugin names can contain &#39;.&#39; as could (according to rumour) update sites
<b class="nc">&nbsp;            int index = n.indexOf(&#39;.&#39;);</b>
<b class="nc">&nbsp;            UpdateSite.Plugin p = null;</b>
&nbsp;
<b class="nc">&nbsp;            if (index == -1) {</b>
<b class="nc">&nbsp;                p = getPlugin(n, UpdateCenter.ID_DEFAULT);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                while (index != -1) {</b>
<b class="nc">&nbsp;                    if (index + 1 &gt;= n.length()) {</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    String pluginName = n.substring(0, index);</b>
<b class="nc">&nbsp;                    String siteName = n.substring(index + 1);</b>
<b class="nc">&nbsp;                    UpdateSite.Plugin plugin = getPlugin(pluginName, siteName);</b>
&nbsp;                    // There could be cases like:
&nbsp;                    // &#39;plugin.ambiguous.updatesite&#39; where both
&nbsp;                    // &#39;plugin&#39; @ &#39;ambiguous.updatesite&#39; and &#39;plugin.ambiguous&#39; @ &#39;updatesite&#39; resolve to valid plugins
<b class="nc">&nbsp;                    if (plugin != null) {</b>
<b class="nc">&nbsp;                        if (p != null) {</b>
<b class="nc">&nbsp;                            throw new Failure(&quot;Ambiguous plugin: &quot; + n);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        p = plugin;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    index = n.indexOf(&#39;.&#39;, index + 1);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (p == null) {</b>
<b class="nc">&nbsp;                throw new Failure(&quot;No such plugin: &quot; + n);</b>
&nbsp;            }
<b class="nc">&nbsp;            Future&lt;UpdateCenter.UpdateCenterJob&gt; jobFuture = p.deploy(dynamicLoad, correlationId, batch, false);</b>
<b class="nc">&nbsp;            installJobs.add(jobFuture);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.get();</b>
<b class="nc">&nbsp;        final UpdateCenter updateCenter = jenkins.getUpdateCenter();</b>
&nbsp;
<b class="nc">&nbsp;        if (dynamicLoad) {</b>
<b class="nc">&nbsp;            installJobs.add(updateCenter.addJob(updateCenter.new CompleteBatchJob(batch, start, correlationId)));</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Authentication currentAuth = Jenkins.getAuthentication2();</b>
&nbsp;
<b class="nc">&nbsp;        if (!jenkins.getInstallState().isSetupComplete()) {</b>
<b class="nc">&nbsp;            jenkins.setInstallState(InstallState.INITIAL_PLUGINS_INSTALLING);</b>
<b class="nc">&nbsp;            updateCenter.persistInstallStatus();</b>
<b class="nc">&nbsp;            new Thread() {</b>
&nbsp;                @Override
&nbsp;                public void run() {
<b class="nc">&nbsp;                    boolean failures = false;</b>
&nbsp;                    INSTALLING: while (true) {
&nbsp;                        try {
<b class="nc">&nbsp;                            updateCenter.persistInstallStatus();</b>
<b class="nc">&nbsp;                            Thread.sleep(500);</b>
<b class="nc">&nbsp;                            failures = false;</b>
<b class="nc">&nbsp;                            for (Future&lt;UpdateCenter.UpdateCenterJob&gt; jobFuture : installJobs) {</b>
<b class="nc">&nbsp;                                if (!jobFuture.isDone() &amp;&amp; !jobFuture.isCancelled()) {</b>
<b class="nc">&nbsp;                                    continue INSTALLING;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                UpdateCenter.UpdateCenterJob job = jobFuture.get();</b>
<b class="nc">&nbsp;                                if (job instanceof InstallationJob &amp;&amp; ((InstallationJob) job).status instanceof DownloadJob.Failure) {</b>
<b class="nc">&nbsp;                                    failures = true;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } catch (Exception e) {</b>
<b class="nc">&nbsp;                            LOGGER.log(WARNING, &quot;Unexpected error while waiting for initial plugin set to install.&quot;, e);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    updateCenter.persistInstallStatus();</b>
<b class="nc">&nbsp;                    if (!failures) {</b>
<b class="nc">&nbsp;                        try (ACLContext acl = ACL.as2(currentAuth)) {</b>
<b class="nc">&nbsp;                            InstallUtil.proceedToNextStateFrom(InstallState.INITIAL_PLUGINS_INSTALLING);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }.start();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return installJobs;</b>
&nbsp;    }
&nbsp;
&nbsp;    @CheckForNull
&nbsp;    private UpdateSite.Plugin getPlugin(String pluginName, String siteName) {
<b class="nc">&nbsp;        UpdateSite updateSite = Jenkins.get().getUpdateCenter().getById(siteName);</b>
<b class="nc">&nbsp;        if (updateSite == null) {</b>
<b class="nc">&nbsp;            throw new Failure(&quot;No such update center: &quot; + siteName);</b>
&nbsp;        }
<b class="nc">&nbsp;        return updateSite.getPlugin(pluginName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Bare-minimum configuration mechanism to change the update center.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doSiteConfigure(@QueryParameter String site) throws IOException {
<b class="nc">&nbsp;        Jenkins hudson = Jenkins.get();</b>
<b class="nc">&nbsp;        hudson.checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        UpdateCenter uc = hudson.getUpdateCenter();</b>
<b class="nc">&nbsp;        PersistedList&lt;UpdateSite&gt; sites = uc.getSites();</b>
<b class="nc">&nbsp;        sites.removeIf(s -&gt; s.getId().equals(UpdateCenter.ID_DEFAULT));</b>
<b class="nc">&nbsp;        sites.add(new UpdateSite(UpdateCenter.ID_DEFAULT, site));</b>
&nbsp;
<b class="nc">&nbsp;        return new HttpRedirect(&quot;advanced&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @POST
&nbsp;    public HttpResponse doProxyConfigure(StaplerRequest req) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins jenkins = Jenkins.get();</b>
<b class="nc">&nbsp;        jenkins.checkPermission(Jenkins.ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;        ProxyConfiguration pc = req.bindJSON(ProxyConfiguration.class, req.getSubmittedForm());</b>
<b class="nc">&nbsp;        ProxyConfigurationManager.saveProxyConfiguration(pc);</b>
<b class="nc">&nbsp;        return new HttpRedirect(&quot;advanced&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    interface PluginCopier {
&nbsp;        void copy(File target) throws Exception;
&nbsp;
&nbsp;        void cleanup();
&nbsp;    }
&nbsp;
&nbsp;    static class FileUploadPluginCopier implements PluginCopier {
&nbsp;        private FileItem fileItem;
&nbsp;
<b class="nc">&nbsp;        FileUploadPluginCopier(FileItem fileItem) {</b>
<b class="nc">&nbsp;            this.fileItem = fileItem;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void copy(File target) throws Exception {
<b class="nc">&nbsp;            fileItem.write(target);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void cleanup() {
<b class="nc">&nbsp;            fileItem.delete();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class UrlPluginCopier implements PluginCopier {
&nbsp;        private String url;
&nbsp;
<b class="nc">&nbsp;        UrlPluginCopier(String url) {</b>
<b class="nc">&nbsp;            this.url = url;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void copy(File target) throws Exception {
<b class="nc">&nbsp;            try (InputStream input =  ProxyConfiguration.getInputStream(new URL(url))) {</b>
<b class="nc">&nbsp;                Files.copy(input, target.toPath());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void cleanup() {
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Uploads a plugin.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doUploadPlugin(StaplerRequest req) throws IOException, ServletException {
&nbsp;        try {
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;            String fileName = &quot;&quot;;</b>
&nbsp;            PluginCopier copier;
<b class="nc">&nbsp;            File tmpDir = Files.createTempDirectory(&quot;uploadDir&quot;).toFile();</b>
<b class="nc">&nbsp;            ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory(DiskFileItemFactory.DEFAULT_SIZE_THRESHOLD, tmpDir));</b>
<b class="nc">&nbsp;            List&lt;FileItem&gt; items = upload.parseRequest(req);</b>
<b class="nc">&nbsp;            if (StringUtils.isNotBlank(items.get(1).getString())) {</b>
&nbsp;                // this is a URL deployment
<b class="nc">&nbsp;                fileName = items.get(1).getString();</b>
<b class="nc">&nbsp;                copier = new UrlPluginCopier(fileName);</b>
&nbsp;            } else {
&nbsp;                // this is a file upload
<b class="nc">&nbsp;                FileItem fileItem = items.get(0);</b>
<b class="nc">&nbsp;                fileName = Util.getFileName(fileItem.getName());</b>
<b class="nc">&nbsp;                copier = new FileUploadPluginCopier(fileItem);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (&quot;&quot;.equals(fileName)) {</b>
<b class="nc">&nbsp;                return new HttpRedirect(&quot;advanced&quot;);</b>
&nbsp;            }
&nbsp;            // we allow the upload of the new jpi&#39;s and the legacy hpi&#39;s
<b class="nc">&nbsp;            if (!fileName.endsWith(&quot;.jpi&quot;) &amp;&amp; !fileName.endsWith(&quot;.hpi&quot;)) {</b>
<b class="nc">&nbsp;                throw new Failure(hudson.model.Messages.Hudson_NotAPlugin(fileName));</b>
&nbsp;            }
&nbsp;
&nbsp;            // first copy into a temporary file name
<b class="nc">&nbsp;            File t = File.createTempFile(&quot;uploaded&quot;, &quot;.jpi&quot;, tmpDir);</b>
<b class="nc">&nbsp;            tmpDir.deleteOnExit();</b>
<b class="nc">&nbsp;            t.deleteOnExit();</b>
&nbsp;            // TODO Remove this workaround after FILEUPLOAD-293 is resolved.
<b class="nc">&nbsp;            Files.delete(Util.fileToPath(t));</b>
&nbsp;            try {
<b class="nc">&nbsp;                copier.copy(t);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
&nbsp;                // Exception thrown is too generic so at least limit the scope where it can occur
<b class="nc">&nbsp;                throw new ServletException(e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            copier.cleanup();</b>
&nbsp;
<b class="nc">&nbsp;            final String baseName = identifyPluginShortName(t);</b>
&nbsp;
<b class="nc">&nbsp;            pluginUploaded = true;</b>
&nbsp;
<b class="nc">&nbsp;            JSONArray dependencies = new JSONArray();</b>
&nbsp;            try {
&nbsp;                Manifest m;
<b class="nc">&nbsp;                try (JarFile jarFile = new JarFile(t)) {</b>
<b class="nc">&nbsp;                    m = jarFile.getManifest();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                String deps = m.getMainAttributes().getValue(&quot;Plugin-Dependencies&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                if (StringUtils.isNotBlank(deps)) {</b>
&nbsp;                    // now we get to parse it!
<b class="nc">&nbsp;                    String[] plugins = deps.split(&quot;,&quot;);</b>
<b class="nc">&nbsp;                    for (String p : plugins) {</b>
&nbsp;                        // should have name:version[;resolution:=optional]
<b class="nc">&nbsp;                        String[] attrs = p.split(&quot;[:;]&quot;);</b>
<b class="nc">&nbsp;                        dependencies.add(new JSONObject()</b>
<b class="nc">&nbsp;                                .element(&quot;name&quot;, attrs[0])</b>
<b class="nc">&nbsp;                                .element(&quot;version&quot;, attrs[1])</b>
<b class="nc">&nbsp;                                .element(&quot;optional&quot;, p.contains(&quot;resolution:=optional&quot;)));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, &quot;Unable to setup dependency list for plugin upload&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // Now create a dummy plugin that we can dynamically load (the InstallationJob will force a restart if one is needed):
<b class="nc">&nbsp;            JSONObject cfg = new JSONObject().</b>
<b class="nc">&nbsp;                    element(&quot;name&quot;, baseName).</b>
<b class="nc">&nbsp;                    element(&quot;version&quot;, &quot;0&quot;). // unused but mandatory</b>
<b class="nc">&nbsp;                    element(&quot;url&quot;, t.toURI().toString()).</b>
<b class="nc">&nbsp;                    element(&quot;dependencies&quot;, dependencies);</b>
<b class="nc">&nbsp;            new UpdateSite(UpdateCenter.ID_UPLOAD, null).new Plugin(UpdateCenter.ID_UPLOAD, cfg).deploy(true);</b>
<b class="nc">&nbsp;            return new HttpRedirect(&quot;updates/&quot;);</b>
<b class="nc">&nbsp;        } catch (FileUploadException e) {</b>
<b class="nc">&nbsp;            throw new ServletException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @RequirePOST public FormValidation doCheckPluginUrl(StaplerRequest request, @QueryParameter String value) throws IOException {
<b class="nc">&nbsp;        if (StringUtils.isNotBlank(value)) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                URL url = new URL(value);</b>
<b class="nc">&nbsp;                if (!url.getProtocol().startsWith(&quot;http&quot;)) {</b>
<b class="nc">&nbsp;                    return FormValidation.error(Messages.PluginManager_invalidUrl());</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (!url.getProtocol().equals(&quot;https&quot;)) {</b>
<b class="nc">&nbsp;                    return FormValidation.warning(Messages.PluginManager_insecureUrl());</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (MalformedURLException e) {</b>
<b class="nc">&nbsp;                return FormValidation.error(e.getMessage());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return FormValidation.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @RequirePOST public FormValidation doCheckUpdateSiteUrl(StaplerRequest request, @QueryParameter String value) throws InterruptedException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        return checkUpdateSiteURL(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(DoNotUse.class) // visible for testing only
&nbsp;    FormValidation checkUpdateSiteURL(@CheckForNull String value) throws InterruptedException {
<b class="fc">&nbsp;        value = Util.fixEmptyAndTrim(value);</b>
&nbsp;
<b class="fc">&nbsp;        if (value == null) {</b>
<b class="fc">&nbsp;            return FormValidation.error(Messages.PluginManager_emptyUpdateSiteUrl());</b>
&nbsp;        }
&nbsp;
&nbsp;        final URI baseUri;
&nbsp;        try {
<b class="fc">&nbsp;            baseUri = new URI(value);</b>
<b class="fc">&nbsp;        } catch (URISyntaxException ex) {</b>
<b class="fc">&nbsp;            return FormValidation.error(ex, Messages.PluginManager_invalidUrl());</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if (&quot;file&quot;.equalsIgnoreCase(baseUri.getScheme())) {</b>
<b class="fc">&nbsp;            File f = new File(baseUri);</b>
<b class="fc">&nbsp;            if (f.isFile()) {</b>
<b class="fc">&nbsp;                return FormValidation.ok();</b>
&nbsp;            }
<b class="fc">&nbsp;            return FormValidation.error(Messages.PluginManager_connectionFailed());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (&quot;https&quot;.equalsIgnoreCase(baseUri.getScheme()) || &quot;http&quot;.equalsIgnoreCase(baseUri.getScheme())) {</b>
&nbsp;            final URI uriWithQuery;
&nbsp;            try {
<b class="fc">&nbsp;                if (baseUri.getRawQuery() == null) {</b>
<b class="fc">&nbsp;                    uriWithQuery = new URI(value + &quot;?version=&quot; + Jenkins.VERSION + &quot;&amp;uctest&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    uriWithQuery = new URI(value + &quot;&amp;version=&quot; + Jenkins.VERSION + &quot;&amp;uctest&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (URISyntaxException e) {</b>
<b class="nc">&nbsp;                return FormValidation.error(e, Messages.PluginManager_invalidUrl());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            HttpClient httpClient = ProxyConfiguration.newHttpClientBuilder()</b>
<b class="fc">&nbsp;                    .connectTimeout(Duration.ofSeconds(5))</b>
<b class="fc">&nbsp;                    .build();</b>
&nbsp;            HttpRequest httpRequest;
&nbsp;            try {
<b class="fc">&nbsp;                httpRequest = ProxyConfiguration.newHttpRequestBuilder(uriWithQuery)</b>
<b class="fc">&nbsp;                        .method(&quot;HEAD&quot;, HttpRequest.BodyPublishers.noBody())</b>
<b class="fc">&nbsp;                        .build();</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;                return FormValidation.error(e, Messages.PluginManager_invalidUrl());</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            try {
<b class="fc">&nbsp;                java.net.http.HttpResponse&lt;Void&gt; httpResponse = httpClient.send(</b>
<b class="fc">&nbsp;                        httpRequest, java.net.http.HttpResponse.BodyHandlers.discarding());</b>
<b class="fc">&nbsp;                if (100 &lt;= httpResponse.statusCode() &amp;&amp; httpResponse.statusCode() &lt;= 399) {</b>
<b class="fc">&nbsp;                    return FormValidation.ok();</b>
&nbsp;                }
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;Obtained a non OK ({0}) response from the update center&quot;,</b>
<b class="nc">&nbsp;                        new Object[] {httpResponse.statusCode(), baseUri});</b>
<b class="nc">&nbsp;                return FormValidation.error(Messages.PluginManager_connectionFailed());</b>
<b class="fc">&nbsp;            } catch (IOException e) {</b>
<b class="fc">&nbsp;                LOGGER.log(Level.FINE, &quot;Failed to check update site&quot;, e);</b>
<b class="fc">&nbsp;                return FormValidation.error(e, Messages.PluginManager_connectionFailed());</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;        // not a file or http(s) scheme
<b class="fc">&nbsp;        return FormValidation.error(Messages.PluginManager_invalidUrl());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @RequirePOST public HttpResponse doCheckUpdatesServer() throws IOException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);</b>
&nbsp;
&nbsp;        // We&#39;ll check the update servers with a try-retry mechanism. The retrier is built with a builder
<b class="nc">&nbsp;        Retrier&lt;FormValidation&gt; updateServerRetrier = new Retrier.Builder&lt;&gt;(</b>
&nbsp;                // the action to perform
&nbsp;                this::checkUpdatesServer,
&nbsp;
&nbsp;                // the way we know whether this attempt was right or wrong
<b class="nc">&nbsp;                (currentAttempt, result) -&gt; result.kind == FormValidation.Kind.OK,</b>
&nbsp;
&nbsp;                // the action name we are trying to perform
&nbsp;                &quot;check updates server&quot;)
&nbsp;
&nbsp;                // the number of attempts to try
<b class="nc">&nbsp;                .withAttempts(CHECK_UPDATE_ATTEMPTS)</b>
&nbsp;
&nbsp;                // the delay between attempts
<b class="nc">&nbsp;                .withDelay(CHECK_UPDATE_SLEEP_TIME_MILLIS)</b>
&nbsp;
&nbsp;                // whatever exception raised is considered as a fail attempt (all exceptions), not a failure
<b class="nc">&nbsp;                .withDuringActionExceptions(new Class[] {Exception.class})</b>
&nbsp;
&nbsp;                // what we do with a failed attempt due to an allowed exception, return an FormValidation.error with the message
<b class="nc">&nbsp;                .withDuringActionExceptionListener((attempt, e) -&gt; FormValidation.errorWithMarkup(e.getClass().getSimpleName() + &quot;: &quot; + e.getLocalizedMessage()))</b>
&nbsp;
&nbsp;                // lets get our retrier object
<b class="nc">&nbsp;                .build();</b>
&nbsp;
&nbsp;        try {
&nbsp;            // Begin the process
<b class="nc">&nbsp;            FormValidation result = updateServerRetrier.start();</b>
&nbsp;
&nbsp;            // Check how it went
<b class="nc">&nbsp;            if (!FormValidation.Kind.OK.equals(result.kind)) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, Messages.PluginManager_UpdateSiteError(CHECK_UPDATE_ATTEMPTS, result.getMessage()));</b>
<b class="nc">&nbsp;                if (CHECK_UPDATE_ATTEMPTS &gt; 1 &amp;&amp; !Logger.getLogger(Retrier.class.getName()).isLoggable(Level.WARNING)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.SEVERE, Messages.PluginManager_UpdateSiteChangeLogLevel(Retrier.class.getName()));</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                lastErrorCheckUpdateCenters = Messages.PluginManager_CheckUpdateServerError(result.getMessage());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                lastErrorCheckUpdateCenters = null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        } catch (Exception e) {</b>
&nbsp;            // It&#39;s never going to be reached because we declared all Exceptions in the withDuringActionExceptions, so
&nbsp;            // whatever exception is considered a expected failed attempt and the retries continue
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, Messages.PluginManager_UnexpectedException(), e);</b>
&nbsp;
&nbsp;            // In order to leave this method as it was, rethrow as IOException
<b class="nc">&nbsp;            throw new IOException(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Stay in the same page in any case
<b class="nc">&nbsp;        return HttpResponses.forwardToPreviousPage();</b>
&nbsp;    }
&nbsp;
&nbsp;    private FormValidation checkUpdatesServer() throws Exception {
<b class="nc">&nbsp;        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSites()) {</b>
<b class="nc">&nbsp;            FormValidation v = site.updateDirectlyNow();</b>
<b class="nc">&nbsp;            if (v.kind != FormValidation.Kind.OK) {</b>
&nbsp;                // Stop with an error
<b class="nc">&nbsp;                return v;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (DownloadService.Downloadable d : DownloadService.Downloadable.all()) {</b>
<b class="nc">&nbsp;            FormValidation v = d.updateNow();</b>
<b class="nc">&nbsp;            if (v.kind != FormValidation.Kind.OK) {</b>
&nbsp;                // Stop with an error
<b class="nc">&nbsp;                return v;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return FormValidation.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last error raised during the update sites checking.
&nbsp;     * @return the last error message
&nbsp;     */
&nbsp;    public String getLastErrorCheckUpdateCenters() {
<b class="nc">&nbsp;        return lastErrorCheckUpdateCenters;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String identifyPluginShortName(File t) {
&nbsp;        try {
<b class="nc">&nbsp;            try (JarFile j = new JarFile(t)) {</b>
<b class="nc">&nbsp;                String name = j.getManifest().getMainAttributes().getValue(&quot;Short-Name&quot;);</b>
<b class="nc">&nbsp;                if (name != null) return name;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;Failed to identify the short name from &quot; + t, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return FilenameUtils.getBaseName(t.getName());    // fall back to the base name of what&#39;s uploaded</b>
&nbsp;    }
&nbsp;
&nbsp;    public Descriptor&lt;ProxyConfiguration&gt; getProxyDescriptor() {
<b class="nc">&nbsp;        return Jenkins.get().getDescriptor(ProxyConfiguration.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prepares plugins for some expected XML configuration.
&nbsp;     * If the configuration (typically a jobs {@code config.xml})
&nbsp;     * needs some plugins to be installed (or updated), those jobs
&nbsp;     * will be triggered.
&nbsp;     * Plugins are dynamically loaded whenever possible.
&nbsp;     * Requires {@link Jenkins#ADMINISTER}.
&nbsp;     * @param configXml configuration that might be uploaded
&nbsp;     * @return an empty list if all is well, else a list of submitted jobs which must be completed before this configuration can be fully read
&nbsp;     * @throws IOException if loading or parsing the configuration failed
&nbsp;     * @see ItemGroupMixIn#createProjectFromXML
&nbsp;     * @see AbstractItem#updateByXml(javax.xml.transform.Source)
&nbsp;     * @see XStream2
&nbsp;     * @see hudson.model.UpdateSite.Plugin#deploy(boolean)
&nbsp;     * @see PluginWrapper#supportsDynamicLoad
&nbsp;     * @see hudson.model.UpdateCenter.DownloadJob.SuccessButRequiresRestart
&nbsp;     * @since 1.483
&nbsp;     */
&nbsp;    public List&lt;Future&lt;UpdateCenter.UpdateCenterJob&gt;&gt; prevalidateConfig(InputStream configXml) throws IOException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        List&lt;Future&lt;UpdateCenter.UpdateCenterJob&gt;&gt; jobs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        UpdateCenter uc = Jenkins.get().getUpdateCenter();</b>
&nbsp;        // TODO call uc.updateAllSites() when available? perhaps not, since we should not block on network here
<b class="nc">&nbsp;        for (Map.Entry&lt;String, VersionNumber&gt; requestedPlugin : parseRequestedPlugins(configXml).entrySet()) {</b>
<b class="nc">&nbsp;            PluginWrapper pw = getPlugin(requestedPlugin.getKey());</b>
<b class="nc">&nbsp;            if (pw == null) { // install new</b>
<b class="nc">&nbsp;                UpdateSite.Plugin toInstall = uc.getPlugin(requestedPlugin.getKey(), requestedPlugin.getValue());</b>
<b class="nc">&nbsp;                if (toInstall == null) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;No such plugin {0} to install&quot;, requestedPlugin.getKey());</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                logPluginWarnings(requestedPlugin, toInstall);</b>
<b class="nc">&nbsp;                jobs.add(toInstall.deploy(true));</b>
<b class="nc">&nbsp;            } else if (pw.isOlderThan(requestedPlugin.getValue())) { // upgrade</b>
<b class="nc">&nbsp;                UpdateSite.Plugin toInstall = uc.getPlugin(requestedPlugin.getKey(), requestedPlugin.getValue());</b>
<b class="nc">&nbsp;                if (toInstall == null) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;No such plugin {0} to upgrade&quot;, requestedPlugin.getKey());</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!pw.isOlderThan(new VersionNumber(toInstall.version))) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;{0}@{1} is no newer than what we already have&quot;, new Object[] {toInstall.name, toInstall.version});</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                logPluginWarnings(requestedPlugin, toInstall);</b>
<b class="nc">&nbsp;                if (!toInstall.isCompatibleWithInstalledVersion()) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;{0}@{1} is incompatible with the installed @{2}&quot;, new Object[] {toInstall.name, toInstall.version, pw.getVersion()});</b>
&nbsp;                }
<b class="nc">&nbsp;                jobs.add(toInstall.deploy(true)); // dynamicLoad=true =&gt; sure to throw RestartRequiredException, but at least message is nicer</b>
&nbsp;            } // else already good
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return jobs;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void logPluginWarnings(Map.Entry&lt;String, VersionNumber&gt; requestedPlugin, UpdateSite.Plugin toInstall) {
<b class="nc">&nbsp;        if (new VersionNumber(toInstall.version).compareTo(requestedPlugin.getValue()) &lt; 0) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;{0} can only be satisfied in @{1}&quot;, new Object[] {requestedPlugin, toInstall.version});</b>
&nbsp;        }
<b class="nc">&nbsp;        if (toInstall.isForNewerHudson()) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;{0}@{1} was built for a newer Jenkins&quot;, new Object[] {toInstall.name, toInstall.version});</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Like {@link #doInstallNecessaryPlugins(StaplerRequest)} but only checks if everything is installed
&nbsp;     * or if some plugins need updates or installation.
&nbsp;     *
&nbsp;     * This method runs without side-effect. I&#39;m still requiring the ADMINISTER permission since
&nbsp;     * XML file can contain various external references and we don&#39;t configure parsers properly against
&nbsp;     * that.
&nbsp;     *
&nbsp;     * @since 1.483
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public JSONArray doPrevalidateConfig(StaplerRequest req) throws IOException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;        JSONArray response = new JSONArray();</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;String, VersionNumber&gt; p : parseRequestedPlugins(req.getInputStream()).entrySet()) {</b>
<b class="nc">&nbsp;            PluginWrapper pw = getPlugin(p.getKey());</b>
<b class="nc">&nbsp;            JSONObject j = new JSONObject()</b>
<b class="nc">&nbsp;                    .accumulate(&quot;name&quot;, p.getKey())</b>
<b class="nc">&nbsp;                    .accumulate(&quot;version&quot;, p.getValue().toString());</b>
<b class="nc">&nbsp;            if (pw == null) { // install new</b>
<b class="nc">&nbsp;                response.add(j.accumulate(&quot;mode&quot;, &quot;missing&quot;));</b>
<b class="nc">&nbsp;            } else if (pw.isOlderThan(p.getValue())) { // upgrade</b>
<b class="nc">&nbsp;                response.add(j.accumulate(&quot;mode&quot;, &quot;old&quot;));</b>
&nbsp;            } // else already good
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return response;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs {@link #prevalidateConfig} on posted XML and redirects to the {@link UpdateCenter}.
&nbsp;     * @since 1.483
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doInstallNecessaryPlugins(StaplerRequest req) throws IOException {
<b class="nc">&nbsp;        prevalidateConfig(req.getInputStream());</b>
<b class="nc">&nbsp;        return HttpResponses.redirectViaContextPath(&quot;pluginManager/updates/&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses configuration XML files and picks up references to XML files.
&nbsp;     */
&nbsp;    public Map&lt;String, VersionNumber&gt; parseRequestedPlugins(InputStream configXml) throws IOException {
<b class="fc">&nbsp;        final Map&lt;String, VersionNumber&gt; requestedPlugins = new TreeMap&lt;&gt;();</b>
&nbsp;        try {
<b class="fc">&nbsp;            SAXParserFactory spf = SAXParserFactory.newInstance();</b>
<b class="fc">&nbsp;            spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</b>
<b class="fc">&nbsp;            spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</b>
<b class="fc">&nbsp;            spf.newSAXParser().parse(configXml, new DefaultHandler() {</b>
&nbsp;                @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
<b class="fc">&nbsp;                    String plugin = attributes.getValue(&quot;plugin&quot;);</b>
<b class="fc">&nbsp;                    if (plugin == null) {</b>
&nbsp;                        return;
&nbsp;                    }
<b class="fc">&nbsp;                    if (!plugin.matches(&quot;[^@]+@[^@]+&quot;)) {</b>
<b class="nc">&nbsp;                        throw new SAXException(&quot;Malformed plugin attribute: &quot; + plugin);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    int at = plugin.indexOf(&#39;@&#39;);</b>
<b class="fc">&nbsp;                    String shortName = plugin.substring(0, at);</b>
<b class="fc">&nbsp;                    VersionNumber existing = requestedPlugins.get(shortName);</b>
<b class="fc">&nbsp;                    VersionNumber requested = new VersionNumber(plugin.substring(at + 1));</b>
<b class="fc">&nbsp;                    if (existing == null || existing.compareTo(requested) &lt; 0) {</b>
<b class="fc">&nbsp;                        requestedPlugins.put(shortName, requested);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override public InputSource resolveEntity(String publicId, String systemId) throws IOException,
&nbsp;                        SAXException {
<b class="nc">&nbsp;                    return RestrictiveEntityResolver.INSTANCE.resolveEntity(publicId, systemId);</b>
&nbsp;                }
&nbsp;
&nbsp;            });
<b class="fc">&nbsp;        } catch (SAXException x) {</b>
<b class="fc">&nbsp;            throw new IOException(&quot;Failed to parse XML&quot;, x);</b>
<b class="nc">&nbsp;        } catch (ParserConfigurationException e) {</b>
<b class="nc">&nbsp;            throw new AssertionError(e); // impossible since we don&#39;t tweak XMLParser</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return requestedPlugins;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(DoNotUse.class) // table.jelly
&nbsp;    public MetadataCache createCache() {
<b class="nc">&nbsp;        return new MetadataCache();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Disable a list of plugins using a strategy for their dependents plugins.
&nbsp;     * @param strategy the strategy regarding how the dependent plugins are processed
&nbsp;     * @param plugins the list of plugins
&nbsp;     * @return the list of results for every plugin and their dependent plugins.
&nbsp;     * @throws IOException see {@link PluginWrapper#disable()}
&nbsp;     */
&nbsp;    public @NonNull List&lt;PluginWrapper.PluginDisableResult&gt; disablePlugins(@NonNull PluginWrapper.PluginDisableStrategy strategy, @NonNull List&lt;String&gt; plugins) throws IOException {
&nbsp;        // Where we store the results of each plugin disablement
<b class="nc">&nbsp;        List&lt;PluginWrapper.PluginDisableResult&gt; results = new ArrayList&lt;&gt;(plugins.size());</b>
&nbsp;
&nbsp;        // Disable all plugins passed
<b class="nc">&nbsp;        for (String pluginName : plugins) {</b>
<b class="nc">&nbsp;            PluginWrapper plugin = this.getPlugin(pluginName);</b>
&nbsp;
<b class="nc">&nbsp;            if (plugin == null) {</b>
<b class="nc">&nbsp;                results.add(new PluginWrapper.PluginDisableResult(pluginName, PluginWrapper.PluginDisableStatus.NO_SUCH_PLUGIN, Messages.PluginWrapper_NoSuchPlugin(pluginName)));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                results.add(plugin.disable(strategy));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return results;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class) // table.jelly
<b class="nc">&nbsp;    public static final class MetadataCache {</b>
<b class="nc">&nbsp;        private final Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        public &lt;T&gt; T of(String key, Class&lt;T&gt; type, Supplier&lt;T&gt; func) {
<b class="nc">&nbsp;            return type.cast(data.computeIfAbsent(key, _ignored -&gt; func.get()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link ClassLoader} that can see all plugins.
&nbsp;     */
&nbsp;    public static final class UberClassLoader extends ClassLoader {
&nbsp;        private final List&lt;PluginWrapper&gt; activePlugins;
&nbsp;
&nbsp;        /** Cache of loaded, or known to be unloadable, classes. */
<b class="fc">&nbsp;        private final ConcurrentMap&lt;String, Optional&lt;Class&lt;?&gt;&gt;&gt; loaded = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        static {
<b class="fc">&nbsp;            registerAsParallelCapable();</b>
&nbsp;        }
&nbsp;
&nbsp;        public UberClassLoader(List&lt;PluginWrapper&gt; activePlugins) {
<b class="fc">&nbsp;            super(PluginManager.class.getClassLoader());</b>
<b class="fc">&nbsp;            this.activePlugins = activePlugins;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
<b class="nc">&nbsp;            if (name.startsWith(&quot;SimpleTemplateScript&quot;)) { // cf. groovy.text.SimpleTemplateEngine</b>
<b class="nc">&nbsp;                throw new ClassNotFoundException(&quot;ignoring &quot; + name);</b>
&nbsp;            }
<b class="nc">&nbsp;            return loaded.computeIfAbsent(name, this::computeValue).orElseThrow(() -&gt; new ClassNotFoundException(name));</b>
&nbsp;        }
&nbsp;
&nbsp;        private Optional&lt;Class&lt;?&gt;&gt; computeValue(String name) {
<b class="nc">&nbsp;            for (PluginWrapper p : activePlugins) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (FAST_LOOKUP) {</b>
<b class="nc">&nbsp;                        return Optional.of(ClassLoaderReflectionToolkit.loadClass(p.classLoader, name));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return Optional.of(p.classLoader.loadClass(name));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (ClassNotFoundException e) {</b>
&nbsp;                    // Not found. Try the next class loader.
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // Not found in any of the class loaders. Delegate.
<b class="nc">&nbsp;            return Optional.empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected URL findResource(String name) {
<b class="nc">&nbsp;            for (PluginWrapper p : activePlugins) {</b>
&nbsp;                URL url;
<b class="nc">&nbsp;                if (FAST_LOOKUP) {</b>
<b class="nc">&nbsp;                    url = ClassLoaderReflectionToolkit._findResource(p.classLoader, name);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    url = p.classLoader.getResource(name);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (url != null) {</b>
<b class="nc">&nbsp;                    return url;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Enumeration&lt;URL&gt; findResources(String name) throws IOException {
<b class="nc">&nbsp;            List&lt;URL&gt; resources = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (PluginWrapper p : activePlugins) {</b>
<b class="nc">&nbsp;                if (FAST_LOOKUP) {</b>
<b class="nc">&nbsp;                    resources.addAll(Collections.list(ClassLoaderReflectionToolkit._findResources(p.classLoader, name)));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    resources.addAll(Collections.list(p.classLoader.getResources(name)));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return Collections.enumeration(resources);</b>
&nbsp;        }
&nbsp;
&nbsp;        void clearCacheMisses() {
<b class="nc">&nbsp;            loaded.values().removeIf(Optional::isEmpty);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
&nbsp;            // only for debugging purpose
<b class="nc">&nbsp;            return &quot;classLoader &quot; +  getClass().getName();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static boolean FAST_LOOKUP = !SystemProperties.getBoolean(PluginManager.class.getName() + &quot;.noFastLookup&quot;);</b>
&nbsp;
&nbsp;    /** @deprecated in Jenkins 2.222 use {@link Jenkins#ADMINISTER} instead */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static final Permission UPLOAD_PLUGINS = new Permission(Jenkins.PERMISSIONS, &quot;UploadPlugins&quot;, Messages._PluginManager_UploadPluginsPermission_Description(), Jenkins.ADMINISTER, PermissionScope.JENKINS);</b>
&nbsp;
&nbsp;    /** @deprecated in Jenkins 2.222 use {@link Jenkins#ADMINISTER} instead */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static final Permission CONFIGURE_UPDATECENTER = new Permission(Jenkins.PERMISSIONS, &quot;ConfigureUpdateCenter&quot;, Messages._PluginManager_ConfigureUpdateCenterPermission_Description(), Jenkins.ADMINISTER, PermissionScope.JENKINS);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Remembers why a plugin failed to deploy.
&nbsp;     */
&nbsp;    public static final class FailedPlugin {
&nbsp;        public final String name;
&nbsp;        public final Exception cause;
&nbsp;        @Nullable
&nbsp;        public final PluginWrapper pluginWrapper;
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor for FailedPlugin when we do not have an associated PluginWrapper
&nbsp;         */
<b class="nc">&nbsp;        public FailedPlugin(String name, Exception cause) {</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.cause = cause;</b>
<b class="nc">&nbsp;            this.pluginWrapper = null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Constructor for FailedPlugin when we know which PluginWrapper failed
&nbsp;         */
<b class="nc">&nbsp;        public FailedPlugin(PluginWrapper pluginWrapper, Exception cause) {</b>
<b class="nc">&nbsp;            this.name = pluginWrapper.getShortName();</b>
<b class="nc">&nbsp;            this.cause = cause;</b>
<b class="nc">&nbsp;            this.pluginWrapper = pluginWrapper;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getExceptionString() {
<b class="nc">&nbsp;            return Functions.printThrowable(cause);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Stores {@link Plugin} instances.
&nbsp;     */
<b class="nc">&nbsp;    /*package*/ static final class PluginInstanceStore {</b>
<b class="nc">&nbsp;        final Map&lt;PluginWrapper, Plugin&gt; store = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link AdministrativeMonitor} that checks if there are any plugins with cycle dependencies.
&nbsp;     */
&nbsp;    @Extension @Symbol(&quot;pluginCycleDependencies&quot;)
<b class="nc">&nbsp;    public static final class PluginCycleDependenciesMonitor extends AdministrativeMonitor {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.PluginManager_PluginCycleDependenciesMonitor_DisplayName();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        private transient volatile boolean isActive = false;</b>
&nbsp;
&nbsp;        private transient volatile List&lt;PluginWrapper&gt; pluginsWithCycle;
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isActivated() {
<b class="nc">&nbsp;            if (pluginsWithCycle == null) {</b>
<b class="nc">&nbsp;                pluginsWithCycle = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (PluginWrapper p : Jenkins.get().getPluginManager().getPlugins()) {</b>
<b class="nc">&nbsp;                    if (p.hasCycleDependency()) {</b>
<b class="nc">&nbsp;                        pluginsWithCycle.add(p);</b>
<b class="nc">&nbsp;                        isActive = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            return isActive;</b>
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;PluginWrapper&gt; getPluginsWithCycle() {
<b class="nc">&nbsp;            return pluginsWithCycle;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link AdministrativeMonitor} that informs the administrator about a required plugin update.
&nbsp;     * @since 1.491
&nbsp;     */
&nbsp;    @Extension @Symbol(&quot;pluginUpdate&quot;)
<b class="nc">&nbsp;    public static final class PluginUpdateMonitor extends AdministrativeMonitor {</b>
&nbsp;
<b class="nc">&nbsp;        private Map&lt;String, PluginUpdateInfo&gt; pluginsToBeUpdated = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Convenience method to ease access to this monitor, this allows other plugins to register required updates.
&nbsp;         * @return this monitor.
&nbsp;         */
&nbsp;        public static PluginUpdateMonitor getInstance() {
<b class="nc">&nbsp;            return ExtensionList.lookupSingleton(PluginUpdateMonitor.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Report to the administrator if the plugin with the given name is older then the required version.
&nbsp;         *
&nbsp;         * @param pluginName shortName of the plugin (artifactId)
&nbsp;         * @param requiredVersion the lowest version which is OK (e.g. 2.2.2)
&nbsp;         * @param message the message to show (plain text)
&nbsp;         */
&nbsp;        public void ifPluginOlderThenReport(String pluginName, String requiredVersion, String message) {
<b class="nc">&nbsp;            Plugin plugin = Jenkins.get().getPlugin(pluginName);</b>
<b class="nc">&nbsp;            if (plugin != null) {</b>
<b class="nc">&nbsp;                if (plugin.getWrapper().getVersionNumber().isOlderThan(new VersionNumber(requiredVersion))) {</b>
<b class="nc">&nbsp;                    pluginsToBeUpdated.put(pluginName, new PluginUpdateInfo(pluginName, message));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isActivated() {
<b class="nc">&nbsp;            return !pluginsToBeUpdated.isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.PluginManager_PluginUpdateMonitor_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * adds a message about a plugin to the manage screen
&nbsp;         * @param pluginName the plugins name
&nbsp;         * @param message the message to be displayed
&nbsp;         */
&nbsp;        public void addPluginToUpdate(String pluginName, String message) {
<b class="nc">&nbsp;            this.pluginsToBeUpdated.put(pluginName, new PluginUpdateInfo(pluginName, message));</b>
&nbsp;        }
&nbsp;
&nbsp;        public Collection&lt;PluginUpdateInfo&gt; getPluginsToBeUpdated() {
<b class="nc">&nbsp;            return pluginsToBeUpdated.values();</b>
&nbsp;        }
&nbsp;
&nbsp;        public static class PluginUpdateInfo {
&nbsp;            public final String pluginName;
&nbsp;            public final String message;
&nbsp;
<b class="nc">&nbsp;            private PluginUpdateInfo(String pluginName, String message) {</b>
<b class="nc">&nbsp;                this.pluginName = pluginName;</b>
<b class="nc">&nbsp;                this.message = message;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link AdministrativeMonitor} that checks if there are any plugins that are deprecated.
&nbsp;     *
&nbsp;     * @since 2.246
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @Symbol(&quot;pluginDeprecation&quot;)
&nbsp;    @Extension
<b class="nc">&nbsp;    public static final class PluginDeprecationMonitor extends AdministrativeMonitor {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.PluginManager_PluginDeprecationMonitor_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isActivated() {
<b class="nc">&nbsp;            return !getDeprecatedPlugins().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;PluginWrapper, String&gt; getDeprecatedPlugins() {
<b class="nc">&nbsp;            return Jenkins.get().getPluginManager().getPlugins().stream()</b>
<b class="nc">&nbsp;                    .filter(PluginWrapper::isDeprecated)</b>
<b class="nc">&nbsp;                    .collect(Collectors.toMap(Function.identity(), it -&gt; it.getDeprecations().get(0).url));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public String unscientific(double d) {
<b class="nc">&nbsp;        return String.format(Locale.US, &quot;%15.4f&quot;, d);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Object getTarget() {
<b class="nc">&nbsp;        if (!SKIP_PERMISSION_CHECK) {</b>
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(DoNotUse.class) // Used from table.jelly
&nbsp;    public boolean isMetaLabel(String label) {
<b class="nc">&nbsp;        return &quot;adopt-this-plugin&quot;.equals(label) || &quot;deprecated&quot;.equals(label);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(DoNotUse.class) // Used from table.jelly
&nbsp;    public boolean hasAdoptThisPluginLabel(UpdateSite.Plugin plugin) {
<b class="nc">&nbsp;        return plugin.hasCategory(&quot;adopt-this-plugin&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(DoNotUse.class) // Used from table.jelly
&nbsp;    public boolean hasAdoptThisPluginLabel(PluginWrapper plugin) {
<b class="nc">&nbsp;        final UpdateSite.Plugin pluginMeta = Jenkins.get().getUpdateCenter().getPlugin(plugin.getShortName());</b>
<b class="nc">&nbsp;        if (pluginMeta == null) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return pluginMeta.hasCategory(&quot;adopt-this-plugin&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Escape hatch for StaplerProxy-based access control
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static /* Script Console modifiable */ boolean SKIP_PERMISSION_CHECK = SystemProperties.getBoolean(PluginManager.class.getName() + &quot;.skipPermissionCheck&quot;);</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
