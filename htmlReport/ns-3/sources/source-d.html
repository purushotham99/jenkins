


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ExtensionFinder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson</a>
</div>

<h1>Coverage Summary for Class: ExtensionFinder (hudson)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ExtensionFinder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ExtensionFinder$DefaultGuiceExtensionAnnotation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceExtensionAnnotation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/76)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder$FaultTolerantScope</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder$FaultTolerantScope$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$GuiceFinder$SezpozModule</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/90)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$Sezpoz</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ExtensionFinder$Sezpoz$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/260)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., InfraDNA, Inc., CloudBees, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson;
&nbsp;
&nbsp;import com.google.inject.AbstractModule;
&nbsp;import com.google.inject.Binding;
&nbsp;import com.google.inject.Guice;
&nbsp;import com.google.inject.Injector;
&nbsp;import com.google.inject.Key;
&nbsp;import com.google.inject.Module;
&nbsp;import com.google.inject.Provider;
&nbsp;import com.google.inject.Scope;
&nbsp;import com.google.inject.Scopes;
&nbsp;import com.google.inject.matcher.Matchers;
&nbsp;import com.google.inject.name.Names;
&nbsp;import com.google.inject.spi.ProvisionListener;
&nbsp;import hudson.init.InitMilestone;
&nbsp;import hudson.model.Descriptor;
&nbsp;import hudson.model.Hudson;
&nbsp;import jakarta.annotation.PostConstruct;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.StreamSupport;
&nbsp;import jenkins.ExtensionComponentSet;
&nbsp;import jenkins.ExtensionFilter;
&nbsp;import jenkins.ExtensionRefreshException;
&nbsp;import jenkins.ProxyInjector;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import net.java.sezpoz.Index;
&nbsp;import net.java.sezpoz.IndexItem;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.springframework.util.ClassUtils;
&nbsp;
&nbsp;/**
&nbsp; * Discovers the implementations of an extension point.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This extension point allows you to write your implementations of {@link ExtensionPoint}s
&nbsp; * in arbitrary DI containers, and have Hudson discover them.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * {@link ExtensionFinder} itself is an extension point, but to avoid infinite recursion,
&nbsp; * Jenkins discovers {@link ExtensionFinder}s through {@link Sezpoz} and that alone.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @since 1.286
&nbsp; * @see ExtensionFilter
&nbsp; */
<b class="nc">&nbsp;public abstract class ExtensionFinder implements ExtensionPoint {</b>
&nbsp;    /**
&nbsp;     * @deprecated as of 1.356
&nbsp;     *      Use and implement {@link #find(Class,Hudson)} that allows us to put some metadata.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @Deprecated
&nbsp;    public &lt;T&gt; Collection&lt;T&gt; findExtensions(Class&lt;T&gt; type, Hudson hudson) {
<b class="nc">&nbsp;        return Collections.emptyList();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this extension finder supports the {@link #refresh()} operation.
&nbsp;     */
&nbsp;    public boolean isRefreshable() {
&nbsp;        try {
<b class="nc">&nbsp;            return getClass().getMethod(&quot;refresh&quot;).getDeclaringClass() != ExtensionFinder.class;</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException e) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebuilds the internal index, if any, so that future {@link #find(Class, Hudson)} calls
&nbsp;     * will discover components newly added to {@link PluginManager#uberClassLoader}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The point of the refresh operation is not to disrupt instances of already loaded {@link ExtensionComponent}s,
&nbsp;     * and only instantiate those that are new. Otherwise this will break the singleton semantics of various
&nbsp;     * objects, such as {@link Descriptor}s.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The behaviour is undefined if {@link #isRefreshable()} is returning false.
&nbsp;     *
&nbsp;     * @since 1.442
&nbsp;     * @see #isRefreshable()
&nbsp;     * @return never null
&nbsp;     */
&nbsp;    public abstract ExtensionComponentSet refresh() throws ExtensionRefreshException;
&nbsp;
&nbsp;    /**
&nbsp;     * Discover extensions of the given type.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is called only once per the given type after all the plugins are loaded,
&nbsp;     * so implementations need not worry about caching.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method should return all the known components at the time of the call, including
&nbsp;     * those that are discovered later via {@link #refresh()}, even though those components
&nbsp;     * are separately returned in {@link ExtensionComponentSet}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt;
&nbsp;     *      The type of the extension points. This is not bound to {@link ExtensionPoint} because
&nbsp;     *      of {@link Descriptor}, which by itself doesn&#39;t implement {@link ExtensionPoint} for
&nbsp;     *      a historical reason.
&nbsp;     * @param jenkins
&nbsp;     *      Jenkins whose behalf this extension finder is performing lookup.
&nbsp;     * @return
&nbsp;     *      Can be empty but never null.
&nbsp;     * @since 1.356
&nbsp;     *      Older implementations provide {@link #findExtensions(Class,Hudson)}
&nbsp;     */
&nbsp;    public abstract &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type, Hudson jenkins);
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; _find(Class&lt;T&gt; type, Hudson hudson) {
<b class="nc">&nbsp;        return find(type, hudson);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs class initializations without creating instances.
&nbsp;     *
&nbsp;     * If two threads try to initialize classes in the opposite order, a dead lock will ensue,
&nbsp;     * and we can get into a similar situation with {@link ExtensionFinder}s.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * That is, one thread can try to list extensions, which results in {@link ExtensionFinder}
&nbsp;     * loading and initializing classes. This happens inside a context of a lock, so that
&nbsp;     * another thread that tries to list the same extensions don&#39;t end up creating different
&nbsp;     * extension instances. So this activity locks extension list first, then class initialization next.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * In the mean time, another thread can load and initialize a class, and that initialization
&nbsp;     * can eventually results in listing up extensions, for example through static initializer.
&nbsp;     * Such activity locks class initialization first, then locks extension list.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This inconsistent locking order results in a dead lock, you see.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * So to reduce the likelihood, this method is called in prior to {@link #find(Class,Hudson)} invocation,
&nbsp;     * but from outside the lock. The implementation is expected to perform all the class initialization activities
&nbsp;     * from here.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * See &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-4993813&quot;&gt;JDK-4993813&lt;/a&gt; for how to force a class initialization.
&nbsp;     * Also see &lt;a href=&quot;https://kohsuke.org/2010/09/01/deadlock-that-you-cant-avoid/&quot;&gt;this blog post&lt;/a&gt; for how class initialization
&nbsp;     * can results in a dead lock.
&nbsp;     */
&nbsp;    public void scout(Class extensionType, Hudson hudson) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Extension
&nbsp;    public static final class DefaultGuiceExtensionAnnotation extends GuiceExtensionAnnotation&lt;Extension&gt; {
&nbsp;        public DefaultGuiceExtensionAnnotation() {
<b class="nc">&nbsp;            super(Extension.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected boolean isOptional(Extension annotation) {
<b class="nc">&nbsp;            return annotation.optional();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected double getOrdinal(Extension annotation) {
<b class="nc">&nbsp;            return annotation.ordinal();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected boolean isActive(AnnotatedElement e) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Captures information about the annotation that we use to mark Guice-instantiated components.
&nbsp;     */
&nbsp;    public abstract static class GuiceExtensionAnnotation&lt;T extends Annotation&gt; {
&nbsp;        public final Class&lt;T&gt; annotationType;
&nbsp;
<b class="nc">&nbsp;        protected GuiceExtensionAnnotation(Class&lt;T&gt; annotationType) {</b>
<b class="nc">&nbsp;            this.annotationType = annotationType;</b>
&nbsp;        }
&nbsp;
&nbsp;        protected abstract double getOrdinal(T annotation);
&nbsp;
&nbsp;        /**
&nbsp;         * Hook to enable subtypes to control which ones to pick up and which ones to ignore.
&nbsp;         */
&nbsp;        protected abstract boolean isActive(AnnotatedElement e);
&nbsp;
&nbsp;        protected abstract boolean isOptional(T annotation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Discovers components via sezpoz but instantiates them by using Guice.
&nbsp;     */
&nbsp;    @Extension
&nbsp;    public static class GuiceFinder extends ExtensionFinder {
&nbsp;        /**
&nbsp;         * Injector that we find components from.
&nbsp;         * &lt;p&gt;
&nbsp;         * To support refresh when Guice doesn&#39;t let us alter the bindings, we&#39;ll create
&nbsp;         * a child container to house newly discovered components. This field points to the
&nbsp;         * youngest such container.
&nbsp;         */
&nbsp;        private volatile Injector container;
&nbsp;
&nbsp;        /**
&nbsp;         * Sezpoz index we are currently using in {@link #container} (and its ancestors.)
&nbsp;         * Needed to compute delta.
&nbsp;         */
&nbsp;        private List&lt;IndexItem&lt;?, Object&gt;&gt; sezpozIndex;
&nbsp;
<b class="nc">&nbsp;        private final Map&lt;Key, Annotation&gt; annotations = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        private final Sezpoz moduleFinder = new Sezpoz();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Map from {@link GuiceExtensionAnnotation#annotationType} to {@link GuiceExtensionAnnotation}
&nbsp;         */
<b class="nc">&nbsp;        private Map&lt;Class&lt;? extends Annotation&gt;, GuiceExtensionAnnotation&lt;?&gt;&gt; extensionAnnotations = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        public GuiceFinder() {</b>
<b class="nc">&nbsp;            refreshExtensionAnnotations();</b>
&nbsp;
<b class="nc">&nbsp;            SezpozModule extensions = new SezpozModule(loadSezpozIndices(Jenkins.get().getPluginManager().uberClassLoader));</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;Module&gt; modules = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            modules.add(new AbstractModule() {</b>
&nbsp;                @Override
&nbsp;                protected void configure() {
<b class="nc">&nbsp;                    Jenkins j = Jenkins.get();</b>
<b class="nc">&nbsp;                    bind(Jenkins.class).toInstance(j);</b>
<b class="nc">&nbsp;                    bind(PluginManager.class).toInstance(j.getPluginManager());</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            modules.add(extensions);</b>
&nbsp;
<b class="nc">&nbsp;            for (ExtensionComponent&lt;Module&gt; ec : moduleFinder.find(Module.class, Hudson.getInstance())) {</b>
<b class="nc">&nbsp;                modules.add(ec.getInstance());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                container = Guice.createInjector(modules);</b>
<b class="nc">&nbsp;                sezpozIndex = extensions.getLoadedIndex();</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to create Guice container from all the plugins&quot;, e);</b>
&nbsp;                // failing to load all bindings are disastrous, so recover by creating minimum that works
&nbsp;                // by just including the core
<b class="nc">&nbsp;                container = Guice.createInjector(new SezpozModule(loadSezpozIndices(Jenkins.class.getClassLoader())));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // expose Injector via lookup mechanism for interop with non-Guice clients
<b class="nc">&nbsp;            Jenkins.get().lookup.set(Injector.class, new ProxyInjector() {</b>
&nbsp;                @Override
&nbsp;                protected Injector resolve() {
<b class="nc">&nbsp;                    return getContainer();</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        private void refreshExtensionAnnotations() {
<b class="nc">&nbsp;            for (ExtensionComponent&lt;GuiceExtensionAnnotation&gt; ec : moduleFinder.find(GuiceExtensionAnnotation.class, Hudson.getInstance())) {</b>
<b class="nc">&nbsp;                GuiceExtensionAnnotation gea = ec.getInstance();</b>
<b class="nc">&nbsp;                extensionAnnotations.put(gea.annotationType, gea);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        private List&lt;IndexItem&lt;?, Object&gt;&gt; loadSezpozIndices(ClassLoader classLoader) {
<b class="nc">&nbsp;            List&lt;IndexItem&lt;?, Object&gt;&gt; indices = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (GuiceExtensionAnnotation&lt;?&gt; gea : extensionAnnotations.values()) {</b>
<b class="nc">&nbsp;                for (IndexItem&lt;?, Object&gt; indexItem : Index.load(gea.annotationType, Object.class, classLoader)) {</b>
<b class="nc">&nbsp;                    indices.add(indexItem);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return Collections.unmodifiableList(indices);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Injector getContainer() {
<b class="nc">&nbsp;            return container;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The basic idea is:
&nbsp;         *
&nbsp;         * &lt;ul&gt;
&nbsp;         *     &lt;li&gt;List up delta as a series of modules
&nbsp;         *     &lt;li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         */
&nbsp;        @Override
&nbsp;        public synchronized ExtensionComponentSet refresh() throws ExtensionRefreshException {
<b class="nc">&nbsp;            refreshExtensionAnnotations();</b>
&nbsp;            // figure out newly discovered sezpoz components
<b class="nc">&nbsp;            List&lt;IndexItem&lt;?, Object&gt;&gt; delta = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Class&lt;? extends Annotation&gt; annotationType : extensionAnnotations.keySet()) {</b>
<b class="nc">&nbsp;                delta.addAll(Sezpoz.listDelta(annotationType, sezpozIndex));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            SezpozModule deltaExtensions = new SezpozModule(delta);</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;Module&gt; modules = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            modules.add(deltaExtensions);</b>
<b class="nc">&nbsp;            for (ExtensionComponent&lt;Module&gt; ec : moduleFinder.refresh().find(Module.class)) {</b>
<b class="nc">&nbsp;                modules.add(ec.getInstance());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                final Injector child = container.createChildInjector(modules);</b>
<b class="nc">&nbsp;                container = child;</b>
<b class="nc">&nbsp;                List&lt;IndexItem&lt;?, Object&gt;&gt; l = new ArrayList&lt;&gt;(sezpozIndex);</b>
<b class="nc">&nbsp;                l.addAll(deltaExtensions.getLoadedIndex());</b>
<b class="nc">&nbsp;                sezpozIndex = l;</b>
&nbsp;
<b class="nc">&nbsp;                return new ExtensionComponentSet() {</b>
&nbsp;                    @Override
&nbsp;                    public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type) {
<b class="nc">&nbsp;                        List&lt;ExtensionComponent&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                        _find(type, result, child);</b>
<b class="nc">&nbsp;                        return result;</b>
&nbsp;                    }
&nbsp;                };
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to create Guice container from newly added plugins&quot;, e);</b>
<b class="nc">&nbsp;                throw new ExtensionRefreshException(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private Object instantiate(IndexItem&lt;?, Object&gt; item) {
&nbsp;            try {
<b class="nc">&nbsp;                return item.instance();</b>
<b class="nc">&nbsp;            } catch (LinkageError | Exception e) {</b>
&nbsp;                // sometimes the instantiation fails in an indirect classloading failure,
&nbsp;                // which results in a LinkageError
<b class="nc">&nbsp;                LOGGER.log(isOptional(item.annotation()) ? Level.FINE : Level.WARNING,</b>
<b class="nc">&nbsp;                           &quot;Failed to load &quot; + item.className(), e);</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean isOptional(Annotation annotation) {
<b class="nc">&nbsp;            GuiceExtensionAnnotation gea = extensionAnnotations.get(annotation.annotationType());</b>
<b class="nc">&nbsp;            return gea.isOptional(annotation);</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean isActive(Annotation annotation, AnnotatedElement e) {
<b class="nc">&nbsp;            GuiceExtensionAnnotation gea = extensionAnnotations.get(annotation.annotationType());</b>
<b class="nc">&nbsp;            return gea.isActive(e);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;U&gt; Collection&lt;ExtensionComponent&lt;U&gt;&gt; find(Class&lt;U&gt; type, Hudson jenkins) {
&nbsp;            // the find method contract requires us to traverse all known components
<b class="nc">&nbsp;            List&lt;ExtensionComponent&lt;U&gt;&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Injector i = container; i != null; i = i.getParent()) {</b>
<b class="nc">&nbsp;                _find(type, result, i);</b>
&nbsp;            }
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        private &lt;U&gt; void _find(Class&lt;U&gt; type, List&lt;ExtensionComponent&lt;U&gt;&gt; result, Injector container) {
<b class="nc">&nbsp;            for (Map.Entry&lt;Key&lt;?&gt;, Binding&lt;?&gt;&gt; e : container.getBindings().entrySet()) {</b>
<b class="nc">&nbsp;                if (type.isAssignableFrom(e.getKey().getTypeLiteral().getRawType())) {</b>
<b class="nc">&nbsp;                    Annotation a = annotations.get(e.getKey());</b>
<b class="nc">&nbsp;                    Object o = e.getValue().getProvider().get();</b>
<b class="nc">&nbsp;                    if (o != null) {</b>
<b class="nc">&nbsp;                        GuiceExtensionAnnotation gea = a != null ? extensionAnnotations.get(a.annotationType()) : null;</b>
<b class="nc">&nbsp;                        result.add(new ExtensionComponent&lt;&gt;(type.cast(o), gea != null ? gea.getOrdinal(a) : 0));</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * TODO: need to learn more about concurrent access to {@link Injector} and how it interacts
&nbsp;         * with classloading.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void scout(Class extensionType, Hudson hudson) {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@link Scope} that allows a failure to create a component,
&nbsp;         * and change the value to null.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This is necessary as a failure to load one plugin shouldn&#39;t fail the startup of the entire Jenkins.
&nbsp;         * Instead, we should just drop the failing plugins.
&nbsp;         */
<b class="nc">&nbsp;        public static final Scope FAULT_TOLERANT_SCOPE = new FaultTolerantScope(true);</b>
<b class="nc">&nbsp;        private static final Scope QUIET_FAULT_TOLERANT_SCOPE = new FaultTolerantScope(false);</b>
&nbsp;
&nbsp;        private static final class FaultTolerantScope implements Scope {
&nbsp;            private final boolean verbose;
&nbsp;
<b class="nc">&nbsp;            FaultTolerantScope(boolean verbose) {</b>
<b class="nc">&nbsp;                this.verbose = verbose;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; Provider&lt;T&gt; scope(final Key&lt;T&gt; key, final Provider&lt;T&gt; unscoped) {
<b class="nc">&nbsp;                final Provider&lt;T&gt; base = Scopes.SINGLETON.scope(key, unscoped);</b>
<b class="nc">&nbsp;                return new Provider&lt;T&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public T get() {
&nbsp;                        try {
<b class="nc">&nbsp;                            return base.get();</b>
<b class="nc">&nbsp;                        } catch (Exception | LinkageError e) {</b>
<b class="nc">&nbsp;                            error(key, e);</b>
<b class="nc">&nbsp;                            return null;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    void error(Key&lt;T&gt; key, Throwable x) {
<b class="nc">&nbsp;                        LOGGER.log(verbose ? Level.WARNING : Level.FINE, &quot;Failed to instantiate &quot; + key + &quot;; skipping this component&quot;, x);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        private static final Logger LOGGER = Logger.getLogger(GuiceFinder.class.getName());</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@link Module} that finds components via sezpoz index.
&nbsp;         * Instead of using SezPoz to instantiate, we&#39;ll instantiate them by using Guice,
&nbsp;         * so that we can take advantage of dependency injection.
&nbsp;         */
&nbsp;        private class SezpozModule extends AbstractModule implements ProvisionListener {
&nbsp;            private final List&lt;IndexItem&lt;?, Object&gt;&gt; index;
&nbsp;            private final List&lt;IndexItem&lt;?, Object&gt;&gt; loadedIndex;
&nbsp;
<b class="nc">&nbsp;            SezpozModule(List&lt;IndexItem&lt;?, Object&gt;&gt; index) {</b>
<b class="nc">&nbsp;                this.index = index;</b>
<b class="nc">&nbsp;                this.loadedIndex = new ArrayList&lt;&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Guice performs various reflection operations on the class to figure out the dependency graph,
&nbsp;             * and that process can cause additional classloading problems, which will fail the injector creation,
&nbsp;             * which in turn has disastrous effect on the startup.
&nbsp;             *
&nbsp;             * &lt;p&gt;
&nbsp;             * Ultimately I&#39;d like to isolate problems to plugins and selectively disable them, allowing
&nbsp;             * Jenkins to start with plugins that work, but I haven&#39;t figured out how.
&nbsp;             *
&nbsp;             * So this is an attempt to detect subset of problems eagerly, by invoking various reflection
&nbsp;             * operations and try to find non-existent classes early.
&nbsp;             */
&nbsp;            private void resolve(Class&lt;?&gt; c) {
<b class="nc">&nbsp;                resolve(c, new HashSet&lt;&gt;());</b>
&nbsp;            }
&nbsp;
&nbsp;            private void resolve(Class&lt;?&gt; c, Set&lt;Class&lt;?&gt;&gt; encountered) {
<b class="nc">&nbsp;                if (!encountered.add(c)) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;                try {
<b class="nc">&nbsp;                    for (Class&lt;?&gt; cc = c; cc != Object.class &amp;&amp; cc != null; cc = cc.getSuperclass()) {</b>
&nbsp;                        /*
&nbsp;                         * See {@link com.google.inject.spi.InjectionPoint#getInjectionPoints(TypeLiteral, boolean, Errors)}
&nbsp;                         */
<b class="nc">&nbsp;                        cc.getGenericSuperclass();</b>
<b class="nc">&nbsp;                        cc.getGenericInterfaces();</b>
&nbsp;
&nbsp;                        /*
&nbsp;                         * See com.google.inject.spi.InjectionPoint#forConstructorOf(TypeLiteral, boolean)
&nbsp;                         * and com.google.inject.spi.InjectionPoint(TypeLiteral, Constructor)
&nbsp;                         */
<b class="nc">&nbsp;                        boolean foundInjectableConstructor = false;</b>
<b class="nc">&nbsp;                        for (Constructor constructor : cc.getDeclaredConstructors()) {</b>
<b class="nc">&nbsp;                            if (constructor.isAnnotationPresent(javax.inject.Inject.class)</b>
<b class="nc">&nbsp;                                    || constructor.isAnnotationPresent(jakarta.inject.Inject.class)</b>
<b class="nc">&nbsp;                                    || constructor.isAnnotationPresent(com.google.inject.Inject.class)) {</b>
<b class="nc">&nbsp;                                constructor.getAnnotatedParameterTypes();</b>
<b class="nc">&nbsp;                                constructor.getParameterAnnotations();</b>
<b class="nc">&nbsp;                                foundInjectableConstructor = true;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        if (!foundInjectableConstructor) {</b>
<b class="nc">&nbsp;                            Constructor&lt;?&gt; noArg = null;</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                noArg = cc.getDeclaredConstructor();</b>
<b class="nc">&nbsp;                            } catch (NoSuchMethodException e) {</b>
&nbsp;                                // ignore
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            if (noArg != null) {</b>
<b class="nc">&nbsp;                                noArg.getAnnotatedParameterTypes();</b>
<b class="nc">&nbsp;                                noArg.getParameterAnnotations();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // See com.google.inject.spi.InjectionPoint(TypeLiteral, Method, boolean)
<b class="nc">&nbsp;                        for (Method method : cc.getDeclaredMethods()) {</b>
<b class="nc">&nbsp;                            if (method.isAnnotationPresent(javax.inject.Inject.class)</b>
<b class="nc">&nbsp;                                    || method.isAnnotationPresent(jakarta.inject.Inject.class)</b>
<b class="nc">&nbsp;                                    || method.isAnnotationPresent(com.google.inject.Inject.class)) {</b>
<b class="nc">&nbsp;                                method.getAnnotatedParameterTypes();</b>
<b class="nc">&nbsp;                                method.getParameterAnnotations();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        // See com.google.inject.spi.InjectionPoint(TypeLiteral, Field, boolean)
<b class="nc">&nbsp;                        for (Field f : cc.getDeclaredFields()) {</b>
<b class="nc">&nbsp;                            if (f.isAnnotationPresent(javax.inject.Inject.class)</b>
<b class="nc">&nbsp;                                    || f.isAnnotationPresent(jakarta.inject.Inject.class)</b>
<b class="nc">&nbsp;                                    || f.isAnnotationPresent(com.google.inject.Inject.class)) {</b>
<b class="nc">&nbsp;                                f.getAnnotations();</b>
<b class="nc">&nbsp;                                f.getAnnotatedType().getAnnotations();</b>
<b class="nc">&nbsp;                                resolve(f.getType(), encountered);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    LOGGER.log(Level.FINER, &quot;{0} looks OK&quot;, c);</b>
<b class="nc">&nbsp;                } catch (RuntimeException x) {</b>
<b class="nc">&nbsp;                    throw new LinkageError(&quot;Failed to resolve &quot; + c, x);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @SuppressWarnings({&quot;unchecked&quot;, &quot;ChainOfInstanceofChecks&quot;})
&nbsp;            @Override
&nbsp;            protected void configure() {
&nbsp;
<b class="nc">&nbsp;                bindListener(Matchers.any(), this);</b>
&nbsp;
<b class="nc">&nbsp;                for (final IndexItem&lt;?, Object&gt; item : index) {</b>
<b class="nc">&nbsp;                    boolean optional = isOptional(item.annotation());</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        AnnotatedElement e = item.element();</b>
<b class="nc">&nbsp;                        Annotation a = item.annotation();</b>
<b class="nc">&nbsp;                        if (!isActive(a, e))   continue;</b>
&nbsp;
<b class="nc">&nbsp;                        Scope scope = optional ? QUIET_FAULT_TOLERANT_SCOPE : FAULT_TOLERANT_SCOPE;</b>
<b class="nc">&nbsp;                        if (e instanceof Class) {</b>
<b class="nc">&nbsp;                            Key key = Key.get((Class) e);</b>
<b class="nc">&nbsp;                            resolve((Class) e);</b>
<b class="nc">&nbsp;                            annotations.put(key, a);</b>
<b class="nc">&nbsp;                            bind(key).in(scope);</b>
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            Class extType;
<b class="nc">&nbsp;                            if (e instanceof Field) {</b>
<b class="nc">&nbsp;                                extType = ((Field) e).getType();</b>
&nbsp;                            } else
<b class="nc">&nbsp;                            if (e instanceof Method) {</b>
<b class="nc">&nbsp;                                extType = ((Method) e).getReturnType();</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                throw new AssertionError();</b>
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            resolve(extType);</b>
&nbsp;
&nbsp;                            // make unique key, because Guice wants that.
<b class="nc">&nbsp;                            Key key = Key.get(extType, Names.named(item.className() + &quot;.&quot; + item.memberName()));</b>
<b class="nc">&nbsp;                            annotations.put(key, a);</b>
<b class="nc">&nbsp;                            bind(key).toProvider(() -&gt; instantiate(item)).in(scope);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        loadedIndex.add(item);</b>
<b class="nc">&nbsp;                    } catch (Exception | LinkageError e) {</b>
&nbsp;                        // sometimes the instantiation fails in an indirect classloading failure,
&nbsp;                        // which results in a LinkageError
<b class="nc">&nbsp;                        LOGGER.log(optional ? Level.FINE : Level.WARNING,</b>
<b class="nc">&nbsp;                                   &quot;Failed to load &quot; + item.className(), e);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;IndexItem&lt;?, Object&gt;&gt; getLoadedIndex() {
<b class="nc">&nbsp;                return List.copyOf(loadedIndex);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; void onProvision(ProvisionInvocation&lt;T&gt; provision) {
<b class="nc">&nbsp;                final T instance = provision.provision();</b>
<b class="nc">&nbsp;                if (instance == null) return;</b>
<b class="nc">&nbsp;                List&lt;Method&gt; methods = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                Class c = instance.getClass();</b>
&nbsp;
&nbsp;                // find PostConstruct methods in class hierarchy, the one from parent class being first in list
&nbsp;                // so that we invoke them before derived class one. This isn&#39;t specified in JSR-250 but implemented
&nbsp;                // this way in Spring and what most developers would expect to happen.
&nbsp;
<b class="nc">&nbsp;                final Set&lt;Class&lt;?&gt;&gt; interfaces = ClassUtils.getAllInterfacesAsSet(instance);</b>
&nbsp;
<b class="nc">&nbsp;                while (c != Object.class) {</b>
<b class="nc">&nbsp;                    Arrays.stream(c.getDeclaredMethods())</b>
<b class="nc">&nbsp;                            .map(m -&gt; getMethodAndInterfaceDeclarations(m, interfaces))</b>
<b class="nc">&nbsp;                            .flatMap(Collection::stream)</b>
<b class="nc">&nbsp;                            .filter(m -&gt; m.getAnnotation(PostConstruct.class) != null || m.getAnnotation(javax.annotation.PostConstruct.class) != null)</b>
<b class="nc">&nbsp;                            .findFirst()</b>
<b class="nc">&nbsp;                            .ifPresent(method -&gt; methods.add(0, method));</b>
<b class="nc">&nbsp;                    c = c.getSuperclass();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (Method postConstruct : methods) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        postConstruct.setAccessible(true);</b>
<b class="nc">&nbsp;                        postConstruct.invoke(instance);</b>
<b class="nc">&nbsp;                    } catch (final Exception e) {</b>
<b class="nc">&nbsp;                        throw new RuntimeException(String.format(&quot;@PostConstruct %s&quot;, postConstruct), e);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns initial {@link Method} as well as all matching ones found in interfaces.
&nbsp;     * This allows to introspect metadata for a method which is both declared in parent class and in implemented
&nbsp;     * interface(s). {@code interfaces} typically is obtained by {@link ClassUtils#getAllInterfacesAsSet}
&nbsp;     */
&nbsp;    Collection&lt;Method&gt; getMethodAndInterfaceDeclarations(Method method, Collection&lt;Class&lt;?&gt;&gt; interfaces) {
<b class="nc">&nbsp;        final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        methods.add(method);</b>
&nbsp;
&nbsp;        // we search for matching method by iteration and comparison vs getMethod to avoid repeated NoSuchMethodException
&nbsp;        // being thrown, while interface typically only define a few set of methods to check.
<b class="nc">&nbsp;        interfaces.stream()</b>
<b class="nc">&nbsp;                .map(Class::getMethods)</b>
<b class="nc">&nbsp;                .flatMap(Arrays::stream)</b>
<b class="nc">&nbsp;                .filter(m -&gt; m.getName().equals(method.getName()) &amp;&amp; Arrays.equals(m.getParameterTypes(), method.getParameterTypes()))</b>
<b class="nc">&nbsp;                .findFirst()</b>
<b class="nc">&nbsp;                .ifPresent(methods::add);</b>
&nbsp;
<b class="nc">&nbsp;        return methods;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * The bootstrap implementation that looks for the {@link Extension} marker.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Uses Sezpoz as the underlying mechanism.
&nbsp;     */
<b class="nc">&nbsp;    public static final class Sezpoz extends ExtensionFinder {</b>
&nbsp;
&nbsp;        private volatile List&lt;IndexItem&lt;Extension, Object&gt;&gt; indices;
&nbsp;
&nbsp;        /**
&nbsp;         * Loads indices (ideally once but as few times as possible), then reuse them later.
&nbsp;         * {@link ExtensionList#ensureLoaded()} guarantees that this method won&#39;t be called until
&nbsp;         * {@link InitMilestone#PLUGINS_PREPARED} is attained, so this method is guaranteed to
&nbsp;         * see all the classes and indices.
&nbsp;         */
&nbsp;        private List&lt;IndexItem&lt;Extension, Object&gt;&gt; getIndices() {
&nbsp;            // this method cannot be synchronized because of a dead lock possibility in the following order of events:
&nbsp;            // 1. thread X can start listing indices, locking this object &#39;SZ&#39;
&nbsp;            // 2. thread Y starts loading a class, locking a classloader &#39;CL&#39;
&nbsp;            // 3. thread X needs to load a class, now blocked on CL
&nbsp;            // 4. thread Y decides to load extensions, now blocked on SZ.
&nbsp;            // 5. dead lock
<b class="nc">&nbsp;            if (indices == null) {</b>
<b class="nc">&nbsp;                ClassLoader cl = Jenkins.get().getPluginManager().uberClassLoader;</b>
<b class="nc">&nbsp;                indices = StreamSupport.stream(Index.load(Extension.class, Object.class, cl).spliterator(), false).collect(Collectors.toUnmodifiableList());</b>
&nbsp;            }
<b class="nc">&nbsp;            return indices;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * SezPoz implements value-equality of {@link IndexItem}, so
&nbsp;         */
&nbsp;        @Override
&nbsp;        public synchronized ExtensionComponentSet refresh() {
<b class="nc">&nbsp;            final List&lt;IndexItem&lt;Extension, Object&gt;&gt; old = indices;</b>
<b class="nc">&nbsp;            if (old == null)      return ExtensionComponentSet.EMPTY; // we haven&#39;t loaded anything</b>
&nbsp;
<b class="nc">&nbsp;            final List&lt;IndexItem&lt;Extension, Object&gt;&gt; delta = listDelta(Extension.class, old);</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;IndexItem&lt;Extension, Object&gt;&gt; r = new ArrayList&lt;&gt;(old);</b>
<b class="nc">&nbsp;            r.addAll(delta);</b>
<b class="nc">&nbsp;            indices = Collections.unmodifiableList(r);</b>
&nbsp;
<b class="nc">&nbsp;            return new ExtensionComponentSet() {</b>
&nbsp;                @Override
&nbsp;                public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type) {
<b class="nc">&nbsp;                    return _find(type, delta);</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        static &lt;T extends Annotation&gt; List&lt;IndexItem&lt;T, Object&gt;&gt; listDelta(Class&lt;T&gt; annotationType, List&lt;? extends IndexItem&lt;?, Object&gt;&gt; old) {
&nbsp;            // list up newly discovered components
<b class="nc">&nbsp;            final List&lt;IndexItem&lt;T, Object&gt;&gt; delta = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            ClassLoader cl = Jenkins.get().getPluginManager().uberClassLoader;</b>
<b class="nc">&nbsp;            for (IndexItem&lt;T, Object&gt; ii : Index.load(annotationType, Object.class, cl)) {</b>
<b class="nc">&nbsp;                if (!old.contains(ii)) {</b>
<b class="nc">&nbsp;                    delta.add(ii);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return delta;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; find(Class&lt;T&gt; type, Hudson jenkins) {
<b class="nc">&nbsp;            return _find(type, getIndices());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Finds all the matching {@link IndexItem}s that match the given type and instantiate them.
&nbsp;         */
&nbsp;        private &lt;T&gt; Collection&lt;ExtensionComponent&lt;T&gt;&gt; _find(Class&lt;T&gt; type, List&lt;IndexItem&lt;Extension, Object&gt;&gt; indices) {
<b class="nc">&nbsp;            List&lt;ExtensionComponent&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            for (IndexItem&lt;Extension, Object&gt; item : indices) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    Class&lt;?&gt; extType = getClassFromIndex(item);</b>
&nbsp;
<b class="nc">&nbsp;                    if (type.isAssignableFrom(extType)) {</b>
<b class="nc">&nbsp;                        Object instance = item.instance();</b>
<b class="nc">&nbsp;                        if (instance != null)</b>
<b class="nc">&nbsp;                            result.add(new ExtensionComponent&lt;&gt;(type.cast(instance), item.annotation()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (LinkageError | Exception e) {</b>
&nbsp;                    // sometimes the instantiation fails in an indirect classloading failure,
&nbsp;                    // which results in a LinkageError
<b class="nc">&nbsp;                    LOGGER.log(logLevel(item), &quot;Failed to load &quot; + item.className(), e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void scout(Class extensionType, Hudson hudson) {
<b class="nc">&nbsp;            for (IndexItem&lt;Extension, Object&gt; item : getIndices()) {</b>
&nbsp;                try {
&nbsp;                    // we might end up having multiple threads concurrently calling into element(),
&nbsp;                    // but we can&#39;t synchronize this --- if we do, the one thread that&#39;s supposed to load a class
&nbsp;                    // can block while other threads wait for the entry into the element call().
&nbsp;                    // looking at the sezpoz code, it should be safe to do so
<b class="nc">&nbsp;                    Class&lt;?&gt; extType = getClassFromIndex(item);</b>
&nbsp;                    // according to JDK-4993813 this is the only way to force class initialization
<b class="nc">&nbsp;                    Class.forName(extType.getName(), true, extType.getClassLoader());</b>
<b class="nc">&nbsp;                } catch (Exception | LinkageError e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(logLevel(item), &quot;Failed to scout &quot; + item.className(), e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        private Level logLevel(IndexItem&lt;Extension, Object&gt; item) {
<b class="nc">&nbsp;            return item.annotation().optional() ? Level.FINE : Level.WARNING;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Class&lt;?&gt; getClassFromIndex(IndexItem&lt;Extension, Object&gt; item) throws InstantiationException {
<b class="nc">&nbsp;        AnnotatedElement e = item.element();</b>
&nbsp;        Class&lt;?&gt; extType;
<b class="nc">&nbsp;        if (e instanceof Class) {</b>
<b class="nc">&nbsp;            extType = (Class) e;</b>
<b class="nc">&nbsp;        } else if (e instanceof Field) {</b>
<b class="nc">&nbsp;            extType = ((Field) e).getType();</b>
<b class="nc">&nbsp;        } else if (e instanceof Method) {</b>
<b class="nc">&nbsp;            extType = ((Method) e).getReturnType();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new AssertionError();</b>
&nbsp;        }
<b class="nc">&nbsp;        return extType;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(ExtensionFinder.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
