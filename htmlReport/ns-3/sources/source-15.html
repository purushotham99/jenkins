


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Launcher</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson</a>
</div>

<h1>Coverage Summary for Class: Launcher (hudson)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Launcher</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (10/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.8%
  </span>
  <span class="absValue">
    (36/77)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Launcher$1</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (2/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$2</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (8/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$DecoratedLauncher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$DummyLauncher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$IOTriplet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$LocalLauncher</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (15/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$LocalLauncher$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$ProcStarter</td>
<td class="coverageStat">
  <span class="percent">
    21.2%
  </span>
  <span class="absValue">
    (7/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31%
  </span>
  <span class="absValue">
    (26/84)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteChannelLaunchCallable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteLaunchCallable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteLaunchCallable$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteLauncher</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.5%
  </span>
  <span class="absValue">
    (3/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteLauncher$KillTask</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteLauncher$ProcImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Launcher$RemoteProcess</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    21.9%
  </span>
  <span class="absValue">
    (28/128)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.1%
  </span>
  <span class="absValue">
    (90/359)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Stephen Connolly, CloudBees, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.Proc.LocalProc;
&nbsp;import hudson.Proc.ProcWithJenkins23271Patch;
&nbsp;import hudson.model.Computer;
&nbsp;import hudson.model.Node;
&nbsp;import hudson.model.Run;
&nbsp;import hudson.model.TaskListener;
&nbsp;import hudson.remoting.Channel;
&nbsp;import hudson.remoting.Pipe;
&nbsp;import hudson.remoting.RemoteInputStream;
&nbsp;import hudson.remoting.RemoteOutputStream;
&nbsp;import hudson.remoting.VirtualChannel;
&nbsp;import hudson.util.ArgumentListBuilder;
&nbsp;import hudson.util.ProcessTree;
&nbsp;import hudson.util.QuotedStringTokenizer;
&nbsp;import hudson.util.StreamCopyThread;
&nbsp;import java.io.BufferedOutputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InterruptedIOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import jenkins.tasks.filters.EnvVarsFilterLocalRule;
&nbsp;import jenkins.tasks.filters.EnvVarsFilterRuleWrapper;
&nbsp;import jenkins.tasks.filters.EnvVarsFilterableBuilder;
&nbsp;import jenkins.util.MemoryReductionUtil;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.Beta;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;
&nbsp;/**
&nbsp; * Starts a process.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This hides the difference between running programs locally vs remotely.
&nbsp; *
&nbsp; *
&nbsp; * &lt;h2&gt;&#39;env&#39; parameter&lt;/h2&gt;
&nbsp; * &lt;p&gt;
&nbsp; * To allow important environment variables to be copied over to the remote machine,
&nbsp; * the &#39;env&#39; parameter shouldn&#39;t contain default inherited environment variables
&nbsp; * (which often contains machine-specific information, like PATH, TIMEZONE, etc.)
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * {@link Launcher} is responsible for inheriting environment variables.
&nbsp; *
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see FilePath#createLauncher(TaskListener)
&nbsp; */
<b class="fc">&nbsp;public abstract class Launcher {</b>
&nbsp;
&nbsp;    @NonNull
&nbsp;    protected final TaskListener listener;
&nbsp;
&nbsp;    @CheckForNull
&nbsp;    protected final VirtualChannel channel;
&nbsp;
&nbsp;    @Restricted(Beta.class)
&nbsp;    protected EnvVarsFilterRuleWrapper envVarsFilterRuleWrapper;
&nbsp;
<b class="fc">&nbsp;    protected Launcher(@NonNull TaskListener listener, @CheckForNull VirtualChannel channel) {</b>
<b class="fc">&nbsp;        this.listener = listener;</b>
<b class="fc">&nbsp;        this.channel = channel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for a decorator.
&nbsp;     * @param launcher Launcher to be decorated
&nbsp;     */
&nbsp;    protected Launcher(@NonNull Launcher launcher) {
<b class="fc">&nbsp;        this(launcher.listener, launcher.channel);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Build the environment filter rules that will be applied on the environment variables
&nbsp;     * @param run The run that requested the command interpretation, could be &lt;code&gt;null&lt;/code&gt; if outside of a run context.
&nbsp;     * @param builder The builder that asked to run this command
&nbsp;     *
&nbsp;     * @since 2.246
&nbsp;     */
&nbsp;    @Restricted(Beta.class)
&nbsp;    public void prepareFilterRules(@CheckForNull Run&lt;?, ?&gt; run, @NonNull EnvVarsFilterableBuilder builder) {
<b class="nc">&nbsp;        List&lt;EnvVarsFilterLocalRule&gt; specificRuleList = builder.buildEnvVarsFilterRules();</b>
<b class="nc">&nbsp;        EnvVarsFilterRuleWrapper ruleWrapper = EnvVarsFilterRuleWrapper.createRuleWrapper(run, builder, this, specificRuleList);</b>
<b class="nc">&nbsp;        this.setEnvVarsFilterRuleWrapper(ruleWrapper);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(Beta.class)
&nbsp;    protected void setEnvVarsFilterRuleWrapper(EnvVarsFilterRuleWrapper envVarsFilterRuleWrapper) {
<b class="nc">&nbsp;        this.envVarsFilterRuleWrapper = envVarsFilterRuleWrapper;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the channel that can be used to run a program remotely.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      {@code null} if the target node is not configured to support this.
&nbsp;     *      this is a transitional measure.
&nbsp;     *      Note that a launcher for the built-in node is always non-null.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public VirtualChannel getChannel() {
<b class="nc">&nbsp;        return channel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link TaskListener} that this launcher uses to
&nbsp;     * report the commands that it&#39;s executing.
&nbsp;     *
&nbsp;     * @return Task listener
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public TaskListener getListener() {
<b class="nc">&nbsp;        return listener;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this {@link Launcher} is encapsulating an execution on a specific {@link Computer},
&nbsp;     * return it.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Because of the way internal Hudson abstractions are set up (that is, {@link Launcher} only
&nbsp;     * needs a {@link VirtualChannel} to do its job and isn&#39;t really required that the channel
&nbsp;     * comes from an existing {@link Computer}), this method may not always the right {@link Computer} instance.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      {@code null} if this launcher is not created from a {@link Computer} object.
&nbsp;     * @deprecated since 2008-11-16.
&nbsp;     *      See the javadoc for why this is inherently unreliable. If you are trying to
&nbsp;     *      figure out the current {@link Computer} from within a build, use
&nbsp;     *      {@link FilePath#toComputer()} or {@link Computer#currentComputer()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @CheckForNull
&nbsp;    public Computer getComputer() {
<b class="nc">&nbsp;        for (Computer c : Jenkins.get().getComputers())</b>
<b class="nc">&nbsp;            if (c.getChannel() == channel)</b>
<b class="nc">&nbsp;                return c;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builder pattern for configuring a process to launch.
&nbsp;     * @since 1.311
&nbsp;     */
<b class="fc">&nbsp;    public final class ProcStarter {</b>
&nbsp;        protected List&lt;String&gt; commands;
&nbsp;        @CheckForNull
&nbsp;        protected boolean[] masks;
&nbsp;        private boolean quiet;
&nbsp;        @CheckForNull
&nbsp;        protected FilePath pwd;
<b class="fc">&nbsp;        @CheckForNull</b>
<b class="fc">&nbsp;        protected OutputStream stdout = OutputStream.nullOutputStream(), stderr;</b>
&nbsp;        @CheckForNull
&nbsp;        private TaskListener stdoutListener;
<b class="fc">&nbsp;        @CheckForNull</b>
&nbsp;        protected InputStream stdin = NULL_INPUT_STREAM;
<b class="fc">&nbsp;        @CheckForNull</b>
&nbsp;        protected String[] envs = null;
&nbsp;        /**
&nbsp;         * Represent the build step, either from legacy build process or from pipeline one
&nbsp;         */
<b class="fc">&nbsp;        @CheckForNull</b>
&nbsp;        @Restricted(Beta.class)
&nbsp;        protected EnvVarsFilterableBuilder envVarsFilterableBuilder = null;
&nbsp;
&nbsp;        /**
&nbsp;         * True to reverse the I/O direction.
&nbsp;         *
&nbsp;         * For example, if {@link #reverseStdout}==true, then we expose
&nbsp;         * {@link InputStream} from {@link Proc} and expect the client to read from it,
&nbsp;         * whereas normally we take {@link OutputStream} via {@link #stdout(OutputStream)}
&nbsp;         * and feed stdout into that output.
&nbsp;         *
&nbsp;         * @since 1.399
&nbsp;         */
&nbsp;        protected boolean reverseStdin, reverseStdout, reverseStderr;
&nbsp;
&nbsp;        /**
&nbsp;         * Passes a white-space separated single-string command (like &quot;cat abc def&quot;) and parse them
&nbsp;         * as a command argument. This method also handles quotes.
&nbsp;         */
&nbsp;        public ProcStarter cmdAsSingleString(String s) {
<b class="nc">&nbsp;            return cmds(QuotedStringTokenizer.tokenize(s));</b>
&nbsp;        }
&nbsp;
&nbsp;        public ProcStarter cmds(String... args) {
<b class="fc">&nbsp;            return cmds(Arrays.asList(args));</b>
&nbsp;        }
&nbsp;
&nbsp;        public ProcStarter cmds(File program, String... args) {
<b class="nc">&nbsp;            commands = new ArrayList&lt;&gt;(args.length + 1);</b>
<b class="nc">&nbsp;            commands.add(program.getPath());</b>
<b class="nc">&nbsp;            commands.addAll(Arrays.asList(args));</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public ProcStarter cmds(List&lt;String&gt; args) {
<b class="fc">&nbsp;            commands = new ArrayList&lt;&gt;(args);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public ProcStarter cmds(ArgumentListBuilder args) {
<b class="nc">&nbsp;            commands = args.toList();</b>
<b class="nc">&nbsp;            masks = args.toMaskArray();</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;String&gt; cmds() {
<b class="nc">&nbsp;            return commands;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Hide parts of the command line from being printed to the log.
&nbsp;         * @param masks true for each position in {@link #cmds(String[])} which should be masked, false to print
&nbsp;         * @return this
&nbsp;         * @see ArgumentListBuilder#add(String, boolean)
&nbsp;         * @see #maskedPrintCommandLine(List, boolean[], FilePath)
&nbsp;         */
&nbsp;        public ProcStarter masks(@CheckForNull boolean... masks) {
<b class="nc">&nbsp;            this.masks = masks;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        public boolean[] masks() {
<b class="nc">&nbsp;            return masks;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Allows {@link #maskedPrintCommandLine(List, boolean[], FilePath)} to be suppressed from {@link hudson.Launcher.LocalLauncher#launch(hudson.Launcher.ProcStarter)}.
&nbsp;         * Useful when the actual command being printed is noisy and unreadable and the caller would rather print diagnostic information in a customized way.
&nbsp;         * @param quiet to suppress printing the command line when starting the process; false to keep default behavior of printing
&nbsp;         * @return {@code this}
&nbsp;         * @since 1.576
&nbsp;         */
&nbsp;        public ProcStarter quiet(boolean quiet) {
<b class="nc">&nbsp;            this.quiet = quiet;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @since 1.576
&nbsp;         */
&nbsp;        public boolean quiet() {
<b class="nc">&nbsp;            return quiet;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Sets the current directory.
&nbsp;         *
&nbsp;         * @param workDir Work directory to be used.
&nbsp;         *                If {@code null}, the default/current directory will be used by the process starter
&nbsp;         * @return {@code this}
&nbsp;         */
&nbsp;        public ProcStarter pwd(@CheckForNull FilePath workDir) {
<b class="nc">&nbsp;            this.pwd = workDir;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        public ProcStarter pwd(@NonNull File workDir) {
<b class="nc">&nbsp;            return pwd(new FilePath(workDir));</b>
&nbsp;        }
&nbsp;
&nbsp;        public ProcStarter pwd(@NonNull String workDir) {
<b class="nc">&nbsp;            return pwd(new File(workDir));</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        public FilePath pwd() {
<b class="nc">&nbsp;            return pwd;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Sets STDOUT destination.
&nbsp;         *
&nbsp;         * @param out Output stream.
&nbsp;         *            Use {@code null} to send STDOUT to {@code /dev/null}.
&nbsp;         * @return {@code this}
&nbsp;         */
&nbsp;        public ProcStarter stdout(@CheckForNull OutputStream out) {
<b class="nc">&nbsp;            this.stdout = out;</b>
<b class="nc">&nbsp;            stdoutListener = null;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Sends the stdout to the given {@link TaskListener}.
&nbsp;         *
&nbsp;         * @param out Task listener (must be safely remotable)
&nbsp;         * @return {@code this}
&nbsp;         */
&nbsp;        public ProcStarter stdout(@NonNull TaskListener out) {
<b class="fc">&nbsp;            stdout = out.getLogger();</b>
<b class="fc">&nbsp;            stdoutListener = out;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets current STDOUT destination.
&nbsp;         *
&nbsp;         * @return STDOUT output stream. {@code null} if STDOUT is suppressed or undefined.
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        public OutputStream stdout() {
<b class="nc">&nbsp;            return stdout;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Controls where the stderr of the process goes.
&nbsp;         * By default, it&#39;s bundled into stdout.
&nbsp;         */
&nbsp;        public ProcStarter stderr(@CheckForNull OutputStream err) {
<b class="nc">&nbsp;            this.stderr =  err;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets current STDERR destination.
&nbsp;         *
&nbsp;         * @return STDERR output stream. {@code null} if suppressed or undefined.
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        public OutputStream stderr() {
<b class="nc">&nbsp;            return stderr;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Controls where the stdin of the process comes from.
&nbsp;         * By default, {@code /dev/null}.
&nbsp;         *
&nbsp;         * @return {@code this}
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public ProcStarter stdin(@CheckForNull InputStream in) {
<b class="nc">&nbsp;            this.stdin = in;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets current STDIN destination.
&nbsp;         *
&nbsp;         * @return STDIN output stream. {@code null} if suppressed or undefined.
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        public InputStream stdin() {
<b class="nc">&nbsp;            return stdin;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Sets the environment variable overrides.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * In addition to what the current process
&nbsp;         * is inherited (if this is going to be launched from a agent agent, that
&nbsp;         * becomes the &quot;current&quot; process), these variables will be also set.
&nbsp;         *
&nbsp;         * @param overrides Environment variables to be overridden
&nbsp;         * @return {@code this}
&nbsp;         */
&nbsp;        public ProcStarter envs(@NonNull Map&lt;String, String&gt; overrides) {
<b class="nc">&nbsp;            this.envs = Util.mapToEnv(overrides);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param overrides
&nbsp;         *      List of &quot;VAR=VALUE&quot;. See {@link #envs(Map)} for the semantics.
&nbsp;         *
&nbsp;         * @return {@code this}
&nbsp;         */
&nbsp;        public ProcStarter envs(@CheckForNull String... overrides) {
<b class="fc">&nbsp;            if (overrides != null) {</b>
<b class="fc">&nbsp;                for (String override : overrides) {</b>
<b class="fc">&nbsp;                    if (override.indexOf(&#39;=&#39;) == -1) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(override);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            this.envs = overrides;</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets a list of environment variables to be set.
&nbsp;         * Returns an empty array if envs field has not been initialized.
&nbsp;         *
&nbsp;         * @return If initialized, returns a copy of internal envs array. Otherwise - a new empty array.
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public String[] envs() {
<b class="nc">&nbsp;            return envs != null ? envs.clone() : MemoryReductionUtil.EMPTY_STRING_ARRAY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the caller will pump {@code stdout} from the child process
&nbsp;         * via {@link Proc#getStdout()} (whereas by default you call {@link #stdout(OutputStream)}
&nbsp;         * and let Jenkins pump stdout into your {@link OutputStream} of choosing.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * When this method is called, {@link Proc#getStdout()} will read the combined output
&nbsp;         * of {@code stdout/stderr} from the child process, unless {@link #readStderr()} is called
&nbsp;         * separately, which lets the caller read those two streams separately.
&nbsp;         *
&nbsp;         * @return {@code this}
&nbsp;         * @since 1.399
&nbsp;         */
&nbsp;        public ProcStarter readStdout() {
<b class="nc">&nbsp;            reverseStdout = true;</b>
<b class="nc">&nbsp;            stdout = stderr = null;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * In addition to the effect of {@link #readStdout()}, indicate that the caller will pump {@code stderr}
&nbsp;         * from the child process separately from {@code stdout}. The stderr will be readable from
&nbsp;         * {@link Proc#getStderr()} while {@link Proc#getStdout()} reads from stdout.
&nbsp;         *
&nbsp;         * @return {@code this}
&nbsp;         * @since 1.399
&nbsp;         */
&nbsp;        public ProcStarter readStderr() {
<b class="nc">&nbsp;            reverseStdout = true;</b>
<b class="nc">&nbsp;            reverseStderr = true;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the caller will directly write to the child process {@link #stdin()} via {@link Proc#getStdin()}.
&nbsp;         * (Whereas by default you call {@link #stdin(InputStream)}
&nbsp;         * and let Jenkins pump your {@link InputStream} of choosing to stdin.)
&nbsp;         *
&nbsp;         * @return {@code this}
&nbsp;         * @since 1.399
&nbsp;         */
&nbsp;        public ProcStarter writeStdin() {
<b class="nc">&nbsp;            reverseStdin = true;</b>
<b class="nc">&nbsp;            stdin = null;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Specify the build step that want to run the command to enable the environment filters
&nbsp;         * @return {@code this}
&nbsp;         * @since 2.246
&nbsp;         */
&nbsp;        @Restricted(Beta.class)
&nbsp;        public ProcStarter buildStep(EnvVarsFilterableBuilder envVarsFilterableBuilder) {
<b class="nc">&nbsp;            this.envVarsFilterableBuilder = envVarsFilterableBuilder;</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @return if set, returns the build step that wants to run the command
&nbsp;         * @since 2.246
&nbsp;         */
&nbsp;        @Restricted(Beta.class)
&nbsp;        public @CheckForNull
&nbsp;        EnvVarsFilterableBuilder buildStep() {
<b class="nc">&nbsp;            return envVarsFilterableBuilder;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Starts the new process as configured.
&nbsp;         */
&nbsp;        public Proc start() throws IOException {
<b class="fc">&nbsp;            return launch(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Starts the process and waits for its completion.
&nbsp;         * @return Return code of the invoked process
&nbsp;         * @throws IOException Operation error (e.g. remote call failure)
&nbsp;         * @throws InterruptedException The process has been interrupted
&nbsp;         */
&nbsp;        public int join() throws IOException, InterruptedException {
&nbsp;            // The logging around procHolderForJoin prevents the preliminary object deallocation we saw in JENKINS-23271
<b class="fc">&nbsp;            final Proc procHolderForJoin = start();</b>
<b class="fc">&nbsp;            LOGGER.log(Level.FINER, &quot;Started the process {0}&quot;, procHolderForJoin);</b>
&nbsp;
<b class="fc">&nbsp;            if (procHolderForJoin instanceof ProcWithJenkins23271Patch) {</b>
<b class="nc">&nbsp;                return procHolderForJoin.join();</b>
&nbsp;            } else {
&nbsp;                // Fallback to the internal handling logic
<b class="fc">&nbsp;                if (!(procHolderForJoin instanceof LocalProc)) {</b>
&nbsp;                    // We consider that the process may be at risk of JENKINS-23271
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Process {0} of type {1} is neither {2} nor instance of {3}. &quot;</b>
&nbsp;                            + &quot;If this process operates with Jenkins agents via remote invocation, you may get into JENKINS-23271&quot;,
<b class="nc">&nbsp;                            new Object[] {procHolderForJoin, procHolderForJoin.getClass(), LocalProc.class, ProcWithJenkins23271Patch.class});</b>
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    final int returnCode = procHolderForJoin.join();</b>
<b class="fc">&nbsp;                    if (LOGGER.isLoggable(Level.FINER)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINER, &quot;Process {0} has finished with the return code {1}&quot;, new Object[]{procHolderForJoin, returnCode});</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return returnCode;</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    if (procHolderForJoin.isAlive()) { // Should never happen but this forces Proc to not be removed and early GC by escape analysis</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, &quot;Process {0} has not finished after the join() method completion&quot;, procHolderForJoin);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Copies a {@link ProcStarter}.
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public ProcStarter copy() {
<b class="nc">&nbsp;            ProcStarter rhs = new ProcStarter().cmds(commands).pwd(pwd).masks(masks).stdin(stdin).stdout(stdout).stderr(stderr).envs(envs).quiet(quiet).buildStep(envVarsFilterableBuilder);</b>
<b class="nc">&nbsp;            rhs.stdoutListener = stdoutListener;</b>
<b class="nc">&nbsp;            rhs.reverseStdin  = this.reverseStdin;</b>
<b class="nc">&nbsp;            rhs.reverseStderr = this.reverseStderr;</b>
<b class="nc">&nbsp;            rhs.reverseStdout = this.reverseStdout;</b>
<b class="nc">&nbsp;            return rhs;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Launches a process by using a {@linkplain ProcStarter builder-pattern} to configure
&nbsp;     * the parameters.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public final ProcStarter launch() {
<b class="fc">&nbsp;        return new ProcStarter();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String cmd, Map&lt;String, String&gt; env, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, Util.mapToEnv(env), out, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, Map&lt;String, String&gt; env, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, Util.mapToEnv(env), out, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, Map&lt;String, String&gt; env, InputStream in, OutputStream out) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, Util.mapToEnv(env), in, out);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Launch a command with optional censoring of arguments from the listener (Note: &lt;strong&gt;The censored portions will
&nbsp;     * remain visible through /proc, pargs, process explorer, etc. i.e. people logged in on the same machine&lt;/strong&gt;
&nbsp;     * This version of the launch command just ensures that it is not visible from a build log which is exposed via the
&nbsp;     * web)
&nbsp;     *
&nbsp;     * @param cmd     The command and all it&#39;s arguments.
&nbsp;     * @param mask    Which of the command and arguments should be masked from the listener
&nbsp;     * @param env     Environment variable overrides.
&nbsp;     * @param out     stdout and stderr of the process will be sent to this stream. the stream won&#39;t be closed.
&nbsp;     * @param workDir null if the working directory could be anything.
&nbsp;     * @return The process of the command.
&nbsp;     * @throws IOException When there are IO problems.
&nbsp;     *
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, boolean[] mask, Map&lt;String, String&gt; env, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, mask, Util.mapToEnv(env), out, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Launch a command with optional censoring of arguments from the listener (Note: &lt;strong&gt;The censored portions will
&nbsp;     * remain visible through /proc, pargs, process explorer, etc. i.e. people logged in on the same machine&lt;/strong&gt;
&nbsp;     * This version of the launch command just ensures that it is not visible from a build log which is exposed via the
&nbsp;     * web)
&nbsp;     *
&nbsp;     * @param cmd     The command and all it&#39;s arguments.
&nbsp;     * @param mask    Which of the command and arguments should be masked from the listener
&nbsp;     * @param env     Environment variable overrides.
&nbsp;     * @param in      null if there&#39;s no input.
&nbsp;     * @param out     stdout and stderr of the process will be sent to this stream. the stream won&#39;t be closed.
&nbsp;     * @return The process of the command.
&nbsp;     * @throws IOException When there are IO problems.
&nbsp;     *
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, boolean[] mask, Map&lt;String, String&gt; env, InputStream in, OutputStream out) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, mask, Util.mapToEnv(env), in, out);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String cmd, String[] env, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(Util.tokenize(cmd), env, out, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, String[] env, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, env, null, out, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, String[] env, InputStream in, OutputStream out) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, env, in, out, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Launch a command with optional censoring of arguments from the listener (Note: &lt;strong&gt;The censored portions will
&nbsp;     * remain visible through /proc, pargs, process explorer, etc. i.e. people logged in on the same machine&lt;/strong&gt;
&nbsp;     * This version of the launch command just ensures that it is not visible from a build log which is exposed via the
&nbsp;     * web)
&nbsp;     *
&nbsp;     * @param cmd     The command and all it&#39;s arguments.
&nbsp;     * @param mask    Which of the command and arguments should be masked from the listener
&nbsp;     * @param env     Environment variable overrides.
&nbsp;     * @param out     stdout and stderr of the process will be sent to this stream. the stream won&#39;t be closed.
&nbsp;     * @param workDir null if the working directory could be anything.
&nbsp;     * @return The process of the command.
&nbsp;     * @throws IOException When there are IO problems.
&nbsp;     *
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, boolean[] mask, String[] env, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, mask, env, null, out, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Launch a command with optional censoring of arguments from the listener (Note: &lt;strong&gt;The censored portions will
&nbsp;     * remain visible through /proc, pargs, process explorer, etc. i.e. people logged in on the same machine&lt;/strong&gt;
&nbsp;     * This version of the launch command just ensures that it is not visible from a build log which is exposed via the
&nbsp;     * web)
&nbsp;     *
&nbsp;     * @param cmd     The command and all it&#39;s arguments.
&nbsp;     * @param mask    Which of the command and arguments should be masked from the listener
&nbsp;     * @param env     Environment variable overrides.
&nbsp;     * @param in      null if there&#39;s no input.
&nbsp;     * @param out     stdout and stderr of the process will be sent to this stream. the stream won&#39;t be closed.
&nbsp;     * @return The process of the command.
&nbsp;     * @throws IOException When there are IO problems.
&nbsp;     *
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public final Proc launch(String[] cmd, boolean[] mask, String[] env, InputStream in, OutputStream out) throws IOException {
<b class="nc">&nbsp;        return launch(cmd, mask, env, in, out, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param env
&nbsp;     *      Environment variable overrides.
&nbsp;     * @param in
&nbsp;     *      null if there&#39;s no input.
&nbsp;     * @param workDir
&nbsp;     *      null if the working directory could be anything.
&nbsp;     * @param out
&nbsp;     *      stdout and stderr of the process will be sent to this stream.
&nbsp;     *      the stream won&#39;t be closed.
&nbsp;     *
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public Proc launch(String[] cmd, String[] env, InputStream in, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(launch().cmds(cmd).envs(env).stdin(in).stdout(out).pwd(workDir));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Launch a command with optional censoring of arguments from the listener (Note: &lt;strong&gt;The censored portions will
&nbsp;     * remain visible through /proc, pargs, process explorer, etc. i.e. people logged in on the same machine&lt;/strong&gt;
&nbsp;     * This version of the launch command just ensures that it is not visible from a build log which is exposed via the
&nbsp;     * web)
&nbsp;     *
&nbsp;     * @param cmd     The command and all it&#39;s arguments.
&nbsp;     * @param mask    Which of the command and arguments should be masked from the listener
&nbsp;     * @param env     Environment variable overrides.
&nbsp;     * @param in      null if there&#39;s no input.
&nbsp;     * @param out     stdout and stderr of the process will be sent to this stream. the stream won&#39;t be closed.
&nbsp;     * @param workDir null if the working directory could be anything.
&nbsp;     * @return The process of the command.
&nbsp;     * @throws IOException When there are IO problems.
&nbsp;     *
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #launch()} and its associated builder pattern
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public Proc launch(String[] cmd, boolean[] mask, String[] env, InputStream in, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;        return launch(launch().cmds(cmd).masks(mask).envs(env).stdin(in).stdout(out).pwd(workDir));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Primarily invoked from {@link ProcStarter#start()} to start a process with a specific launcher.
&nbsp;     */
&nbsp;    public abstract Proc launch(@NonNull ProcStarter starter) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Launches a specified process and connects its input/output to a {@link Channel}, then
&nbsp;     * return it.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When the returned channel is terminated, the process will be killed.
&nbsp;     *
&nbsp;     * @param cmd
&nbsp;     *      The commands.
&nbsp;     * @param out
&nbsp;     *      Where the stderr from the launched process will be sent.
&nbsp;     * @param workDir
&nbsp;     *      The working directory of the new process, or {@code null} to inherit
&nbsp;     *      from the current process
&nbsp;     * @param envVars
&nbsp;     *      Environment variable overrides. In addition to what the current process
&nbsp;     *      is inherited (if this is going to be launched from an agent, that
&nbsp;     *      becomes the &quot;current&quot; process), these variables will be also set.
&nbsp;     */
&nbsp;    public abstract Channel launchChannel(@NonNull String[] cmd, @NonNull OutputStream out,
&nbsp;            @CheckForNull FilePath workDir, @NonNull Map&lt;String, String&gt; envVars) throws IOException, InterruptedException;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this {@link Launcher} is going to launch on Unix.
&nbsp;     */
&nbsp;    public boolean isUnix() {
<b class="nc">&nbsp;        return File.pathSeparatorChar == &#39;:&#39;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calls {@link ProcessTree#killAll(Map)} to kill processes.
&nbsp;     */
&nbsp;    public abstract void kill(Map&lt;String, String&gt; modelEnvVars) throws IOException, InterruptedException;
&nbsp;
&nbsp;    /**
&nbsp;     * Prints out the command line to the listener so that users know what we are doing.
&nbsp;     */
&nbsp;    protected final void printCommandLine(@NonNull String[] cmd, @CheckForNull FilePath workDir) {
<b class="fc">&nbsp;        StringBuilder buf = new StringBuilder();</b>
<b class="fc">&nbsp;        if (workDir != null) {</b>
<b class="nc">&nbsp;            buf.append(&#39;[&#39;);</b>
<b class="nc">&nbsp;            if (showFullPath)</b>
<b class="nc">&nbsp;                buf.append(workDir.getRemote());</b>
&nbsp;            else
<b class="nc">&nbsp;                buf.append(workDir.getRemote().replaceFirst(&quot;^.+[/\\\\]&quot;, &quot;&quot;));</b>
<b class="nc">&nbsp;            buf.append(&quot;] &quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        buf.append(&#39;$&#39;);</b>
<b class="fc">&nbsp;        for (String c : cmd) {</b>
<b class="fc">&nbsp;            buf.append(&#39; &#39;);</b>
<b class="fc">&nbsp;            if (c.indexOf(&#39; &#39;) &gt;= 0) {</b>
<b class="fc">&nbsp;                if (c.indexOf(&#39;&quot;&#39;) &gt;= 0)</b>
<b class="nc">&nbsp;                    buf.append(&#39;\&#39;&#39;).append(c).append(&#39;\&#39;&#39;);</b>
&nbsp;                else
<b class="fc">&nbsp;                    buf.append(&#39;&quot;&#39;).append(c).append(&#39;&quot;&#39;);</b>
&nbsp;            } else
<b class="fc">&nbsp;                buf.append(c);</b>
&nbsp;        }
<b class="fc">&nbsp;        listener.getLogger().println(buf);</b>
<b class="fc">&nbsp;        listener.getLogger().flush();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prints out the command line to the listener with some portions masked to prevent sensitive information from being
&nbsp;     * recorded on the listener.
&nbsp;     *
&nbsp;     * @param cmd     The commands
&nbsp;     * @param mask    An array of booleans which control whether a cmd element should be masked ({@code true}) or
&nbsp;     *                remain unmasked ({@code false}).
&nbsp;     * @param workDir The work dir.
&nbsp;     */
&nbsp;    protected final void maskedPrintCommandLine(@NonNull List&lt;String&gt; cmd, @CheckForNull boolean[] mask, @CheckForNull FilePath workDir) {
<b class="fc">&nbsp;        if (mask == null) {</b>
<b class="fc">&nbsp;            printCommandLine(cmd.toArray(new String[0]), workDir);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        assert mask.length == cmd.size();</b>
<b class="nc">&nbsp;        final String[] masked = new String[cmd.size()];</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; cmd.size(); i++) {</b>
<b class="nc">&nbsp;            if (mask[i]) {</b>
<b class="nc">&nbsp;                masked[i] = &quot;********&quot;;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                masked[i] = cmd.get(i);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        printCommandLine(masked, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected final void maskedPrintCommandLine(@NonNull String[] cmd, @NonNull boolean[] mask, @CheckForNull FilePath workDir) {
<b class="nc">&nbsp;        maskedPrintCommandLine(Arrays.asList(cmd), mask, workDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a decorated {@link Launcher} for the given node.
&nbsp;     *
&nbsp;     * @param node Node for which this launcher is created.
&nbsp;     * @return Decorated instance of the Launcher.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public final Launcher decorateFor(@NonNull Node node) {
<b class="nc">&nbsp;        Launcher l = this;</b>
<b class="nc">&nbsp;        for (LauncherDecorator d : LauncherDecorator.all())</b>
<b class="nc">&nbsp;            l = d.decorate(l, node);</b>
<b class="nc">&nbsp;        return l;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a decorated {@link Launcher} that puts the given set of arguments as a prefix to any commands
&nbsp;     * that it invokes.
&nbsp;     *
&nbsp;     * @param prefix Prefixes to be appended
&nbsp;     * @since 1.299
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public final Launcher decorateByPrefix(final String... prefix) {
<b class="fc">&nbsp;        final Launcher outer = this;</b>
<b class="fc">&nbsp;        return new Launcher(outer) {</b>
&nbsp;            @Override
&nbsp;            public boolean isUnix() {
<b class="fc">&nbsp;                return outer.isUnix();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Proc launch(ProcStarter starter) throws IOException {
<b class="nc">&nbsp;                starter.commands.addAll(0, Arrays.asList(prefix));</b>
<b class="nc">&nbsp;                boolean[] masks = starter.masks;</b>
<b class="nc">&nbsp;                if (masks != null) {</b>
<b class="nc">&nbsp;                    starter.masks = prefix(masks);</b>
&nbsp;                }
<b class="nc">&nbsp;                return outer.launch(starter);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Channel launchChannel(String[] cmd, OutputStream out, FilePath workDir, Map&lt;String, String&gt; envVars) throws IOException, InterruptedException {
<b class="nc">&nbsp;                return outer.launchChannel(prefix(cmd), out, workDir, envVars);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void kill(Map&lt;String, String&gt; modelEnvVars) throws IOException, InterruptedException {
<b class="nc">&nbsp;                outer.kill(modelEnvVars);</b>
&nbsp;            }
&nbsp;
&nbsp;            private String[] prefix(@NonNull String[] args) {
<b class="nc">&nbsp;                String[] newArgs = new String[args.length + prefix.length];</b>
<b class="nc">&nbsp;                System.arraycopy(prefix, 0, newArgs, 0, prefix.length);</b>
<b class="nc">&nbsp;                System.arraycopy(args, 0, newArgs, prefix.length, args.length);</b>
<b class="nc">&nbsp;                return newArgs;</b>
&nbsp;            }
&nbsp;
&nbsp;            private boolean[] prefix(@NonNull boolean[] args) {
<b class="nc">&nbsp;                boolean[] newArgs = new boolean[args.length + prefix.length];</b>
<b class="nc">&nbsp;                System.arraycopy(args, 0, newArgs, prefix.length, args.length);</b>
<b class="nc">&nbsp;                return newArgs;</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a decorated {@link Launcher} that automatically adds the specified environment
&nbsp;     * variables.
&nbsp;     *
&nbsp;     * Those that are specified in {@link ProcStarter#envs(String...)} will take precedence over
&nbsp;     * what&#39;s specified here.
&nbsp;     *
&nbsp;     * @since 1.489
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public final Launcher decorateByEnv(@NonNull EnvVars _env) {
<b class="fc">&nbsp;        final EnvVars env = new EnvVars(_env);</b>
<b class="fc">&nbsp;        final Launcher outer = this;</b>
<b class="fc">&nbsp;        return new Launcher(outer) {</b>
&nbsp;            @Override
&nbsp;            public boolean isUnix() {
<b class="fc">&nbsp;                return outer.isUnix();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Proc launch(ProcStarter starter) throws IOException {
<b class="fc">&nbsp;                EnvVars e = new EnvVars(env);</b>
<b class="fc">&nbsp;                if (starter.envs != null) {</b>
<b class="fc">&nbsp;                    for (String env : starter.envs) {</b>
<b class="fc">&nbsp;                        e.addLine(env);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                starter.envs = Util.mapToEnv(e);</b>
<b class="fc">&nbsp;                return outer.launch(starter);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Channel launchChannel(String[] cmd, OutputStream out, FilePath workDir, Map&lt;String, String&gt; envVars) throws IOException, InterruptedException {
<b class="nc">&nbsp;                EnvVars e = new EnvVars(env);</b>
<b class="nc">&nbsp;                e.putAll(envVars);</b>
<b class="nc">&nbsp;                return outer.launchChannel(cmd, out, workDir, e);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void kill(Map&lt;String, String&gt; modelEnvVars) throws IOException, InterruptedException {
<b class="nc">&nbsp;                outer.kill(modelEnvVars);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Launcher} that launches process locally.
&nbsp;     */
&nbsp;    public static class LocalLauncher extends Launcher {
&nbsp;        public LocalLauncher(@NonNull TaskListener listener) {
<b class="fc">&nbsp;            this(listener, FilePath.localChannel);</b>
&nbsp;        }
&nbsp;
&nbsp;        public LocalLauncher(TaskListener listener, VirtualChannel channel) {
<b class="fc">&nbsp;            super(listener, channel);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Proc launch(ProcStarter ps) throws IOException {
<b class="fc">&nbsp;            if (!ps.quiet) {</b>
<b class="fc">&nbsp;                maskedPrintCommandLine(ps.commands, ps.masks, ps.pwd);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            EnvVars jobEnv = inherit(ps.envs);</b>
&nbsp;
<b class="fc">&nbsp;            if (envVarsFilterRuleWrapper != null) {</b>
<b class="nc">&nbsp;                envVarsFilterRuleWrapper.filter(jobEnv, this, listener);</b>
&nbsp;                // reset the rules to prevent build step without rules configuration to re-use those
<b class="nc">&nbsp;                envVarsFilterRuleWrapper = null;</b>
&nbsp;            }
&nbsp;
&nbsp;            // replace variables in command line
<b class="fc">&nbsp;            String[] jobCmd = new String[ps.commands.size()];</b>
<b class="fc">&nbsp;            for (int idx = 0; idx &lt; jobCmd.length; idx++)</b>
<b class="fc">&nbsp;                jobCmd[idx] = jobEnv.expand(ps.commands.get(idx));</b>
&nbsp;
<b class="fc">&nbsp;            return new LocalProc(jobCmd, Util.mapToEnv(jobEnv),</b>
<b class="fc">&nbsp;                    ps.reverseStdin ? LocalProc.SELFPUMP_INPUT : ps.stdin,</b>
<b class="fc">&nbsp;                    ps.reverseStdout ? LocalProc.SELFPUMP_OUTPUT : ps.stdout,</b>
<b class="fc">&nbsp;                    ps.reverseStderr ? LocalProc.SELFPUMP_OUTPUT : ps.stderr,</b>
<b class="fc">&nbsp;                    toFile(ps.pwd));</b>
&nbsp;        }
&nbsp;
&nbsp;        private File toFile(FilePath f) {
<b class="fc">&nbsp;            return f == null ? null : new File(f.getRemote());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Channel launchChannel(String[] cmd, OutputStream out, FilePath workDir, Map&lt;String, String&gt; envVars) throws IOException {
<b class="nc">&nbsp;            printCommandLine(cmd, workDir);</b>
&nbsp;
<b class="nc">&nbsp;            ProcessBuilder pb = new ProcessBuilder(cmd);</b>
<b class="nc">&nbsp;            pb.directory(toFile(workDir));</b>
<b class="nc">&nbsp;            if (envVars != null) pb.environment().putAll(envVars);</b>
&nbsp;
<b class="nc">&nbsp;            return launchChannel(out, pb);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void kill(Map&lt;String, String&gt; modelEnvVars) throws InterruptedException {
<b class="nc">&nbsp;            ProcessTree.get().killAll(modelEnvVars);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @param out
&nbsp;         *      Where the stderr from the launched process will be sent.
&nbsp;         */
&nbsp;        public Channel launchChannel(OutputStream out, ProcessBuilder pb) throws IOException {
<b class="nc">&nbsp;            final EnvVars cookie = EnvVars.createCookie();</b>
<b class="nc">&nbsp;            pb.environment().putAll(cookie);</b>
&nbsp;
<b class="nc">&nbsp;            final Process proc = pb.start();</b>
&nbsp;
<b class="nc">&nbsp;            final Thread t2 = new StreamCopyThread(pb.command() + &quot;: stderr copier&quot;, proc.getErrorStream(), out);</b>
<b class="nc">&nbsp;            t2.start();</b>
&nbsp;
<b class="nc">&nbsp;            return new Channel(&quot;locally launched channel on &quot; + pb.command(),</b>
<b class="nc">&nbsp;                Computer.threadPoolForRemoting, proc.getInputStream(), proc.getOutputStream(), out) {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Kill the process when the channel is severed.
&nbsp;                 */
&nbsp;                @Override
&nbsp;                public synchronized void terminate(IOException e) {
<b class="nc">&nbsp;                    super.terminate(e);</b>
<b class="nc">&nbsp;                    ProcessTree pt = ProcessTree.get();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        pt.killAll(proc, cookie);</b>
<b class="nc">&nbsp;                    } catch (InterruptedException x) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.INFO, &quot;Interrupted&quot;, x);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public synchronized void close() throws IOException {
<b class="nc">&nbsp;                    super.close();</b>
&nbsp;                    // wait for all the output from the process to be picked up
&nbsp;                    try {
<b class="nc">&nbsp;                        t2.join();</b>
<b class="nc">&nbsp;                    } catch (InterruptedException e) {</b>
&nbsp;                        // process the interrupt later
<b class="nc">&nbsp;                        Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static class DummyLauncher extends Launcher {
&nbsp;
&nbsp;        public DummyLauncher(@NonNull TaskListener listener) {
<b class="nc">&nbsp;            super(listener, null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Proc launch(ProcStarter starter) throws IOException {
<b class="nc">&nbsp;            throw new IOException(&quot;Can not call launch on a dummy launcher.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Channel launchChannel(String[] cmd, OutputStream out, FilePath workDir, Map&lt;String, String&gt; envVars) throws IOException, InterruptedException {
<b class="nc">&nbsp;            throw new IOException(&quot;Can not call launchChannel on a dummy launcher.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void kill(Map&lt;String, String&gt; modelEnvVars) throws IOException, InterruptedException {
&nbsp;            // Kill method should do nothing.
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Launches processes remotely by using the given channel.
&nbsp;     */
&nbsp;    public static class RemoteLauncher extends Launcher {
&nbsp;        private final boolean isUnix;
&nbsp;
&nbsp;        public RemoteLauncher(@NonNull TaskListener listener, @NonNull VirtualChannel channel, boolean isUnix) {
<b class="fc">&nbsp;            super(listener, channel);</b>
<b class="fc">&nbsp;            this.isUnix = isUnix;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @NonNull
&nbsp;        public VirtualChannel getChannel() {
<b class="nc">&nbsp;            VirtualChannel vc = super.getChannel();</b>
<b class="nc">&nbsp;            if (vc == null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;RemoteLauncher has been initialized with Null channel. It should not happen&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return super.getChannel();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Proc launch(ProcStarter ps) throws IOException {
<b class="nc">&nbsp;            final OutputStream out = ps.stdout == null || ps.stdoutListener != null ? null : new RemoteOutputStream(new CloseProofOutputStream(ps.stdout));</b>
<b class="nc">&nbsp;            final OutputStream err = ps.stderr == null ? null : new RemoteOutputStream(new CloseProofOutputStream(ps.stderr));</b>
<b class="nc">&nbsp;            final InputStream in = ps.stdin == null || ps.stdin == NULL_INPUT_STREAM ? null : new RemoteInputStream(ps.stdin, false);</b>
&nbsp;
<b class="nc">&nbsp;            final FilePath psPwd = ps.pwd;</b>
<b class="nc">&nbsp;            final String workDir = psPwd == null ? null : psPwd.getRemote();</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                RemoteLaunchCallable remote = new RemoteLaunchCallable(ps.commands, ps.masks, ps.envs, in, ps.reverseStdin, out, ps.reverseStdout, err, ps.reverseStderr, ps.quiet, workDir, listener, ps.stdoutListener);</b>
<b class="nc">&nbsp;                remote.setEnvVarsFilterRuleWrapper(envVarsFilterRuleWrapper);</b>
&nbsp;                // reset the rules to prevent build step without rules configuration to re-use those
<b class="nc">&nbsp;                envVarsFilterRuleWrapper = null;</b>
<b class="nc">&nbsp;                return new ProcImpl(getChannel().call(remote));</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                throw (IOException) new InterruptedIOException().initCause(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Channel launchChannel(String[] cmd, OutputStream err, FilePath _workDir, Map&lt;String, String&gt; envOverrides) throws IOException, InterruptedException {
<b class="nc">&nbsp;            printCommandLine(cmd, _workDir);</b>
&nbsp;
<b class="nc">&nbsp;            Pipe out = Pipe.createRemoteToLocal();</b>
<b class="nc">&nbsp;            final String workDir = _workDir == null ? null : _workDir.getRemote();</b>
&nbsp;
<b class="nc">&nbsp;            OutputStream os = getChannel().call(new RemoteChannelLaunchCallable(cmd, out, err, workDir, envOverrides));</b>
&nbsp;
<b class="nc">&nbsp;            return new Channel(&quot;remotely launched channel on &quot; + channel,</b>
<b class="nc">&nbsp;                Computer.threadPoolForRemoting, out.getIn(), new BufferedOutputStream(os));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isUnix() {
<b class="fc">&nbsp;            return isUnix;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void kill(final Map&lt;String, String&gt; modelEnvVars) throws IOException, InterruptedException {
<b class="nc">&nbsp;            getChannel().call(new KillTask(modelEnvVars));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;RemoteLauncher[&quot; + getChannel() + &quot;]&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final class KillTask extends MasterToSlaveCallable&lt;Void, RuntimeException&gt; {
&nbsp;            private final Map&lt;String, String&gt; modelEnvVars;
&nbsp;
<b class="nc">&nbsp;            KillTask(Map&lt;String, String&gt; modelEnvVars) {</b>
<b class="nc">&nbsp;                this.modelEnvVars = modelEnvVars;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Void call() throws RuntimeException {
&nbsp;                try {
<b class="nc">&nbsp;                    ProcessTree.get().killAll(modelEnvVars);</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
&nbsp;                    // we are asked to terminate early by the caller, so no need to do anything
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;        }
&nbsp;
&nbsp;        public static final class ProcImpl extends Proc implements ProcWithJenkins23271Patch {
&nbsp;            private final RemoteProcess process;
&nbsp;            private final IOTriplet io;
&nbsp;
<b class="nc">&nbsp;            public ProcImpl(RemoteProcess process) {</b>
<b class="nc">&nbsp;                this.process = process;</b>
<b class="nc">&nbsp;                this.io = process.getIOtriplet();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void kill() throws IOException, InterruptedException {
&nbsp;                try {
<b class="nc">&nbsp;                    process.kill();</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    if (this.isAlive()) { // Should never happen but this forces Proc to not be removed and early GC by escape analysis</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, &quot;Process {0} has not really finished after the kill() method execution&quot;, this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int join() throws IOException, InterruptedException {
&nbsp;                try {
<b class="nc">&nbsp;                    final int returnCode = process.join();</b>
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(Level.FINER)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINER, &quot;Process {0} has finished with the return code {1}&quot;, new Object[]{this, returnCode});</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return returnCode;</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    if (this.isAlive()) { // Should never happen but this forces Proc to not be removed and early GC by escape analysis</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, &quot;Process {0} has not really finished after the join() method completion&quot;, this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isAlive() throws IOException, InterruptedException {
<b class="nc">&nbsp;                return process.isAlive();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InputStream getStdout() {
<b class="nc">&nbsp;                return io.stdout;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InputStream getStderr() {
<b class="nc">&nbsp;                return io.stderr;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public OutputStream getStdin() {
<b class="nc">&nbsp;                return io.stdin;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A launcher which delegates to a provided inner launcher.
&nbsp;     * Allows subclasses to only implement methods they want to override.
&nbsp;     * Originally, this launcher has been implemented in
&nbsp;     * &lt;a href=&quot;https://plugins.jenkins.io/custom-tools-plugin&quot;&gt;
&nbsp;     * Custom Tools Plugin&lt;/a&gt;.
&nbsp;     *
&nbsp;     * @author rcampbell
&nbsp;     * @author Oleg Nenashev, Synopsys Inc.
&nbsp;     * @since 1.568
&nbsp;     */
&nbsp;    public static class DecoratedLauncher extends Launcher {
&nbsp;
&nbsp;        private final Launcher inner;
&nbsp;
&nbsp;        public DecoratedLauncher(@NonNull Launcher inner) {
<b class="nc">&nbsp;            super(inner);</b>
<b class="nc">&nbsp;            this.inner = inner;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Proc launch(ProcStarter starter) throws IOException {
<b class="nc">&nbsp;            return inner.launch(starter);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Channel launchChannel(String[] cmd, OutputStream out,
&nbsp;                FilePath workDir, Map&lt;String, String&gt; envVars) throws IOException,
&nbsp;                InterruptedException {
<b class="nc">&nbsp;            return inner.launchChannel(cmd, out, workDir, envVars);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void kill(Map&lt;String, String&gt; modelEnvVars) throws IOException,
&nbsp;                InterruptedException {
<b class="nc">&nbsp;            inner.kill(modelEnvVars);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isUnix() {
<b class="nc">&nbsp;            return inner.isUnix();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Proc launch(String[] cmd, boolean[] mask, String[] env, InputStream in, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;            return inner.launch(cmd, mask, env, in, out, workDir);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Computer getComputer() {
<b class="nc">&nbsp;            return inner.getComputer();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public TaskListener getListener() {
<b class="nc">&nbsp;            return inner.getListener();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return super.toString() + &quot;; decorates &quot; + inner.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public VirtualChannel getChannel() {
<b class="nc">&nbsp;            return inner.getChannel();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Proc launch(String[] cmd, String[] env, InputStream in, OutputStream out, FilePath workDir) throws IOException {
<b class="nc">&nbsp;            return inner.launch(cmd, env, in, out, workDir);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets nested launcher.
&nbsp;         * @return Inner launcher
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public Launcher getInner() {
<b class="nc">&nbsp;            return inner;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static class IOTriplet implements Serializable {</b>
&nbsp;        @CheckForNull
&nbsp;        InputStream stdout, stderr;
&nbsp;        @CheckForNull
&nbsp;        OutputStream stdin;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;    /**
&nbsp;     * Remoting interface of a remote process
&nbsp;     */
&nbsp;
&nbsp;    public interface RemoteProcess {
&nbsp;        int join() throws InterruptedException, IOException;
&nbsp;
&nbsp;        void kill() throws IOException, InterruptedException;
&nbsp;
&nbsp;        boolean isAlive() throws IOException, InterruptedException;
&nbsp;
&nbsp;        @NonNull
&nbsp;        IOTriplet getIOtriplet();
&nbsp;    }
&nbsp;
&nbsp;    private static class RemoteLaunchCallable extends MasterToSlaveCallable&lt;RemoteProcess, IOException&gt; {
&nbsp;        private final @NonNull List&lt;String&gt; cmd;
&nbsp;        private final @CheckForNull boolean[] masks;
&nbsp;        private final @CheckForNull String[] env;
&nbsp;        private final @CheckForNull InputStream in;
&nbsp;        private final @CheckForNull OutputStream out;
&nbsp;        private final @CheckForNull OutputStream err;
&nbsp;        private final @CheckForNull String workDir;
&nbsp;        private final @NonNull TaskListener listener;
&nbsp;        private final @CheckForNull TaskListener stdoutListener;
&nbsp;        private final boolean reverseStdin, reverseStdout, reverseStderr;
&nbsp;        private final boolean quiet;
&nbsp;
&nbsp;        private EnvVarsFilterRuleWrapper envVarsFilterRuleWrapper;
&nbsp;
&nbsp;        RemoteLaunchCallable(@NonNull List&lt;String&gt; cmd, @CheckForNull boolean[] masks, @CheckForNull String[] env,
&nbsp;                @CheckForNull InputStream in, boolean reverseStdin,
&nbsp;                @CheckForNull OutputStream out, boolean reverseStdout,
&nbsp;                @CheckForNull OutputStream err, boolean reverseStderr,
<b class="nc">&nbsp;                boolean quiet, @CheckForNull String workDir, @NonNull TaskListener listener, @CheckForNull TaskListener stdoutListener) {</b>
<b class="nc">&nbsp;            this.cmd = new ArrayList&lt;&gt;(cmd);</b>
<b class="nc">&nbsp;            this.masks = masks;</b>
<b class="nc">&nbsp;            this.env = env;</b>
<b class="nc">&nbsp;            this.in = in;</b>
<b class="nc">&nbsp;            this.out = out;</b>
<b class="nc">&nbsp;            this.err = err;</b>
<b class="nc">&nbsp;            this.workDir = workDir;</b>
<b class="nc">&nbsp;            this.listener = listener;</b>
<b class="nc">&nbsp;            this.stdoutListener = stdoutListener;</b>
<b class="nc">&nbsp;            this.reverseStdin = reverseStdin;</b>
<b class="nc">&nbsp;            this.reverseStdout = reverseStdout;</b>
<b class="nc">&nbsp;            this.reverseStderr = reverseStderr;</b>
<b class="nc">&nbsp;            this.quiet = quiet;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public void setEnvVarsFilterRuleWrapper(EnvVarsFilterRuleWrapper envVarsFilterRuleWrapper) {
<b class="nc">&nbsp;            this.envVarsFilterRuleWrapper = envVarsFilterRuleWrapper;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public RemoteProcess call() throws IOException {
<b class="nc">&nbsp;            final Channel channel = getOpenChannelOrFail();</b>
<b class="nc">&nbsp;            LocalLauncher localLauncher = new LocalLauncher(listener);</b>
<b class="nc">&nbsp;            localLauncher.setEnvVarsFilterRuleWrapper(envVarsFilterRuleWrapper);</b>
&nbsp;
<b class="nc">&nbsp;            Launcher.ProcStarter ps = localLauncher.launch();</b>
<b class="nc">&nbsp;            ps.cmds(cmd).masks(masks).envs(env).stdin(in).stderr(err).quiet(quiet);</b>
<b class="nc">&nbsp;            if (stdoutListener != null) {</b>
<b class="nc">&nbsp;                ps.stdout(stdoutListener.getLogger());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                ps.stdout(out);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (workDir != null)   ps.pwd(workDir);</b>
<b class="nc">&nbsp;            if (reverseStdin)   ps.writeStdin();</b>
<b class="nc">&nbsp;            if (reverseStdout)  ps.readStdout();</b>
<b class="nc">&nbsp;            if (reverseStderr)  ps.readStderr();</b>
&nbsp;
<b class="nc">&nbsp;            final Proc p = ps.start();</b>
&nbsp;
<b class="nc">&nbsp;            return channel.export(RemoteProcess.class, new RemoteProcess() {</b>
&nbsp;                @Override
&nbsp;                public int join() throws InterruptedException, IOException {
&nbsp;                    try {
<b class="nc">&nbsp;                        return p.join();</b>
&nbsp;                    } finally {
&nbsp;                        // make sure I/O is delivered to the remote before we return
<b class="nc">&nbsp;                        Channel taskChannel = null;</b>
&nbsp;                        try {
&nbsp;                            // Sync IO will fail automatically if the channel is being closed, no need to use getOpenChannelOrFail()
<b class="nc">&nbsp;                            taskChannel = Channel.currentOrFail();</b>
<b class="nc">&nbsp;                            taskChannel.syncIO();</b>
<b class="nc">&nbsp;                        } catch (Throwable t) {</b>
&nbsp;                            // this includes a failure to sync, agent.jar too old, etc
<b class="nc">&nbsp;                            LOGGER.log(Level.INFO, &quot;Failed to synchronize IO streams on the channel &quot; + taskChannel, t);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void kill() throws IOException, InterruptedException {
<b class="nc">&nbsp;                    p.kill();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isAlive() throws IOException, InterruptedException {
<b class="nc">&nbsp;                    return p.isAlive();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public IOTriplet getIOtriplet() {
<b class="nc">&nbsp;                    IOTriplet r = new IOTriplet();</b>
<b class="nc">&nbsp;                    if (reverseStdout)  r.stdout = new RemoteInputStream(p.getStdout());</b>
<b class="nc">&nbsp;                    if (reverseStderr)  r.stderr = new RemoteInputStream(p.getStderr());</b>
<b class="nc">&nbsp;                    if (reverseStdin)   r.stdin  = new RemoteOutputStream(p.getStdin());</b>
<b class="nc">&nbsp;                    return r;</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    private static class RemoteChannelLaunchCallable extends MasterToSlaveCallable&lt;OutputStream, IOException&gt; {
&nbsp;        @NonNull
&nbsp;        private final String[] cmd;
&nbsp;        @NonNull
&nbsp;        private final Pipe out;
&nbsp;        @CheckForNull
&nbsp;        private final String workDir;
&nbsp;        @NonNull
&nbsp;        private final OutputStream err;
&nbsp;        @NonNull
&nbsp;        private final Map&lt;String, String&gt; envOverrides;
&nbsp;
&nbsp;        RemoteChannelLaunchCallable(@NonNull String[] cmd, @NonNull Pipe out, @NonNull OutputStream err,
<b class="nc">&nbsp;                @CheckForNull String workDir, @NonNull Map&lt;String, String&gt; envOverrides) {</b>
<b class="nc">&nbsp;            this.cmd = cmd;</b>
<b class="nc">&nbsp;            this.out = out;</b>
<b class="nc">&nbsp;            this.err = new RemoteOutputStream(err);</b>
<b class="nc">&nbsp;            this.workDir = workDir;</b>
<b class="nc">&nbsp;            this.envOverrides = envOverrides;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public OutputStream call() throws IOException {
<b class="nc">&nbsp;            Process p = Runtime.getRuntime().exec(cmd,</b>
<b class="nc">&nbsp;                Util.mapToEnv(inherit(envOverrides)),</b>
<b class="nc">&nbsp;                workDir == null ? null : new File(workDir));</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;String&gt; cmdLines = Arrays.asList(cmd);</b>
<b class="nc">&nbsp;            new StreamCopyThread(&quot;stdin copier for remote agent on &quot; + cmdLines,</b>
<b class="nc">&nbsp;                p.getInputStream(), out.getOut()).start();</b>
<b class="nc">&nbsp;            new StreamCopyThread(&quot;stderr copier for remote agent on &quot; + cmdLines,</b>
<b class="nc">&nbsp;                p.getErrorStream(), err).start();</b>
&nbsp;
&nbsp;            // TODO: don&#39;t we need to join?
&nbsp;
<b class="nc">&nbsp;            return new RemoteOutputStream(p.getOutputStream());</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Expands the list of environment variables by inheriting current env variables.
&nbsp;     */
&nbsp;    private static EnvVars inherit(@CheckForNull String[] env) {
&nbsp;        // convert String[] to Map first
<b class="fc">&nbsp;        EnvVars m = new EnvVars();</b>
<b class="fc">&nbsp;        if (env != null) {</b>
<b class="fc">&nbsp;            for (String e : env) {</b>
<b class="fc">&nbsp;                int index = e.indexOf(&#39;=&#39;);</b>
<b class="fc">&nbsp;                m.put(e.substring(0, index), e.substring(index + 1));</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // then do the inheritance
<b class="fc">&nbsp;        return inherit(m);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Expands the list of environment variables by inheriting current env variables.
&nbsp;     */
&nbsp;    private static EnvVars inherit(@NonNull Map&lt;String, String&gt; overrides) {
<b class="fc">&nbsp;        EnvVars m = new EnvVars(EnvVars.masterEnvVars);</b>
<b class="fc">&nbsp;        m.overrideExpandingAll(overrides);</b>
<b class="fc">&nbsp;        return m;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Debug option to display full current path instead of just the last token.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for debugging&quot;)
<b class="fc">&nbsp;    public static boolean showFullPath = false;</b>
&nbsp;
<b class="fc">&nbsp;    private static final InputStream NULL_INPUT_STREAM = InputStream.nullInputStream();</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Launcher.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
