


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FilePath</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson</a>
</div>

<h1>Coverage Summary for Class: FilePath (hudson)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FilePath</td>
<td class="coverageStat">
  <span class="percent">
    69.6%
  </span>
  <span class="absValue">
    (112/161)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.7%
  </span>
  <span class="absValue">
    (380/626)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FilePath$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Absolutize</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$AbstractInterceptorCallableWrapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Archive</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CallableWith</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Chmod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CopyRecursiveLocal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CopyRecursiveLocal$1</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.2%
  </span>
  <span class="absValue">
    (12/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CopyRecursiveRemoteToLocal</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CopyTo</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CopyToWithPermission</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CreateTempDir</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CreateTempFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$CreateTextTempFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.2%
  </span>
  <span class="absValue">
    (13/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Delete</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$DeleteContents</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$DeleteRecursive</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$DeleteSuffixesRecursive</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Digest</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$DirectoryFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$DisplayOption</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Exists</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ExplicitlySpecifiedDirScanner</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$FileCallable</td>
  </tr>
  <tr>
    <td class="name">FilePath$FileCallableWrapper</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$FileCallableWrapperFactory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$FileMaskNoMatchesFoundException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$GetFreeDiskSpace</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$GetHomeDirectory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$GetTotalDiskSpace</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$GetUsableDiskSpace</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$HasSymlink</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$IsDescendant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76%
  </span>
  <span class="absValue">
    (38/50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$IsDirectory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$IsUnix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$LastModified</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Length</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ListFilter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ListGlob</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Mkdirs</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Mode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$MoveAllChildrenTo</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$OffsetPipeSecureFileCallable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$OptionalDiscardingFileFilter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Read</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ReadFromTar</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ReadLink</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ReadToString</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$RemoteCopier</td>
  </tr>
  <tr>
    <td class="name">FilePath$RenameTo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$SetLastModified</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$SymlinkRetainingFileFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$SymlinkTo</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$TarCompression</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$TarCompression$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$TarCompression$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Touch</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ToURI</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$TunneledInterruptedException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Unpack</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UntarFrom</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UntarLocal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UntarRemote</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UnzipFrom</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UnzipLocal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UnzipRemote</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$UrlFactory</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ValidateAntFileMask</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.1%
  </span>
  <span class="absValue">
    (62/72)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ValidateAntFileMask$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$ValidateAntFileMask$1Cancel</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$VisitorInfo</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$Write</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$WritePipe</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilePath$WriteToTar</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    65.7%
  </span>
  <span class="absValue">
    (213/324)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.8%
  </span>
  <span class="absValue">
    (705/1140)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Eric Lefevre-Ardant, Erik Ramfelt, Michael B. Donohue, Alan Harder,
&nbsp; * Manufacture Francaise des Pneumatiques Michelin, Romain Seguy
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson;
&nbsp;
&nbsp;import static hudson.Util.fileToPath;
&nbsp;import static hudson.Util.fixEmpty;
&nbsp;import static hudson.Util.fixEmptyAndTrim;
&nbsp;
&nbsp;import com.google.common.annotations.VisibleForTesting;
&nbsp;import com.jcraft.jzlib.GZIPInputStream;
&nbsp;import com.jcraft.jzlib.GZIPOutputStream;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.Launcher.LocalLauncher;
&nbsp;import hudson.Launcher.RemoteLauncher;
&nbsp;import hudson.model.AbstractProject;
&nbsp;import hudson.model.Computer;
&nbsp;import hudson.model.Item;
&nbsp;import hudson.model.TaskListener;
&nbsp;import hudson.remoting.Callable;
&nbsp;import hudson.remoting.Channel;
&nbsp;import hudson.remoting.DelegatingCallable;
&nbsp;import hudson.remoting.Future;
&nbsp;import hudson.remoting.LocalChannel;
&nbsp;import hudson.remoting.Pipe;
&nbsp;import hudson.remoting.RemoteInputStream;
&nbsp;import hudson.remoting.RemoteInputStream.Flag;
&nbsp;import hudson.remoting.RemoteOutputStream;
&nbsp;import hudson.remoting.VirtualChannel;
&nbsp;import hudson.remoting.Which;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.slaves.WorkspaceList;
&nbsp;import hudson.tasks.ArtifactArchiver;
&nbsp;import hudson.util.DaemonThreadFactory;
&nbsp;import hudson.util.DirScanner;
&nbsp;import hudson.util.ExceptionCatchingThreadFactory;
&nbsp;import hudson.util.FileVisitor;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.HeadBufferingStream;
&nbsp;import hudson.util.IOUtils;
&nbsp;import hudson.util.NamingThreadFactory;
&nbsp;import hudson.util.io.Archiver;
&nbsp;import hudson.util.io.ArchiverFactory;
&nbsp;import java.io.BufferedInputStream;
&nbsp;import java.io.BufferedOutputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.FileFilter;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InterruptedIOException;
&nbsp;import java.io.NotSerializableException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.OutputStreamWriter;
&nbsp;import java.io.RandomAccessFile;
&nbsp;import java.io.Serializable;
&nbsp;import java.io.Writer;
&nbsp;import java.net.HttpURLConnection;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLConnection;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.CopyOption;
&nbsp;import java.nio.file.FileSystemException;
&nbsp;import java.nio.file.FileSystems;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.LinkOption;
&nbsp;import java.nio.file.NoSuchFileException;
&nbsp;import java.nio.file.OpenOption;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.nio.file.StandardCopyOption;
&nbsp;import java.nio.file.attribute.FileAttribute;
&nbsp;import java.nio.file.attribute.FileTime;
&nbsp;import java.nio.file.attribute.PosixFilePermission;
&nbsp;import java.nio.file.attribute.PosixFilePermissions;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.StringTokenizer;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import jenkins.MasterToSlaveFileCallable;
&nbsp;import jenkins.SlaveToMasterFileCallable;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import jenkins.util.ContextResettingExecutorService;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.VirtualFile;
&nbsp;import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
&nbsp;import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
&nbsp;import org.apache.commons.fileupload.FileItem;
&nbsp;import org.apache.commons.io.input.CountingInputStream;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.apache.tools.ant.BuildException;
&nbsp;import org.apache.tools.ant.DirectoryScanner;
&nbsp;import org.apache.tools.ant.Project;
&nbsp;import org.apache.tools.ant.types.FileSet;
&nbsp;import org.apache.tools.zip.ZipEntry;
&nbsp;import org.apache.tools.zip.ZipFile;
&nbsp;import org.jenkinsci.remoting.RoleChecker;
&nbsp;import org.jenkinsci.remoting.RoleSensitive;
&nbsp;import org.jenkinsci.remoting.SerializableOnlyOverRemoting;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;
&nbsp;/**
&nbsp; * {@link File} like object with remoting support.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Unlike {@link File}, which always implies a file path on the current computer,
&nbsp; * {@link FilePath} represents a file path on a specific agent or the controller.
&nbsp; *
&nbsp; * Despite that, {@link FilePath} can be used much like {@link File}. It exposes
&nbsp; * a bunch of operations (and we should add more operations as long as they are
&nbsp; * generally useful), and when invoked against a file on a remote node, {@link FilePath}
&nbsp; * executes the necessary code remotely, thereby providing semi-transparent file
&nbsp; * operations.
&nbsp; *
&nbsp; * &lt;h2&gt;Using {@link FilePath} smartly&lt;/h2&gt;
&nbsp; * &lt;p&gt;
&nbsp; * The transparency makes it easy to write plugins without worrying too much about
&nbsp; * remoting, by making it works like NFS, where remoting happens at the file-system
&nbsp; * layer.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * But one should note that such use of remoting may not be optional. Sometimes,
&nbsp; * it makes more sense to move some computation closer to the data, as opposed to
&nbsp; * move the data to the computation. For example, if you are just computing a MD5
&nbsp; * digest of a file, then it would make sense to do the digest on the host where
&nbsp; * the file is located, as opposed to send the whole data to the controller and do MD5
&nbsp; * digesting there.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * {@link FilePath} supports this &quot;code migration&quot; by in the
&nbsp; * {@link #act(FileCallable)} method. One can pass in a custom implementation
&nbsp; * of {@link FileCallable}, to be executed on the node where the data is located.
&nbsp; * The following code shows the example:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; * void someMethod(FilePath file) {
&nbsp; *     // make &#39;file&#39; a fresh empty directory.
&nbsp; *     file.act(new Freshen());
&nbsp; * }
&nbsp; * // if &#39;file&#39; is on a different node, this FileCallable will
&nbsp; * // be transferred to that node and executed there.
&nbsp; * private static final class Freshen implements FileCallable&amp;lt;Void&amp;gt; {
&nbsp; *     private static final long serialVersionUID = 1;
&nbsp; *     &amp;#64;Override public Void invoke(File f, VirtualChannel channel) {
&nbsp; *         // f and file represent the same thing
&nbsp; *         f.deleteContents();
&nbsp; *         f.mkdirs();
&nbsp; *         return null;
&nbsp; *     }
&nbsp; * }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * When {@link FileCallable} is transferred to a remote node, it will be done so
&nbsp; * by using the same Java serialization scheme that the remoting module uses.
&nbsp; * See {@link Channel} for more about this.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * {@link FilePath} itself can be sent over to a remote node as a part of {@link Callable}
&nbsp; * serialization. For example, sending a {@link FilePath} of a remote node to that
&nbsp; * node causes {@link FilePath} to become &quot;local&quot;. Similarly, sending a
&nbsp; * {@link FilePath} that represents the local computer causes it to become &quot;remote.&quot;
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see VirtualFile
&nbsp; */
&nbsp;public final class FilePath implements SerializableOnlyOverRemoting {
&nbsp;
<b class="fc">&nbsp;    public enum DisplayOption implements OpenOption, CopyOption {</b>
<b class="fc">&nbsp;        IGNORE_TMP_DIRS</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maximum http redirects we will follow. This defaults to the same number as Firefox/Chrome tolerates.
&nbsp;     */
&nbsp;    private static final int MAX_REDIRECTS = 20;
&nbsp;
&nbsp;    /**
&nbsp;     * When this {@link FilePath} represents the remote path,
&nbsp;     * this field is always non-null on the controller (the field represents
&nbsp;     * the channel to the remote agent.) When transferred to an agent via remoting,
&nbsp;     * this field reverts to null, since it&#39;s transient.
&nbsp;     *
&nbsp;     * When this {@link FilePath} represents a path on the controller,
&nbsp;     * this field is null on the controller. When transferred to an agent via remoting,
&nbsp;     * this field becomes non-null, representing the {@link Channel}
&nbsp;     * back to the controller.
&nbsp;     *
&nbsp;     * This is used to determine whether we are running on the controller / the built-in node, or an agent.
&nbsp;     */
&nbsp;    private transient VirtualChannel channel;
&nbsp;
&nbsp;    /**
&nbsp;     * Represent the path to the file in the controller or the agent
&nbsp;     * Since the platform of the agent might be different, can&#39;t use java.io.File
&nbsp;     *
&nbsp;     * The field could not be final since it&#39;s modified in {@link #readResolve()}
&nbsp;     */
&nbsp;    private /*final*/ String remote;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link FilePath} that represents a path on the given node.
&nbsp;     *
&nbsp;     * @param channel
&nbsp;     *      To create a path that represents a remote path, pass in a {@link Channel}
&nbsp;     *      that&#39;s connected to that machine. If {@code null}, that means the local file path.
&nbsp;     */
<b class="fc">&nbsp;    public FilePath(@CheckForNull VirtualChannel channel, @NonNull String remote) {</b>
<b class="fc">&nbsp;        this.channel = channel instanceof LocalChannel ? null : channel;</b>
<b class="fc">&nbsp;        this.remote = normalize(remote);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * To create {@link FilePath} that represents a &quot;local&quot; path.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * A &quot;local&quot; path means a file path on the computer where the
&nbsp;     * constructor invocation happened.
&nbsp;     */
<b class="fc">&nbsp;    public FilePath(@NonNull File localPath) {</b>
<b class="fc">&nbsp;        this.channel = null;</b>
<b class="fc">&nbsp;        this.remote = normalize(localPath.getPath());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Construct a path starting with a base location.
&nbsp;     * @param base starting point for resolution, and defines channel
&nbsp;     * @param rel a path that when relative will be resolved against base
&nbsp;     */
<b class="fc">&nbsp;    public FilePath(@NonNull FilePath base, @NonNull String rel) {</b>
<b class="fc">&nbsp;        this.channel = base.channel;</b>
<b class="fc">&nbsp;        this.remote = normalize(resolvePathIfRelative(base, rel));</b>
&nbsp;    }
&nbsp;
&nbsp;    private Object readResolve() {
<b class="fc">&nbsp;        this.remote = normalize(this.remote);</b>
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String resolvePathIfRelative(@NonNull FilePath base, @NonNull String rel) {
<b class="fc">&nbsp;        if (isAbsolute(rel)) return rel;</b>
<b class="fc">&nbsp;        if (base.isUnix()) {</b>
&nbsp;            // shouldn&#39;t need this replace, but better safe than sorry
<b class="fc">&nbsp;            return base.remote + &#39;/&#39; + rel.replace(&#39;\\&#39;, &#39;/&#39;);</b>
&nbsp;        } else {
&nbsp;            // need this replace, see Slave.getWorkspaceFor and AbstractItem.getFullName, nested jobs on Windows
&nbsp;            // agents will always have a rel containing at least one &#39;/&#39; character. JENKINS-13649
<b class="fc">&nbsp;            return base.remote + &#39;\\&#39; + rel.replace(&#39;/&#39;, &#39;\\&#39;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is the given path name an absolute path?
&nbsp;     */
&nbsp;    private static boolean isAbsolute(@NonNull String rel) {
<b class="fc">&nbsp;        return rel.startsWith(&quot;/&quot;) || DRIVE_PATTERN.matcher(rel).matches() || UNC_PATTERN.matcher(rel).matches();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final Pattern DRIVE_PATTERN = Pattern.compile(&quot;[A-Za-z]:[\\\\/].*&quot;),</b>
<b class="fc">&nbsp;            UNC_PATTERN = Pattern.compile(&quot;^\\\\\\\\.*&quot;),</b>
<b class="fc">&nbsp;            ABSOLUTE_PREFIX_PATTERN = Pattern.compile(&quot;^(\\\\\\\\|(?:[A-Za-z]:)?[\\\\/])[\\\\/]*&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link File#getParent()} etc cannot handle &quot;..&quot; and &quot;.&quot; in the path component very well,
&nbsp;     * so remove them.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static String normalize(@NonNull String path) {
<b class="fc">&nbsp;        StringBuilder buf = new StringBuilder();</b>
&nbsp;        // Check for prefix designating absolute path
<b class="fc">&nbsp;        Matcher m = ABSOLUTE_PREFIX_PATTERN.matcher(path);</b>
<b class="fc">&nbsp;        if (m.find()) {</b>
<b class="fc">&nbsp;            buf.append(m.group(1));</b>
<b class="fc">&nbsp;            path = path.substring(m.end());</b>
&nbsp;        }
<b class="fc">&nbsp;        boolean isAbsolute = buf.length() &gt; 0;</b>
&nbsp;        // Split remaining path into tokens, trimming any duplicate or trailing separators
<b class="fc">&nbsp;        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        int s = 0, end = path.length();</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; end; i++) {</b>
<b class="fc">&nbsp;            char c = path.charAt(i);</b>
<b class="fc">&nbsp;            if (c == &#39;/&#39; || c == &#39;\\&#39;) {</b>
<b class="fc">&nbsp;                tokens.add(path.substring(s, i));</b>
<b class="fc">&nbsp;                s = i;</b>
&nbsp;                // Skip any extra separator chars
&nbsp;                //noinspection StatementWithEmptyBody
<b class="fc">&nbsp;                while (++i &lt; end &amp;&amp; ((c = path.charAt(i)) == &#39;/&#39; || c == &#39;\\&#39;))</b>
<b class="fc">&nbsp;                    ;</b>
&nbsp;                // Add token for separator unless we reached the end
<b class="fc">&nbsp;                if (i &lt; end) tokens.add(path.substring(s, s + 1));</b>
<b class="fc">&nbsp;                s = i;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (s &lt; end) tokens.add(path.substring(s));</b>
&nbsp;        // Look through tokens for &quot;.&quot; or &quot;..&quot;
<b class="fc">&nbsp;        for (int i = 0; i &lt; tokens.size();) {</b>
<b class="fc">&nbsp;            String token = tokens.get(i);</b>
<b class="fc">&nbsp;            if (token.equals(&quot;.&quot;)) {</b>
<b class="fc">&nbsp;                tokens.remove(i);</b>
<b class="fc">&nbsp;                if (tokens.size() &gt; 0)</b>
<b class="fc">&nbsp;                    tokens.remove(i &gt; 0 ? i - 1 : i);</b>
<b class="fc">&nbsp;            } else if (token.equals(&quot;..&quot;)) {</b>
<b class="fc">&nbsp;                if (i == 0) {</b>
&nbsp;                    // If absolute path, just remove: /../something
&nbsp;                    // If relative path, not collapsible so leave as-is
<b class="fc">&nbsp;                    tokens.remove(0);</b>
<b class="fc">&nbsp;                    if (tokens.size() &gt; 0) token += tokens.remove(0);</b>
<b class="fc">&nbsp;                    if (!isAbsolute) buf.append(token);</b>
&nbsp;                } else {
&nbsp;                    // Normalize: remove something/.. plus separator before/after
<b class="fc">&nbsp;                    i -= 2;</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; 3; j++) tokens.remove(i);</b>
<b class="fc">&nbsp;                    if (i &gt; 0) tokens.remove(i - 1);</b>
<b class="fc">&nbsp;                    else if (tokens.size() &gt; 0) tokens.remove(0);</b>
&nbsp;                }
&nbsp;            } else
<b class="fc">&nbsp;                i += 2;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;        // Recombine tokens
<b class="fc">&nbsp;        for (String token : tokens) buf.append(token);</b>
<b class="fc">&nbsp;        if (buf.length() == 0) buf.append(&#39;.&#39;);</b>
<b class="fc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the remote path is Unix.
&nbsp;     */
&nbsp;    boolean isUnix() {
&nbsp;        // if the path represents a local path, there&#39;s no need to guess.
<b class="fc">&nbsp;        if (!isRemote())</b>
<b class="fc">&nbsp;            return File.pathSeparatorChar != &#39;;&#39;;</b>
&nbsp;
&nbsp;        // note that we can&#39;t use the usual File.pathSeparator etc., as the OS of
&nbsp;        // the machine where this code runs and the OS that this FilePath refers to may be different.
&nbsp;
&nbsp;        // Windows absolute path is &#39;X:\...&#39;, so this is usually a good indication of Windows path
<b class="fc">&nbsp;        if (remote.length() &gt; 3 &amp;&amp; remote.charAt(1) == &#39;:&#39; &amp;&amp; remote.charAt(2) == &#39;\\&#39;)</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        // Windows can handle &#39;/&#39; as a path separator but Unix can&#39;t,
&nbsp;        // so err on Unix side
<b class="fc">&nbsp;        return !remote.contains(&quot;\\&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the full path of the file on the remote machine.
&nbsp;     *
&nbsp;     */
&nbsp;    public String getRemote() {
<b class="fc">&nbsp;        return remote;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a zip file from this directory or a file and sends that to the given output stream.
&nbsp;     *
&nbsp;     * @deprecated as of 1.315. Use {@link #zip(OutputStream)} that has more consistent name.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void createZipArchive(OutputStream os) throws IOException, InterruptedException {
<b class="nc">&nbsp;        zip(os);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a zip file from this directory or a file and sends that to the given output stream.
&nbsp;     */
&nbsp;    public void zip(OutputStream os) throws IOException, InterruptedException {
<b class="fc">&nbsp;        zip(os, (FileFilter) null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void zip(FilePath dst) throws IOException, InterruptedException {
<b class="nc">&nbsp;        try (OutputStream os = dst.write()) {</b>
<b class="nc">&nbsp;            zip(os);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a zip file from this directory by using the specified filter,
&nbsp;     * and sends the result to the given output stream.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *      Must be serializable since it may be executed remotely. Can be null to add all files.
&nbsp;     *
&nbsp;     * @since 1.315
&nbsp;     */
&nbsp;    public void zip(OutputStream os, FileFilter filter) throws IOException, InterruptedException {
<b class="fc">&nbsp;        archive(ArchiverFactory.ZIP, os, filter);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a zip file from this directory by only including the files that match the given glob.
&nbsp;     *
&nbsp;     * @param glob
&nbsp;     *      Ant style glob, like &quot;**&amp;#x2F;*.xml&quot;. If empty or null, this method
&nbsp;     *      works like {@link #createZipArchive(OutputStream)}
&nbsp;     *
&nbsp;     * @since 1.129
&nbsp;     * @deprecated as of 1.315
&nbsp;     *      Use {@link #zip(OutputStream,String)} that has more consistent name.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void createZipArchive(OutputStream os, final String glob) throws IOException, InterruptedException {
<b class="nc">&nbsp;        archive(ArchiverFactory.ZIP, os, glob);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a zip file from this directory by only including the files that match the given glob.
&nbsp;     *
&nbsp;     * @param glob
&nbsp;     *      Ant style glob, like &quot;**&amp;#x2F;*.xml&quot;. If empty or null, this method
&nbsp;     *      works like {@link #createZipArchive(OutputStream)}, inserting a top-level directory into the ZIP.
&nbsp;     *
&nbsp;     * @since 1.315
&nbsp;     */
&nbsp;    public void zip(OutputStream os, final String glob) throws IOException, InterruptedException {
<b class="fc">&nbsp;        archive(ArchiverFactory.ZIP, os, glob);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Uses the given scanner on &#39;this&#39; directory to list up files and then archive it to a zip stream.
&nbsp;     */
&nbsp;    public int zip(OutputStream out, DirScanner scanner) throws IOException, InterruptedException {
<b class="nc">&nbsp;        return archive(ArchiverFactory.ZIP, out, scanner);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Uses the given scanner on &#39;this&#39; directory to list up files and then archive it to a zip stream.
&nbsp;     *
&nbsp;     * @param out The OutputStream to write the zip into.
&nbsp;     * @param scanner A DirScanner for scanning the directory and filtering its contents.
&nbsp;     * @param verificationRoot A root or base directory for checking for any symlinks in this files parentage.
&nbsp;     *             Any symlinks between a file and root should be ignored.
&nbsp;     *             Symlinks in the parentage outside root will not be checked.
&nbsp;     * @param prefix The portion of file path that will be added at the beginning of the relative path inside the archive.
&nbsp;     *               If non-empty, a trailing forward slash will be enforced.
&nbsp;     * @param openOptions the options to apply when opening.
&nbsp;     * @return The number of files/directories archived.
&nbsp;     *          This is only really useful to check for a situation where nothing
&nbsp;     */
&nbsp;    public int zip(OutputStream out, DirScanner scanner, String verificationRoot, String prefix, OpenOption... openOptions) throws IOException, InterruptedException {
<b class="fc">&nbsp;        ArchiverFactory archiverFactory = prefix == null ? ArchiverFactory.ZIP : ArchiverFactory.createZipWithPrefix(prefix, openOptions);</b>
<b class="fc">&nbsp;        return archive(archiverFactory, out, scanner, verificationRoot, openOptions);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Archives this directory into the specified archive format, to the given {@link OutputStream}, by using
&nbsp;     * {@link DirScanner} to choose what files to include.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      number of files/directories archived. This is only really useful to check for a situation where nothing
&nbsp;     *      is archived.
&nbsp;     */
&nbsp;    public int archive(final ArchiverFactory factory, OutputStream os, final DirScanner scanner) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return archive(factory, os, scanner, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Archives this directory into the specified archive format, to the given {@link OutputStream}, by using
&nbsp;     * {@link DirScanner} to choose what files to include.
&nbsp;     *
&nbsp;     * @param factory The ArchiverFactory for creating the archive.
&nbsp;     * @param os The OutputStream to write the zip into.
&nbsp;     * @param verificationRoot A root or base directory for checking for any symlinks in this files parentage.
&nbsp;     *             Any symlinks between a file and root should be ignored.
&nbsp;     *             Symlinks in the parentage outside root will not be checked.
&nbsp;     * @param openOptions options to apply when opening.
&nbsp;     *
&nbsp;     * @return The number of files/directories archived.
&nbsp;     *          This is only really useful to check for a situation where nothing
&nbsp;     */
&nbsp;    public int archive(final ArchiverFactory factory, OutputStream os, final DirScanner scanner,
&nbsp;                       String verificationRoot, OpenOption... openOptions) throws IOException, InterruptedException {
<b class="fc">&nbsp;        final OutputStream out = channel != null ? new RemoteOutputStream(os) : os;</b>
<b class="fc">&nbsp;        return act(new Archive(factory, out, scanner, verificationRoot, openOptions));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Archive extends MasterToSlaveFileCallable&lt;Integer&gt; {
&nbsp;        private final ArchiverFactory factory;
&nbsp;        private final OutputStream out;
&nbsp;        private final DirScanner scanner;
&nbsp;        private final String verificationRoot;
&nbsp;        private OpenOption[] openOptions;
&nbsp;
<b class="fc">&nbsp;        Archive(ArchiverFactory factory, OutputStream out, DirScanner scanner, String verificationRoot, OpenOption... openOptions) {</b>
<b class="fc">&nbsp;            this.factory = factory;</b>
<b class="fc">&nbsp;            this.out = out;</b>
<b class="fc">&nbsp;            this.scanner = scanner;</b>
<b class="fc">&nbsp;            this.verificationRoot = verificationRoot;</b>
<b class="fc">&nbsp;            this.openOptions = openOptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;            public Integer invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;                try (Archiver a = factory.create(out)) {</b>
<b class="fc">&nbsp;                    scanner.scan(f, ignoringTmpDirs(ignoringSymlinks(a, verificationRoot, openOptions), verificationRoot, openOptions));</b>
<b class="fc">&nbsp;                    return a.countEntries();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    public int archive(final ArchiverFactory factory, OutputStream os, final FileFilter filter) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return archive(factory, os, new DirScanner.Filter(filter));</b>
&nbsp;    }
&nbsp;
&nbsp;    public int archive(final ArchiverFactory factory, OutputStream os, final String glob) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return archive(factory, os, new DirScanner.Glob(glob, null));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When this {@link FilePath} represents a zip file, extracts that zip file.
&nbsp;     *
&nbsp;     * @param target
&nbsp;     *      Target directory to expand files to. All the necessary directories will be created.
&nbsp;     * @since 1.248
&nbsp;     * @see #unzipFrom(InputStream)
&nbsp;     */
&nbsp;    public void unzip(final FilePath target) throws IOException, InterruptedException {
&nbsp;        // TODO: post release, re-unite two branches by introducing FileStreamCallable that resolves InputStream
<b class="fc">&nbsp;        if (channel != target.channel) { // local -&gt; remote or remote-&gt;local</b>
<b class="nc">&nbsp;            final RemoteInputStream in = new RemoteInputStream(read(), Flag.GREEDY);</b>
<b class="nc">&nbsp;            target.act(new UnzipRemote(in));</b>
<b class="nc">&nbsp;        } else { // local -&gt; local or remote-&gt;remote</b>
<b class="fc">&nbsp;            target.act(new UnzipLocal(this));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class UnzipRemote extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final RemoteInputStream in;
&nbsp;
<b class="nc">&nbsp;        UnzipRemote(RemoteInputStream in) {</b>
<b class="nc">&nbsp;            this.in = in;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File dir, VirtualChannel channel) throws IOException, InterruptedException {
<b class="nc">&nbsp;            unzip(dir, in);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    private static class UnzipLocal extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;
&nbsp;        private final FilePath filePath;
&nbsp;
<b class="fc">&nbsp;        private UnzipLocal(FilePath filePath) {</b>
<b class="fc">&nbsp;            this.filePath = filePath;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File dir, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            if (this.filePath.isRemote()) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Expected local path for file: &quot; + filePath); // this.channel==target.channel above</b>
&nbsp;            }
<b class="fc">&nbsp;            unzip(dir, new File(this.filePath.getRemote())); // shortcut to local file</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When this {@link FilePath} represents a tar file, extracts that tar file.
&nbsp;     *
&nbsp;     * @param target
&nbsp;     *      Target directory to expand files to. All the necessary directories will be created.
&nbsp;     * @param compression
&nbsp;     *      Compression mode of this tar file.
&nbsp;     * @since 1.292
&nbsp;     * @see #untarFrom(InputStream, TarCompression)
&nbsp;     */
&nbsp;    public void untar(final FilePath target, final TarCompression compression) throws IOException, InterruptedException {
<b class="fc">&nbsp;        final FilePath source = FilePath.this;</b>
&nbsp;        // TODO: post release, re-unite two branches by introducing FileStreamCallable that resolves InputStream
<b class="fc">&nbsp;        if (source.channel != target.channel) { // local -&gt; remote or remote-&gt;local</b>
<b class="nc">&nbsp;            final RemoteInputStream in = new RemoteInputStream(source.read(), Flag.GREEDY);</b>
<b class="nc">&nbsp;            target.act(new UntarRemote(source.getName(), compression, in));</b>
<b class="nc">&nbsp;        } else { // local -&gt; local or remote-&gt;remote</b>
<b class="fc">&nbsp;            target.act(new UntarLocal(source, compression));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class UntarRemote extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final TarCompression compression;
&nbsp;        private final RemoteInputStream in;
&nbsp;        private final String name;
&nbsp;
<b class="nc">&nbsp;        UntarRemote(String name, TarCompression compression, RemoteInputStream in) {</b>
<b class="nc">&nbsp;            this.compression = compression;</b>
<b class="nc">&nbsp;            this.in = in;</b>
<b class="nc">&nbsp;            this.name = name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File dir, VirtualChannel channel) throws IOException, InterruptedException {
<b class="nc">&nbsp;            readFromTar(name, dir, compression.extract(in));</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    private static class UntarLocal extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final TarCompression compression;
&nbsp;        private final FilePath filePath;
&nbsp;
<b class="fc">&nbsp;        UntarLocal(FilePath source, TarCompression compression) {</b>
<b class="fc">&nbsp;            this.filePath = source;</b>
<b class="fc">&nbsp;            this.compression = compression;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File dir, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            readFromTar(this.filePath.getName(), dir, compression.extract(this.filePath.read()));</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads the given InputStream as a zip file and extracts it into this directory.
&nbsp;     *
&nbsp;     * @param _in
&nbsp;     *      The stream will be closed by this method after it&#39;s fully read.
&nbsp;     * @since 1.283
&nbsp;     * @see #unzip(FilePath)
&nbsp;     */
&nbsp;    public void unzipFrom(InputStream _in) throws IOException, InterruptedException {
<b class="fc">&nbsp;        final InputStream in = new RemoteInputStream(_in, Flag.GREEDY);</b>
<b class="fc">&nbsp;        act(new UnzipFrom(in));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class UnzipFrom extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final InputStream in;
&nbsp;
<b class="fc">&nbsp;        UnzipFrom(InputStream in) {</b>
<b class="fc">&nbsp;            this.in = in;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File dir, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            unzip(dir, in);</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    private static void unzip(File dir, InputStream in) throws IOException {
<b class="fc">&nbsp;        File tmpFile = File.createTempFile(&quot;tmpzip&quot;, null); // uses java.io.tmpdir</b>
&nbsp;        try {
&nbsp;            // TODO why does this not simply use ZipInputStream?
<b class="fc">&nbsp;            IOUtils.copy(in, tmpFile);</b>
<b class="fc">&nbsp;            unzip(dir, tmpFile);</b>
&nbsp;        }
&nbsp;        finally {
<b class="fc">&nbsp;            Files.delete(Util.fileToPath(tmpFile));</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void unzip(File dir, File zipFile) throws IOException {
<b class="fc">&nbsp;        dir = dir.getAbsoluteFile();    // without absolutization, getParentFile below seems to fail</b>
&nbsp;
<b class="fc">&nbsp;        try (ZipFile zip = new ZipFile(zipFile)) {</b>
<b class="fc">&nbsp;            Enumeration&lt;ZipEntry&gt; entries = zip.getEntries();</b>
<b class="fc">&nbsp;            while (entries.hasMoreElements()) {</b>
<b class="fc">&nbsp;                ZipEntry e = entries.nextElement();</b>
<b class="fc">&nbsp;                File f = new File(dir, e.getName());</b>
<b class="fc">&nbsp;                if (!f.getCanonicalFile().toPath().startsWith(dir.getCanonicalPath())) {</b>
<b class="nc">&nbsp;                    throw new IOException(</b>
<b class="nc">&nbsp;                        &quot;Zip &quot; + zipFile.getPath() + &quot; contains illegal file name that breaks out of the target directory: &quot; + e.getName());</b>
&nbsp;                }
<b class="fc">&nbsp;                if (e.isDirectory()) {</b>
<b class="fc">&nbsp;                    mkdirs(f);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    File p = f.getParentFile();</b>
<b class="fc">&nbsp;                    if (p != null) {</b>
<b class="fc">&nbsp;                        mkdirs(p);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    try (InputStream input = zip.getInputStream(e)) {</b>
<b class="fc">&nbsp;                        IOUtils.copy(input, f);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        FilePath target = new FilePath(f);</b>
<b class="fc">&nbsp;                        int mode = e.getUnixMode();</b>
<b class="fc">&nbsp;                        if (mode != 0)    // Ant returns 0 if the archive doesn&#39;t record the access mode</b>
<b class="fc">&nbsp;                            target.chmod(mode);</b>
<b class="nc">&nbsp;                    } catch (InterruptedException ex) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, &quot;unable to set permissions&quot;, ex);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    Files.setLastModifiedTime(Util.fileToPath(f), e.getLastModifiedTime());</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Absolutizes this {@link FilePath} and returns the new one.
&nbsp;     */
&nbsp;    public FilePath absolutize() throws IOException, InterruptedException {
<b class="nc">&nbsp;        return new FilePath(channel, act(new Absolutize()));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class Absolutize extends MasterToSlaveFileCallable&lt;String&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            return f.getAbsolutePath();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasSymlink(FilePath verificationRoot, OpenOption... openOptions) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new HasSymlink(verificationRoot == null ? null : verificationRoot.remote, openOptions));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class HasSymlink extends MasterToSlaveFileCallable&lt;Boolean&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final String verificationRoot;
&nbsp;        private OpenOption[] openOptions;
&nbsp;
<b class="fc">&nbsp;        HasSymlink(String verificationRoot, OpenOption... openOptions) {</b>
<b class="fc">&nbsp;            this.verificationRoot = verificationRoot;</b>
<b class="fc">&nbsp;            this.openOptions = openOptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            return isSymlink(f, verificationRoot, openOptions);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public boolean containsSymlink(FilePath verificationRoot, OpenOption... openOptions) throws IOException, InterruptedException {
<b class="nc">&nbsp;        return !list(new SymlinkRetainingFileFilter(verificationRoot, openOptions)).isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class SymlinkRetainingFileFilter implements FileFilter, Serializable {
&nbsp;
&nbsp;        private final String verificationRoot;
&nbsp;        private OpenOption[] openOptions;
&nbsp;
<b class="nc">&nbsp;        SymlinkRetainingFileFilter(FilePath verificationRoot, OpenOption... openOptions) {</b>
<b class="nc">&nbsp;            this.verificationRoot = verificationRoot == null ? null : verificationRoot.remote;</b>
<b class="nc">&nbsp;            this.openOptions = openOptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean accept(File file) {
<b class="nc">&nbsp;            return isSymlink(file, verificationRoot, openOptions);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a symlink to the specified target.
&nbsp;     *
&nbsp;     * @param target
&nbsp;     *      The file that the symlink should point to.
&nbsp;     * @param listener
&nbsp;     *      If symlink creation requires a help of an external process, the error will be reported here.
&nbsp;     * @since 1.456
&nbsp;     */
&nbsp;    public void symlinkTo(final String target, final TaskListener listener) throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new SymlinkTo(target, listener));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class SymlinkTo extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final String target;
&nbsp;        private final TaskListener listener;
&nbsp;
<b class="fc">&nbsp;        SymlinkTo(String target, TaskListener listener) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
<b class="fc">&nbsp;            this.listener = listener;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            Util.createSymlink(f.getParentFile(), target, f.getName(), listener);</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves symlink, if the given file is a symlink. Otherwise, return null.
&nbsp;     * &lt;p&gt;
&nbsp;     * If the resolution fails, report an error.
&nbsp;     *
&nbsp;     * @since 1.456
&nbsp;     */
&nbsp;    public String readLink() throws IOException, InterruptedException {
<b class="nc">&nbsp;        return act(new ReadLink());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class ReadLink extends MasterToSlaveFileCallable&lt;String&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="nc">&nbsp;            return Util.resolveSymlink(f);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="fc">&nbsp;        if (this == o) return true;</b>
<b class="fc">&nbsp;        if (o == null || getClass() != o.getClass()) return false;</b>
&nbsp;
<b class="fc">&nbsp;        FilePath that = (FilePath) o;</b>
&nbsp;
<b class="fc">&nbsp;        if (!Objects.equals(channel, that.channel)) return false;</b>
<b class="fc">&nbsp;        return remote.equals(that.remote);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;        return 31 * (channel != null ? channel.hashCode() : 0) + remote.hashCode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Supported tar file compression methods.
&nbsp;     */
<b class="fc">&nbsp;    public enum TarCompression {</b>
<b class="fc">&nbsp;        NONE {</b>
&nbsp;            @Override
&nbsp;            public InputStream extract(InputStream in) {
<b class="fc">&nbsp;                return new BufferedInputStream(in);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public OutputStream compress(OutputStream out) {
<b class="fc">&nbsp;                return new BufferedOutputStream(out);</b>
&nbsp;            }
&nbsp;        },
<b class="fc">&nbsp;        GZIP {</b>
&nbsp;            @Override
&nbsp;            public InputStream extract(InputStream _in) throws IOException {
<b class="fc">&nbsp;                HeadBufferingStream in = new HeadBufferingStream(_in, SIDE_BUFFER_SIZE);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new GZIPInputStream(in, 8192, true);</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // various people reported &quot;java.io.IOException: Not in GZIP format&quot; here, so diagnose this problem better
<b class="nc">&nbsp;                    in.fillSide();</b>
<b class="nc">&nbsp;                    throw new IOException(e.getMessage() + &quot;\nstream=&quot; + Util.toHexString(in.getSideBuffer()), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public OutputStream compress(OutputStream out) throws IOException {
<b class="fc">&nbsp;                return new GZIPOutputStream(new BufferedOutputStream(out));</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        public abstract InputStream extract(InputStream in) throws IOException;
&nbsp;
&nbsp;        public abstract OutputStream compress(OutputStream in) throws IOException;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads the given InputStream as a tar file and extracts it into this directory.
&nbsp;     *
&nbsp;     * @param _in
&nbsp;     *      The stream will be closed by this method after it&#39;s fully read.
&nbsp;     * @param compression
&nbsp;     *      The compression method in use.
&nbsp;     * @since 1.292
&nbsp;     */
&nbsp;    public void untarFrom(InputStream _in, final TarCompression compression) throws IOException, InterruptedException {
<b class="nc">&nbsp;        try (_in) {</b>
<b class="nc">&nbsp;            final InputStream in = new RemoteInputStream(_in, Flag.GREEDY);</b>
<b class="nc">&nbsp;            act(new UntarFrom(compression, in));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class UntarFrom extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final TarCompression compression;
&nbsp;        private final InputStream in;
&nbsp;
<b class="nc">&nbsp;        UntarFrom(TarCompression compression, InputStream in) {</b>
<b class="nc">&nbsp;            this.compression = compression;</b>
<b class="nc">&nbsp;            this.in = in;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File dir, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            readFromTar(&quot;input stream&quot;, dir, compression.extract(in));</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Given a tgz/zip file, extracts it to the given target directory, if necessary.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is a convenience method designed for installing a binary package to a location
&nbsp;     * that supports upgrade and downgrade. Specifically,
&nbsp;     *
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;If the target directory doesn&#39;t exist {@linkplain #mkdirs() it will be created}.
&nbsp;     * &lt;li&gt;The timestamp of the archive is left in the installation directory upon extraction.
&nbsp;     * &lt;li&gt;If the timestamp left in the directory does not match the timestamp of the current archive file,
&nbsp;     *     the directory contents will be discarded and the archive file will be re-extracted.
&nbsp;     * &lt;li&gt;If the connection is refused but the target directory already exists, it is left alone.
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * @param archive
&nbsp;     *      The resource that represents the tgz/zip file. This URL must support the {@code Last-Modified} header or the {@code ETag} header.
&nbsp;     *      (For example, you could use {@link ClassLoader#getResource}.)
&nbsp;     * @param listener
&nbsp;     *      If non-null, a message will be printed to this listener once this method decides to
&nbsp;     *      extract an archive, or if there is any issue.
&nbsp;     * @param message a message to be printed in case extraction will proceed.
&nbsp;     * @return
&nbsp;     *      true if the archive was extracted. false if the extraction was skipped because the target directory
&nbsp;     *      was considered up to date.
&nbsp;     * @since 1.299
&nbsp;     */
&nbsp;    public boolean installIfNecessaryFrom(@NonNull URL archive, @CheckForNull TaskListener listener, @NonNull String message) throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (listener == null) {</b>
<b class="fc">&nbsp;            listener = TaskListener.NULL;</b>
&nbsp;        }
<b class="fc">&nbsp;        return installIfNecessaryFrom(archive, listener, message, MAX_REDIRECTS);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean installIfNecessaryFrom(@NonNull URL archive, @NonNull TaskListener listener, @NonNull String message, int maxRedirects) throws InterruptedException, IOException {
&nbsp;        try {
<b class="fc">&nbsp;            FilePath timestamp = this.child(&quot;.timestamp&quot;);</b>
<b class="fc">&nbsp;            long lastModified = timestamp.lastModified();</b>
&nbsp;            // https://httpwg.org/specs/rfc9110.html#field.etag is the ETag specification
&nbsp;            // Read previously stored ETag if timestamp is available
<b class="fc">&nbsp;            String etag = timestamp.exists() ? fixEmptyAndTrim(timestamp.readToString()) : null;</b>
&nbsp;            URLConnection con;
&nbsp;            try {
<b class="fc">&nbsp;                con = ProxyConfiguration.open(archive);</b>
<b class="fc">&nbsp;                if (lastModified != 0) {</b>
<b class="fc">&nbsp;                    con.setIfModifiedSince(lastModified);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (etag != null) {</b>
<b class="fc">&nbsp;                    con.setRequestProperty(&quot;If-None-Match&quot;, etag);</b>
&nbsp;                }
<b class="fc">&nbsp;                con.connect();</b>
<b class="nc">&nbsp;            } catch (IOException x) {</b>
<b class="nc">&nbsp;                if (this.exists()) {</b>
&nbsp;                    // Cannot connect now, so assume whatever was last unpacked is still OK.
<b class="nc">&nbsp;                    listener.getLogger().println(&quot;Skipping installation of &quot; + archive + &quot; to &quot; + remote + &quot;: &quot; + x);</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw x;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            if (con instanceof HttpURLConnection) {</b>
<b class="fc">&nbsp;                HttpURLConnection httpCon = (HttpURLConnection) con;</b>
<b class="fc">&nbsp;                int responseCode = httpCon.getResponseCode();</b>
<b class="fc">&nbsp;                if (responseCode == HttpURLConnection.HTTP_MOVED_PERM</b>
&nbsp;                        || responseCode == HttpURLConnection.HTTP_MOVED_TEMP) {
&nbsp;                    // follows redirect
<b class="fc">&nbsp;                    if (maxRedirects &gt; 0) {</b>
<b class="fc">&nbsp;                        String location = httpCon.getHeaderField(&quot;Location&quot;);</b>
<b class="fc">&nbsp;                        listener.getLogger().println(&quot;Following redirect &quot; + archive.toExternalForm() + &quot; -&gt; &quot; + location);</b>
<b class="fc">&nbsp;                        return installIfNecessaryFrom(getUrlFactory().newURL(location), listener, message, maxRedirects - 1);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        listener.getLogger().println(&quot;Skipping installation of &quot; + archive + &quot; to &quot; + remote + &quot; due to too many redirects.&quot;);</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                if (lastModified != 0 || etag != null) {</b>
<b class="fc">&nbsp;                    if (responseCode == HttpURLConnection.HTTP_NOT_MODIFIED) {</b>
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (responseCode != HttpURLConnection.HTTP_OK) {</b>
<b class="fc">&nbsp;                        listener.getLogger().println(&quot;Skipping installation of &quot; + archive + &quot; to &quot; + remote + &quot; due to server error: &quot; + responseCode + &quot; &quot; + httpCon.getResponseMessage());</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            long sourceTimestamp = con.getLastModified();</b>
<b class="fc">&nbsp;            String resultEtag = fixEmptyAndTrim(con.getHeaderField(&quot;ETag&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            if (this.exists()) {</b>
<b class="fc">&nbsp;                if (equalETags(etag, resultEtag)) {</b>
<b class="fc">&nbsp;                    return false;   // already up to date</b>
&nbsp;                }
<b class="fc">&nbsp;                if (lastModified != 0 &amp;&amp; sourceTimestamp == lastModified)</b>
<b class="nc">&nbsp;                    return false;   // already up to date</b>
<b class="fc">&nbsp;                this.deleteContents();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                this.mkdirs();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            listener.getLogger().println(message);</b>
&nbsp;
<b class="fc">&nbsp;            if (isRemote()) {</b>
&nbsp;                // First try to download from the agent machine.
&nbsp;                try {
<b class="nc">&nbsp;                    act(new Unpack(archive));</b>
<b class="nc">&nbsp;                    if (resultEtag != null &amp;&amp; !equalETags(etag, resultEtag)) {</b>
&nbsp;                        /* Store the ETag value in the timestamp file for later use */
<b class="nc">&nbsp;                        timestamp.write(resultEtag, &quot;UTF-8&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    timestamp.touch(sourceTimestamp);</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } catch (IOException x) {</b>
<b class="nc">&nbsp;                    Functions.printStackTrace(x, listener.error(&quot;Failed to download &quot; + archive + &quot; from agent; will retry from controller&quot;));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // for HTTP downloads, enable automatic retry for added resilience
<b class="fc">&nbsp;            InputStream in = archive.getProtocol().startsWith(&quot;http&quot;) ? ProxyConfiguration.getInputStream(archive) : con.getInputStream();</b>
<b class="fc">&nbsp;            CountingInputStream cis = new CountingInputStream(in);</b>
&nbsp;            try {
<b class="fc">&nbsp;                if (archive.toExternalForm().endsWith(&quot;.zip&quot;))</b>
<b class="fc">&nbsp;                    unzipFrom(cis);</b>
&nbsp;                else
<b class="nc">&nbsp;                    untarFrom(cis, TarCompression.GZIP);</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                throw new IOException(String.format(&quot;Failed to unpack %s (%d bytes read of total %d)&quot;,</b>
<b class="nc">&nbsp;                        archive, cis.getByteCount(), con.getContentLength()), e);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (resultEtag != null &amp;&amp; !equalETags(etag, resultEtag)) {</b>
&nbsp;                /* Store the ETag value in the timestamp file for later use */
<b class="fc">&nbsp;                timestamp.write(resultEtag, &quot;UTF-8&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            timestamp.touch(sourceTimestamp);</b>
<b class="fc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to install &quot; + archive + &quot; to &quot; + remote, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /* Return true if etag1 equals etag2 as defined by the etag specification
&nbsp;       https://httpwg.org/specs/rfc9110.html#field.etag
&nbsp;     */
&nbsp;    private boolean equalETags(String etag1, String etag2) {
<b class="fc">&nbsp;        if (etag1 == null || etag2 == null) {</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (etag1.equals(etag2)) {</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        /* Weak tags are identified by leading characters &quot;W/&quot; as a marker */
&nbsp;        /* Weak tag marker must not be considered in tag comparison.
&nbsp;           This implements the weak comparison in the specification at
&nbsp;           https://httpwg.org/specs/rfc9110.html#field.etag */
<b class="fc">&nbsp;        String opaqueTag1 = etag1.startsWith(&quot;W/&quot;) ? etag1.substring(2) : etag1;</b>
<b class="fc">&nbsp;        String opaqueTag2 = etag2.startsWith(&quot;W/&quot;) ? etag2.substring(2) : etag2;</b>
<b class="fc">&nbsp;        return opaqueTag1.equals(opaqueTag2);</b>
&nbsp;    }
&nbsp;
&nbsp;    // this reads from arbitrary URL
&nbsp;    private static final class Unpack extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final URL archive;
&nbsp;
<b class="nc">&nbsp;        Unpack(URL archive) {</b>
<b class="nc">&nbsp;            this.archive = archive;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override public Void invoke(File dir, VirtualChannel channel) throws IOException, InterruptedException {
<b class="nc">&nbsp;            try (InputStream in = archive.openStream()) {</b>
<b class="nc">&nbsp;                CountingInputStream cis = new CountingInputStream(in);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (archive.toExternalForm().endsWith(&quot;.zip&quot;)) {</b>
<b class="nc">&nbsp;                        unzip(dir, cis);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        readFromTar(&quot;input stream&quot;, dir, TarCompression.GZIP.extract(cis));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IOException x) {</b>
<b class="nc">&nbsp;                    throw new IOException(String.format(&quot;Failed to unpack %s (%d bytes read)&quot;, archive, cis.getByteCount()), x);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads the URL on the current VM, and streams the data to this file using the Remoting channel.
&nbsp;     * &lt;p&gt;This is different from resolving URL remotely.
&nbsp;     * If you instead wished to open an HTTP(S) URL on the remote side,
&nbsp;     * prefer &lt;a href=&quot;http://javadoc.jenkins.io/plugin/apache-httpcomponents-client-4-api/io/jenkins/plugins/httpclient/RobustHTTPClient.html#copyFromRemotely-hudson.FilePath-java.net.URL-hudson.model.TaskListener-&quot;&gt;{@code RobustHTTPClient.copyFromRemotely}&lt;/a&gt;.
&nbsp;     * @since 1.293
&nbsp;     */
&nbsp;    public void copyFrom(URL url) throws IOException, InterruptedException {
<b class="nc">&nbsp;        try (InputStream in = url.openStream()) {</b>
<b class="nc">&nbsp;            copyFrom(in);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Replaces the content of this file by the data from the given {@link InputStream}.
&nbsp;     *
&nbsp;     * @since 1.293
&nbsp;     */
&nbsp;    public void copyFrom(InputStream in) throws IOException, InterruptedException {
<b class="nc">&nbsp;        try (OutputStream os = write()) {</b>
<b class="nc">&nbsp;            org.apache.commons.io.IOUtils.copy(in, os);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method to call {@link FilePath#copyTo(FilePath)}.
&nbsp;     *
&nbsp;     * @since 1.311
&nbsp;     */
&nbsp;    public void copyFrom(FilePath src) throws IOException, InterruptedException {
<b class="nc">&nbsp;        src.copyTo(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Place the data from {@link FileItem} into the file location specified by this {@link FilePath} object.
&nbsp;     */
&nbsp;    public void copyFrom(FileItem file) throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                file.write(new File(remote));</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                throw new IOException(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
<b class="nc">&nbsp;            try (InputStream i = file.getInputStream();</b>
<b class="nc">&nbsp;                 OutputStream o = write()) {</b>
<b class="nc">&nbsp;                org.apache.commons.io.IOUtils.copy(i, o);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Code that gets executed on the machine where the {@link FilePath} is local.
&nbsp;     * Used to act on {@link FilePath}.
&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt; implementations must be serializable, so prefer a static nested class to an inner class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Subtypes would likely want to extend from either {@link MasterToSlaveCallable}
&nbsp;     * or {@link SlaveToMasterFileCallable}.
&nbsp;     *
&nbsp;     * @see FilePath#act(FileCallable)
&nbsp;     */
&nbsp;    public interface FileCallable&lt;T&gt; extends Serializable, RoleSensitive {
&nbsp;        /**
&nbsp;         * Performs the computational task on the node where the data is located.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * All the exceptions are forwarded to the caller.
&nbsp;         *
&nbsp;         * @param f
&nbsp;         *      {@link File} that represents the local file that {@link FilePath} has represented.
&nbsp;         * @param channel
&nbsp;         *      The &quot;back pointer&quot; of the {@link Channel} that represents the communication
&nbsp;         *      with the node from where the code was sent.
&nbsp;         */
&nbsp;        T invoke(File f, VirtualChannel channel) throws IOException, InterruptedException;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes some program on the machine that this {@link FilePath} exists,
&nbsp;     * so that one can perform local file operations.
&nbsp;     */
&nbsp;    public &lt;T&gt; T act(final FileCallable&lt;T&gt; callable) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(callable, callable.getClass().getClassLoader());</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T&gt; T act(final FileCallable&lt;T&gt; callable, ClassLoader cl) throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (channel != null) {</b>
&nbsp;            // run this on a remote system
&nbsp;            try {
<b class="fc">&nbsp;                DelegatingCallable&lt;T, IOException&gt; wrapper = new FileCallableWrapper&lt;&gt;(callable, cl, this);</b>
<b class="fc">&nbsp;                for (FileCallableWrapperFactory factory : ExtensionList.lookup(FileCallableWrapperFactory.class)) {</b>
<b class="nc">&nbsp;                    wrapper = factory.wrap(wrapper);</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                return channel.call(wrapper);</b>
<b class="fc">&nbsp;            } catch (TunneledInterruptedException e) {</b>
<b class="fc">&nbsp;                throw (InterruptedException) new InterruptedException(e.getMessage()).initCause(e);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // the file is on the local machine.
<b class="fc">&nbsp;            return callable.invoke(new File(remote), localChannel);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This extension point allows to contribute a wrapper around a fileCallable so that a plugin can &quot;intercept&quot; a
&nbsp;     * call.
&nbsp;     * &lt;p&gt;The {@link #wrap(hudson.remoting.DelegatingCallable)} method itself will be executed on the controller
&nbsp;     * (and may collect contextual data if needed) and the returned wrapper will be executed on remote.
&nbsp;     *
&nbsp;     * @since 1.482
&nbsp;     * @see AbstractInterceptorCallableWrapper
&nbsp;     */
<b class="nc">&nbsp;    public abstract static class FileCallableWrapperFactory implements ExtensionPoint {</b>
&nbsp;
&nbsp;        public abstract &lt;T&gt; DelegatingCallable&lt;T, IOException&gt; wrap(DelegatingCallable&lt;T, IOException&gt; callable);
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Abstract {@link DelegatingCallable} that exposes a Before/After pattern for
&nbsp;     * {@link hudson.FilePath.FileCallableWrapperFactory} that want to implement AOP-style interceptors
&nbsp;     * @since 1.482
&nbsp;     */
&nbsp;    public abstract static class AbstractInterceptorCallableWrapper&lt;T&gt; implements DelegatingCallable&lt;T, IOException&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        private final DelegatingCallable&lt;T, IOException&gt; callable;
&nbsp;
<b class="nc">&nbsp;        protected AbstractInterceptorCallableWrapper(DelegatingCallable&lt;T, IOException&gt; callable) {</b>
<b class="nc">&nbsp;            this.callable = callable;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final ClassLoader getClassLoader() {
<b class="nc">&nbsp;            return callable.getClassLoader();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final T call() throws IOException {
<b class="nc">&nbsp;            before();</b>
&nbsp;            try {
<b class="nc">&nbsp;                return callable.call();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                after();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Executed before the actual FileCallable is invoked. This code will run on remote
&nbsp;         */
<b class="nc">&nbsp;        protected void before() {}</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Executed after the actual FileCallable is invoked (even if this one failed). This code will run on remote
&nbsp;         */
<b class="nc">&nbsp;        protected void after() {}</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Executes some program on the machine that this {@link FilePath} exists,
&nbsp;     * so that one can perform local file operations.
&nbsp;     */
&nbsp;    public &lt;T&gt; Future&lt;T&gt; actAsync(final FileCallable&lt;T&gt; callable) throws IOException, InterruptedException {
&nbsp;        try {
<b class="fc">&nbsp;            DelegatingCallable&lt;T, IOException&gt; wrapper = new FileCallableWrapper&lt;&gt;(callable, this);</b>
<b class="fc">&nbsp;            for (FileCallableWrapperFactory factory : ExtensionList.lookup(FileCallableWrapperFactory.class)) {</b>
<b class="nc">&nbsp;                wrapper = factory.wrap(wrapper);</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            return (channel != null ? channel : localChannel)</b>
<b class="fc">&nbsp;                .callAsync(wrapper);</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
&nbsp;            // wrap it into a new IOException so that we get the caller&#39;s stack trace as well.
<b class="nc">&nbsp;            throw new IOException(&quot;remote file operation failed&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes some program on the machine that this {@link FilePath} exists,
&nbsp;     * so that one can perform local file operations.
&nbsp;     */
&nbsp;    public &lt;V, E extends Throwable&gt; V act(Callable&lt;V, E&gt; callable) throws IOException, InterruptedException, E {
<b class="nc">&nbsp;        if (channel != null) {</b>
&nbsp;            // run this on a remote system
<b class="nc">&nbsp;            return channel.call(callable);</b>
&nbsp;        } else {
&nbsp;            // the file is on the local machine
<b class="nc">&nbsp;            return callable.call();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Takes a {@link FilePath}+{@link FileCallable} pair and returns the equivalent {@link Callable}.
&nbsp;     * When executing the resulting {@link Callable}, it executes {@link FileCallable#act(FileCallable)}
&nbsp;     * on this {@link FilePath}.
&nbsp;     *
&nbsp;     * @since 1.522
&nbsp;     */
&nbsp;    public &lt;V&gt; Callable&lt;V, IOException&gt; asCallableWith(final FileCallable&lt;V&gt; task) {
<b class="nc">&nbsp;        return new CallableWith&lt;&gt;(task);</b>
&nbsp;    }
&nbsp;
&nbsp;    private class CallableWith&lt;V&gt; implements Callable&lt;V, IOException&gt; {
&nbsp;        private final FileCallable&lt;V&gt; task;
&nbsp;
<b class="nc">&nbsp;        CallableWith(FileCallable&lt;V&gt; task) {</b>
<b class="nc">&nbsp;            this.task = task;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public V call() throws IOException {
&nbsp;            try {
<b class="nc">&nbsp;                return act(task);</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                throw (IOException) new InterruptedIOException().initCause(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void checkRoles(RoleChecker checker) throws SecurityException {
<b class="nc">&nbsp;            task.checkRoles(checker);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts this file to the URI, relative to the machine
&nbsp;     * on which this file is available.
&nbsp;     */
&nbsp;    public URI toURI() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new ToURI());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class ToURI extends MasterToSlaveFileCallable&lt;URI&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public URI invoke(File f, VirtualChannel channel) {
<b class="fc">&nbsp;            return f.toURI();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link VirtualFile} representation of this {@link FilePath}
&nbsp;     *
&nbsp;     * @since 1.532
&nbsp;     */
&nbsp;    public VirtualFile toVirtualFile() {
<b class="fc">&nbsp;        return VirtualFile.forFilePath(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this {@link FilePath} represents a file on a particular {@link Computer}, return it.
&nbsp;     * Otherwise null.
&nbsp;     * @since 1.571
&nbsp;     */
&nbsp;    public @CheckForNull Computer toComputer() {
<b class="nc">&nbsp;        Jenkins j = Jenkins.getInstanceOrNull();</b>
<b class="nc">&nbsp;        if (j != null) {</b>
<b class="nc">&nbsp;            for (Computer c : j.getComputers()) {</b>
<b class="nc">&nbsp;                if (getChannel() == c.getChannel()) {</b>
<b class="nc">&nbsp;                    return c;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates this directory.
&nbsp;     */
&nbsp;    public void mkdirs() throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (!act(new Mkdirs())) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to mkdirs: &quot; + remote);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class Mkdirs extends MasterToSlaveFileCallable&lt;Boolean&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            if (mkdirs(f) || f.exists())</b>
<b class="fc">&nbsp;                return true;    // OK</b>
&nbsp;
&nbsp;            // following Ant &lt;mkdir&gt; task to avoid possible race condition.
<b class="nc">&nbsp;            Thread.sleep(10);</b>
&nbsp;
<b class="nc">&nbsp;            return mkdirs(f) || f.exists();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes all suffixes recursively.
&nbsp;     * @throws IOException if it exists but could not be successfully deleted
&nbsp;     * @since 2.244
&nbsp;     */
&nbsp;    public void deleteSuffixesRecursive() throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new DeleteSuffixesRecursive());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes all suffixed directories that are separated by {@link WorkspaceList#COMBINATOR}, including all its contents recursively.
&nbsp;     */
<b class="fc">&nbsp;    private static class DeleteSuffixesRecursive extends MasterToSlaveFileCallable&lt;Void&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            for (File file : listParentFiles(f)) {</b>
<b class="fc">&nbsp;                if (file.getName().startsWith(f.getName() + WorkspaceList.COMBINATOR)) {</b>
<b class="fc">&nbsp;                    Util.deleteRecursive(file.toPath(), path -&gt; path.toFile());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static File[] listParentFiles(File f) {
<b class="fc">&nbsp;        File parentFile = f.getParentFile();</b>
<b class="fc">&nbsp;        if (parentFile != null) {</b>
<b class="fc">&nbsp;            File[] files = parentFile.listFiles();</b>
<b class="fc">&nbsp;            if (files != null) {</b>
<b class="fc">&nbsp;                return files;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new File[0];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this directory, including all its contents recursively.
&nbsp;     */
&nbsp;    public void deleteRecursive() throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new DeleteRecursive());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class DeleteRecursive extends MasterToSlaveFileCallable&lt;Void&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            Util.deleteRecursive(fileToPath(f), path -&gt; path.toFile());</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes all the contents of this directory, but not the directory itself
&nbsp;     */
&nbsp;    public void deleteContents() throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new DeleteContents());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class DeleteContents extends MasterToSlaveFileCallable&lt;Void&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            Util.deleteContentsRecursive(fileToPath(f), path -&gt; path.toFile());</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the file name portion except the extension.
&nbsp;     *
&nbsp;     * For example, &quot;foo&quot; for &quot;foo.txt&quot; and &quot;foo.tar&quot; for &quot;foo.tar.gz&quot;.
&nbsp;     */
&nbsp;    public String getBaseName() {
<b class="nc">&nbsp;        String n = getName();</b>
<b class="nc">&nbsp;        int idx = n.lastIndexOf(&#39;.&#39;);</b>
<b class="nc">&nbsp;        if (idx &lt; 0)  return n;</b>
<b class="nc">&nbsp;        return n.substring(0, idx);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Gets just the file name portion without directories.
&nbsp;     *
&nbsp;     * For example, &quot;foo.txt&quot; for &quot;../abc/foo.txt&quot;
&nbsp;     */
&nbsp;
&nbsp;    public String getName() {
<b class="fc">&nbsp;        String r = remote;</b>
<b class="fc">&nbsp;        if (r.endsWith(&quot;\\&quot;) || r.endsWith(&quot;/&quot;))</b>
<b class="nc">&nbsp;            r = r.substring(0, r.length() - 1);</b>
&nbsp;
<b class="fc">&nbsp;        int len = r.length() - 1;</b>
<b class="fc">&nbsp;        while (len &gt;= 0) {</b>
<b class="fc">&nbsp;            char ch = r.charAt(len);</b>
<b class="fc">&nbsp;            if (ch == &#39;\\&#39; || ch == &#39;/&#39;)</b>
<b class="nc">&nbsp;                break;</b>
<b class="fc">&nbsp;            len--;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        return r.substring(len + 1);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Short for {@code getParent().child(rel)}. Useful for getting other files in the same directory.
&nbsp;     * @return null if {@link #getParent} would have
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public FilePath sibling(String rel) {
<b class="nc">&nbsp;        FilePath parent = getParent();</b>
<b class="nc">&nbsp;        return parent != null ? parent.child(rel) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a {@link FilePath} by adding the given suffix to this path name.
&nbsp;     */
&nbsp;    public FilePath withSuffix(String suffix) {
<b class="fc">&nbsp;        return new FilePath(channel, remote + suffix);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The same as {@link FilePath#FilePath(FilePath,String)} but more OO.
&nbsp;     * @param relOrAbsolute a relative or absolute path
&nbsp;     * @return a file on the same channel
&nbsp;     */
&nbsp;    public @NonNull FilePath child(String relOrAbsolute) {
<b class="fc">&nbsp;        return new FilePath(this, relOrAbsolute);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the parent file.
&nbsp;     * @return parent FilePath or null if there is no parent
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public FilePath getParent() {
<b class="fc">&nbsp;        int i = remote.length() - 2;</b>
<b class="fc">&nbsp;        for (; i &gt;= 0; i--) {</b>
<b class="fc">&nbsp;            char ch = remote.charAt(i);</b>
<b class="fc">&nbsp;            if (ch == &#39;\\&#39; || ch == &#39;/&#39;)</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return i &gt;= 0 ? new FilePath(channel, remote.substring(0, i + 1)) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a temporary file in the directory that this {@link FilePath} object designates.
&nbsp;     *
&nbsp;     * @param prefix
&nbsp;     *      The prefix string to be used in generating the file&#39;s name; must be
&nbsp;     *      at least three characters long
&nbsp;     * @param suffix
&nbsp;     *      The suffix string to be used in generating the file&#39;s name; may be
&nbsp;     *      null, in which case the suffix &quot;.tmp&quot; will be used
&nbsp;     * @return
&nbsp;     *      The new FilePath pointing to the temporary file
&nbsp;     * @see File#createTempFile(String, String)
&nbsp;     */
&nbsp;    public FilePath createTempFile(final String prefix, final String suffix) throws IOException, InterruptedException {
&nbsp;        try {
<b class="nc">&nbsp;            return new FilePath(this, act(new CreateTempFile(prefix, suffix)));</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to create a temp file on &quot; + remote, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class CreateTempFile extends MasterToSlaveFileCallable&lt;String&gt; {
&nbsp;        private final String prefix;
&nbsp;        private final String suffix;
&nbsp;
<b class="nc">&nbsp;        CreateTempFile(String prefix, String suffix) {</b>
<b class="nc">&nbsp;            this.prefix = prefix;</b>
<b class="nc">&nbsp;            this.suffix = suffix;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File dir, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            File f = File.createTempFile(prefix, suffix, dir);</b>
<b class="nc">&nbsp;            return f.getName();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a temporary file in this directory and set the contents to the
&nbsp;     * given text (encoded in the platform default encoding)
&nbsp;     *
&nbsp;     * @param prefix
&nbsp;     *      The prefix string to be used in generating the file&#39;s name; must be
&nbsp;     *      at least three characters long
&nbsp;     * @param suffix
&nbsp;     *      The suffix string to be used in generating the file&#39;s name; may be
&nbsp;     *      null, in which case the suffix &quot;.tmp&quot; will be used
&nbsp;     * @param contents
&nbsp;     *      The initial contents of the temporary file.
&nbsp;     * @return
&nbsp;     *      The new FilePath pointing to the temporary file
&nbsp;     * @see File#createTempFile(String, String)
&nbsp;     */
&nbsp;    public FilePath createTextTempFile(final String prefix, final String suffix, final String contents) throws IOException, InterruptedException {
<b class="nc">&nbsp;        return createTextTempFile(prefix, suffix, contents, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a temporary file in this directory (or the system temporary
&nbsp;     * directory) and set the contents to the given text (encoded in the
&nbsp;     * platform default encoding)
&nbsp;     *
&nbsp;     * @param prefix
&nbsp;     *      The prefix string to be used in generating the file&#39;s name; must be
&nbsp;     *      at least three characters long
&nbsp;     * @param suffix
&nbsp;     *      The suffix string to be used in generating the file&#39;s name; may be
&nbsp;     *      null, in which case the suffix &quot;.tmp&quot; will be used
&nbsp;     * @param contents
&nbsp;     *      The initial contents of the temporary file.
&nbsp;     * @param inThisDirectory
&nbsp;     *      If true, then create this temporary in the directory pointed to by
&nbsp;     *      this.
&nbsp;     *      If false, then the temporary file is created in the system temporary
&nbsp;     *      directory (java.io.tmpdir)
&nbsp;     * @return
&nbsp;     *      The new FilePath pointing to the temporary file
&nbsp;     * @see File#createTempFile(String, String)
&nbsp;     */
&nbsp;    public FilePath createTextTempFile(final String prefix, final String suffix, final String contents, final boolean inThisDirectory) throws IOException, InterruptedException {
&nbsp;        try {
<b class="fc">&nbsp;            return new FilePath(channel, act(new CreateTextTempFile(inThisDirectory, prefix, suffix, contents)));</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to create a temp file on &quot; + remote, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class CreateTextTempFile extends MasterToSlaveFileCallable&lt;String&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final boolean inThisDirectory;
&nbsp;        private final String prefix;
&nbsp;        private final String suffix;
&nbsp;        private final String contents;
&nbsp;
<b class="fc">&nbsp;        CreateTextTempFile(boolean inThisDirectory, String prefix, String suffix, String contents) {</b>
<b class="fc">&nbsp;            this.inThisDirectory = inThisDirectory;</b>
<b class="fc">&nbsp;            this.prefix = prefix;</b>
<b class="fc">&nbsp;            this.suffix = suffix;</b>
<b class="fc">&nbsp;            this.contents = contents;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File dir, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            if (!inThisDirectory)</b>
<b class="nc">&nbsp;                dir = new File(System.getProperty(&quot;java.io.tmpdir&quot;));</b>
&nbsp;            else
<b class="fc">&nbsp;                mkdirs(dir);</b>
&nbsp;
&nbsp;            File f;
&nbsp;            try {
<b class="fc">&nbsp;                f = File.createTempFile(prefix, suffix, dir);</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                throw new IOException(&quot;Failed to create a temporary directory in &quot; + dir, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            try (Writer w = Files.newBufferedWriter(Util.fileToPath(f), Charset.defaultCharset())) {</b>
<b class="fc">&nbsp;                w.write(contents);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return f.getAbsolutePath();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a temporary directory inside the directory represented by &#39;this&#39;
&nbsp;     *
&nbsp;     * @param prefix
&nbsp;     *      The prefix string to be used in generating the directory&#39;s name;
&nbsp;     *      must be at least three characters long
&nbsp;     * @param suffix
&nbsp;     *      The suffix string to be used in generating the directory&#39;s name; may
&nbsp;     *      be null, in which case the suffix &quot;.tmp&quot; will be used
&nbsp;     * @return
&nbsp;     *      The new FilePath pointing to the temporary directory
&nbsp;     * @since 1.311
&nbsp;     * @see Files#createTempDirectory(Path, String, FileAttribute[])
&nbsp;     */
&nbsp;    public FilePath createTempDir(final String prefix, final String suffix) throws IOException, InterruptedException {
&nbsp;        try {
&nbsp;            String[] s;
<b class="fc">&nbsp;            if (StringUtils.isBlank(suffix)) {</b>
<b class="fc">&nbsp;                s = new String[]{prefix, &quot;tmp&quot;}; // see File.createTempFile - tmp is used if suffix is null</b>
&nbsp;            } else {
<b class="fc">&nbsp;                s = new String[]{prefix, suffix};</b>
&nbsp;            }
<b class="fc">&nbsp;            String name = String.join(&quot;.&quot;, s);</b>
<b class="fc">&nbsp;            return new FilePath(this, act(new CreateTempDir(name)));</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to create a temp directory on &quot; + remote, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class CreateTempDir extends MasterToSlaveFileCallable&lt;String&gt; {
&nbsp;        private final String name;
&nbsp;
<b class="fc">&nbsp;        CreateTempDir(String name) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;            @Override
&nbsp;            public String invoke(File dir, VirtualChannel channel) throws IOException {
&nbsp;
&nbsp;                Path tempPath;
<b class="fc">&nbsp;                final boolean isPosix = FileSystems.getDefault().supportedFileAttributeViews().contains(&quot;posix&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                if (isPosix) {</b>
<b class="nc">&nbsp;                    tempPath = Files.createTempDirectory(Util.fileToPath(dir), name,</b>
<b class="nc">&nbsp;                            PosixFilePermissions.asFileAttribute(EnumSet.allOf(PosixFilePermission.class)));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    tempPath = Files.createTempDirectory(Util.fileToPath(dir), name);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (tempPath.toFile() == null) {</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to obtain file from path &quot; + dir);</b>
&nbsp;                }
<b class="fc">&nbsp;                return tempPath.toFile().getName();</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this file.
&nbsp;     * @return true, for a modicum of compatibility
&nbsp;     * @throws IOException if it exists but could not be successfully deleted
&nbsp;     */
&nbsp;    public boolean delete() throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new Delete());</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class Delete extends MasterToSlaveFileCallable&lt;Void&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            Util.deleteFile(f);</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the file exists.
&nbsp;     */
&nbsp;    public boolean exists() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new Exists());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class Exists extends MasterToSlaveFileCallable&lt;Boolean&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            return f.exists();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the last modified time stamp of this file, by using the clock
&nbsp;     * of the machine where this file actually resides.
&nbsp;     *
&nbsp;     * @see File#lastModified()
&nbsp;     * @see #touch(long)
&nbsp;     */
&nbsp;    public long lastModified() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new LastModified());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class LastModified extends MasterToSlaveFileCallable&lt;Long&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Long invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            return f.lastModified();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a file (if not already exist) and sets the timestamp.
&nbsp;     *
&nbsp;     * @since 1.299
&nbsp;     */
&nbsp;    public void touch(final long timestamp) throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new Touch(timestamp));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Touch extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final long timestamp;
&nbsp;
<b class="fc">&nbsp;        Touch(long timestamp) {</b>
<b class="fc">&nbsp;            this.timestamp = timestamp;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = -5094638816500738429L;
&nbsp;
&nbsp;            @Override
&nbsp;            public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;                if (!f.exists()) {</b>
<b class="fc">&nbsp;                    Files.newOutputStream(fileToPath(f)).close();</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!f.setLastModified(timestamp))</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to set the timestamp of &quot; + f + &quot; to &quot; + timestamp);</b>
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    private void setLastModifiedIfPossible(final long timestamp) throws IOException, InterruptedException {
<b class="fc">&nbsp;        String message = act(new SetLastModified(timestamp));</b>
&nbsp;
<b class="fc">&nbsp;        if (message != null) {</b>
<b class="nc">&nbsp;            LOGGER.warning(message);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class SetLastModified extends MasterToSlaveFileCallable&lt;String&gt; {
&nbsp;        private final long timestamp;
&nbsp;
<b class="fc">&nbsp;        SetLastModified(long timestamp) {</b>
<b class="fc">&nbsp;            this.timestamp = timestamp;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = -828220335793641630L;
&nbsp;
&nbsp;            @Override
&nbsp;            public String invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;                if (!f.setLastModified(timestamp)) {</b>
<b class="nc">&nbsp;                    if (Functions.isWindows()) {</b>
&nbsp;                        // On Windows this seems to fail often. See JENKINS-11073
&nbsp;                        // Therefore don&#39;t fail, but just log a warning
<b class="nc">&nbsp;                        return &quot;Failed to set the timestamp of &quot; + f + &quot; to &quot; + timestamp;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to set the timestamp of &quot; + f + &quot; to &quot; + timestamp);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the file is a directory.
&nbsp;     */
&nbsp;    public boolean isDirectory() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new IsDirectory());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class IsDirectory extends MasterToSlaveFileCallable&lt;Boolean&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            return f.isDirectory();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the file size in bytes.
&nbsp;     *
&nbsp;     * @since 1.129
&nbsp;     */
&nbsp;    public long length() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new Length());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class Length extends MasterToSlaveFileCallable&lt;Long&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Long invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            return f.length();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of unallocated bytes in the partition of that file.
&nbsp;     * @since 1.542
&nbsp;     */
&nbsp;    public long getFreeDiskSpace() throws IOException, InterruptedException {
<b class="nc">&nbsp;        return act(new GetFreeDiskSpace());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class GetFreeDiskSpace extends MasterToSlaveFileCallable&lt;Long&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Long invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            return f.getFreeSpace();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the total number of bytes in the partition of that file.
&nbsp;     * @since 1.542
&nbsp;     */
&nbsp;    public long getTotalDiskSpace() throws IOException, InterruptedException {
<b class="nc">&nbsp;        return act(new GetTotalDiskSpace());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class GetTotalDiskSpace extends MasterToSlaveFileCallable&lt;Long&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Long invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            return f.getTotalSpace();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of usable bytes in the partition of that file.
&nbsp;     * @since 1.542
&nbsp;     */
&nbsp;    public long getUsableDiskSpace() throws IOException, InterruptedException {
<b class="nc">&nbsp;        return act(new GetUsableDiskSpace());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class GetUsableDiskSpace extends MasterToSlaveFileCallable&lt;Long&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Long invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            return f.getUsableSpace();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the file permission.
&nbsp;     *
&nbsp;     * On Windows, no-op.
&nbsp;     *
&nbsp;     * @param mask
&nbsp;     *      File permission mask. To simplify the permission copying,
&nbsp;     *      if the parameter is -1, this method becomes no-op.
&nbsp;     *      &lt;p&gt;
&nbsp;     *      please note mask is expected to be an octal if you use &lt;a href=&quot;http://en.wikipedia.org/wiki/Chmod&quot;&gt;chmod command line values&lt;/a&gt;,
&nbsp;     *      so preceded by a &#39;0&#39; in java notation, ie {@code chmod(0644)}
&nbsp;     *      &lt;p&gt;
&nbsp;     *      Only supports setting read, write, or execute permissions for the
&nbsp;     *      owner, group, or others, so the largest permissible value is 0777.
&nbsp;     *      Attempting to set larger values (i.e. the setgid, setuid, or sticky
&nbsp;     *      bits) will cause an IOException to be thrown.
&nbsp;     *
&nbsp;     * @since 1.303
&nbsp;     * @see #mode()
&nbsp;     */
&nbsp;    public void chmod(final int mask) throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (!isUnix() || mask == -1)   return;</b>
<b class="nc">&nbsp;        act(new Chmod(mask));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Chmod extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final int mask;
&nbsp;
<b class="nc">&nbsp;        Chmod(int mask) {</b>
<b class="nc">&nbsp;            this.mask = mask;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            _chmod(f, mask);</b>
&nbsp;
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Change permissions via NIO.
&nbsp;     */
&nbsp;    private static void _chmod(File f, int mask) throws IOException {
&nbsp;        // TODO WindowsPosix actually does something here (WindowsLibC._wchmod); should we let it?
&nbsp;        // Anyway the existing calls already skip this method if on Windows.
<b class="nc">&nbsp;        if (File.pathSeparatorChar == &#39;;&#39;)  return; // noop</b>
&nbsp;
<b class="nc">&nbsp;        Files.setPosixFilePermissions(fileToPath(f), Util.modeToPermissions(mask));</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static boolean CHMOD_WARNED = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the file permission bit mask.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      -1 on Windows, since such a concept doesn&#39;t make sense.
&nbsp;     * @since 1.311
&nbsp;     * @see #chmod(int)
&nbsp;     */
&nbsp;    public int mode() throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (!isUnix())   return -1;</b>
<b class="nc">&nbsp;        return act(new Mode());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class Mode extends MasterToSlaveFileCallable&lt;Integer&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            return IOUtils.mode(f);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up files and directories in this directory.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method returns direct children of the directory denoted by the &#39;this&#39; object.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public List&lt;FilePath&gt; list() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return list((FileFilter) null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up files and directories in this directory.
&nbsp;     *
&nbsp;     * This is intended to allow the caller to provide {@link java.nio.file.LinkOption#NOFOLLOW_LINKS} to ignore
&nbsp;     * symlinks.
&nbsp;     * @param verificationRoot A root or base directory for checking for any symlinks in this files parentage.
&nbsp;     *             Any symlinks between a file and root should be ignored.
&nbsp;     *             Symlinks in the parentage outside root will not be checked.
&nbsp;     * @param openOptions the options to apply when opening.
&nbsp;     * @return Direct children of this directory.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public List&lt;FilePath&gt; list(FilePath verificationRoot, OpenOption... openOptions) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return list(new OptionalDiscardingFileFilter(verificationRoot, openOptions));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up subdirectories.
&nbsp;     *
&nbsp;     * @return can be empty but never null. Doesn&#39;t contain &quot;.&quot; and &quot;..&quot;
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public List&lt;FilePath&gt; listDirectories() throws IOException, InterruptedException {
<b class="nc">&nbsp;        return list(new DirectoryFilter());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final class DirectoryFilter implements FileFilter, Serializable {</b>
&nbsp;        @Override
&nbsp;        public boolean accept(File f) {
<b class="nc">&nbsp;            return f.isDirectory();</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up files in this directory, just like {@link File#listFiles(FileFilter)}.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *      The optional filter used to narrow down the result.
&nbsp;     *      If non-null, must be {@link Serializable}.
&nbsp;     *      If this {@link FilePath} represents a remote path,
&nbsp;     *      the filter object will be executed on the remote machine.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public List&lt;FilePath&gt; list(final FileFilter filter) throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (filter != null &amp;&amp; !(filter instanceof Serializable)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Non-serializable filter of &quot; + filter.getClass());</b>
&nbsp;        }
<b class="fc">&nbsp;        return act(new ListFilter(filter), (filter != null ? filter : this).getClass().getClassLoader());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class ListFilter extends MasterToSlaveFileCallable&lt;List&lt;FilePath&gt;&gt; {
&nbsp;        private final FileFilter filter;
&nbsp;
<b class="fc">&nbsp;        ListFilter(FileFilter filter) {</b>
<b class="fc">&nbsp;            this.filter = filter;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;FilePath&gt; invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;                File[] children = f.listFiles(filter);</b>
<b class="fc">&nbsp;                if (children == null) {</b>
<b class="nc">&nbsp;                    return Collections.emptyList();</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                ArrayList&lt;FilePath&gt; r = new ArrayList&lt;&gt;(children.length);</b>
<b class="fc">&nbsp;                for (File child : children)</b>
<b class="fc">&nbsp;                    r.add(new FilePath(child));</b>
&nbsp;
<b class="fc">&nbsp;                return r;</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up files in this directory that matches the given Ant-style filter.
&nbsp;     *
&nbsp;     * @param includes
&nbsp;     *      See {@link FileSet} for the syntax. String like &quot;foo/*.zip&quot; or &quot;foo/*&amp;#42;/*.xml&quot;
&nbsp;     * @return
&nbsp;     *      can be empty but always non-null.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public FilePath[] list(final String includes) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return list(includes, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up files in this directory that matches the given Ant-style filter.
&nbsp;     *
&nbsp;     * @param includes
&nbsp;     *      See {@link FileSet} for the syntax. String like &quot;foo/*.zip&quot; or &quot;foo/*&amp;#42;/*.xml&quot;
&nbsp;     * @param excludes
&nbsp;     *      See {@link FileSet} for the syntax. String like &quot;foo/*.zip&quot; or &quot;foo/*&amp;#42;/*.xml&quot;
&nbsp;     * @return
&nbsp;     *      can be empty but always non-null.
&nbsp;     * @since 1.407
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public FilePath[] list(final String includes, final String excludes) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return list(includes, excludes, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List up files in this directory that matches the given Ant-style filter.
&nbsp;     *
&nbsp;     * @param includes
&nbsp;     *      See {@link FileSet} for the syntax. String like &quot;foo/*.zip&quot; or &quot;foo/*&amp;#42;/*.xml&quot;
&nbsp;     * @param excludes
&nbsp;     *      See {@link FileSet} for the syntax. String like &quot;foo/*.zip&quot; or &quot;foo/*&amp;#42;/*.xml&quot;
&nbsp;     * @param defaultExcludes whether to use the ant default excludes
&nbsp;     * @return
&nbsp;     *      can be empty but always non-null.
&nbsp;     * @since 1.465
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public FilePath[] list(final String includes, final String excludes, final boolean defaultExcludes) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new ListGlob(includes, excludes, defaultExcludes));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class ListGlob extends MasterToSlaveFileCallable&lt;FilePath[]&gt; {
&nbsp;        private final String includes;
&nbsp;        private final String excludes;
&nbsp;        private final boolean defaultExcludes;
&nbsp;
<b class="fc">&nbsp;        ListGlob(String includes, String excludes, boolean defaultExcludes) {</b>
<b class="fc">&nbsp;            this.includes = includes;</b>
<b class="fc">&nbsp;            this.excludes = excludes;</b>
<b class="fc">&nbsp;            this.defaultExcludes = defaultExcludes;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;            @Override
&nbsp;            public FilePath[] invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;                String[] files = glob(f, includes, excludes, defaultExcludes);</b>
&nbsp;
<b class="fc">&nbsp;                FilePath[] r = new FilePath[files.length];</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; r.length; i++)</b>
<b class="fc">&nbsp;                    r[i] = new FilePath(new File(f, files[i]));</b>
&nbsp;
<b class="fc">&nbsp;                return r;</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Runs Ant glob expansion.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      A set of relative file names from the base directory.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    private static String[] glob(File dir, String includes, String excludes, boolean defaultExcludes) throws IOException {
<b class="fc">&nbsp;        if (isAbsolute(includes))</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Expecting Ant GLOB pattern, but saw &#39;&quot; + includes + &quot;&#39;. See https://ant.apache.org/manual/Types/fileset.html for syntax&quot;);</b>
<b class="fc">&nbsp;        FileSet fs = Util.createFileSet(dir, includes, excludes);</b>
<b class="fc">&nbsp;        fs.setDefaultexcludes(defaultExcludes);</b>
&nbsp;        DirectoryScanner ds;
&nbsp;        try {
<b class="fc">&nbsp;            ds = fs.getDirectoryScanner(new Project());</b>
<b class="nc">&nbsp;        } catch (BuildException x) {</b>
<b class="nc">&nbsp;            throw new IOException(x.getMessage());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return ds.getIncludedFiles();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads this file.
&nbsp;     */
&nbsp;    public InputStream read() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return read(null, new OpenOption[0]);</b>
&nbsp;    }
&nbsp;
&nbsp;    public InputStream read(FilePath rootPath, OpenOption... openOptions) throws IOException, InterruptedException {
<b class="fc">&nbsp;        String rootPathString = rootPath == null ? null : rootPath.remote;</b>
<b class="fc">&nbsp;        if (channel == null) {</b>
<b class="fc">&nbsp;            File file = new File(remote);</b>
<b class="fc">&nbsp;            InputStream inputStream = newInputStreamDenyingSymlinkAsNeeded(file, rootPathString, openOptions);</b>
<b class="fc">&nbsp;            return inputStream;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Pipe p = Pipe.createRemoteToLocal();</b>
<b class="nc">&nbsp;        actAsync(new Read(p, rootPathString, openOptions));</b>
&nbsp;
<b class="nc">&nbsp;        return p.getIn();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static InputStream newInputStreamDenyingSymlinkAsNeeded(File file, String verificationRoot, OpenOption... openOptions) throws IOException {
<b class="fc">&nbsp;        InputStream inputStream = null;</b>
&nbsp;        try {
<b class="fc">&nbsp;            denyTmpDir(file, verificationRoot, openOptions);</b>
<b class="fc">&nbsp;            denySymlink(file, verificationRoot, openOptions);</b>
<b class="fc">&nbsp;            inputStream = openInputStream(file, openOptions);</b>
<b class="fc">&nbsp;            denySymlink(file, verificationRoot, openOptions);</b>
<b class="fc">&nbsp;        } catch (IOException ioe) {</b>
<b class="fc">&nbsp;            if (inputStream != null) {</b>
<b class="nc">&nbsp;                inputStream.close();</b>
&nbsp;            }
<b class="fc">&nbsp;            throw ioe;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return inputStream;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static InputStream openInputStream(File file, OpenOption[] openOptions) throws IOException {
<b class="fc">&nbsp;        return Files.newInputStream(fileToPath(file), stripLocalOptions(openOptions));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static OpenOption[] stripLocalOptions(OpenOption... openOptions) {
<b class="fc">&nbsp;        if (openOptions != null) {</b>
<b class="fc">&nbsp;            return Arrays.stream(openOptions).filter(option -&gt; option != DisplayOption.IGNORE_TMP_DIRS).toArray(OpenOption[]::new);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void denySymlink(File file, String root, OpenOption... openOptions) throws IOException {
&nbsp;        /* This should be checked right before the file is opened or otherwise traversed.
&nbsp;           If at all possible, it should also be checked immediately afterwards.
&nbsp;           This narrows any possible race conditions that may exist in weird situations,
&nbsp;           platforms, or implementations.
&nbsp;           newInputStreamDenyingSymlinkAsNeeded(...) demonstrates how this would be done.
&nbsp;
&nbsp;           This is useful for preventing symlink following on systems that don&#39;t support
&nbsp;           LinkOption.NOFOLLOW_LINK. Notable among those, is AIX. It is also important for
&nbsp;           prohibiting Windows Junctions, which are not considered symlinks by the
&nbsp;           Files.newInputStream(path, LinkOption.NOFOLLOW_LINKS) implementation.
&nbsp;        */
&nbsp;
<b class="fc">&nbsp;        if (isSymlink(file, root, openOptions)) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Symlinks are prohibited.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void denyTmpDir(File file, String root, OpenOption... openOptions) throws IOException {
<b class="fc">&nbsp;        if (isTmpDir(file, root, openOptions)) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Tmp directory is prohibited.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isSymlink(File file, String root, OpenOption... openOptions) {
<b class="fc">&nbsp;        if (isNoFollowLink(openOptions)) {</b>
<b class="fc">&nbsp;            if (Util.isSymlink(file.toPath())) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return isFileAncestorSymlink(file, root);</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isSymlink(VisitorInfo visitorInfo) {
<b class="fc">&nbsp;        return isSymlink(visitorInfo.f, visitorInfo.verificationRoot, visitorInfo.openOptions);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isTmpDir(File file, String root, OpenOption... openOptions) {
<b class="fc">&nbsp;        if (isIgnoreTmpDirs(openOptions)) {</b>
<b class="nc">&nbsp;            if (isTmpDir(file)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return isFileAncestorTmpDir(file, root);</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isTmpDir(String filename, OpenOption... openOptions) {
<b class="nc">&nbsp;        if (isIgnoreTmpDirs(openOptions)) {</b>
<b class="nc">&nbsp;            return isTmpDir(filename);</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isTmpDir(VisitorInfo visitorInfo) {
<b class="nc">&nbsp;        return isTmpDir(visitorInfo.f, visitorInfo.verificationRoot, visitorInfo.openOptions);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isTmpDir(File file) {
<b class="nc">&nbsp;        return file.isDirectory() &amp;&amp; isTmpDir(file.getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isTmpDir(String filename) {
<b class="nc">&nbsp;        return filename.length() &gt; WorkspaceList.TMP_DIR_SUFFIX.length() &amp;&amp; filename.endsWith(WorkspaceList.TMP_DIR_SUFFIX);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isNoFollowLink(OpenOption... openOptions) {
<b class="fc">&nbsp;        return Arrays.asList(openOptions).contains(LinkOption.NOFOLLOW_LINKS);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isIgnoreTmpDirs(OpenOption... openOptions) {
<b class="fc">&nbsp;        return Arrays.asList(openOptions).contains(DisplayOption.IGNORE_TMP_DIRS);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isFileAncestorSymlink(File file, String root) {
<b class="fc">&nbsp;        return doesFileAncestorMatch(file, root, Util::isSymlink);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether an ancestor of this file is a tmp directory, between the specified
&nbsp;     * file and the root path. Ancestors further up the tree are not considered.
&nbsp;     * @param file The base file for the beginning of the search.
&nbsp;     * @param root The root path for ending the search.
&nbsp;     * @return True if there is a tmp directory within the domain. False otherwise.
&nbsp;     */
&nbsp;    private static boolean isFileAncestorTmpDir(File file, String root) {
<b class="nc">&nbsp;        return doesFileAncestorMatch(file, root, path -&gt; isTmpDir(path.toFile()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines whether an ancestor of this file is a symlink, between the specified
&nbsp;     * file and the root path. Ancestors further up the tree are not considered.
&nbsp;     * @param file The base file for the beginning of the search.
&nbsp;     * @param root The root path for ending the search.
&nbsp;     * @return True if there is a symlink within the domain. False otherwise.
&nbsp;     */
&nbsp;     private static boolean doesFileAncestorMatch(File file, String root, Predicate&lt;Path&gt; matcher) {
<b class="fc">&nbsp;        if (root != null) {</b>
<b class="fc">&nbsp;            Path rootPath = Paths.get(root);</b>
<b class="fc">&nbsp;            Path currPath = file.toPath();</b>
&nbsp;            try {
<b class="fc">&nbsp;                while (!getRealPath(currPath).equals(getRealPath(rootPath))) {</b>
<b class="fc">&nbsp;                    if (matcher.test(currPath)) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    currPath = currPath.getParent();</b>
<b class="fc">&nbsp;                    if (currPath == null) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            } catch (IOException ioe) {</b>
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Read extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final Pipe p;
&nbsp;        private String verificationRoot;
&nbsp;        private OpenOption[] openOptions;
&nbsp;
<b class="nc">&nbsp;        Read(Pipe p, String verificationRoot, OpenOption... openOptions) {</b>
<b class="nc">&nbsp;            this.p = p;</b>
<b class="nc">&nbsp;            this.verificationRoot = verificationRoot;</b>
<b class="nc">&nbsp;            this.openOptions = openOptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="nc">&nbsp;            try (InputStream fis = newInputStreamDenyingSymlinkAsNeeded(f, verificationRoot, openOptions); OutputStream out = p.getOut()) {</b>
<b class="nc">&nbsp;                org.apache.commons.io.IOUtils.copy(fis, out);</b>
<b class="nc">&nbsp;            } catch (Exception x) {</b>
<b class="nc">&nbsp;                p.error(x);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads this file from the specific offset.
&nbsp;     * @since 1.586
&nbsp;     */
&nbsp;    public InputStream readFromOffset(final long offset) throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            final RandomAccessFile raf = new RandomAccessFile(new File(remote), &quot;r&quot;);</b>
&nbsp;            try {
<b class="nc">&nbsp;                raf.seek(offset);</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    raf.close();</b>
<b class="nc">&nbsp;                } catch (IOException e1) {</b>
&nbsp;                    // ignore
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return new InputStream() {</b>
&nbsp;                @Override
&nbsp;                public int read() throws IOException {
<b class="nc">&nbsp;                    return raf.read();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void close() throws IOException {
<b class="nc">&nbsp;                    raf.close();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int read(byte[] b, int off, int len) throws IOException {
<b class="nc">&nbsp;                    return raf.read(b, off, len);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int read(byte[] b) throws IOException {
<b class="nc">&nbsp;                    return raf.read(b);</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final Pipe p = Pipe.createRemoteToLocal();</b>
<b class="nc">&nbsp;        actAsync(new OffsetPipeSecureFileCallable(p, offset));</b>
<b class="nc">&nbsp;        return new java.util.zip.GZIPInputStream(p.getIn());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class OffsetPipeSecureFileCallable extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        private Pipe p;
&nbsp;        private long offset;
&nbsp;
<b class="nc">&nbsp;        private OffsetPipeSecureFileCallable(Pipe p, long offset) {</b>
<b class="nc">&nbsp;            this.p = p;</b>
<b class="nc">&nbsp;            this.offset = offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            try (OutputStream os = p.getOut();</b>
<b class="nc">&nbsp;                 OutputStream out = new java.util.zip.GZIPOutputStream(os, 8192);</b>
<b class="nc">&nbsp;                 RandomAccessFile raf = new RandomAccessFile(f, &quot;r&quot;)) {</b>
<b class="nc">&nbsp;                raf.seek(offset);</b>
<b class="nc">&nbsp;                byte[] buf = new byte[8192];</b>
&nbsp;                int len;
<b class="nc">&nbsp;                while ((len = raf.read(buf)) &gt;= 0) {</b>
<b class="nc">&nbsp;                    out.write(buf, 0, len);</b>
&nbsp;                }
<b class="nc">&nbsp;                return null;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads this file into a string, by using the current system encoding on the remote machine.
&nbsp;     */
&nbsp;    public String readToString() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new ReadToString());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class ReadToString extends MasterToSlaveFileCallable&lt;String&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            return Files.readString(fileToPath(f), Charset.defaultCharset());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes to this file.
&nbsp;     * If this file already exists, it will be overwritten.
&nbsp;     * If the directory doesn&#39;t exist, it will be created.
&nbsp;     *
&nbsp;     * &lt;P&gt;
&nbsp;     * I/O operation to remote {@link FilePath} happens asynchronously, meaning write operations to the returned
&nbsp;     * {@link OutputStream} will return without receiving a confirmation from the remote that the write happened.
&nbsp;     * I/O operations also happens asynchronously from the {@link Channel#call(Callable)} operations, so if
&nbsp;     * you write to a remote file and then execute {@link Channel#call(Callable)} and try to access the newly copied
&nbsp;     * file, it might not be fully written yet.
&nbsp;     */
&nbsp;    public OutputStream write() throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (channel == null) {</b>
<b class="fc">&nbsp;            File f = new File(remote).getAbsoluteFile();</b>
<b class="fc">&nbsp;            mkdirs(f.getParentFile());</b>
<b class="fc">&nbsp;            return Files.newOutputStream(fileToPath(f));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return act(new WritePipe());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class WritePipe extends MasterToSlaveFileCallable&lt;OutputStream&gt; {</b>
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;            @Override
&nbsp;            public OutputStream invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;                f = f.getAbsoluteFile();</b>
<b class="fc">&nbsp;                mkdirs(f.getParentFile());</b>
<b class="fc">&nbsp;                return new RemoteOutputStream(Files.newOutputStream(fileToPath(f)));</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Overwrites this file by placing the given String as the content.
&nbsp;     *
&nbsp;     * @param encoding
&nbsp;     *      Null to use the platform default encoding on the remote machine.
&nbsp;     * @since 1.105
&nbsp;     */
&nbsp;    public void write(final String content, final String encoding) throws IOException, InterruptedException {
<b class="fc">&nbsp;        act(new Write(encoding, content));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Write extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final String encoding;
&nbsp;        private final String content;
&nbsp;
<b class="fc">&nbsp;        Write(String encoding, String content) {</b>
<b class="fc">&nbsp;            this.encoding = encoding;</b>
<b class="fc">&nbsp;            this.content = content;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            mkdirs(f.getParentFile());</b>
<b class="fc">&nbsp;            try (OutputStream fos = Files.newOutputStream(fileToPath(f));</b>
<b class="fc">&nbsp;                    Writer w = encoding != null ? new OutputStreamWriter(fos, encoding) : new OutputStreamWriter(fos, Charset.defaultCharset())) {</b>
<b class="fc">&nbsp;                w.write(content);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes the MD5 digest of the file in hex string.
&nbsp;     * @see Util#getDigestOf(File)
&nbsp;     */
&nbsp;    public String digest() throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new Digest());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static class Digest extends MasterToSlaveFileCallable&lt;String&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            return Util.getDigestOf(f);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rename this file/directory to the target filepath.  This FilePath and the target must
&nbsp;     * be on the same host
&nbsp;     */
&nbsp;    public void renameTo(final FilePath target) throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (this.channel != target.channel) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;renameTo target must be on the same host&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        act(new RenameTo(target));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class RenameTo extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final FilePath target;
&nbsp;
<b class="nc">&nbsp;        RenameTo(FilePath target) {</b>
<b class="nc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            Files.move(fileToPath(f), fileToPath(new File(target.remote)), LinkOption.NOFOLLOW_LINKS);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Moves all the contents of this directory into the specified directory, then delete this directory itself.
&nbsp;     *
&nbsp;     * @since 1.308.
&nbsp;     */
&nbsp;    public void moveAllChildrenTo(final FilePath target) throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (this.channel != target.channel) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;pullUpTo target must be on the same host&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        act(new MoveAllChildrenTo(target));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class MoveAllChildrenTo extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final FilePath target;
&nbsp;
<b class="fc">&nbsp;        MoveAllChildrenTo(FilePath target) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;            @Override
&nbsp;            public Void invoke(File f, VirtualChannel channel) throws IOException {
&nbsp;                // JENKINS-16846: if f.getName() is the same as one of the files/directories in f,
&nbsp;                // the rename op will fail
<b class="fc">&nbsp;                File tmp = new File(f.getAbsolutePath() + &quot;.__rename&quot;);</b>
<b class="fc">&nbsp;                if (!f.renameTo(tmp))</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to rename &quot; + f + &quot; to &quot; + tmp);</b>
&nbsp;
<b class="fc">&nbsp;                File t = new File(target.getRemote());</b>
&nbsp;
<b class="fc">&nbsp;                for (File child : tmp.listFiles()) {</b>
<b class="fc">&nbsp;                    File target = new File(t, child.getName());</b>
<b class="fc">&nbsp;                    if (!child.renameTo(target))</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to rename &quot; + child + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="fc">&nbsp;                Files.deleteIfExists(Util.fileToPath(tmp));</b>
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies this file to the specified target.
&nbsp;     */
&nbsp;    public void copyTo(FilePath target) throws IOException, InterruptedException {
&nbsp;        try {
<b class="fc">&nbsp;            try (OutputStream out = target.write()) {</b>
<b class="fc">&nbsp;                copyTo(out);</b>
<b class="fc">&nbsp;            }</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to copy &quot; + this + &quot; to &quot; + target, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies this file to the specified target, with file permissions and other meta attributes intact.
&nbsp;     * @since 1.311
&nbsp;     */
&nbsp;    public void copyToWithPermission(FilePath target) throws IOException, InterruptedException {
&nbsp;        // Use NIO copy with StandardCopyOption.COPY_ATTRIBUTES when copying on the same machine.
<b class="fc">&nbsp;        if (this.channel == target.channel) {</b>
<b class="nc">&nbsp;            act(new CopyToWithPermission(target));</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        copyTo(target);</b>
&nbsp;        // copy file permission
<b class="fc">&nbsp;        target.chmod(mode());</b>
<b class="fc">&nbsp;        target.setLastModifiedIfPossible(lastModified());</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class CopyToWithPermission extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final FilePath target;
&nbsp;
<b class="nc">&nbsp;        CopyToWithPermission(FilePath target) {</b>
<b class="nc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            File targetFile = new File(target.remote);</b>
<b class="nc">&nbsp;            File targetDir = targetFile.getParentFile();</b>
<b class="nc">&nbsp;            Files.createDirectories(fileToPath(targetDir));</b>
<b class="nc">&nbsp;            Files.copy(fileToPath(f), fileToPath(targetFile), StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends the contents of this file into the given {@link OutputStream}.
&nbsp;     */
&nbsp;    public void copyTo(OutputStream os) throws IOException, InterruptedException {
<b class="fc">&nbsp;        final OutputStream out = new RemoteOutputStream(os);</b>
&nbsp;
<b class="fc">&nbsp;        act(new CopyTo(out));</b>
&nbsp;
&nbsp;        // make sure the writes fully got delivered to &#39;os&#39; before we return.
&nbsp;        // this is needed because I/O operation is asynchronous
<b class="fc">&nbsp;        syncIO();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class CopyTo extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private static final long serialVersionUID = 4088559042349254141L;
&nbsp;        private final OutputStream out;
&nbsp;
<b class="fc">&nbsp;        CopyTo(OutputStream out) {</b>
<b class="fc">&nbsp;            this.out = out;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            try (InputStream fis = Files.newInputStream(fileToPath(f))) {</b>
<b class="fc">&nbsp;                org.apache.commons.io.IOUtils.copy(fis, out);</b>
<b class="fc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            } finally {</b>
<b class="fc">&nbsp;                out.close();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * With fix to JENKINS-11251 (remoting 2.15), this is no longer necessary.
&nbsp;     * But I&#39;m keeping it for a while so that users who manually deploy agent.jar has time to deploy new version
&nbsp;     * before this goes away.
&nbsp;     */
&nbsp;    private void syncIO() throws InterruptedException {
&nbsp;        try {
<b class="fc">&nbsp;            if (channel != null)</b>
<b class="fc">&nbsp;                channel.syncLocalIO();</b>
<b class="nc">&nbsp;        } catch (AbstractMethodError e) {</b>
&nbsp;            // legacy agent.jar. Handle this gracefully
&nbsp;            try {
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Looks like an old agent.jar. Please update &quot; + Which.jarFile(Channel.class) + &quot; to the new version&quot;, e);</b>
<b class="nc">&nbsp;            } catch (IOException ignored) {</b>
&nbsp;                // really ignore this time
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A pointless function to work around what appears to be a HotSpot problem. See JENKINS-5756 and bug 6933067
&nbsp;     * on BugParade for more details.
&nbsp;     */
&nbsp;    private void _syncIO() throws InterruptedException {
<b class="nc">&nbsp;        channel.syncLocalIO();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remoting interface used for {@link FilePath#copyRecursiveTo(String, FilePath)}.
&nbsp;     *
&nbsp;     * TODO: this might not be the most efficient way to do the copy.
&nbsp;     */
&nbsp;    interface RemoteCopier {
&nbsp;        /**
&nbsp;         * @param fileName
&nbsp;         *      relative path name to the output file. Path separator must be &#39;/&#39;.
&nbsp;         */
&nbsp;        void open(String fileName) throws IOException;
&nbsp;
&nbsp;        void write(byte[] buf, int len) throws IOException;
&nbsp;
&nbsp;        void close() throws IOException;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies the contents of this directory recursively into the specified target directory.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      the number of files copied.
&nbsp;     * @since 1.312
&nbsp;     */
&nbsp;    public int copyRecursiveTo(FilePath target) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return copyRecursiveTo(&quot;**/*&quot;, target);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies the files that match the given file mask to the specified target node.
&nbsp;     *
&nbsp;     * @param fileMask
&nbsp;     *      Ant GLOB pattern.
&nbsp;     *      String like &quot;foo/bar/*.xml&quot; Multiple patterns can be separated
&nbsp;     *      by &#39;,&#39;, and whitespace can surround &#39;,&#39; so that you can write
&nbsp;     *      &quot;abc, def&quot; and &quot;abc,def&quot; to mean the same thing.
&nbsp;     * @return
&nbsp;     *      the number of files copied.
&nbsp;     */
&nbsp;    public int copyRecursiveTo(String fileMask, FilePath target) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return copyRecursiveTo(fileMask, null, target);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies the files that match the given file mask to the specified target node.
&nbsp;     *
&nbsp;     * @param fileMask
&nbsp;     *      Ant GLOB pattern.
&nbsp;     *      String like &quot;foo/bar/*.xml&quot; Multiple patterns can be separated
&nbsp;     *      by &#39;,&#39;, and whitespace can surround &#39;,&#39; so that you can write
&nbsp;     *      &quot;abc, def&quot; and &quot;abc,def&quot; to mean the same thing.
&nbsp;     * @param excludes
&nbsp;     *      Files to be excluded. Can be null.
&nbsp;     * @return
&nbsp;     *      the number of files copied.
&nbsp;     */
&nbsp;    public int copyRecursiveTo(final String fileMask, final String excludes, final FilePath target) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return copyRecursiveTo(new DirScanner.Glob(fileMask, excludes), target, fileMask);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies files according to a specified scanner to a target node.
&nbsp;     * @param scanner a way of enumerating some files (must be serializable for possible delivery to remote side)
&nbsp;     * @param target the destination basedir
&nbsp;     * @param description a description of the fileset, for logging purposes
&nbsp;     * @return the number of files copied
&nbsp;     * @since 1.532
&nbsp;     */
&nbsp;    public int copyRecursiveTo(final DirScanner scanner, final FilePath target, final String description) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return copyRecursiveTo(scanner, target, description, TarCompression.GZIP);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies files according to a specified scanner to a target node.
&nbsp;     * @param scanner a way of enumerating some files (must be serializable for possible delivery to remote side)
&nbsp;     * @param target the destination basedir
&nbsp;     * @param description a description of the fileset, for logging purposes
&nbsp;     * @param compression compression to use
&nbsp;     * @return the number of files copied
&nbsp;     * @since 2.196
&nbsp;     */
&nbsp;    public int copyRecursiveTo(final DirScanner scanner, final FilePath target, final String description, @NonNull TarCompression compression) throws IOException, InterruptedException {
<b class="fc">&nbsp;        if (this.channel == target.channel) {</b>
&nbsp;            // local to local copy.
<b class="fc">&nbsp;            return act(new CopyRecursiveLocal(target, scanner));</b>
&nbsp;        } else
<b class="fc">&nbsp;        if (this.channel == null) {</b>
&nbsp;            // local -&gt; remote copy
<b class="fc">&nbsp;            final Pipe pipe = Pipe.createLocalToRemote();</b>
&nbsp;
<b class="fc">&nbsp;            Future&lt;Void&gt; future = target.actAsync(new ReadFromTar(target, pipe, description, compression));</b>
<b class="fc">&nbsp;            Future&lt;Integer&gt; future2 = actAsync(new WriteToTar(scanner, pipe, compression));</b>
&nbsp;            try {
&nbsp;                // JENKINS-9540 in case the reading side failed, report that error first
<b class="fc">&nbsp;                future.get();</b>
<b class="fc">&nbsp;                return future2.get();</b>
<b class="nc">&nbsp;            } catch (ExecutionException e) {</b>
<b class="nc">&nbsp;                throw ioWithCause(e);</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // remote -&gt; local copy
<b class="nc">&nbsp;            final Pipe pipe = Pipe.createRemoteToLocal();</b>
&nbsp;
<b class="nc">&nbsp;            Future&lt;Integer&gt; future = actAsync(new CopyRecursiveRemoteToLocal(pipe, scanner, compression));</b>
&nbsp;            try {
<b class="nc">&nbsp;                readFromTar(remote + &#39;/&#39; + description, new File(target.remote), compression.extract(pipe.getIn()));</b>
<b class="nc">&nbsp;            } catch (IOException e) { // BuildException or IOException</b>
&nbsp;                try {
<b class="nc">&nbsp;                    future.get(3, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;                    throw e;    // the remote side completed successfully, so the error must be local</b>
<b class="nc">&nbsp;                } catch (ExecutionException x) {</b>
&nbsp;                    // report both errors
<b class="nc">&nbsp;                    e.addSuppressed(x);</b>
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                } catch (TimeoutException ignored) {</b>
&nbsp;                    // remote is hanging, just throw the original exception
<b class="nc">&nbsp;                    throw e;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            try {
<b class="nc">&nbsp;                return future.get();</b>
<b class="nc">&nbsp;            } catch (ExecutionException e) {</b>
<b class="nc">&nbsp;                throw ioWithCause(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private IOException ioWithCause(ExecutionException e) {
<b class="nc">&nbsp;        Throwable cause = e.getCause();</b>
<b class="nc">&nbsp;        if (cause == null) cause = e;</b>
<b class="nc">&nbsp;        return cause instanceof IOException</b>
<b class="nc">&nbsp;                ? (IOException) cause</b>
<b class="nc">&nbsp;                : new IOException(cause)</b>
&nbsp;                ;
&nbsp;    }
&nbsp;
&nbsp;    private static class CopyRecursiveLocal extends MasterToSlaveFileCallable&lt;Integer&gt; {
&nbsp;        private final FilePath target;
&nbsp;        private final DirScanner scanner;
&nbsp;
<b class="fc">&nbsp;        CopyRecursiveLocal(FilePath target, DirScanner scanner) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
<b class="fc">&nbsp;            this.scanner = scanner;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer invoke(File base, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            if (!base.exists()) {</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (target.channel != null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Expected null channel for &quot; + target);</b>
&nbsp;            }
<b class="fc">&nbsp;            final File dest = new File(target.remote);</b>
<b class="fc">&nbsp;            final AtomicInteger count = new AtomicInteger();</b>
<b class="fc">&nbsp;            scanner.scan(base, new FileVisitor() {</b>
&nbsp;                private boolean exceptionEncountered;
&nbsp;                private boolean logMessageShown;
&nbsp;                @SuppressFBWarnings(value = &quot;PATH_TRAVERSAL_IN&quot;, justification = &quot;TODO needs triage&quot;)
&nbsp;                @Override
&nbsp;                public void visit(File f, String relativePath) throws IOException {
<b class="fc">&nbsp;                    if (f.isFile()) {</b>
<b class="fc">&nbsp;                        File target = new File(dest, relativePath);</b>
<b class="fc">&nbsp;                        mkdirsE(target.getParentFile());</b>
<b class="fc">&nbsp;                        Path targetPath = fileToPath(target);</b>
<b class="fc">&nbsp;                        exceptionEncountered = exceptionEncountered || !tryCopyWithAttributes(f, targetPath);</b>
<b class="fc">&nbsp;                        if (exceptionEncountered) {</b>
<b class="nc">&nbsp;                            Files.copy(fileToPath(f), targetPath, StandardCopyOption.REPLACE_EXISTING);</b>
<b class="nc">&nbsp;                            if (!logMessageShown) {</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.INFO,</b>
&nbsp;                                    &quot;JENKINS-52325: Jenkins failed to retain attributes when copying to {0}, so proceeding without attributes.&quot;,
<b class="nc">&nbsp;                                    dest.getAbsolutePath());</b>
<b class="nc">&nbsp;                                logMessageShown = true;</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        count.incrementAndGet();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                private boolean tryCopyWithAttributes(File f, Path targetPath) {
&nbsp;                    try {
<b class="fc">&nbsp;                        Files.copy(fileToPath(f), targetPath,</b>
&nbsp;                            StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING);
<b class="nc">&nbsp;                    } catch (IOException e) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINE, &quot;Unable to copy: {0}&quot;, e.getMessage());</b>
<b class="nc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean understandsSymlink() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(value = &quot;PATH_TRAVERSAL_IN&quot;, justification = &quot;TODO needs triage&quot;)
&nbsp;                @Override
&nbsp;                public void visitSymlink(File link, String target, String relativePath) throws IOException {
&nbsp;                    try {
<b class="nc">&nbsp;                        mkdirsE(new File(dest, relativePath).getParentFile());</b>
<b class="nc">&nbsp;                        Util.createSymlink(dest, target, relativePath, TaskListener.NULL);</b>
<b class="nc">&nbsp;                    } catch (InterruptedException x) {</b>
<b class="nc">&nbsp;                        throw new IOException(x);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    count.incrementAndGet();</b>
&nbsp;                }
&nbsp;            });
<b class="fc">&nbsp;            return count.get();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class ReadFromTar extends MasterToSlaveFileCallable&lt;Void&gt; {
&nbsp;        private final Pipe pipe;
&nbsp;        private final String description;
&nbsp;        private final TarCompression compression;
&nbsp;        private final FilePath target;
&nbsp;
<b class="fc">&nbsp;        ReadFromTar(FilePath target, Pipe pipe, String description, @NonNull TarCompression compression) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
<b class="fc">&nbsp;            this.pipe = pipe;</b>
<b class="fc">&nbsp;            this.description = description;</b>
<b class="fc">&nbsp;            this.compression = compression;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Void invoke(File f, VirtualChannel channel) throws IOException {
<b class="fc">&nbsp;            try (InputStream in = pipe.getIn()) {</b>
<b class="fc">&nbsp;                readFromTar(target.remote + &#39;/&#39; + description, f, compression.extract(in));</b>
<b class="fc">&nbsp;                return null;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class WriteToTar extends MasterToSlaveFileCallable&lt;Integer&gt; {
&nbsp;        private final DirScanner scanner;
&nbsp;        private final Pipe pipe;
&nbsp;        private final TarCompression compression;
&nbsp;
<b class="fc">&nbsp;        WriteToTar(DirScanner scanner, Pipe pipe, @NonNull TarCompression compression) {</b>
<b class="fc">&nbsp;            this.scanner = scanner;</b>
<b class="fc">&nbsp;            this.pipe = pipe;</b>
<b class="fc">&nbsp;            this.compression = compression;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer invoke(File f, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            return writeToTar(f, scanner, compression.compress(pipe.getOut()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class CopyRecursiveRemoteToLocal extends MasterToSlaveFileCallable&lt;Integer&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final Pipe pipe;
&nbsp;        private final DirScanner scanner;
&nbsp;        private final TarCompression compression;
&nbsp;
<b class="nc">&nbsp;        CopyRecursiveRemoteToLocal(Pipe pipe, DirScanner scanner, @NonNull TarCompression compression) {</b>
<b class="nc">&nbsp;            this.pipe = pipe;</b>
<b class="nc">&nbsp;            this.scanner = scanner;</b>
<b class="nc">&nbsp;            this.compression = compression;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Integer invoke(File f, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            try (OutputStream out = pipe.getOut()) {</b>
<b class="nc">&nbsp;                return writeToTar(f, scanner, compression.compress(out));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes files in &#39;this&#39; directory to a tar stream.
&nbsp;     *
&nbsp;     * @param glob
&nbsp;     *      Ant file pattern mask, like &quot;**&amp;#x2F;*.java&quot;.
&nbsp;     */
&nbsp;    public int tar(OutputStream out, final String glob) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return archive(ArchiverFactory.TAR, out, glob);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int tar(OutputStream out, FileFilter filter) throws IOException, InterruptedException {
<b class="nc">&nbsp;        return archive(ArchiverFactory.TAR, out, filter);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Uses the given scanner on &#39;this&#39; directory to list up files and then archive it to a tar stream.
&nbsp;     */
&nbsp;    public int tar(OutputStream out, DirScanner scanner) throws IOException, InterruptedException {
<b class="nc">&nbsp;        return archive(ArchiverFactory.TAR, out, scanner);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes to a tar stream and stores obtained files to the base dir.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      number of files/directories that are written.
&nbsp;     */
&nbsp;    private static Integer writeToTar(File baseDir, DirScanner scanner, OutputStream out) throws IOException {
<b class="fc">&nbsp;        Archiver tw = ArchiverFactory.TAR.create(out);</b>
<b class="fc">&nbsp;        try (tw) {</b>
<b class="fc">&nbsp;            scanner.scan(baseDir, tw);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return tw.countEntries();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads from a tar stream and stores obtained files to the base dir.
&nbsp;     * Supports large files &gt; 10 GB since 1.627 when this was migrated to use commons-compress.
&nbsp;     */
&nbsp;    private static void readFromTar(String name, File baseDir, InputStream in) throws IOException {
&nbsp;
&nbsp;        // TarInputStream t = new TarInputStream(in);
<b class="fc">&nbsp;        try (TarArchiveInputStream t = new TarArchiveInputStream(in)) {</b>
&nbsp;            TarArchiveEntry te;
<b class="fc">&nbsp;            while ((te = t.getNextTarEntry()) != null) {</b>
<b class="fc">&nbsp;                File f = new File(baseDir, te.getName());</b>
<b class="fc">&nbsp;                if (!f.toPath().normalize().startsWith(baseDir.toPath())) {</b>
<b class="nc">&nbsp;                    throw new IOException(</b>
<b class="nc">&nbsp;                            &quot;Tar &quot; + name + &quot; contains illegal file name that breaks out of the target directory: &quot; + te.getName());</b>
&nbsp;                }
<b class="fc">&nbsp;                if (te.isDirectory()) {</b>
<b class="nc">&nbsp;                    mkdirs(f);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    File parent = f.getParentFile();</b>
<b class="fc">&nbsp;                    if (parent != null) mkdirs(parent);</b>
&nbsp;
<b class="fc">&nbsp;                    if (te.isSymbolicLink()) {</b>
<b class="nc">&nbsp;                        new FilePath(f).symlinkTo(te.getLinkName(), TaskListener.NULL);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        IOUtils.copy(t, f);</b>
&nbsp;
<b class="fc">&nbsp;                        Files.setLastModifiedTime(Util.fileToPath(f), FileTime.from(te.getModTime().toInstant()));</b>
<b class="fc">&nbsp;                        int mode = te.getMode() &amp; 0777;</b>
<b class="fc">&nbsp;                        if (mode != 0 &amp;&amp; !Functions.isWindows()) // be defensive</b>
<b class="nc">&nbsp;                            _chmod(f, mode);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to extract &quot; + name, e);</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;            Thread.currentThread().interrupt(); // process this later</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to extract &quot; + name, e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Launcher} for starting processes on the node
&nbsp;     * that has this file.
&nbsp;     * @since 1.89
&nbsp;     */
&nbsp;    public Launcher createLauncher(TaskListener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null)</b>
<b class="nc">&nbsp;            return new LocalLauncher(listener);</b>
&nbsp;        else
<b class="nc">&nbsp;            return new RemoteLauncher(listener, channel, channel.call(new IsUnix()));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final class IsUnix extends MasterToSlaveCallable&lt;Boolean, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        @NonNull
&nbsp;        public Boolean call() throws IOException {
<b class="nc">&nbsp;            return File.pathSeparatorChar == &#39;:&#39;;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #validateAntFileMask(String, int)} with (practically) unbounded number of operations.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      null if no error was found. Otherwise, returns a human-readable error message.
&nbsp;     * @since 1.90
&nbsp;     * @see #validateFileMask(FilePath, String)
&nbsp;     * @deprecated use {@link #validateAntFileMask(String, int)} instead
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public String validateAntFileMask(final String fileMasks) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return validateAntFileMask(fileMasks, Integer.MAX_VALUE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #validateAntFileMask(String, int, boolean)} with caseSensitive set to true.
&nbsp;     */
&nbsp;    public String validateAntFileMask(final String fileMasks, final int bound) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return validateAntFileMask(fileMasks, bound, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #validateAntFileMask(String, int, boolean)} with the default number of operations.
&nbsp;     * @see #VALIDATE_ANT_FILE_MASK_BOUND
&nbsp;     * @since 2.325
&nbsp;     */
&nbsp;    public String validateAntFileMask(final String fileMasks, final boolean caseSensitive) throws IOException, InterruptedException {
<b class="nc">&nbsp;        return validateAntFileMask(fileMasks, VALIDATE_ANT_FILE_MASK_BOUND, caseSensitive);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Default bound for {@link #validateAntFileMask(String, int, boolean)}.
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static int VALIDATE_ANT_FILE_MASK_BOUND = SystemProperties.getInteger(FilePath.class.getName() + &quot;.VALIDATE_ANT_FILE_MASK_BOUND&quot;, 10000);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A dedicated subtype of {@link InterruptedException} for when no matching Ant file mask
&nbsp;     * matches are found.
&nbsp;     *
&nbsp;     * @see ArtifactArchiver
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static class FileMaskNoMatchesFoundException extends InterruptedException {
&nbsp;        private FileMaskNoMatchesFoundException(String message) {
<b class="fc">&nbsp;            super(message);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Validates the ant file mask (like &quot;foo/bar/*.txt, zot/*.jar&quot;) against this directory, and try to point out the problem.
&nbsp;     * This performs only a bounded number of operations.
&nbsp;     *
&nbsp;     * &lt;p&gt;Whereas the unbounded overload is appropriate for calling from cancelable, long-running tasks such as build steps,
&nbsp;     * this overload should be used when an answer is needed quickly, such as for {@link #validateFileMask(String)}
&nbsp;     * or anything else returning {@link FormValidation}.
&nbsp;     *
&nbsp;     * &lt;p&gt;If a positive match is found, {@code null} is returned immediately.
&nbsp;     * A message is returned in case the file pattern can definitely be determined to not match anything in the directory within the alloted time.
&nbsp;     * If the time runs out without finding a match but without ruling out the possibility that there might be one, {@link InterruptedException} is thrown,
&nbsp;     * in which case the calling code should give the user the benefit of the doubt and use {@link hudson.util.FormValidation.Kind#OK} (with or without a message).
&nbsp;     *
&nbsp;     * &lt;p&gt;While this can be used in conjunction with {@link FormValidation}, it&#39;s generally better to use {@link #validateFileMask(String)} and
&nbsp;     * its overloads for use in {@code doCheck} form validation methods related to workspaces, as that performs an appropriate permission check.
&nbsp;     * Callers of this method or its overloads from web methods should ensure permissions are checked before this method is invoked.
&nbsp;     *
&nbsp;     * @param bound a maximum number of negative operations (deliberately left vague) to perform before giving up on a precise answer; try {@link #VALIDATE_ANT_FILE_MASK_BOUND}
&nbsp;     * @throws InterruptedException not only in case of a channel failure, but also if too many operations were performed without finding any matches
&nbsp;     * @since 1.484
&nbsp;     */
&nbsp;    public @CheckForNull String validateAntFileMask(final String fileMasks, final int bound, final boolean caseSensitive) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new ValidateAntFileMask(fileMasks, caseSensitive, bound));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class ValidateAntFileMask extends MasterToSlaveFileCallable&lt;String&gt; {
&nbsp;        private final String fileMasks;
&nbsp;        private final boolean caseSensitive;
&nbsp;        private final int bound;
&nbsp;
<b class="fc">&nbsp;        ValidateAntFileMask(String fileMasks, boolean caseSensitive, int bound) {</b>
<b class="fc">&nbsp;            this.fileMasks = fileMasks;</b>
<b class="fc">&nbsp;            this.caseSensitive = caseSensitive;</b>
<b class="fc">&nbsp;            this.bound = bound;</b>
&nbsp;        }
&nbsp;
&nbsp;            private static final long serialVersionUID = 1;
&nbsp;
&nbsp;            @Override
&nbsp;            public String invoke(File dir, VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;                if (fileMasks.startsWith(&quot;~&quot;))</b>
<b class="nc">&nbsp;                    return Messages.FilePath_TildaDoesntWork();</b>
&nbsp;
<b class="fc">&nbsp;                StringTokenizer tokens = new StringTokenizer(fileMasks, &quot;,&quot;);</b>
&nbsp;
<b class="fc">&nbsp;                while (tokens.hasMoreTokens()) {</b>
<b class="fc">&nbsp;                    final String fileMask = tokens.nextToken().trim();</b>
<b class="fc">&nbsp;                    if (hasMatch(dir, fileMask, caseSensitive))</b>
<b class="fc">&nbsp;                        continue;   // no error on this portion</b>
&nbsp;
&nbsp;                    // JENKINS-5253 - if we can get some match in case-insensitive mode
&nbsp;                    // and user requested case-sensitive match, notify the user
<b class="fc">&nbsp;                    if (caseSensitive &amp;&amp; hasMatch(dir, fileMask, false)) {</b>
<b class="fc">&nbsp;                        return Messages.FilePath_validateAntFileMask_matchWithCaseInsensitive(fileMask);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // in 1.172 we introduced an incompatible change to stop using &#39; &#39; as the separator
&nbsp;                    // so see if we can match by using &#39; &#39; as the separator
<b class="fc">&nbsp;                    if (fileMask.contains(&quot; &quot;)) {</b>
<b class="nc">&nbsp;                        boolean matched = true;</b>
<b class="nc">&nbsp;                        for (String token : Util.tokenize(fileMask))</b>
<b class="nc">&nbsp;                            matched &amp;= hasMatch(dir, token, caseSensitive);</b>
<b class="nc">&nbsp;                        if (matched)</b>
<b class="nc">&nbsp;                            return Messages.FilePath_validateAntFileMask_whitespaceSeparator();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // a common mistake is to assume the wrong base dir, and there are two variations
&nbsp;                    // to this: (1) the user gave us aa/bb/cc/dd where cc/dd was correct
&nbsp;                    // and (2) the user gave us cc/dd where aa/bb/cc/dd was correct.
&nbsp;
&nbsp;                    { // check the (1) above first
<b class="fc">&nbsp;                        String f = fileMask;</b>
&nbsp;                        while (true) {
<b class="fc">&nbsp;                            int idx = findSeparator(f);</b>
<b class="fc">&nbsp;                            if (idx == -1)     break;</b>
<b class="fc">&nbsp;                            f = f.substring(idx + 1);</b>
&nbsp;
<b class="fc">&nbsp;                            if (hasMatch(dir, f, caseSensitive))</b>
<b class="nc">&nbsp;                                return Messages.FilePath_validateAntFileMask_doesntMatchAndSuggest(fileMask, f);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    { // check the (2) above next as this is more expensive.
&nbsp;                        // Try prepending &quot;**/&quot; to see if that results in a match
<b class="fc">&nbsp;                        FileSet fs = Util.createFileSet(dir, &quot;**/&quot; + fileMask);</b>
<b class="fc">&nbsp;                        fs.setCaseSensitive(caseSensitive);</b>
<b class="fc">&nbsp;                        DirectoryScanner ds = fs.getDirectoryScanner(new Project());</b>
<b class="fc">&nbsp;                        if (ds.getIncludedFilesCount() != 0) {</b>
&nbsp;                            // try shorter name first so that the suggestion results in the least amount of changes
<b class="fc">&nbsp;                            String[] names = ds.getIncludedFiles();</b>
<b class="fc">&nbsp;                            Arrays.sort(names, SHORTER_STRING_FIRST);</b>
<b class="fc">&nbsp;                            for (String f : names) {</b>
&nbsp;                                // now we want to decompose f to the leading portion that matched &quot;**&quot;
&nbsp;                                // and the trailing portion that matched the file mask, so that
&nbsp;                                // we can suggest the user error.
&nbsp;                                //
&nbsp;                                // this is not a very efficient/clever way to do it, but it&#39;s relatively simple
&nbsp;
<b class="fc">&nbsp;                                StringBuilder prefix = new StringBuilder();</b>
&nbsp;                                while (true) {
<b class="fc">&nbsp;                                    int idx = findSeparator(f);</b>
<b class="fc">&nbsp;                                    if (idx == -1)     break;</b>
&nbsp;
<b class="fc">&nbsp;                                    prefix.append(f, 0, idx).append(&#39;/&#39;);</b>
<b class="fc">&nbsp;                                    f = f.substring(idx + 1);</b>
<b class="fc">&nbsp;                                    if (hasMatch(dir, prefix + fileMask, caseSensitive))</b>
<b class="fc">&nbsp;                                        return Messages.FilePath_validateAntFileMask_doesntMatchAndSuggest(fileMask, prefix + fileMask);</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    { // finally, see if we can identify any sub portion that&#39;s valid. Otherwise, bail out
<b class="fc">&nbsp;                        String previous = null;</b>
<b class="fc">&nbsp;                        String pattern = fileMask;</b>
&nbsp;
&nbsp;                        while (true) {
<b class="fc">&nbsp;                            if (hasMatch(dir, pattern, caseSensitive)) {</b>
&nbsp;                                // found a match
<b class="fc">&nbsp;                                if (previous == null)</b>
<b class="nc">&nbsp;                                    return Messages.FilePath_validateAntFileMask_portionMatchAndSuggest(fileMask, pattern);</b>
&nbsp;                                else
<b class="fc">&nbsp;                                    return Messages.FilePath_validateAntFileMask_portionMatchButPreviousNotMatchAndSuggest(fileMask, pattern, previous);</b>
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            int idx = findSeparator(pattern);</b>
<b class="fc">&nbsp;                            if (idx &lt; 0) { // no more path component left to go back</b>
<b class="fc">&nbsp;                                if (pattern.equals(fileMask))</b>
<b class="fc">&nbsp;                                    return Messages.FilePath_validateAntFileMask_doesntMatchAnything(fileMask);</b>
&nbsp;                                else
<b class="nc">&nbsp;                                    return Messages.FilePath_validateAntFileMask_doesntMatchAnythingAndSuggest(fileMask, pattern);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            // cut off the trailing component and try again
<b class="fc">&nbsp;                            previous = pattern;</b>
<b class="fc">&nbsp;                            pattern = pattern.substring(0, idx);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                return null; // no error</b>
&nbsp;            }
&nbsp;
&nbsp;            private boolean hasMatch(File dir, String pattern, boolean bCaseSensitive) throws InterruptedException {
<b class="fc">&nbsp;                class Cancel extends RuntimeException {}</b>
&nbsp;
<b class="fc">&nbsp;                DirectoryScanner ds = bound == Integer.MAX_VALUE ? new DirectoryScanner() : new DirectoryScanner() {</b>
&nbsp;                    int ticks;
<b class="fc">&nbsp;                    long start = System.currentTimeMillis();</b>
&nbsp;                    @Override public synchronized boolean isCaseSensitive() {
<b class="fc">&nbsp;                        if (!filesIncluded.isEmpty() || !dirsIncluded.isEmpty() || ticks++ &gt; bound || System.currentTimeMillis() - start &gt; 5000) {</b>
<b class="fc">&nbsp;                            throw new Cancel();</b>
&nbsp;                        }
<b class="fc">&nbsp;                        filesNotIncluded.clear();</b>
<b class="fc">&nbsp;                        dirsNotIncluded.clear();</b>
&nbsp;                        // notFollowedSymlinks might be large, but probably unusual
&nbsp;                        // scannedDirs will typically be largish, but seems to be needed
<b class="fc">&nbsp;                        return super.isCaseSensitive();</b>
&nbsp;                    }
&nbsp;                };
<b class="fc">&nbsp;                ds.setBasedir(dir);</b>
<b class="fc">&nbsp;                ds.setIncludes(new String[] {pattern});</b>
<b class="fc">&nbsp;                ds.setCaseSensitive(bCaseSensitive);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    ds.scan();</b>
<b class="fc">&nbsp;                } catch (Cancel c) {</b>
<b class="fc">&nbsp;                    if (ds.getIncludedFilesCount() != 0 || ds.getIncludedDirsCount() != 0) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        throw (FileMaskNoMatchesFoundException) new FileMaskNoMatchesFoundException(&quot;no matches found within &quot; + bound).initCause(c);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return ds.getIncludedFilesCount() != 0 || ds.getIncludedDirsCount() != 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finds the position of the first path separator.
&nbsp;             */
&nbsp;            private int findSeparator(String pattern) {
<b class="fc">&nbsp;                int idx1 = pattern.indexOf(&#39;\\&#39;);</b>
<b class="fc">&nbsp;                int idx2 = pattern.indexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;                if (idx1 == -1)    return idx2;</b>
<b class="fc">&nbsp;                if (idx2 == -1)    return idx1;</b>
<b class="nc">&nbsp;                return Math.min(idx1, idx2);</b>
&nbsp;            }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final UrlFactory DEFAULT_URL_FACTORY = new UrlFactory();</b>
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
<b class="fc">&nbsp;    static class UrlFactory {</b>
&nbsp;        public URL newURL(String location) throws MalformedURLException {
<b class="nc">&nbsp;            return new URL(location);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private UrlFactory urlFactory;
&nbsp;
&nbsp;    @VisibleForTesting
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    void setUrlFactory(UrlFactory urlFactory) {
<b class="fc">&nbsp;        this.urlFactory = urlFactory;</b>
&nbsp;    }
&nbsp;
&nbsp;    private UrlFactory getUrlFactory() {
<b class="fc">&nbsp;        if (urlFactory != null) {</b>
<b class="fc">&nbsp;            return urlFactory;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return DEFAULT_URL_FACTORY;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Short for {@code validateFileMask(path, value, true)}
&nbsp;     */
&nbsp;    public static FormValidation validateFileMask(@CheckForNull FilePath path, String value) throws IOException {
<b class="nc">&nbsp;        return FilePath.validateFileMask(path, value, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shortcut for {@link #validateFileMask(String,boolean,boolean)} with {@code errorIfNotExist} true, as the left-hand side can be null.
&nbsp;     */
&nbsp;    public static FormValidation validateFileMask(@CheckForNull FilePath path, String value, boolean caseSensitive) throws IOException {
<b class="nc">&nbsp;        if (path == null) return FormValidation.ok();</b>
<b class="nc">&nbsp;        return path.validateFileMask(value, true, caseSensitive);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Short for {@code validateFileMask(value, true, true)}
&nbsp;     */
&nbsp;    public FormValidation validateFileMask(String value) throws IOException {
<b class="nc">&nbsp;        return validateFileMask(value, true, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Short for {@code validateFileMask(value, errorIfNotExist, true)}
&nbsp;     */
&nbsp;    public FormValidation validateFileMask(String value, boolean errorIfNotExist) throws IOException {
<b class="nc">&nbsp;        return validateFileMask(value, errorIfNotExist, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the GLOB-style file mask. See {@link #validateAntFileMask(String)}.
&nbsp;     * Requires configure permission on ancestor {@link AbstractProject} object in request,
&nbsp;     * or {@link Jenkins#MANAGE} permission if no such ancestor is found.
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that this permission check may not always make sense based on the directory provided;
&nbsp;     * callers should consider using {@link #validateFileMask(FilePath, String, boolean)} and its overloads instead
&nbsp;     * (once appropriate permission checks have succeeded).
&nbsp;     *
&nbsp;     * @since 1.294
&nbsp;     */
&nbsp;    public FormValidation validateFileMask(String value, boolean errorIfNotExist, boolean caseSensitive) throws IOException {
<b class="nc">&nbsp;        checkPermissionForValidate();</b>
&nbsp;
<b class="nc">&nbsp;        value = fixEmpty(value);</b>
<b class="nc">&nbsp;        if (value == null)</b>
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            if (!exists()) // no workspace. can&#39;t check</b>
<b class="nc">&nbsp;                return FormValidation.ok();</b>
&nbsp;
<b class="nc">&nbsp;            String msg = validateAntFileMask(value, VALIDATE_ANT_FILE_MASK_BOUND, caseSensitive);</b>
<b class="nc">&nbsp;            if (errorIfNotExist)     return FormValidation.error(msg);</b>
<b class="nc">&nbsp;            else                    return FormValidation.warning(msg);</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;            return FormValidation.ok(Messages.FilePath_did_not_manage_to_validate_may_be_too_sl(value));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Validates a relative file path from this {@link FilePath}.
&nbsp;     * Requires configure permission on ancestor {@link AbstractProject} object in request,
&nbsp;     * or {@link Jenkins#MANAGE} permission if no such ancestor is found.
&nbsp;     *
&nbsp;     * &lt;p&gt;Note that this permission check may not always make sense based on the directory provided;
&nbsp;     * callers should consider using {@link #validateFileMask(FilePath, String, boolean)} and its overloads instead
&nbsp;     * (once appropriate permission checks have succeeded).
&nbsp;     *
&nbsp;     * @param value
&nbsp;     *      The relative path being validated.
&nbsp;     * @param errorIfNotExist
&nbsp;     *      If true, report an error if the given relative path doesn&#39;t exist. Otherwise, it&#39;s a warning.
&nbsp;     * @param expectingFile
&nbsp;     *      If true, we expect the relative path to point to a file.
&nbsp;     *      Otherwise, the relative path is expected to be pointing to a directory.
&nbsp;     */
&nbsp;    public FormValidation validateRelativePath(String value, boolean errorIfNotExist, boolean expectingFile) throws IOException {
<b class="nc">&nbsp;        checkPermissionForValidate();</b>
&nbsp;
<b class="nc">&nbsp;        value = fixEmpty(value);</b>
&nbsp;
&nbsp;        // none entered yet, or something is seriously wrong
<b class="nc">&nbsp;        if (value == null) return FormValidation.ok();</b>
&nbsp;
&nbsp;        // a common mistake is to use wildcard
<b class="nc">&nbsp;        if (value.contains(&quot;*&quot;)) return FormValidation.error(Messages.FilePath_validateRelativePath_wildcardNotAllowed());</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            if (!exists())    // no base directory. can&#39;t check</b>
<b class="nc">&nbsp;                return FormValidation.ok();</b>
&nbsp;
<b class="nc">&nbsp;            FilePath path = child(value);</b>
<b class="nc">&nbsp;            if (path.exists()) {</b>
<b class="nc">&nbsp;                if (expectingFile) {</b>
<b class="nc">&nbsp;                    if (!path.isDirectory())</b>
<b class="nc">&nbsp;                        return FormValidation.ok();</b>
&nbsp;                    else
<b class="nc">&nbsp;                        return FormValidation.error(Messages.FilePath_validateRelativePath_notFile(value));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (path.isDirectory())</b>
<b class="nc">&nbsp;                        return FormValidation.ok();</b>
&nbsp;                    else
<b class="nc">&nbsp;                        return FormValidation.error(Messages.FilePath_validateRelativePath_notDirectory(value));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String msg = expectingFile ? Messages.FilePath_validateRelativePath_noSuchFile(value) :</b>
<b class="nc">&nbsp;                Messages.FilePath_validateRelativePath_noSuchDirectory(value);</b>
<b class="nc">&nbsp;            if (errorIfNotExist)     return FormValidation.error(msg);</b>
<b class="nc">&nbsp;            else                    return FormValidation.warning(msg);</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void checkPermissionForValidate() {
<b class="nc">&nbsp;        AccessControlled subject = Stapler.getCurrentRequest().findAncestorObject(AbstractProject.class);</b>
<b class="nc">&nbsp;        if (subject == null)</b>
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.MANAGE);</b>
&nbsp;        else
<b class="nc">&nbsp;            subject.checkPermission(Item.CONFIGURE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A convenience method over {@link #validateRelativePath(String, boolean, boolean)}.
&nbsp;     */
&nbsp;    public FormValidation validateRelativeDirectory(String value, boolean errorIfNotExist) throws IOException {
<b class="nc">&nbsp;        return validateRelativePath(value, errorIfNotExist, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    public FormValidation validateRelativeDirectory(String value) throws IOException {
<b class="nc">&nbsp;        return validateRelativeDirectory(value, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated @Override
&nbsp;    public String toString() {
&nbsp;        // to make writing JSPs easily, return local
<b class="nc">&nbsp;        return remote;</b>
&nbsp;    }
&nbsp;
&nbsp;    public VirtualChannel getChannel() {
<b class="fc">&nbsp;        if (channel != null)   return channel;</b>
<b class="fc">&nbsp;        else                return localChannel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this {@link FilePath} represents a remote file.
&nbsp;     */
&nbsp;    public boolean isRemote() {
<b class="fc">&nbsp;        return channel != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void writeObject(ObjectOutputStream oos) throws IOException {
<b class="fc">&nbsp;        Channel target = _getChannelForSerialization();</b>
<b class="fc">&nbsp;        if (channel != null &amp;&amp; channel != target) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Can&#39;t send a remote FilePath to a different remote channel (current=&quot; + channel + &quot;, target=&quot; + target + &quot;)&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        oos.defaultWriteObject();</b>
<b class="fc">&nbsp;        oos.writeBoolean(channel == null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Channel _getChannelForSerialization() {
&nbsp;        try {
<b class="fc">&nbsp;            return getChannelForSerialization();</b>
<b class="nc">&nbsp;        } catch (NotSerializableException x) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;A FilePath object is being serialized when it should not be, indicating a bug in a plugin. See https://www.jenkins.io/redirect/filepath-serialization for details.&quot;, x);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
<b class="fc">&nbsp;        Channel channel = _getChannelForSerialization();</b>
&nbsp;
<b class="fc">&nbsp;        ois.defaultReadObject();</b>
<b class="fc">&nbsp;        if (ois.readBoolean()) {</b>
<b class="nc">&nbsp;            this.channel = channel;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            this.channel = null;</b>
&nbsp;            // If the remote channel wants us to create a FilePath that points to a local file,
&nbsp;            // we need to make sure the access control takes place.
&nbsp;            // Any FileCallables acting on a deserialized FilePath need to ensure they&#39;re subjecting it to
&nbsp;            // access control checks like #reading(File) etc.
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @RestrictedSince(&quot;2.328&quot;)
&nbsp;    public static final int SIDE_BUFFER_SIZE = 1024;
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(FilePath.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Adapts {@link FileCallable} to {@link Callable}.
&nbsp;     */
&nbsp;    private static class FileCallableWrapper&lt;T&gt; implements DelegatingCallable&lt;T, IOException&gt; {
&nbsp;        private final FileCallable&lt;T&gt; callable;
&nbsp;        private transient ClassLoader classLoader;
&nbsp;        private final FilePath filePath;
&nbsp;
<b class="fc">&nbsp;        FileCallableWrapper(FileCallable&lt;T&gt; callable, FilePath filePath) {</b>
<b class="fc">&nbsp;            this.callable = callable;</b>
<b class="fc">&nbsp;            this.classLoader = callable.getClass().getClassLoader();</b>
<b class="fc">&nbsp;            this.filePath = filePath;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        private FileCallableWrapper(FileCallable&lt;T&gt; callable, ClassLoader classLoader, FilePath filePath) {</b>
<b class="fc">&nbsp;            this.callable = callable;</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
<b class="fc">&nbsp;            this.filePath = filePath;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public T call() throws IOException {
&nbsp;            try {
<b class="fc">&nbsp;                return callable.invoke(new File(filePath.remote), filePath.channel);</b>
<b class="fc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="fc">&nbsp;                throw new TunneledInterruptedException(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Role check comes from {@link FileCallable}s.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void checkRoles(RoleChecker checker) throws SecurityException {
<b class="nc">&nbsp;            callable.checkRoles(checker);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public ClassLoader getClassLoader() {
<b class="fc">&nbsp;            return classLoader;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return callable.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to tunnel {@link InterruptedException} over a Java signature that only allows {@link IOException}
&nbsp;     */
&nbsp;    private static class TunneledInterruptedException extends IOException {
&nbsp;        private TunneledInterruptedException(InterruptedException cause) {
<b class="fc">&nbsp;            super(cause);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final Comparator&lt;String&gt; SHORTER_STRING_FIRST = Comparator.comparingInt(String::length);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link FilePath} representation of the &quot;~&quot; directory
&nbsp;     * (User&#39;s home directory in the Unix sense) of the given channel.
&nbsp;     */
&nbsp;    public static FilePath getHomeDirectory(VirtualChannel ch) throws InterruptedException, IOException {
<b class="nc">&nbsp;        return ch.call(new GetHomeDirectory());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class GetHomeDirectory extends MasterToSlaveCallable&lt;FilePath, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public FilePath call() throws IOException {
<b class="nc">&nbsp;            return new FilePath(new File(System.getProperty(&quot;user.home&quot;)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper class to make it easy to send an explicit list of files using {@link FilePath} methods.
&nbsp;     * @since 1.532
&nbsp;     */
<b class="nc">&nbsp;    public static final class ExplicitlySpecifiedDirScanner extends DirScanner {</b>
&nbsp;
&nbsp;        private static final long serialVersionUID = 1;
&nbsp;
&nbsp;        private final Map&lt;String, String&gt; files;
&nbsp;
&nbsp;        /**
&nbsp;         * Create a scanner (it actually does no scanning).
&nbsp;         * @param files a map from logical relative paths as per {@link FileVisitor#visit}, to actual relative paths within the scanned directory
&nbsp;         */
<b class="nc">&nbsp;        public ExplicitlySpecifiedDirScanner(Map&lt;String, String&gt; files) {</b>
<b class="nc">&nbsp;            this.files = files;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override public void scan(File dir, FileVisitor visitor) throws IOException {
<b class="nc">&nbsp;            for (Map.Entry&lt;String, String&gt; entry : files.entrySet()) {</b>
<b class="nc">&nbsp;                String archivedPath = entry.getKey();</b>
<b class="nc">&nbsp;                assert archivedPath.indexOf(&#39;\\&#39;) == -1;</b>
<b class="nc">&nbsp;                String workspacePath = entry.getValue();</b>
<b class="nc">&nbsp;                assert workspacePath.indexOf(&#39;\\&#39;) == -1;</b>
<b class="nc">&nbsp;                scanSingle(new File(dir, workspacePath), archivedPath, visitor);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final ExecutorService threadPoolForRemoting = new ContextResettingExecutorService(</b>
<b class="fc">&nbsp;            Executors.newCachedThreadPool(</b>
&nbsp;                    new ExceptionCatchingThreadFactory(
&nbsp;                            new NamingThreadFactory(new DaemonThreadFactory(), &quot;FilePath.localPool&quot;))
&nbsp;            ));
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Channel to the current instance.
&nbsp;     */
&nbsp;    @NonNull
<b class="fc">&nbsp;    public static final LocalChannel localChannel = new LocalChannel(threadPoolForRemoting);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps {@link FileVisitor} to ignore symlinks.
&nbsp;     */
&nbsp;    public static FileVisitor ignoringSymlinks(final FileVisitor v, String verificationRoot, OpenOption... openOptions) {
<b class="fc">&nbsp;        return validatingVisitor(FilePath::isNoFollowLink,</b>
<b class="fc">&nbsp;                visitorInfo -&gt; !isSymlink(visitorInfo),</b>
&nbsp;                v, verificationRoot, openOptions);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps {@link FileVisitor} to ignore tmp directories.
&nbsp;     */
&nbsp;    public static FileVisitor ignoringTmpDirs(final FileVisitor v, String verificationRoot, OpenOption... openOptions) {
<b class="fc">&nbsp;        return validatingVisitor(FilePath::isIgnoreTmpDirs,</b>
<b class="nc">&nbsp;                visitorInfo -&gt; !isTmpDir(visitorInfo),</b>
&nbsp;                v, verificationRoot, openOptions);
&nbsp;    }
&nbsp;
&nbsp;    private static FileVisitor validatingVisitor(Predicate&lt;OpenOption[]&gt; gater, Predicate&lt;VisitorInfo&gt; matcher,
&nbsp;                                                 final FileVisitor v, String verificationRoot, OpenOption... openOptions) {
<b class="fc">&nbsp;        if (gater.test(openOptions)) {</b>
<b class="fc">&nbsp;            return new FileVisitor() {</b>
&nbsp;                @Override
&nbsp;                public void visit(File f, String relativePath) throws IOException {
<b class="fc">&nbsp;                    VisitorInfo visitorInfo = new VisitorInfo(f, verificationRoot, openOptions);</b>
<b class="fc">&nbsp;                    if (verificationRoot == null || matcher.test(visitorInfo)) {</b>
<b class="fc">&nbsp;                        v.visit(f, relativePath);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean understandsSymlink() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
<b class="fc">&nbsp;        return v;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean mkdirs(File dir) throws IOException {
<b class="fc">&nbsp;        if (dir.exists())   return false;</b>
<b class="fc">&nbsp;        Files.createDirectories(fileToPath(dir));</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static File mkdirsE(File dir) throws IOException {
<b class="fc">&nbsp;        if (dir.exists()) {</b>
<b class="fc">&nbsp;            return dir;</b>
&nbsp;        }
<b class="nc">&nbsp;        return IOUtils.mkdirs(dir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the relative child is really a descendant after symlink resolution if any.
&nbsp;     */
&nbsp;    public boolean isDescendant(@NonNull String potentialChildRelativePath) throws IOException, InterruptedException {
<b class="fc">&nbsp;        return act(new IsDescendant(potentialChildRelativePath));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class IsDescendant extends MasterToSlaveFileCallable&lt;Boolean&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private String potentialChildRelativePath;
&nbsp;
<b class="fc">&nbsp;        private IsDescendant(@NonNull String potentialChildRelativePath) {</b>
<b class="fc">&nbsp;            this.potentialChildRelativePath = potentialChildRelativePath;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean invoke(@NonNull File parentFile, @NonNull VirtualChannel channel) throws IOException, InterruptedException {
<b class="fc">&nbsp;            if (new File(potentialChildRelativePath).isAbsolute()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Only a relative path is supported, the given path is absolute: &quot; + potentialChildRelativePath);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            Path parentAbsolutePath = Util.fileToPath(parentFile.getAbsoluteFile());</b>
&nbsp;            Path parentRealPath;
&nbsp;            try {
<b class="fc">&nbsp;                if (Functions.isWindows()) {</b>
<b class="fc">&nbsp;                    parentRealPath = this.windowsToRealPath(parentAbsolutePath);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    parentRealPath = parentAbsolutePath.toRealPath();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            catch (NoSuchFileException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, String.format(&quot;Cannot find the real path to the parentFile: %s&quot;, parentAbsolutePath), e);</b>
<b class="nc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            // example: &quot;a/b/c&quot; that will become &quot;b/c&quot; then just &quot;c&quot;, and finally an empty string
<b class="fc">&nbsp;            String remainingPath = potentialChildRelativePath;</b>
&nbsp;
<b class="fc">&nbsp;            Path currentFilePath = parentFile.toPath();</b>
<b class="fc">&nbsp;            while (!remainingPath.isEmpty()) {</b>
<b class="fc">&nbsp;                Path directChild = this.getDirectChild(currentFilePath, remainingPath);</b>
<b class="fc">&nbsp;                Path childUsingFullPath = currentFilePath.resolve(remainingPath);</b>
<b class="fc">&nbsp;                String childUsingFullPathAbs = childUsingFullPath.toAbsolutePath().toString();</b>
<b class="fc">&nbsp;                String directChildAbs = directChild.toAbsolutePath().toString();</b>
&nbsp;
<b class="fc">&nbsp;                if (childUsingFullPathAbs.length() == directChildAbs.length()) {</b>
<b class="fc">&nbsp;                    remainingPath = &quot;&quot;;</b>
&nbsp;                } else {
&nbsp;                    // +1 to avoid the last slash
<b class="fc">&nbsp;                    remainingPath = childUsingFullPathAbs.substring(directChildAbs.length() + 1);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                File childFileSymbolic = Util.resolveSymlinkToFile(directChild.toFile());</b>
<b class="fc">&nbsp;                if (childFileSymbolic == null) {</b>
<b class="fc">&nbsp;                    currentFilePath = directChild;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    currentFilePath = childFileSymbolic.toPath();</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                Path currentFileAbsolutePath = currentFilePath.toAbsolutePath();</b>
&nbsp;                try {
<b class="fc">&nbsp;                    Path child = currentFileAbsolutePath.toRealPath();</b>
<b class="fc">&nbsp;                    if (!child.startsWith(parentRealPath)) {</b>
<b class="fc">&nbsp;                        LOGGER.log(Level.FINE, &quot;Child [{0}] does not start with parent [{1}] =&gt; not descendant&quot;, new Object[]{ child, parentRealPath });</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                } catch (NoSuchFileException e) {</b>
&nbsp;                    // nonexistent file / Windows Server 2016 + MSFT docker
&nbsp;                    // in case this folder / file will be copied somewhere else,
&nbsp;                    // it becomes the responsibility of that system to check the isDescendant with the existing links
&nbsp;                    // we are not taking the parentRealPath to avoid possible problem
<b class="fc">&nbsp;                    Path child = currentFileAbsolutePath.normalize();</b>
<b class="fc">&nbsp;                    Path parent = parentAbsolutePath.normalize();</b>
<b class="fc">&nbsp;                    return child.startsWith(parent);</b>
<b class="nc">&nbsp;                } catch (FileSystemException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, String.format(&quot;Problem during call to the method toRealPath on %s&quot;, currentFileAbsolutePath), e);</b>
<b class="nc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        private @CheckForNull Path getDirectChild(Path parentPath, String childPath) {
<b class="fc">&nbsp;            Path current = parentPath.resolve(childPath);</b>
<b class="fc">&nbsp;            while (current != null &amp;&amp; !parentPath.equals(current.getParent())) {</b>
<b class="fc">&nbsp;                current = current.getParent();</b>
&nbsp;            }
<b class="fc">&nbsp;            return current;</b>
&nbsp;        }
&nbsp;
&nbsp;        private @NonNull Path windowsToRealPath(@NonNull Path path) throws IOException {
&nbsp;            try {
<b class="fc">&nbsp;                return path.toRealPath();</b>
&nbsp;            }
<b class="nc">&nbsp;            catch (IOException e) {</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, String.format(&quot;relaxedToRealPath cannot use the regular toRealPath on %s, trying with toRealPath(LinkOption.NOFOLLOW_LINKS)&quot;, path), e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // that&#39;s required for specific environment like Windows Server 2016, running MSFT docker
&nbsp;            // where the root is a &lt;SYMLINKD&gt;
<b class="nc">&nbsp;            return path.toRealPath(LinkOption.NOFOLLOW_LINKS);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Path getRealPath(Path path) throws IOException {
<b class="fc">&nbsp;        return Functions.isWindows() ? windowsToRealPath(path) : path.toRealPath();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static @NonNull Path windowsToRealPath(@NonNull Path path) throws IOException {
&nbsp;        try {
<b class="fc">&nbsp;            return path.toRealPath();</b>
&nbsp;        }
<b class="fc">&nbsp;        catch (IOException e) {</b>
<b class="fc">&nbsp;            if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, String.format(&quot;relaxedToRealPath cannot use the regular toRealPath on %s, trying with toRealPath(LinkOption.NOFOLLOW_LINKS)&quot;, path), e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // that&#39;s required for specific environment like Windows Server 2016, running MSFT docker
&nbsp;        // where the root is a &lt;SYMLINKD&gt;
<b class="fc">&nbsp;        return path.toRealPath(LinkOption.NOFOLLOW_LINKS);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class OptionalDiscardingFileFilter implements FileFilter, Serializable {
&nbsp;
&nbsp;        private final String verificationRoot;
&nbsp;        private OpenOption[] openOptions;
&nbsp;
<b class="fc">&nbsp;        OptionalDiscardingFileFilter(FilePath verificationRoot, OpenOption... openOptions) {</b>
<b class="fc">&nbsp;            this.verificationRoot = verificationRoot == null ? null : verificationRoot.remote;</b>
<b class="fc">&nbsp;            this.openOptions = openOptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean accept(File file) {
<b class="fc">&nbsp;            return !isSymlink(file, verificationRoot, openOptions) &amp;&amp; !isTmpDir(file, verificationRoot, openOptions);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    private static class VisitorInfo {
&nbsp;        File f;
&nbsp;        String verificationRoot;
&nbsp;        OpenOption[] openOptions;
&nbsp;
<b class="fc">&nbsp;        VisitorInfo(File f, String verificationRoot, OpenOption[] openOptions) {</b>
<b class="fc">&nbsp;            this.f = f;</b>
<b class="fc">&nbsp;            this.verificationRoot = verificationRoot;</b>
<b class="fc">&nbsp;            this.openOptions = openOptions;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
