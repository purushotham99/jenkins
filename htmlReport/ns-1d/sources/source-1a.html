


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > NodeProvisioner</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.slaves</a>
</div>

<h1>Coverage Summary for Class: NodeProvisioner (hudson.slaves)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">NodeProvisioner</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/153)
  </span>
</td>
</tr>
  <tr>
    <td class="name">NodeProvisioner$NodeProvisionerInvoker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NodeProvisioner$PlannedNode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NodeProvisioner$StandardStrategyImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NodeProvisioner$Strategy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NodeProvisioner$StrategyDecision</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NodeProvisioner$StrategyState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/266)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.slaves;
&nbsp;
&nbsp;import static hudson.model.LoadStatistics.DECAY;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.AbortException;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.model.Computer;
&nbsp;import hudson.model.Label;
&nbsp;import hudson.model.LoadStatistics;
&nbsp;import hudson.model.MultiStageTimeSeries;
&nbsp;import hudson.model.MultiStageTimeSeries.TimeScale;
&nbsp;import hudson.model.Node;
&nbsp;import hudson.model.PeriodicWork;
&nbsp;import hudson.model.Queue;
&nbsp;import java.awt.Color;
&nbsp;import java.io.IOException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.Timer;
&nbsp;import net.jcip.annotations.GuardedBy;
&nbsp;import org.jenkinsci.Symbol;
&nbsp;
&nbsp;/**
&nbsp; * Uses the {@link LoadStatistics} and determines when we need to allocate
&nbsp; * new {@link Node}s through {@link Cloud}.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;public class NodeProvisioner {
&nbsp;    /**
&nbsp;     * The node addition activity in progress.
&nbsp;     */
&nbsp;    public static class PlannedNode {
&nbsp;        /**
&nbsp;         * Used to display this planned node to UI. Should ideally include the identifier unique to the node
&nbsp;         * being provisioned (like the instance ID), but if such an identifier doesn&#39;t readily exist, this
&nbsp;         * can be just a name of the template being provisioned (like the machine image ID.)
&nbsp;         */
&nbsp;        public final String displayName;
&nbsp;
&nbsp;        /**
&nbsp;         * Used to launch and return a {@link Node} object. {@link NodeProvisioner} will check
&nbsp;         * this {@link Future}&#39;s isDone() method to determine when to finalize this object.
&nbsp;         */
&nbsp;        public final Future&lt;Node&gt; future;
&nbsp;
&nbsp;        /**
&nbsp;         * The number of executors that will be provided by the {@link Node} launched by
&nbsp;         * this object. This is used for capacity planning in {@link NodeProvisioner#update}.
&nbsp;         */
&nbsp;        public final int numExecutors;
&nbsp;
&nbsp;        /**
&nbsp;         * Construct a PlannedNode instance without {@link Cloud} callback for finalization.
&nbsp;         *
&nbsp;         * @param displayName Used to display this object in the UI.
&nbsp;         * @param future Used to launch a @{link Node} object.
&nbsp;         * @param numExecutors The number of executors that will be provided by the launched {@link Node}.
&nbsp;         */
<b class="nc">&nbsp;        public PlannedNode(String displayName, Future&lt;Node&gt; future, int numExecutors) {</b>
<b class="nc">&nbsp;            if (displayName == null || future == null || numExecutors &lt; 1)  throw new IllegalArgumentException();</b>
<b class="nc">&nbsp;            this.displayName = displayName;</b>
<b class="nc">&nbsp;            this.future = future;</b>
<b class="nc">&nbsp;            this.numExecutors = numExecutors;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicate that this {@link PlannedNode} is being finalized.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * {@link NodeProvisioner} will call this method when it&#39;s done with {@link PlannedNode}.
&nbsp;         * This indicates that the {@link PlannedNode}&#39;s work has been completed
&nbsp;         * (successfully or otherwise) and it is about to be removed from the list of pending
&nbsp;         * {@link Node}s to be launched.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * Create a subtype of this class and override this method to add any necessary behaviour.
&nbsp;         *
&nbsp;         * @since 1.503
&nbsp;         */
&nbsp;        public void spent() {
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Load for the label.
&nbsp;     */
&nbsp;    private final LoadStatistics stat;
&nbsp;
&nbsp;    /**
&nbsp;     * For which label are we working?
&nbsp;     * Null if this {@link NodeProvisioner} is working for the entire Hudson,
&nbsp;     * for jobs that are unassigned to any particular node.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    private final Label label;
&nbsp;
<b class="nc">&nbsp;    private final AtomicReference&lt;List&lt;PlannedNode&gt;&gt; pendingLaunches</b>
&nbsp;            = new AtomicReference&lt;&gt;(new ArrayList&lt;&gt;());
&nbsp;
<b class="nc">&nbsp;    private final Lock provisioningLock = new ReentrantLock();</b>
&nbsp;
<b class="nc">&nbsp;    @GuardedBy(&quot;provisioningLock&quot;)</b>
&nbsp;    private StrategyState provisioningState = null;
&nbsp;
&nbsp;    private transient volatile long lastSuggestedReview;
&nbsp;    private transient volatile boolean queuedReview;
&nbsp;
&nbsp;    /**
&nbsp;     * Exponential moving average of the &quot;planned capacity&quot; over time, which is the number of
&nbsp;     * additional executors being brought up.
&nbsp;     *
&nbsp;     * This is used to filter out high-frequency components from the planned capacity, so that
&nbsp;     * the comparison with other low-frequency only variables won&#39;t leave spikes.
&nbsp;     */
<b class="nc">&nbsp;    private final MultiStageTimeSeries plannedCapacitiesEMA =</b>
<b class="nc">&nbsp;            new MultiStageTimeSeries(Messages._NodeProvisioner_EmptyString(), Color.WHITE, 0, DECAY);</b>
&nbsp;
<b class="nc">&nbsp;    public NodeProvisioner(@CheckForNull Label label, LoadStatistics loadStatistics) {</b>
<b class="nc">&nbsp;        this.label = label;</b>
<b class="nc">&nbsp;        this.stat = loadStatistics;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Nodes that are being launched.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      Can be empty but never null
&nbsp;     * @since 1.401
&nbsp;     */
&nbsp;    public List&lt;PlannedNode&gt; getPendingLaunches() {
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(pendingLaunches.get());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Give the {@link NodeProvisioner} a hint that now would be a good time to think about provisioning some nodes.
&nbsp;     * Hints are throttled to one every second.
&nbsp;     *
&nbsp;     * @since 1.415
&nbsp;     */
&nbsp;    public void suggestReviewNow() {
<b class="nc">&nbsp;        if (!queuedReview) {</b>
<b class="nc">&nbsp;            long delay = TimeUnit.SECONDS.toMillis(1) - (System.currentTimeMillis() - lastSuggestedReview);</b>
<b class="nc">&nbsp;            if (delay &lt; 0) {</b>
<b class="nc">&nbsp;                lastSuggestedReview = System.currentTimeMillis();</b>
<b class="nc">&nbsp;                Computer.threadPoolForRemoting.submit(() -&gt; {</b>
<b class="nc">&nbsp;                    LOGGER.fine(() -&gt; &quot;running suggested review for &quot; + label);</b>
<b class="nc">&nbsp;                    update();</b>
&nbsp;                });
&nbsp;            } else {
<b class="nc">&nbsp;                queuedReview = true;</b>
<b class="nc">&nbsp;                LOGGER.fine(() -&gt; &quot;running suggested review in &quot; + delay + &quot; ms for &quot; + label);</b>
<b class="nc">&nbsp;                Timer.get().schedule(() -&gt; {</b>
<b class="nc">&nbsp;                    lastSuggestedReview = System.currentTimeMillis();</b>
<b class="nc">&nbsp;                    LOGGER.fine(() -&gt; &quot;running suggested review for &quot; + label + &quot; after &quot; + delay + &quot; ms&quot;);</b>
<b class="nc">&nbsp;                    update();</b>
&nbsp;                }, delay, TimeUnit.MILLISECONDS);
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            LOGGER.fine(() -&gt; &quot;ignoring suggested review for &quot; + label);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Periodically invoked to keep track of the load.
&nbsp;     * Launches additional nodes if necessary.
&nbsp;     *
&nbsp;     * Note: This method will obtain a lock on {@link #provisioningLock} first (to ensure that one and only one
&nbsp;     * instance of this provisioner is running at a time) and then a lock on {@link Queue#lock}
&nbsp;     */
&nbsp;    private void update() {
<b class="nc">&nbsp;        long start = LOGGER.isLoggable(Level.FINER) ? System.nanoTime() : 0;</b>
<b class="nc">&nbsp;        provisioningLock.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            lastSuggestedReview = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            queuedReview = false;</b>
<b class="nc">&nbsp;            Jenkins jenkins = Jenkins.get();</b>
&nbsp;            // clean up the cancelled launch activity, then count the # of executors that we are about to
&nbsp;            // bring up.
&nbsp;
<b class="nc">&nbsp;            int plannedCapacitySnapshot = 0;</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;PlannedNode&gt; snapPendingLaunches = new ArrayList&lt;&gt;(pendingLaunches.get());</b>
<b class="nc">&nbsp;            for (PlannedNode f : snapPendingLaunches) {</b>
<b class="nc">&nbsp;                if (f.future.isDone()) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Node node = null;</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            node = f.future.get();</b>
<b class="nc">&nbsp;                        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                            throw new AssertionError(&quot;InterruptedException occurred&quot;, e); // since we confirmed that the future is already done</b>
<b class="nc">&nbsp;                        } catch (ExecutionException e) {</b>
<b class="nc">&nbsp;                            Throwable cause = e.getCause();</b>
<b class="nc">&nbsp;                            if (!(cause instanceof AbortException)) {</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.WARNING,</b>
&nbsp;                                        &quot;Unexpected exception encountered while provisioning agent &quot;
&nbsp;                                                + f.displayName,
&nbsp;                                        cause);
&nbsp;                            }
<b class="nc">&nbsp;                            fireOnFailure(f, cause);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
<b class="nc">&nbsp;                        if (node != null) {</b>
<b class="nc">&nbsp;                            fireOnComplete(f, node);</b>
&nbsp;
&nbsp;                            try {
<b class="nc">&nbsp;                                jenkins.addNode(node);</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.INFO,</b>
&nbsp;                                        &quot;{0} provisioning successfully completed. &quot;
&nbsp;                                                + &quot;We have now {1,number,integer} computer(s)&quot;,
<b class="nc">&nbsp;                                        new Object[]{f.displayName, jenkins.getComputers().length});</b>
<b class="nc">&nbsp;                                fireOnCommit(f, node);</b>
<b class="nc">&nbsp;                            } catch (IOException e) {</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.WARNING,</b>
&nbsp;                                        &quot;Provisioned agent &quot; + f.displayName + &quot; failed to launch&quot;,
&nbsp;                                        e);
<b class="nc">&nbsp;                                fireOnRollback(f, node, e);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (Error e) {</b>
&nbsp;                        // we are not supposed to try and recover from Errors
<b class="nc">&nbsp;                        throw e;</b>
<b class="nc">&nbsp;                    } catch (Throwable e) {</b>
&nbsp;                        // Just log it
<b class="nc">&nbsp;                        LOGGER.log(Level.SEVERE,</b>
&nbsp;                                &quot;Unexpected uncaught exception encountered while processing agent &quot;
&nbsp;                                        + f.displayName,
&nbsp;                                e);
&nbsp;                    } finally {
<b class="nc">&nbsp;                        while (true) {</b>
<b class="nc">&nbsp;                            List&lt;PlannedNode&gt; orig = pendingLaunches.get();</b>
<b class="nc">&nbsp;                            List&lt;PlannedNode&gt; repl = new ArrayList&lt;&gt;(orig);</b>
&nbsp;                            // the contract for List.remove(o) is that the first element i where
&nbsp;                            // (o==null ? get(i)==null : o.equals(get(i)))
&nbsp;                            // is true will be removed from the list
&nbsp;                            // since PlannedNode.equals(o) is not final and we cannot assume
&nbsp;                            // that subclasses do not override with an equals which does not
&nbsp;                            // assure object identity comparison, we need to manually
&nbsp;                            // do the removal based on instance identity not equality
<b class="nc">&nbsp;                            boolean changed = false;</b>
<b class="nc">&nbsp;                            for (Iterator&lt;PlannedNode&gt; iterator = repl.iterator(); iterator.hasNext(); ) {</b>
<b class="nc">&nbsp;                                PlannedNode p = iterator.next();</b>
<b class="nc">&nbsp;                                if (p == f) {</b>
<b class="nc">&nbsp;                                    iterator.remove();</b>
<b class="nc">&nbsp;                                    changed = true;</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            if (!changed || pendingLaunches.compareAndSet(orig, repl)) {</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        f.spent();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    plannedCapacitySnapshot += f.numExecutors;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            float plannedCapacity = plannedCapacitySnapshot;</b>
<b class="nc">&nbsp;            plannedCapacitiesEMA.update(plannedCapacity);</b>
&nbsp;
<b class="nc">&nbsp;            final LoadStatistics.LoadStatisticsSnapshot snapshot = stat.computeSnapshot();</b>
&nbsp;
<b class="nc">&nbsp;            int availableSnapshot = snapshot.getAvailableExecutors();</b>
<b class="nc">&nbsp;            int queueLengthSnapshot = snapshot.getQueueLength();</b>
&nbsp;
<b class="nc">&nbsp;            if (queueLengthSnapshot &lt;= availableSnapshot) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINER,</b>
&nbsp;                        &quot;Queue length {0} is less than the available capacity {1}. No provisioning strategy required&quot;,
<b class="nc">&nbsp;                        new Object[]{queueLengthSnapshot, availableSnapshot});</b>
<b class="nc">&nbsp;                provisioningState = null;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                provisioningState = new StrategyState(snapshot, label, plannedCapacitySnapshot);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (provisioningState != null) {</b>
<b class="nc">&nbsp;                List&lt;Strategy&gt; strategies = Jenkins.get().getExtensionList(Strategy.class);</b>
<b class="nc">&nbsp;                for (Strategy strategy : strategies.isEmpty()</b>
<b class="nc">&nbsp;                        ? List.of(new StandardStrategyImpl())</b>
<b class="nc">&nbsp;                        : strategies) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINER, &quot;Consulting {0} provisioning strategy with state {1}&quot;,</b>
&nbsp;                            new Object[]{strategy, provisioningState});
<b class="nc">&nbsp;                    if (StrategyDecision.PROVISIONING_COMPLETED == strategy.apply(provisioningState)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINER, &quot;Provisioning strategy {0} declared provisioning complete&quot;,</b>
&nbsp;                                strategy);
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            provisioningLock.unlock();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (LOGGER.isLoggable(Level.FINER)) {</b>
<b class="nc">&nbsp;            LOGGER.finer(() -&gt; &quot;ran update on &quot; + label + &quot; in &quot; + (System.nanoTime() - start) / 1_000_000 + &quot;ms&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the decision taken by an individual {@link hudson.slaves.NodeProvisioner.Strategy}.
&nbsp;     * @since 1.588
&nbsp;     */
<b class="nc">&nbsp;    public enum StrategyDecision {</b>
&nbsp;        /**
&nbsp;         * This decision is the default decision and indicates that the {@link hudson.slaves.NodeProvisioner.Strategy}
&nbsp;         * either could not provision sufficient resources or did not take any action. Any remaining strategies
&nbsp;         * will be able to contribute to the ultimate decision.
&nbsp;         */
<b class="nc">&nbsp;        CONSULT_REMAINING_STRATEGIES,</b>
&nbsp;        /**
&nbsp;         * This decision indicates that the {@link hudson.slaves.NodeProvisioner.Strategy} has taken sufficient
&nbsp;         * action so as to ensure that the required resources are available, and therefore there is no requirement
&nbsp;         * to consult the remaining strategies. Only return this decision when you are certain that there is no
&nbsp;         * need for additional provisioning actions (i.e. you detected an excess workload and have provisioned enough
&nbsp;         * for that excess workload).
&nbsp;         */
<b class="nc">&nbsp;        PROVISIONING_COMPLETED</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extension point for node provisioning strategies.
&nbsp;     * @since 1.588
&nbsp;     */
<b class="nc">&nbsp;    public abstract static class Strategy implements ExtensionPoint {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Called by {@link NodeProvisioner#update()} to apply this strategy against the specified state.
&nbsp;         * Any provisioning activities should be recorded by calling
&nbsp;         * {@link hudson.slaves.NodeProvisioner.StrategyState#recordPendingLaunches(java.util.Collection)}
&nbsp;         * This method will be called by a thread that is holding {@link hudson.slaves.NodeProvisioner#provisioningLock}
&nbsp;         * @param state the current state.
&nbsp;         * @return the decision.
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        @GuardedBy(&quot;NodeProvisioner.this&quot;)
&nbsp;        public abstract StrategyDecision apply(@NonNull StrategyState state);
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parameter object for {@link hudson.slaves.NodeProvisioner.Strategy}.
&nbsp;     * Intentionally non-static as we need to reference some fields in {@link hudson.slaves.NodeProvisioner}
&nbsp;     * @since 1.588
&nbsp;     */
&nbsp;    public final class StrategyState {
&nbsp;        /**
&nbsp;         * The label under consideration.
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        private final Label label;
&nbsp;        /**
&nbsp;         * The planned capacity for this {@link #label}.
&nbsp;         */
&nbsp;        private final int plannedCapacitySnapshot;
&nbsp;        /**
&nbsp;         * The current statistics snapshot for this {@link #label}.
&nbsp;         */
&nbsp;        private final LoadStatistics.LoadStatisticsSnapshot snapshot;
&nbsp;        /**
&nbsp;         * The additional planned capacity for this {@link #label} and provisioned by previous strategies during the
&nbsp;         * current updating of the {@link NodeProvisioner}.
&nbsp;         */
&nbsp;        @GuardedBy(&quot;this&quot;)
&nbsp;        private int additionalPlannedCapacity;
&nbsp;
&nbsp;        /**
&nbsp;         * Should only be instantiated by {@link NodeProvisioner#update()}
&nbsp;         * @param label the label.
&nbsp;         * @param plannedCapacitySnapshot the planned executor count.
&nbsp;         */
<b class="nc">&nbsp;        private StrategyState(LoadStatistics.LoadStatisticsSnapshot snapshot, @CheckForNull Label label, int plannedCapacitySnapshot) {</b>
<b class="nc">&nbsp;            this.snapshot = snapshot;</b>
<b class="nc">&nbsp;            this.label = label;</b>
<b class="nc">&nbsp;            this.plannedCapacitySnapshot = plannedCapacitySnapshot;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The label under consideration.
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        public Label getLabel() {
<b class="nc">&nbsp;            return label;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The current snapshot of the load statistics for this {@link #getLabel()}.
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public LoadStatistics.LoadStatisticsSnapshot getSnapshot() {
<b class="nc">&nbsp;            return snapshot;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The number of items in the queue requiring this {@link #getLabel()}.
&nbsp;         * @deprecated use {@link #getSnapshot()}, {@link LoadStatistics.LoadStatisticsSnapshot#getQueueLength()}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public int getQueueLengthSnapshot() {
<b class="nc">&nbsp;            return snapshot.getQueueLength();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The planned capacity for this {@link #getLabel()}.
&nbsp;         */
&nbsp;        public int getPlannedCapacitySnapshot() {
<b class="nc">&nbsp;            return plannedCapacitySnapshot;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The number of idle executors for this {@link #getLabel()}
&nbsp;         * @deprecated use {@link #getSnapshot()}, {@link LoadStatistics.LoadStatisticsSnapshot#getAvailableExecutors()}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public int getIdleSnapshot() {
<b class="nc">&nbsp;            return snapshot.getAvailableExecutors();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The total number of executors for this {@link #getLabel()}
&nbsp;         * @deprecated use {@link #getSnapshot()}, {@link LoadStatistics.LoadStatisticsSnapshot#getOnlineExecutors()}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public int getTotalSnapshot() {
<b class="nc">&nbsp;            return snapshot.getOnlineExecutors();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The additional planned capacity for this {@link #getLabel()} and provisioned by previous strategies during
&nbsp;         * the current updating of the {@link NodeProvisioner}.
&nbsp;         */
&nbsp;        public synchronized int getAdditionalPlannedCapacity() {
<b class="nc">&nbsp;            return additionalPlannedCapacity;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of items in the queue requiring this {@link #getLabel()}.
&nbsp;         */
&nbsp;        public float getQueueLengthLatest() {
<b class="nc">&nbsp;            return stat.queueLength.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average planned capacity for this {@link #getLabel()}.
&nbsp;         */
&nbsp;        public float getPlannedCapacityLatest() {
<b class="nc">&nbsp;            return plannedCapacitiesEMA.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of idle executors for this {@link #getLabel()}
&nbsp;         * @deprecated use {@link #getAvailableExecutorsLatest()}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public float getIdleLatest() {
<b class="nc">&nbsp;            return getAvailableExecutorsLatest();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average total number of executors for this {@link #getLabel()}
&nbsp;         * @deprecated use {@link #getOnlineExecutorsLatest()}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public float getTotalLatest() {
<b class="nc">&nbsp;            return getOnlineExecutorsLatest();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of defined executors for this {@link #getLabel()}
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public float getDefinedExecutorsLatest() {
<b class="nc">&nbsp;            return stat.definedExecutors.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of online executors for this {@link #getLabel()}
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public float getOnlineExecutorsLatest() {
<b class="nc">&nbsp;            return stat.onlineExecutors.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of connecting executors for this {@link #getLabel()}
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public float getConnectingExecutorsLatest() {
<b class="nc">&nbsp;            return stat.connectingExecutors.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of busy executors for this {@link #getLabel()}
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public float getBusyExecutorsLatest() {
<b class="nc">&nbsp;            return stat.busyExecutors.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of idle executors for this {@link #getLabel()}
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public float getIdleExecutorsLatest() {
<b class="nc">&nbsp;            return stat.idleExecutors.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The time series average number of available executors for this {@link #getLabel()}
&nbsp;         * @since 1.607
&nbsp;         */
&nbsp;        public float getAvailableExecutorsLatest() {
<b class="nc">&nbsp;            return stat.availableExecutors.getLatest(TIME_SCALE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If a {@link hudson.slaves.NodeProvisioner.Strategy} takes some provisioning action, it should record
&nbsp;         * and {@link hudson.slaves.NodeProvisioner.PlannedNode} instances by calling this method.
&nbsp;         *
&nbsp;         * @param plannedNodes the {@link hudson.slaves.NodeProvisioner.PlannedNode} instances.
&nbsp;         */
&nbsp;        public void recordPendingLaunches(PlannedNode... plannedNodes) {
<b class="nc">&nbsp;            recordPendingLaunches(Arrays.asList(plannedNodes));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If a {@link hudson.slaves.NodeProvisioner.Strategy} takes some provisioning action, it should record
&nbsp;         * and {@link hudson.slaves.NodeProvisioner.PlannedNode} instances by calling this method.
&nbsp;         *
&nbsp;         * @param plannedNodes the {@link hudson.slaves.NodeProvisioner.PlannedNode} instances.
&nbsp;         */
&nbsp;        public void recordPendingLaunches(Collection&lt;PlannedNode&gt; plannedNodes) {
<b class="nc">&nbsp;            int additionalPlannedCapacity = 0;</b>
<b class="nc">&nbsp;            for (PlannedNode f : plannedNodes) {</b>
<b class="nc">&nbsp;                if (f.future.isDone()) {</b>
&nbsp;                    // if done we should use the actual delivered capacity
&nbsp;                    try {
<b class="nc">&nbsp;                        Node node = f.future.get();</b>
<b class="nc">&nbsp;                        if (node != null) {</b>
<b class="nc">&nbsp;                            additionalPlannedCapacity += node.getNumExecutors();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (InterruptedException | ExecutionException e) {</b>
&nbsp;                        // InterruptedException: should never happen as we were told the future was done
&nbsp;                        // ExecutionException: ignore, this will be caught by others later
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    additionalPlannedCapacity += f.numExecutors;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            while (!plannedNodes.isEmpty()) {</b>
<b class="nc">&nbsp;                List&lt;PlannedNode&gt; orig = pendingLaunches.get();</b>
<b class="nc">&nbsp;                List&lt;PlannedNode&gt; repl = new ArrayList&lt;&gt;(orig);</b>
<b class="nc">&nbsp;                repl.addAll(plannedNodes);</b>
<b class="nc">&nbsp;                if (pendingLaunches.compareAndSet(orig, repl)) {</b>
<b class="nc">&nbsp;                    if (additionalPlannedCapacity &gt; 0) {</b>
<b class="nc">&nbsp;                        synchronized (this) {</b>
<b class="nc">&nbsp;                            this.additionalPlannedCapacity += additionalPlannedCapacity;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            String sb = &quot;StrategyState{&quot; + &quot;label=&quot; + label +</b>
&nbsp;                    &quot;, snapshot=&quot; + snapshot +
&nbsp;                    &quot;, plannedCapacitySnapshot=&quot; + plannedCapacitySnapshot +
&nbsp;                    &quot;, additionalPlannedCapacity=&quot; + additionalPlannedCapacity +
&nbsp;                    &#39;}&#39;;
<b class="nc">&nbsp;            return sb;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The default strategy.
&nbsp;     *
&nbsp;     * @since 1.588
&nbsp;     */
&nbsp;    @Extension @Symbol(&quot;standard&quot;)
<b class="nc">&nbsp;    public static class StandardStrategyImpl extends Strategy {</b>
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public StrategyDecision apply(@NonNull StrategyState state) {
&nbsp;        /*
&nbsp;            Here we determine how many additional agents we need to keep up with the load (if at all),
&nbsp;            which involves a simple math.
&nbsp;
&nbsp;            Broadly speaking, first we check that all the executors are fully utilized before attempting
&nbsp;            to start any new agent (this also helps to ignore the temporary gap between different numbers,
&nbsp;            as changes in them are not necessarily synchronized --- for example, there&#39;s a time lag between
&nbsp;            when an agent launches (thus bringing the planned capacity down) and the time when its executors
&nbsp;            pick up builds (thus bringing the queue length down.)
&nbsp;
&nbsp;            Once we confirm that, we compare the # of buildable items against the additional agents
&nbsp;            that are being brought online. If we have more jobs than our executors can handle, we&#39;ll launch a new agent.
&nbsp;
&nbsp;            So this computation involves three stats:
&nbsp;
&nbsp;              1. # of idle executors
&nbsp;              2. # of jobs that are starving for executors
&nbsp;              3. # of additional agents being provisioned (planned capacities.)
&nbsp;
&nbsp;            To ignore a temporary surge/drop, we make conservative estimates on each one of them. That is,
&nbsp;            we take the current snapshot value, and we take the current exponential moving average (EMA) value,
&nbsp;            and use the max/min.
&nbsp;
&nbsp;            This is another measure to be robust against temporary surge/drop in those indicators, and helps
&nbsp;            us avoid over-reacting to stats.
&nbsp;
&nbsp;            If we only use the snapshot value or EMA value, tests confirmed that the gap creates phantom
&nbsp;            excessive loads and Hudson ends up firing excessive capacities. In a static system, over the time
&nbsp;            EMA and the snapshot value becomes the same, so this makes sure that in a long run this conservative
&nbsp;            estimate won&#39;t create a starvation.
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;            final LoadStatistics.LoadStatisticsSnapshot snapshot = state.getSnapshot();</b>
<b class="nc">&nbsp;            boolean needSomeWhenNoneAtAll = snapshot.getAvailableExecutors() + snapshot.getConnectingExecutors() == 0</b>
<b class="nc">&nbsp;                    &amp;&amp; snapshot.getOnlineExecutors() + state.getPlannedCapacitySnapshot() + state.getAdditionalPlannedCapacity() == 0</b>
<b class="nc">&nbsp;                    &amp;&amp; snapshot.getQueueLength() &gt; 0;</b>
<b class="nc">&nbsp;            float available = Math.max(snapshot.getAvailableExecutors(), state.getAvailableExecutorsLatest());</b>
<b class="nc">&nbsp;            if (available &lt; MARGIN || needSomeWhenNoneAtAll) {</b>
&nbsp;                // make sure the system is fully utilized before attempting any new launch.
&nbsp;
&nbsp;                // this is the amount of work left to be done
<b class="nc">&nbsp;                float qlen = Math.min(state.getQueueLengthLatest(), snapshot.getQueueLength());</b>
&nbsp;
<b class="nc">&nbsp;                float connectingCapacity = Math.min(state.getConnectingExecutorsLatest(), snapshot.getConnectingExecutors());</b>
&nbsp;
&nbsp;                // ... and this is the additional executors we&#39;ve already provisioned.
<b class="nc">&nbsp;                float plannedCapacity = Math.max(state.getPlannedCapacityLatest(), state.getPlannedCapacitySnapshot())</b>
<b class="nc">&nbsp;                        + state.getAdditionalPlannedCapacity();</b>
&nbsp;
<b class="nc">&nbsp;                float excessWorkload = qlen - plannedCapacity - connectingCapacity;</b>
<b class="nc">&nbsp;                if (needSomeWhenNoneAtAll &amp;&amp; excessWorkload &lt; 1) {</b>
&nbsp;                    // in this specific exceptional case we should just provision right now
&nbsp;                    // the exponential smoothing will delay the build unnecessarily
<b class="nc">&nbsp;                    excessWorkload = 1;</b>
&nbsp;                }
<b class="nc">&nbsp;                float m = calcThresholdMargin(state.getTotalSnapshot());</b>
<b class="nc">&nbsp;                if (excessWorkload &gt; 1 - m) { // and there&#39;s more work to do...</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Excess workload {0,number,#.###} detected. &quot;</b>
&nbsp;                                    + &quot;(planned capacity={1,number,#.###},connecting capacity={7,number,#.###},&quot;
&nbsp;                                    + &quot;Qlen={2,number,#.###},available={3,number,#.###}&amp;{4,number,integer},&quot;
&nbsp;                                    + &quot;online={5,number,integer},m={6,number,#.###})&quot;,
&nbsp;                            new Object[]{
<b class="nc">&nbsp;                                    excessWorkload,</b>
<b class="nc">&nbsp;                                    plannedCapacity,</b>
<b class="nc">&nbsp;                                    qlen,</b>
<b class="nc">&nbsp;                                    available,</b>
<b class="nc">&nbsp;                                    snapshot.getAvailableExecutors(),</b>
<b class="nc">&nbsp;                                    snapshot.getOnlineExecutors(),</b>
<b class="nc">&nbsp;                                    m,</b>
<b class="nc">&nbsp;                                    snapshot.getConnectingExecutors(),</b>
&nbsp;                            });
&nbsp;
&nbsp;                    CLOUD:
<b class="nc">&nbsp;                    for (Cloud c : Jenkins.get().clouds) {</b>
<b class="nc">&nbsp;                        if (excessWorkload &lt; 0) {</b>
<b class="nc">&nbsp;                            break;  // enough agents allocated</b>
&nbsp;                        }
<b class="nc">&nbsp;                        Cloud.CloudState cloudState = new Cloud.CloudState(state.getLabel(), state.getAdditionalPlannedCapacity());</b>
&nbsp;
&nbsp;                        // Make sure this cloud actually can provision for this label.
<b class="nc">&nbsp;                        if (c.canProvision(cloudState)) {</b>
&nbsp;                            // provisioning a new node should be conservative --- for example if excessWorkload is 1.4,
&nbsp;                            // we don&#39;t want to allocate two nodes but just one.
&nbsp;                            // OTOH, because of the exponential decay, even when we need one agent,
&nbsp;                            // excess workload is always
&nbsp;                            // something like 0.95, in which case we want to allocate one node.
&nbsp;                            // so the threshold here is 1-MARGIN, and hence floor(excessWorkload+MARGIN) is needed to
&nbsp;                            // handle this.
&nbsp;
<b class="nc">&nbsp;                            int workloadToProvision = (int) Math.round(Math.floor(excessWorkload + m));</b>
&nbsp;
<b class="nc">&nbsp;                            for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</b>
<b class="nc">&nbsp;                                if (cl.canProvision(c, cloudState, workloadToProvision) != null) {</b>
&nbsp;                                    // consider displaying reasons in a future cloud ux
<b class="nc">&nbsp;                                    continue CLOUD;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;
<b class="nc">&nbsp;                            Collection&lt;PlannedNode&gt; additionalCapacities = c.provision(cloudState, workloadToProvision);</b>
&nbsp;
<b class="nc">&nbsp;                            fireOnStarted(c, state.getLabel(), additionalCapacities);</b>
&nbsp;
<b class="nc">&nbsp;                            for (PlannedNode ac : additionalCapacities) {</b>
<b class="nc">&nbsp;                                excessWorkload -= ac.numExecutors;</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.INFO, &quot;Started provisioning {0} from {1} with {2,number,integer} &quot;</b>
&nbsp;                                                + &quot;executors. Remaining excess workload: {3,number,#.###}&quot;,
<b class="nc">&nbsp;                                        new Object[]{ac.displayName, c.name, ac.numExecutors, excessWorkload});</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            state.recordPendingLaunches(additionalCapacities);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                    // we took action, only pass on to other strategies if our action was insufficient
<b class="nc">&nbsp;                    return excessWorkload &gt; 1 - m ? StrategyDecision.CONSULT_REMAINING_STRATEGIES : StrategyDecision.PROVISIONING_COMPLETED;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            // if we reach here then the standard strategy obviously decided to do nothing, so let any other strategies
&nbsp;            // take their considerations.
<b class="nc">&nbsp;            return StrategyDecision.CONSULT_REMAINING_STRATEGIES;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Computes the threshold for triggering an allocation.
&nbsp;         * &lt;p/&gt;
&nbsp;         * &lt;p/&gt;
&nbsp;         * Because the excessive workload value is EMA, even when the snapshot value of the excessive
&nbsp;         * workload is 1, the value never really gets to 1. So we need to introduce a notion of the margin M,
&nbsp;         * where we provision a new node if the EMA of the excessive workload goes beyond 1-M (where M is a small value
&nbsp;         * in the (0,1) range.)
&nbsp;         * &lt;p/&gt;
&nbsp;         * &lt;p/&gt;
&nbsp;         * M effectively controls how long Hudson waits until allocating a new node, in the face of workload.
&nbsp;         * This delay is justified for absorbing temporary ups and downs, and can be interpreted as Hudson
&nbsp;         * holding off provisioning in the hope that one of the existing nodes will become available.
&nbsp;         * &lt;p/&gt;
&nbsp;         * &lt;p/&gt;
&nbsp;         * M can be a constant value, but there&#39;s a benefit in adjusting M based on the total current capacity,
&nbsp;         * based on the above justification; that is, if there&#39;s no existing capacity at all, holding off
&nbsp;         * an allocation doesn&#39;t make much sense, as there won&#39;t be any executors available no matter how long we wait.
&nbsp;         * On the other hand, if we have a large number of existing executors, chances are good that some
&nbsp;         * of them become available &amp;mdash; the chance gets better and better as the number of current total
&nbsp;         * capacity increases.
&nbsp;         * &lt;p/&gt;
&nbsp;         * &lt;p/&gt;
&nbsp;         * Therefore, we compute the threshold margin as follows:
&nbsp;         * &lt;p/&gt;
&nbsp;         * &lt;pre&gt;
&nbsp;         *   M(t) = M* + (M0 - M*) alpha ^ t
&nbsp;         * &lt;/pre&gt;
&nbsp;         * &lt;p/&gt;
&nbsp;         * ... where:
&nbsp;         * &lt;p/&gt;
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;M* is the ultimate margin value that M(t) converges to with t-&gt;inf,
&nbsp;         * &lt;li&gt;M0 is the value of M(0), the initial value.
&nbsp;         * &lt;li&gt;alpha is the decay factor in (0,1). M(t) converges to M* faster if alpha is smaller.
&nbsp;         * &lt;/ul&gt;
&nbsp;         */
&nbsp;        private float calcThresholdMargin(int totalSnapshot) {
<b class="nc">&nbsp;            float f = (float) (MARGIN + (MARGIN0 - MARGIN) * Math.pow(MARGIN_DECAY, totalSnapshot));</b>
&nbsp;            // defensively ensure that the threshold margin is in (0,1)
<b class="nc">&nbsp;            f = Math.max(f, 0);</b>
<b class="nc">&nbsp;            f = Math.min(f, 1);</b>
<b class="nc">&nbsp;            return f;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Periodically invoke NodeProvisioners
&nbsp;     */
&nbsp;    @Extension
<b class="nc">&nbsp;    public static class NodeProvisionerInvoker extends PeriodicWork {</b>
&nbsp;        /**
&nbsp;         * Give some initial warm up time so that statically connected agents
&nbsp;         * can be brought online before we start allocating more.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="nc">&nbsp;        public static int INITIALDELAY = SystemProperties.getInteger(NodeProvisioner.class.getName() + &quot;.initialDelay&quot;, LoadStatistics.CLOCK * 10);</b>
&nbsp;        @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="nc">&nbsp;        public static int RECURRENCEPERIOD = SystemProperties.getInteger(NodeProvisioner.class.getName() + &quot;.recurrencePeriod&quot;, LoadStatistics.CLOCK);</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public long getInitialDelay() {
<b class="nc">&nbsp;            return INITIALDELAY;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public long getRecurrencePeriod() {
<b class="nc">&nbsp;            return RECURRENCEPERIOD;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void doRun() {
<b class="nc">&nbsp;            Jenkins j = Jenkins.get();</b>
<b class="nc">&nbsp;            j.unlabeledNodeProvisioner.update();</b>
<b class="nc">&nbsp;            for (Label l : j.getLabels())</b>
<b class="nc">&nbsp;                l.nodeProvisioner.update();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(NodeProvisioner.class.getName());</b>
<b class="nc">&nbsp;    private static final float MARGIN = SystemProperties.getInteger(NodeProvisioner.class.getName() + &quot;.MARGIN&quot;, 10) / 100f;</b>
<b class="nc">&nbsp;    private static final float MARGIN0 = Math.max(MARGIN, getFloatSystemProperty(NodeProvisioner.class.getName() + &quot;.MARGIN0&quot;, 0.5f));</b>
<b class="nc">&nbsp;    private static final float MARGIN_DECAY = getFloatSystemProperty(NodeProvisioner.class.getName() + &quot;.MARGIN_DECAY&quot;, 0.5f);</b>
&nbsp;
&nbsp;    // TODO: picker should be selectable
<b class="nc">&nbsp;    private static final TimeScale TIME_SCALE = TimeScale.SEC10;</b>
&nbsp;
&nbsp;    private static float getFloatSystemProperty(String propName, float defaultValue) {
<b class="nc">&nbsp;        String v = SystemProperties.getString(propName);</b>
<b class="nc">&nbsp;        if (v != null)</b>
&nbsp;            try {
<b class="nc">&nbsp;                return Float.parseFloat(v);</b>
<b class="nc">&nbsp;            } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;                LOGGER.warning(&quot;Failed to parse a float value from system property &quot; + propName + &quot;. value was &quot; + v);</b>
&nbsp;            }
<b class="nc">&nbsp;        return defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) {
<b class="nc">&nbsp;        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                cl.onFailure(plannedNode, cause);</b>
<b class="nc">&nbsp;            } catch (Error e) {</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Unexpected uncaught exception encountered while &quot;</b>
&nbsp;                        + &quot;processing onFailure() listener call in &quot; + cl + &quot; for agent &quot;
&nbsp;                        + plannedNode.displayName, e);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void fireOnRollback(final NodeProvisioner.PlannedNode plannedNode, final Node newNode,
&nbsp;                                       final Throwable cause) {
<b class="nc">&nbsp;        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                cl.onRollback(plannedNode, newNode, cause);</b>
<b class="nc">&nbsp;            } catch (Error e) {</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Unexpected uncaught exception encountered while &quot;</b>
&nbsp;                        + &quot;processing onRollback() listener call in &quot; + cl + &quot; for agent &quot;
<b class="nc">&nbsp;                        + newNode.getDisplayName(), e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void fireOnComplete(final NodeProvisioner.PlannedNode plannedNode, final Node newNode) {
<b class="nc">&nbsp;        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                cl.onComplete(plannedNode, newNode);</b>
<b class="nc">&nbsp;            } catch (Error e) {</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Unexpected uncaught exception encountered while &quot;</b>
&nbsp;                        + &quot;processing onComplete() listener call in &quot; + cl + &quot; for agent &quot;
&nbsp;                        + plannedNode.displayName, e);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void fireOnCommit(final NodeProvisioner.PlannedNode plannedNode, final Node newNode) {
<b class="nc">&nbsp;        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                cl.onCommit(plannedNode, newNode);</b>
<b class="nc">&nbsp;            } catch (Error e) {</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Unexpected uncaught exception encountered while &quot;</b>
&nbsp;                        + &quot;processing onCommit() listener call in &quot; + cl + &quot; for agent &quot;
<b class="nc">&nbsp;                        + newNode.getDisplayName(), e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void fireOnStarted(final Cloud cloud, final Label label,
&nbsp;                                      final Collection&lt;NodeProvisioner.PlannedNode&gt; plannedNodes) {
<b class="nc">&nbsp;        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                cl.onStarted(cloud, label, plannedNodes);</b>
<b class="nc">&nbsp;            } catch (Error e) {</b>
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Unexpected uncaught exception encountered while &quot;</b>
&nbsp;                        + &quot;processing onStarted() listener call in &quot; + cl + &quot; for label &quot;
<b class="nc">&nbsp;                        + label.toString(), e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
