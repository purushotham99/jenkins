


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > SlaveComputer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.slaves</a>
</div>

<h1>Coverage Summary for Class: SlaveComputer (hudson.slaves)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SlaveComputer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/310)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SlaveComputer$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$AbsolutePath</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$CommunicationProtocol</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$DetectDefaultCharset</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$DetectOS</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$ListFullEnvironment</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$LoadingCount</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$LoadingPrefetchCacheCount</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$LoadingTime</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$LogHolder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$LowPermissionResponse</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$SlaveInitializer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$SlaveLogFetcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SlaveComputer$SlaveVersion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/89)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/390)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Stephen Connolly
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.slaves;
&nbsp;
&nbsp;import static hudson.slaves.SlaveComputer.LogHolder.SLAVE_LOG_HANDLER;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckReturnValue;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.OverrideMustInvoke;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.AbortException;
&nbsp;import hudson.FilePath;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Main;
&nbsp;import hudson.RestrictedSince;
&nbsp;import hudson.Util;
&nbsp;import hudson.console.ConsoleLogFilter;
&nbsp;import hudson.model.Computer;
&nbsp;import hudson.model.Executor;
&nbsp;import hudson.model.ExecutorListener;
&nbsp;import hudson.model.Node;
&nbsp;import hudson.model.Queue;
&nbsp;import hudson.model.Slave;
&nbsp;import hudson.model.TaskListener;
&nbsp;import hudson.model.User;
&nbsp;import hudson.remoting.Channel;
&nbsp;import hudson.remoting.ChannelBuilder;
&nbsp;import hudson.remoting.CommandTransport;
&nbsp;import hudson.remoting.Engine;
&nbsp;import hudson.remoting.Launcher;
&nbsp;import hudson.remoting.VirtualChannel;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.slaves.OfflineCause.ChannelTermination;
&nbsp;import hudson.util.Futures;
&nbsp;import hudson.util.RingBufferLogHandler;
&nbsp;import hudson.util.StreamTaskListener;
&nbsp;import hudson.util.VersionNumber;
&nbsp;import hudson.util.io.RewindableFileOutputStream;
&nbsp;import hudson.util.io.RewindableRotatingFileOutputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.PrintStream;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.security.Security;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.logging.Handler;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.LogRecord;
&nbsp;import java.util.logging.Logger;
&nbsp;import jenkins.agents.AgentComputerUtil;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.security.ChannelConfigurator;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import jenkins.slaves.EncryptedSlaveAgentJnlpFile;
&nbsp;import jenkins.slaves.JnlpAgentReceiver;
&nbsp;import jenkins.slaves.RemotingVersionInfo;
&nbsp;import jenkins.slaves.systemInfo.SlaveSystemInfo;
&nbsp;import jenkins.util.Listeners;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import org.jenkinsci.remoting.ChannelStateException;
&nbsp;import org.jenkinsci.remoting.util.LoggingChannelListener;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.Beta;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.HttpRedirect;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.WebMethod;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;
&nbsp;/**
&nbsp; * {@link Computer} for {@link Slave}s.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
<b class="nc">&nbsp;public class SlaveComputer extends Computer {</b>
&nbsp;    private volatile Channel channel;
<b class="nc">&nbsp;    private transient volatile boolean acceptingTasks = true;</b>
&nbsp;    private Charset defaultCharset;
&nbsp;    private Boolean isUnix;
&nbsp;    /**
&nbsp;     * Effective {@link ComputerLauncher} that hides the details of
&nbsp;     * how we launch a agent agent on this computer.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is normally the same as {@link Slave#getLauncher()} but
&nbsp;     * can be different. See {@link #grabLauncher(Node)}.
&nbsp;     */
&nbsp;    private ComputerLauncher launcher;
&nbsp;
&nbsp;    /**
&nbsp;     * Perpetually writable log file.
&nbsp;     */
&nbsp;    private final RewindableFileOutputStream log;
&nbsp;
&nbsp;    /**
&nbsp;     * {@link StreamTaskListener} that wraps {@link #log}, hence perpetually writable.
&nbsp;     */
&nbsp;    private final TaskListener taskListener;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Number of failed attempts to reconnect to this node
&nbsp;     * (so that if we keep failing to reconnect, we can stop
&nbsp;     * trying.)
&nbsp;     */
&nbsp;    private transient int numRetryAttempt;
&nbsp;
&nbsp;    /**
&nbsp;     * Tracks the status of the last launch operation, which is always asynchronous.
&nbsp;     * This can be used to wait for the completion, or cancel the launch activity.
&nbsp;     */
<b class="nc">&nbsp;    private volatile Future&lt;?&gt; lastConnectActivity = null;</b>
&nbsp;
<b class="nc">&nbsp;    private Object constructed = new Object();</b>
&nbsp;
&nbsp;    private transient volatile String absoluteRemoteFs;
&nbsp;
&nbsp;    public SlaveComputer(Slave slave) {
<b class="nc">&nbsp;        super(slave);</b>
<b class="nc">&nbsp;        this.log = new RewindableRotatingFileOutputStream(getLogFile(), 10);</b>
<b class="nc">&nbsp;        this.taskListener = new StreamTaskListener(decorate(this.log));</b>
<b class="nc">&nbsp;        assert slave.getNumExecutors() != 0 : &quot;Computer created with 0 executors&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Uses {@link ConsoleLogFilter} to decorate logger.
&nbsp;     */
&nbsp;    private OutputStream decorate(OutputStream os) {
<b class="nc">&nbsp;        for (ConsoleLogFilter f : ConsoleLogFilter.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                os = f.decorateLogger(this, os);</b>
<b class="nc">&nbsp;            } catch (IOException | InterruptedException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to filter log with &quot; + f, e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return os;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @OverrideMustInvoke
&nbsp;    public boolean isAcceptingTasks() {
&nbsp;        // our boolean flag is an override on any additional programmatic reasons why this agent might not be
&nbsp;        // accepting tasks.
<b class="nc">&nbsp;        return acceptingTasks &amp;&amp; super.isAcceptingTasks();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.498
&nbsp;     */
&nbsp;    public String getJnlpMac() {
<b class="nc">&nbsp;        return JnlpAgentReceiver.SLAVE_SECRET.mac(getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows suspension of tasks being accepted by the agent computer. While this could be called by a
&nbsp;     * {@linkplain hudson.slaves.ComputerLauncher} or a {@linkplain hudson.slaves.RetentionStrategy}, such usage
&nbsp;     * can result in fights between multiple actors calling setting differential values. A better approach
&nbsp;     * is to override {@link hudson.slaves.RetentionStrategy#isAcceptingTasks(hudson.model.Computer)} if the
&nbsp;     * {@link hudson.slaves.RetentionStrategy} needs to control availability.
&nbsp;     *
&nbsp;     * @param acceptingTasks {@code true} if the agent can accept tasks.
&nbsp;     */
&nbsp;    public void setAcceptingTasks(boolean acceptingTasks) {
<b class="nc">&nbsp;        this.acceptingTasks = acceptingTasks;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Boolean isUnix() {
<b class="nc">&nbsp;        return isUnix;</b>
&nbsp;    }
&nbsp;
&nbsp;    @CheckForNull
&nbsp;    @Override
&nbsp;    public Slave getNode() {
<b class="nc">&nbsp;        Node node = super.getNode();</b>
<b class="nc">&nbsp;        if (node == null || node instanceof Slave) {</b>
<b class="nc">&nbsp;            return (Slave) node;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            logger.log(Level.WARNING, &quot;found an unexpected kind of node {0} from {1} with nodeName={2}&quot;, new Object[] {node, this, nodeName});</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Offers a way to write to the log file for this agent.
&nbsp;     * @since 2.9
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public TaskListener getListener() {
<b class="nc">&nbsp;        return taskListener;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getIconClassName() {
<b class="nc">&nbsp;        Future&lt;?&gt; l = lastConnectActivity;</b>
<b class="nc">&nbsp;        if (l != null &amp;&amp; !l.isDone())</b>
<b class="nc">&nbsp;            return &quot;symbol-computer&quot;;</b>
<b class="nc">&nbsp;        return super.getIconClassName();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated since 2008-05-20.
&nbsp;     */
&nbsp;    @Deprecated @Override
&nbsp;    public boolean isJnlpAgent() {
<b class="nc">&nbsp;        return launcher instanceof JNLPLauncher;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isLaunchSupported() {
<b class="nc">&nbsp;        return launcher.isLaunchSupported();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the {@link ComputerLauncher} for this {@code SlaveComputer}.
&nbsp;     * @since 1.312
&nbsp;     */
&nbsp;    public ComputerLauncher getLauncher() {
<b class="nc">&nbsp;        return launcher;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the {@link ComputerLauncher} for this SlaveComputer, strips off
&nbsp;     * any {@link DelegatingComputerLauncher}s or {@link ComputerLauncherFilter}s.
&nbsp;     * @since 2.83
&nbsp;     */
&nbsp;    public ComputerLauncher getDelegatedLauncher() {
<b class="nc">&nbsp;        ComputerLauncher l = launcher;</b>
&nbsp;        while (true) {
<b class="nc">&nbsp;            if (l instanceof DelegatingComputerLauncher) {</b>
<b class="nc">&nbsp;                l = ((DelegatingComputerLauncher) l).getLauncher();</b>
<b class="nc">&nbsp;            } else if (l instanceof ComputerLauncherFilter) {</b>
<b class="nc">&nbsp;                l = ((ComputerLauncherFilter) l).getCore();</b>
&nbsp;            } else {
&nbsp;                break;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return l;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected Future&lt;?&gt; _connect(boolean forceReconnect) {
<b class="nc">&nbsp;        if (channel != null)   return Futures.precomputed(null);</b>
<b class="nc">&nbsp;        if (!forceReconnect &amp;&amp; isConnecting())</b>
<b class="nc">&nbsp;            return lastConnectActivity;</b>
<b class="nc">&nbsp;        if (forceReconnect &amp;&amp; isConnecting())</b>
<b class="nc">&nbsp;            logger.fine(&quot;Forcing a reconnect on &quot; + getName());</b>
&nbsp;
<b class="nc">&nbsp;        closeChannel();</b>
<b class="nc">&nbsp;        Throwable threadInfo = new Throwable(&quot;launched here&quot;);</b>
<b class="nc">&nbsp;        return lastConnectActivity = Computer.threadPoolForRemoting.submit(() -&gt; {</b>
&nbsp;            // do this on another thread so that the lengthy launch operation
&nbsp;            // (which is typical) won&#39;t block UI thread.
&nbsp;
<b class="nc">&nbsp;            try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) { // background activity should run like a super user</b>
<b class="nc">&nbsp;                log.rewind();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    for (ComputerListener cl : ComputerListener.all())</b>
<b class="nc">&nbsp;                        cl.preLaunch(SlaveComputer.this, taskListener);</b>
<b class="nc">&nbsp;                    offlineCause = null;</b>
<b class="nc">&nbsp;                    launcher.launch(SlaveComputer.this, taskListener);</b>
<b class="nc">&nbsp;                } catch (AbortException e) {</b>
<b class="nc">&nbsp;                    e.addSuppressed(threadInfo);</b>
<b class="nc">&nbsp;                    taskListener.error(e.getMessage());</b>
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
<b class="nc">&nbsp;                    e.addSuppressed(threadInfo);</b>
<b class="nc">&nbsp;                    Util.displayIOException(e, taskListener);</b>
<b class="nc">&nbsp;                    Functions.printStackTrace(e, taskListener.error(Messages.ComputerLauncher_unexpectedError()));</b>
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    e.addSuppressed(threadInfo);</b>
<b class="nc">&nbsp;                    Functions.printStackTrace(e, taskListener.error(Messages.ComputerLauncher_abortedLaunch()));</b>
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                } catch (RuntimeException | Error e) {</b>
<b class="nc">&nbsp;                    e.addSuppressed(threadInfo);</b>
<b class="nc">&nbsp;                    Functions.printStackTrace(e, taskListener.error(Messages.ComputerLauncher_unexpectedError()));</b>
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } finally {</b>
<b class="nc">&nbsp;                if (channel == null &amp;&amp; offlineCause == null) {</b>
<b class="nc">&nbsp;                    offlineCause = new OfflineCause.LaunchFailed();</b>
<b class="nc">&nbsp;                    for (ComputerListener cl : ComputerListener.all())</b>
<b class="nc">&nbsp;                        cl.onLaunchFailure(SlaveComputer.this, taskListener);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (channel == null)</b>
<b class="nc">&nbsp;                throw new IOException(&quot;Agent failed to connect, even though the launcher didn&#39;t report it. See the log output for details.&quot;);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void taskAccepted(Executor executor, Queue.Task task) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINER, &quot;Accepted {0} on {1}&quot;, new Object[] {task.toString(), executor.getOwner().getDisplayName()});</b>
&nbsp;
<b class="nc">&nbsp;        if (launcher instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) launcher).taskAccepted(executor, task);</b>
&nbsp;        }
&nbsp;        //getNode() can return null at indeterminate times when nodes go offline
<b class="nc">&nbsp;        Slave node = getNode();</b>
<b class="nc">&nbsp;        if (node != null &amp;&amp; node.getRetentionStrategy() instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) node.getRetentionStrategy()).taskAccepted(executor, task);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void taskStarted(Executor executor, Queue.Task task) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINER, &quot;Started {0} on {1}&quot;, new Object[] {task.toString(), executor.getOwner().getDisplayName()});</b>
<b class="nc">&nbsp;        if (launcher instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) launcher).taskStarted(executor, task);</b>
&nbsp;        }
<b class="nc">&nbsp;        RetentionStrategy r = getRetentionStrategy();</b>
<b class="nc">&nbsp;        if (r instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) r).taskStarted(executor, task);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void taskCompleted(Executor executor, Queue.Task task, long durationMS) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Completed {0} on {1}&quot;, new Object[] {task.toString(), executor.getOwner().getDisplayName()});</b>
<b class="nc">&nbsp;        if (launcher instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) launcher).taskCompleted(executor, task, durationMS);</b>
&nbsp;        }
<b class="nc">&nbsp;        RetentionStrategy r = getRetentionStrategy();</b>
<b class="nc">&nbsp;        if (r instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) r).taskCompleted(executor, task, durationMS);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void taskCompletedWithProblems(Executor executor, Queue.Task task, long durationMS, Throwable problems) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Completed with problems {0} on {1}&quot;, new Object[] {task.toString(), executor.getOwner().getDisplayName()});</b>
<b class="nc">&nbsp;        if (launcher instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) launcher).taskCompletedWithProblems(executor, task, durationMS, problems);</b>
&nbsp;        }
<b class="nc">&nbsp;        RetentionStrategy r = getRetentionStrategy();</b>
<b class="nc">&nbsp;        if (r instanceof ExecutorListener) {</b>
<b class="nc">&nbsp;            ((ExecutorListener) r).taskCompletedWithProblems(executor, task, durationMS, problems);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isConnecting() {
<b class="nc">&nbsp;        Future&lt;?&gt; l = lastConnectActivity;</b>
<b class="nc">&nbsp;        return isOffline() &amp;&amp; l != null &amp;&amp; !l.isDone();</b>
&nbsp;    }
&nbsp;
&nbsp;    public OutputStream openLogFile() {
&nbsp;        try {
<b class="nc">&nbsp;            log.rewind();</b>
<b class="nc">&nbsp;            return log;</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            logger.log(Level.SEVERE, &quot;Failed to create log file &quot; + getLogFile(), e);</b>
<b class="nc">&nbsp;            return OutputStream.nullOutputStream();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private final Object channelLock = new Object();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Channel} from the given stream and sets that to this agent.
&nbsp;     *
&nbsp;     * Same as {@link #setChannel(InputStream, OutputStream, OutputStream, Channel.Listener)}, but for
&nbsp;     * {@link TaskListener}.
&nbsp;     */
&nbsp;    public void setChannel(@NonNull InputStream in, @NonNull OutputStream out,
&nbsp;                           @NonNull TaskListener taskListener,
&nbsp;                           @CheckForNull Channel.Listener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        setChannel(in, out, taskListener.getLogger(), listener);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Channel} from the given stream and sets that to this agent.
&nbsp;     *
&nbsp;     * @param in
&nbsp;     *      Stream connected to the remote agent. It&#39;s the caller&#39;s responsibility to do
&nbsp;     *      buffering on this stream, if that&#39;s necessary.
&nbsp;     * @param out
&nbsp;     *      Stream connected to the remote peer. It&#39;s the caller&#39;s responsibility to do
&nbsp;     *      buffering on this stream, if that&#39;s necessary.
&nbsp;     * @param launchLog
&nbsp;     *      If non-null, receive the portion of data in {@code is} before
&nbsp;     *      the data goes into the &quot;binary mode&quot;. This is useful
&nbsp;     *      when the established communication channel might include some data that might
&nbsp;     *      be useful for debugging/trouble-shooting.
&nbsp;     * @param listener
&nbsp;     *      Gets a notification when the channel closes, to perform clean up. Can be null.
&nbsp;     *      By the time this method is called, the cause of the termination is reported to the user,
&nbsp;     *      so the implementation of the listener doesn&#39;t need to do that again.
&nbsp;     */
&nbsp;    public void setChannel(@NonNull InputStream in, @NonNull OutputStream out,
&nbsp;                           @CheckForNull OutputStream launchLog,
&nbsp;                           @CheckForNull Channel.Listener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        ChannelBuilder cb = new ChannelBuilder(nodeName, threadPoolForRemoting)</b>
<b class="nc">&nbsp;            .withMode(Channel.Mode.NEGOTIATE)</b>
<b class="nc">&nbsp;            .withHeaderStream(launchLog);</b>
&nbsp;
<b class="nc">&nbsp;        for (ChannelConfigurator cc : ChannelConfigurator.all()) {</b>
<b class="nc">&nbsp;            cc.onChannelBuilding(cb, this);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        Channel channel = cb.build(in, out);</b>
<b class="nc">&nbsp;        setChannel(channel, launchLog, listener);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Channel} from the given Channel Builder and Command Transport.
&nbsp;     * This method can be used to allow {@link ComputerLauncher}s to create channels not based on I/O streams.
&nbsp;     *
&nbsp;     * @param cb
&nbsp;     *      Channel Builder.
&nbsp;     *      To print launch logs this channel builder should have a Header Stream defined
&nbsp;     *      (see {@link ChannelBuilder#getHeaderStream()}) in this argument or by one of {@link ChannelConfigurator}s.
&nbsp;     * @param commandTransport
&nbsp;     *      Command Transport
&nbsp;     * @param listener
&nbsp;     *      Gets a notification when the channel closes, to perform clean up. Can be {@code null}.
&nbsp;     *      By the time this method is called, the cause of the termination is reported to the user,
&nbsp;     *      so the implementation of the listener doesn&#39;t need to do that again.
&nbsp;     * @since 2.127
&nbsp;     */
&nbsp;    @Restricted(Beta.class)
&nbsp;    public void setChannel(@NonNull ChannelBuilder cb,
&nbsp;                           @NonNull CommandTransport commandTransport,
&nbsp;                           @CheckForNull Channel.Listener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        for (ChannelConfigurator cc : ChannelConfigurator.all()) {</b>
<b class="nc">&nbsp;            cc.onChannelBuilding(cb, this);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        OutputStream headerStream = cb.getHeaderStream();</b>
<b class="nc">&nbsp;        if (headerStream == null) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;No header stream defined when setting channel for computer {0}. &quot; +</b>
&nbsp;                    &quot;Launch log won&#39;t be printed&quot;, this);
&nbsp;        }
<b class="nc">&nbsp;        Channel channel = cb.build(commandTransport);</b>
<b class="nc">&nbsp;        setChannel(channel, headerStream, listener);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shows {@link Channel#classLoadingCount}.
&nbsp;     * @return Requested value or {@code -1} if the agent is offline.
&nbsp;     * @since 1.495
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public int getClassLoadingCount() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new LoadingCount(false));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shows {@link Channel#classLoadingPrefetchCacheCount}.
&nbsp;     * @return Requested value or {@code -1} in case that capability is not supported or if the agent is offline.
&nbsp;     * @since 1.519
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public int getClassLoadingPrefetchCacheCount() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!channel.remoteCapability.supportsPrefetch()) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new LoadingPrefetchCacheCount());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shows {@link Channel#resourceLoadingCount}.
&nbsp;     * @return Requested value or {@code -1} if the agent is offline.
&nbsp;     * @since 1.495
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public int getResourceLoadingCount() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new LoadingCount(true));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shows {@link Channel#classLoadingTime}.
&nbsp;     * @return Requested value or {@code -1} if the agent is offline.
&nbsp;     * @since 1.495
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public long getClassLoadingTime() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new LoadingTime(false));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shows {@link Channel#resourceLoadingTime}.
&nbsp;     * @return Requested value or {@code -1} if the agent is offline.
&nbsp;     * @since 1.495
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public long getResourceLoadingTime() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new LoadingTime(true));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the remote FS root absolute path or {@code null} if the agent is off-line. The absolute path may change
&nbsp;     * between connections if the connection method does not provide a consistent working directory and the node&#39;s
&nbsp;     * remote FS is specified as a relative path.
&nbsp;     *
&nbsp;     * @return the remote FS root absolute path or {@code null} if the agent is off-line.
&nbsp;     * @since 1.606
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public String getAbsoluteRemoteFs() {
<b class="nc">&nbsp;        return channel == null ? null : absoluteRemoteFs;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Just for restFul api.
&nbsp;     * Returns the remote FS root absolute path or {@code null} if the agent is off-line. The absolute path may change
&nbsp;     * between connections if the connection method does not provide a consistent working directory and the node&#39;s
&nbsp;     * remote FS is specified as a relative path.
&nbsp;     * @see #getAbsoluteRemoteFs()
&nbsp;     * @return the remote FS root absolute path or {@code null} if the agent is off-line or don&#39;t have connect permission.
&nbsp;     * @since 2.125
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    @CheckForNull
&nbsp;    public String getAbsoluteRemotePath() {
<b class="nc">&nbsp;        if (hasPermission(CONNECT)) {</b>
<b class="nc">&nbsp;            return getAbsoluteRemoteFs();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class LoadingCount extends MasterToSlaveCallable&lt;Integer, RuntimeException&gt; {
&nbsp;        private final boolean resource;
&nbsp;
<b class="nc">&nbsp;        LoadingCount(boolean resource) {</b>
<b class="nc">&nbsp;            this.resource = resource;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override public Integer call() {
<b class="nc">&nbsp;            Channel c = Channel.current();</b>
<b class="nc">&nbsp;            if (c == null) {</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
<b class="nc">&nbsp;            return resource ? c.resourceLoadingCount.get() : c.classLoadingCount.get();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    static class LoadingPrefetchCacheCount extends MasterToSlaveCallable&lt;Integer, RuntimeException&gt; {</b>
&nbsp;        @Override public Integer call() {
<b class="nc">&nbsp;            Channel c = Channel.current();</b>
<b class="nc">&nbsp;            if (c == null) {</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
<b class="nc">&nbsp;            return c.classLoadingPrefetchCacheCount.get();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class LoadingTime extends MasterToSlaveCallable&lt;Long, RuntimeException&gt; {
&nbsp;        private final boolean resource;
&nbsp;
<b class="nc">&nbsp;        LoadingTime(boolean resource) {</b>
<b class="nc">&nbsp;            this.resource = resource;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override public Long call() {
<b class="nc">&nbsp;            Channel c = Channel.current();</b>
<b class="nc">&nbsp;            if (c == null) {</b>
<b class="nc">&nbsp;                return -1L;</b>
&nbsp;            }
<b class="nc">&nbsp;            return resource ? c.resourceLoadingTime.get() : c.classLoadingTime.get();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets up the connection through an existing channel.
&nbsp;     * @param channel the channel to use; &lt;strong&gt;warning:&lt;/strong&gt; callers are expected to have called {@link ChannelConfigurator} already.
&nbsp;     * @param launchLog Launch log. If not {@code null}, will receive launch log messages
&nbsp;     * @param listener Channel event listener to be attached (if not {@code null})
&nbsp;     * @since 1.444
&nbsp;     */
&nbsp;    public void setChannel(@NonNull Channel channel,
&nbsp;                           @CheckForNull OutputStream launchLog,
&nbsp;                           @CheckForNull Channel.Listener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (this.channel != null)</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Already connected&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        final TaskListener taskListener = launchLog != null ? new StreamTaskListener(launchLog) : TaskListener.NULL;</b>
<b class="nc">&nbsp;        PrintStream log = taskListener.getLogger();</b>
&nbsp;
<b class="nc">&nbsp;        channel.setProperty(SlaveComputer.class, this);</b>
&nbsp;
<b class="nc">&nbsp;        channel.addListener(new LoggingChannelListener(logger, Level.FINEST) {</b>
&nbsp;            @Override
&nbsp;            public void onClosed(Channel c, IOException cause) {
&nbsp;                // Orderly shutdown will have null exception
<b class="nc">&nbsp;                if (cause != null) {</b>
<b class="nc">&nbsp;                    offlineCause = new ChannelTermination(cause);</b>
<b class="nc">&nbsp;                    Functions.printStackTrace(cause, taskListener.error(&quot;Connection terminated&quot;));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    taskListener.getLogger().println(&quot;Connection terminated&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                closeChannel();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    launcher.afterDisconnect(SlaveComputer.this, taskListener);</b>
<b class="nc">&nbsp;                } catch (Throwable t) {</b>
<b class="nc">&nbsp;                    LogRecord lr = new LogRecord(Level.SEVERE,</b>
&nbsp;                            &quot;Launcher {0}&#39;s afterDisconnect method propagated an exception when {1}&#39;s connection was closed: {2}&quot;);
<b class="nc">&nbsp;                    lr.setThrown(t);</b>
<b class="nc">&nbsp;                    lr.setParameters(new Object[]{launcher, SlaveComputer.this.getName(), t.getMessage()});</b>
<b class="nc">&nbsp;                    logger.log(lr);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        if (listener != null)</b>
<b class="nc">&nbsp;            channel.addListener(listener);</b>
&nbsp;
<b class="nc">&nbsp;        String slaveVersion = channel.call(new SlaveVersion());</b>
<b class="nc">&nbsp;        log.println(&quot;Remoting version: &quot; + slaveVersion);</b>
<b class="nc">&nbsp;        VersionNumber agentVersion = new VersionNumber(slaveVersion);</b>
<b class="nc">&nbsp;        if (agentVersion.isOlderThan(RemotingVersionInfo.getMinimumSupportedVersion())) {</b>
<b class="nc">&nbsp;            if (!ALLOW_UNSUPPORTED_REMOTING_VERSIONS) {</b>
<b class="nc">&nbsp;                taskListener.fatalError(</b>
&nbsp;                        &quot;Rejecting the connection because the Remoting version is older than the&quot;
&nbsp;                            + &quot; minimum required version (%s). To allow the connection anyway, set&quot;
&nbsp;                            + &quot; the hudson.slaves.SlaveComputer.allowUnsupportedRemotingVersions&quot;
&nbsp;                            + &quot; system property to true.&quot;,
<b class="nc">&nbsp;                        RemotingVersionInfo.getMinimumSupportedVersion());</b>
<b class="nc">&nbsp;                disconnect(new OfflineCause.LaunchFailed());</b>
&nbsp;                return;
&nbsp;            } else {
<b class="nc">&nbsp;                taskListener.error(</b>
&nbsp;                        &quot;The Remoting version is older than the minimum required version (%s).&quot;
&nbsp;                            + &quot; The connection will be allowed, but compatibility is NOT&quot;
&nbsp;                            + &quot; guaranteed.&quot;,
<b class="nc">&nbsp;                        RemotingVersionInfo.getMinimumSupportedVersion());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        log.println(&quot;Launcher: &quot; + getLauncher().getClass().getSimpleName());</b>
&nbsp;
<b class="nc">&nbsp;        String communicationProtocol = channel.call(new CommunicationProtocol());</b>
<b class="nc">&nbsp;        if (communicationProtocol != null) {</b>
<b class="nc">&nbsp;            log.println(&quot;Communication Protocol: &quot; + communicationProtocol);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        boolean _isUnix = channel.call(new DetectOS());</b>
<b class="nc">&nbsp;        log.println(_isUnix ? hudson.model.Messages.Slave_UnixSlave() : hudson.model.Messages.Slave_WindowsSlave());</b>
&nbsp;
<b class="nc">&nbsp;        String defaultCharsetName = channel.call(new DetectDefaultCharset());</b>
&nbsp;
<b class="nc">&nbsp;        Slave node = getNode();</b>
<b class="nc">&nbsp;        if (node == null) { // Node has been disabled/removed during the connection</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Node &quot; + nodeName + &quot; has been deleted during the channel setup&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String remoteFS = node.getRemoteFS();</b>
<b class="nc">&nbsp;        if (Util.isRelativePath(remoteFS)) {</b>
<b class="nc">&nbsp;            remoteFS = channel.call(new AbsolutePath(remoteFS));</b>
<b class="nc">&nbsp;            log.println(&quot;NOTE: Relative remote path resolved to: &quot; + remoteFS);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (_isUnix &amp;&amp; !remoteFS.contains(&quot;/&quot;) &amp;&amp; remoteFS.contains(&quot;\\&quot;))</b>
<b class="nc">&nbsp;            log.println(&quot;WARNING: &quot; + remoteFS</b>
<b class="nc">&nbsp;                    + &quot; looks suspiciously like Windows path. Maybe you meant &quot; + remoteFS.replace(&#39;\\&#39;, &#39;/&#39;) + &quot;?&quot;);</b>
<b class="nc">&nbsp;        FilePath root = new FilePath(channel, remoteFS);</b>
&nbsp;
&nbsp;        // reference counting problem is known to happen, such as JENKINS-9017, and so as a preventive measure
&nbsp;        // we pin the base classloader so that it&#39;ll never get GCed. When this classloader gets released,
&nbsp;        // it&#39;ll have a catastrophic impact on the communication.
<b class="nc">&nbsp;        channel.pinClassLoader(getClass().getClassLoader());</b>
&nbsp;
<b class="nc">&nbsp;        channel.call(new SlaveInitializer(DEFAULT_RING_BUFFER_SIZE));</b>
<b class="nc">&nbsp;        try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;            for (ComputerListener cl : ComputerListener.all()) {</b>
<b class="nc">&nbsp;                cl.preOnline(this, channel, root, taskListener);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        offlineCause = null;</b>
&nbsp;
&nbsp;        // update the data structure atomically to prevent others from seeing a channel that&#39;s not properly initialized yet
<b class="nc">&nbsp;        synchronized (channelLock) {</b>
<b class="nc">&nbsp;            if (this.channel != null) {</b>
&nbsp;                // check again. we used to have this entire method in a big synchronization block,
&nbsp;                // but Channel constructor blocks for an external process to do the connection
&nbsp;                // if CommandLauncher is used, and that cannot be interrupted because it blocks at InputStream.
&nbsp;                // so if the process hangs, it hangs the thread in a lock, and since Hudson will try to relaunch,
&nbsp;                // we&#39;ll end up queuing the lot of threads in a pseudo deadlock.
&nbsp;                // This implementation prevents that by avoiding a lock. JENKINS-1705 is likely a manifestation of this.
<b class="nc">&nbsp;                channel.close();</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Already connected&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            isUnix = _isUnix;</b>
<b class="nc">&nbsp;            numRetryAttempt = 0;</b>
<b class="nc">&nbsp;            this.channel = channel;</b>
<b class="nc">&nbsp;            this.absoluteRemoteFs = remoteFS;</b>
<b class="nc">&nbsp;            defaultCharset = Charset.forName(defaultCharsetName);</b>
&nbsp;
<b class="nc">&nbsp;            synchronized (statusChangeLock) {</b>
<b class="nc">&nbsp;                statusChangeLock.notifyAll();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;            for (ComputerListener cl : ComputerListener.all()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    cl.onOnline(this, taskListener);</b>
<b class="nc">&nbsp;                } catch (AbortException e) {</b>
<b class="nc">&nbsp;                    taskListener.error(e.getMessage());</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
&nbsp;                    // Per Javadoc log exceptions but still go online.
&nbsp;                    // NOTE: this does not include Errors, which indicate a fatal problem
<b class="nc">&nbsp;                    Functions.printStackTrace(e, taskListener.error(Messages.ComputerLauncher_unexpectedError()));</b>
<b class="nc">&nbsp;                } catch (Throwable e) {</b>
<b class="nc">&nbsp;                    closeChannel();</b>
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        log.println(&quot;Agent successfully connected and online&quot;);</b>
<b class="nc">&nbsp;        Jenkins.get().getQueue().scheduleMaintenance();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Channel getChannel() {
<b class="nc">&nbsp;        return channel;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Charset getDefaultCharset() {
<b class="nc">&nbsp;        return defaultCharset;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;LogRecord&gt; getLogRecords() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null)</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        else
<b class="nc">&nbsp;            return channel.call(new SlaveLogFetcher());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inline editing of description
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public synchronized void doSubmitDescription(StaplerResponse rsp, @QueryParameter String description) throws IOException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
&nbsp;
<b class="nc">&nbsp;        final Slave node = this.getNode();</b>
<b class="nc">&nbsp;        if (node != null) {</b>
<b class="nc">&nbsp;            node.setNodeDescription(description);</b>
&nbsp;        } else { // Node has been disabled/removed during other session tries to change the description.
<b class="nc">&nbsp;            throw new IOException(&quot;Description will be not set. The node &quot; + nodeName + &quot; does not exist (anymore).&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doDoDisconnect(@QueryParameter String offlineMessage) {
<b class="nc">&nbsp;        if (channel != null) {</b>
&nbsp;            //does nothing in case computer is already disconnected
<b class="nc">&nbsp;            checkPermission(DISCONNECT);</b>
<b class="nc">&nbsp;            offlineMessage = Util.fixEmptyAndTrim(offlineMessage);</b>
<b class="nc">&nbsp;            disconnect(new OfflineCause.UserCause(User.current(), offlineMessage));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new HttpRedirect(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Future&lt;?&gt; disconnect(OfflineCause cause) {
<b class="nc">&nbsp;        super.disconnect(cause);</b>
<b class="nc">&nbsp;        return Computer.threadPoolForRemoting.submit(new Runnable() {</b>
&nbsp;            @Override
&nbsp;            public void run() {
&nbsp;                // do this on another thread so that any lengthy disconnect operation
&nbsp;                // (which could be typical) won&#39;t block UI thread.
<b class="nc">&nbsp;                launcher.beforeDisconnect(SlaveComputer.this, taskListener);</b>
<b class="nc">&nbsp;                closeChannel();</b>
<b class="nc">&nbsp;                launcher.afterDisconnect(SlaveComputer.this, taskListener);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    @Override
&nbsp;    public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        checkPermission(CONNECT);</b>
&nbsp;
<b class="nc">&nbsp;        if (channel != null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                req.getView(this, &quot;already-launched.jelly&quot;).forward(req, rsp);</b>
<b class="nc">&nbsp;            } catch (IOException x) {</b>
<b class="nc">&nbsp;                throw x;</b>
<b class="nc">&nbsp;            } catch (/*Servlet*/Exception x) {</b>
<b class="nc">&nbsp;                throw new IOException(x);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        connect(true);</b>
&nbsp;
&nbsp;        // TODO: would be nice to redirect the user to &quot;launching...&quot; wait page,
&nbsp;        // then spend a few seconds there and poll for the completion periodically.
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;log&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void tryReconnect() {
<b class="nc">&nbsp;        numRetryAttempt++;</b>
<b class="nc">&nbsp;        if (numRetryAttempt &lt; 6 || numRetryAttempt % 12 == 0) {</b>
&nbsp;            // initially retry several times quickly, and after that, do it infrequently.
<b class="nc">&nbsp;            logger.info(&quot;Attempting to reconnect &quot; + nodeName);</b>
<b class="nc">&nbsp;            connect(true);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Serves jar files for inbound agents.
&nbsp;     *
&nbsp;     * @deprecated since 2008-08-18.
&nbsp;     *      This URL binding is no longer used and moved up directly under to {@link jenkins.model.Jenkins},
&nbsp;     *      but it&#39;s left here for now just in case some old inbound agents request it.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public Slave.JnlpJar getJnlpJars(String fileName) {
<b class="nc">&nbsp;        return new Slave.JnlpJar(fileName);</b>
&nbsp;    }
&nbsp;
&nbsp;    @WebMethod(name = &quot;slave-agent.jnlp&quot;) // backward compatibility
&nbsp;    public HttpResponse doSlaveAgentJnlp(StaplerRequest req, StaplerResponse res) {
<b class="nc">&nbsp;        return doJenkinsAgentJnlp(req, res);</b>
&nbsp;    }
&nbsp;
&nbsp;    @WebMethod(name = &quot;jenkins-agent.jnlp&quot;)
&nbsp;    public HttpResponse doJenkinsAgentJnlp(StaplerRequest req, StaplerResponse res) {
<b class="nc">&nbsp;        LOGGER.log(</b>
&nbsp;                Level.WARNING,
<b class="nc">&nbsp;                &quot;Agent \&quot;&quot; + getName()</b>
&nbsp;                        + &quot;\&quot; is connecting with the \&quot;-jnlpUrl\&quot; argument, which is deprecated.&quot;
&nbsp;                        + &quot; Use \&quot;-url\&quot; and \&quot;-name\&quot; instead, potentially also passing in&quot;
&nbsp;                        + &quot; \&quot;-webSocket\&quot;, \&quot;-tunnel\&quot;, and/or work directory options as needed.&quot;);
<b class="nc">&nbsp;        return new EncryptedSlaveAgentJnlpFile(this, &quot;jenkins-agent.jnlp.jelly&quot;, getName(), CONNECT);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    class LowPermissionResponse {</b>
&nbsp;        @WebMethod(name = &quot;jenkins-agent.jnlp&quot;)
&nbsp;        public HttpResponse doJenkinsAgentJnlp(StaplerRequest req, StaplerResponse res) {
<b class="nc">&nbsp;            return SlaveComputer.this.doJenkinsAgentJnlp(req, res);</b>
&nbsp;        }
&nbsp;
&nbsp;        @WebMethod(name = &quot;slave-agent.jnlp&quot;) // backward compatibility
&nbsp;        public HttpResponse doSlaveAgentJnlp(StaplerRequest req, StaplerResponse res) {
<b class="nc">&nbsp;            return SlaveComputer.this.doJenkinsAgentJnlp(req, res);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Object getTarget() {
<b class="nc">&nbsp;        if (!SKIP_PERMISSION_CHECK) {</b>
<b class="nc">&nbsp;            if (!Jenkins.get().hasPermission(Jenkins.READ)) {</b>
<b class="nc">&nbsp;                return new LowPermissionResponse();</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void kill() {
<b class="nc">&nbsp;        super.kill();</b>
<b class="nc">&nbsp;        closeChannel();</b>
&nbsp;        try {
<b class="nc">&nbsp;            log.close();</b>
<b class="nc">&nbsp;        } catch (IOException x) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;Failed to close agent log&quot;, x);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            Util.deleteRecursive(getLogDir());</b>
<b class="nc">&nbsp;        } catch (IOException ex) {</b>
<b class="nc">&nbsp;            logger.log(Level.WARNING, &quot;Unable to delete agent logs&quot;, ex);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public RetentionStrategy getRetentionStrategy() {
<b class="nc">&nbsp;        Slave n = getNode();</b>
<b class="nc">&nbsp;        return n == null ? RetentionStrategy.NOOP : n.getRetentionStrategy();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If still connected, disconnect.
&nbsp;     */
&nbsp;    private void closeChannel() {
&nbsp;        // TODO: race condition between this and the setChannel method.
&nbsp;        Channel c;
<b class="nc">&nbsp;        synchronized (channelLock) {</b>
<b class="nc">&nbsp;            c = channel;</b>
<b class="nc">&nbsp;            channel = null;</b>
<b class="nc">&nbsp;            absoluteRemoteFs = null;</b>
<b class="nc">&nbsp;            isUnix = null;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (c != null) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                c.close();</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                logger.log(Level.SEVERE, &quot;Failed to terminate channel to &quot; + getDisplayName(), e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Listeners.notify(ComputerListener.class, true, l -&gt; l.onOffline(this, offlineCause));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void setNode(final Node node) {
<b class="nc">&nbsp;        super.setNode(node);</b>
<b class="nc">&nbsp;        launcher = grabLauncher(node);</b>
&nbsp;
&nbsp;        // maybe the configuration was changed to relaunch the agent, so try to re-launch now.
&nbsp;        // &quot;constructed==null&quot; test is an ugly hack to avoid launching before the object is fully
&nbsp;        // constructed.
<b class="nc">&nbsp;        if (constructed != null) {</b>
<b class="nc">&nbsp;            if (node instanceof Slave) {</b>
<b class="nc">&nbsp;                Queue.withLock(new Runnable() {</b>
&nbsp;                    @Override
&nbsp;                    public void run() {
<b class="nc">&nbsp;                        ((Slave) node).getRetentionStrategy().check(SlaveComputer.this);</b>
&nbsp;                    }
&nbsp;                });
&nbsp;            } else {
<b class="nc">&nbsp;                connect(false);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Grabs a {@link ComputerLauncher} out of {@link Node} to keep it in this {@link Computer}.
&nbsp;     * The returned launcher will be set to {@link #launcher} and used to carry out the actual launch operation.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Subtypes that needs to decorate {@link ComputerLauncher} can do so by overriding this method.
&nbsp;     * This is useful for {@link SlaveComputer}s for clouds for example, where one normally needs
&nbsp;     * additional pre-launch step (such as waiting for the provisioned node to become available)
&nbsp;     * before the user specified launch step (like SSH connection) kicks in.
&nbsp;     *
&nbsp;     * @see ComputerLauncherFilter
&nbsp;     */
&nbsp;    protected ComputerLauncher grabLauncher(Node node) {
<b class="nc">&nbsp;        return ((Slave) node).getLauncher();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the agent version
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public String getSlaveVersion() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return &quot;Unknown (agent is offline)&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new SlaveVersion());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the OS description.
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public String getOSDescription() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            return &quot;Unknown (agent is offline)&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return channel.call(new DetectOS()) ? &quot;Unix&quot; : &quot;Windows&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Expose real full env vars map from agent for UI presentation
&nbsp;     */
&nbsp;    @CheckReturnValue
&nbsp;    public Map&lt;String, String&gt; getEnvVarsFull() throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (channel == null) {</b>
<b class="nc">&nbsp;            Map&lt;String, String&gt; env = new TreeMap&lt;&gt;();</b>
<b class="nc">&nbsp;            env.put(&quot;N/A&quot;, &quot;N/A&quot;);</b>
<b class="nc">&nbsp;            return env;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return channel.call(new ListFullEnvironment());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class ListFullEnvironment extends MasterToSlaveCallable&lt;Map&lt;String, String&gt;, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public Map&lt;String, String&gt; call() throws IOException {
<b class="nc">&nbsp;            Map&lt;String, String&gt; env = new TreeMap&lt;&gt;(System.getenv());</b>
<b class="nc">&nbsp;            if (Main.isUnitTest || Main.isDevelopmentMode) {</b>
&nbsp;                // if unit test is launched with maven debug switch,
&nbsp;                // we need to prevent forked Maven processes from seeing it, or else
&nbsp;                // they&#39;ll hang
<b class="nc">&nbsp;                env.remove(&quot;MAVEN_OPTS&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return env;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final Logger logger = Logger.getLogger(SlaveComputer.class.getName());</b>
&nbsp;
<b class="nc">&nbsp;    private static final class SlaveVersion extends MasterToSlaveCallable&lt;String, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public String call() throws IOException {
<b class="nc">&nbsp;            try { return Launcher.VERSION; }</b>
<b class="nc">&nbsp;            catch (Throwable ex) { return &quot;&lt; 1.335&quot;; } // Older agent.jar won&#39;t have VERSION</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final class CommunicationProtocol extends MasterToSlaveCallable&lt;String, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public String call() throws IOException {
&nbsp;            try {
<b class="nc">&nbsp;                Engine engine = Engine.current();</b>
<b class="nc">&nbsp;                if (engine != null) {</b>
<b class="nc">&nbsp;                    return engine.getProtocolName();</b>
&nbsp;                }
<b class="nc">&nbsp;                return Launcher.getCommunicationProtocolName();</b>
<b class="nc">&nbsp;            } catch (NoSuchMethodError ex) {</b>
&nbsp;                // Remoting does not support this feature
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final class DetectOS extends MasterToSlaveCallable&lt;Boolean, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public Boolean call() throws IOException {
<b class="nc">&nbsp;            return File.pathSeparatorChar == &#39;:&#39;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class AbsolutePath extends MasterToSlaveCallable&lt;String, IOException&gt; {
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        private final String relativePath;
&nbsp;
<b class="nc">&nbsp;        private AbsolutePath(String relativePath) {</b>
<b class="nc">&nbsp;            this.relativePath = relativePath;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String call() throws IOException {
<b class="nc">&nbsp;            return new File(relativePath).getAbsolutePath();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final class DetectDefaultCharset extends MasterToSlaveCallable&lt;String, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public String call() throws IOException {
<b class="nc">&nbsp;            return Charset.defaultCharset().name();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Puts the {@link #SLAVE_LOG_HANDLER} into a separate class so that loading this class
&nbsp;     * in JVM doesn&#39;t end up loading tons of additional classes.
&nbsp;     */
<b class="nc">&nbsp;    static final class LogHolder {</b>
&nbsp;        /**
&nbsp;         * This field is used on each agent to record logs on the agent.
&nbsp;         */
&nbsp;        static RingBufferLogHandler SLAVE_LOG_HANDLER;
&nbsp;    }
&nbsp;
&nbsp;    private static class SlaveInitializer extends MasterToSlaveCallable&lt;Void, RuntimeException&gt; {
&nbsp;        final int ringBufferSize;
&nbsp;
<b class="nc">&nbsp;        SlaveInitializer(int ringBufferSize) {</b>
<b class="nc">&nbsp;            this.ringBufferSize = ringBufferSize;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressFBWarnings(value = &quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot;, justification = &quot;field is static for the reason explained in the Javadoc for LogHolder&quot;)
&nbsp;        public Void call() {
<b class="nc">&nbsp;            SLAVE_LOG_HANDLER = new RingBufferLogHandler(ringBufferSize);</b>
&nbsp;
&nbsp;            // avoid double installation of the handler. Inbound agents can reconnect to the controller multiple times
&nbsp;            // and each connection gets a different RemoteClassLoader, so we need to evict them by class name,
&nbsp;            // not by their identity.
<b class="nc">&nbsp;            for (Handler h : LOGGER.getHandlers()) {</b>
<b class="nc">&nbsp;                if (h.getClass().getName().equals(SLAVE_LOG_HANDLER.getClass().getName()))</b>
<b class="nc">&nbsp;                    LOGGER.removeHandler(h);</b>
&nbsp;            }
<b class="nc">&nbsp;            LOGGER.addHandler(SLAVE_LOG_HANDLER);</b>
&nbsp;
&nbsp;            // remove Sun PKCS11 provider if present. See http://wiki.jenkins-ci.org/display/JENKINS/Solaris+Issue+6276483
&nbsp;            try {
<b class="nc">&nbsp;                Security.removeProvider(&quot;SunPKCS11-Solaris&quot;);</b>
<b class="nc">&nbsp;            } catch (SecurityException e) {</b>
&nbsp;                // ignore this error.
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                getChannelOrFail().setProperty(&quot;agent&quot;, Boolean.TRUE); // indicate that this side of the channel is the agent side.</b>
<b class="nc">&nbsp;            } catch (ChannelStateException e) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
<b class="nc">&nbsp;        private static final Logger LOGGER = Logger.getLogger(&quot;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains a {@link VirtualChannel} that allows some computation to be performed on the controller.
&nbsp;     * This method can be called from any thread on the controller, or from agent (more precisely,
&nbsp;     * it only works from the remoting request-handling thread in agents, which means if you&#39;ve started
&nbsp;     * separate thread on agents, that&#39;ll fail.)
&nbsp;     *
&nbsp;     * @return null if the calling thread doesn&#39;t have any trace of where its controller is.
&nbsp;     * @since 1.362
&nbsp;     * @deprecated Use {@link AgentComputerUtil#getChannelToController()} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static VirtualChannel getChannelToMaster() {
<b class="nc">&nbsp;        return AgentComputerUtil.getChannelToController();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Helper method for Jelly.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    @RestrictedSince(&quot;2.163&quot;)
&nbsp;    public static List&lt;SlaveSystemInfo&gt; getSystemInfoExtensions() {
<b class="nc">&nbsp;        return SlaveSystemInfo.all();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class SlaveLogFetcher extends MasterToSlaveCallable&lt;List&lt;LogRecord&gt;, RuntimeException&gt; {</b>
&nbsp;        @Override
&nbsp;        public List&lt;LogRecord&gt; call() {
<b class="nc">&nbsp;            return new ArrayList&lt;&gt;(SLAVE_LOG_HANDLER.getView());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Escape hatch for allowing connections from agents with unsupported Remoting versions.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="nc">&nbsp;    public static /* not final */ boolean ALLOW_UNSUPPORTED_REMOTING_VERSIONS = SystemProperties.getBoolean(SlaveComputer.class.getName() + &quot;.allowUnsupportedRemotingVersions&quot;);</b>
&nbsp;
&nbsp;    // use RingBufferLogHandler class name to configure for backward compatibility
<b class="nc">&nbsp;    private static final int DEFAULT_RING_BUFFER_SIZE = SystemProperties.getInteger(RingBufferLogHandler.class.getName() + &quot;.defaultSize&quot;, 256);</b>
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(SlaveComputer.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
