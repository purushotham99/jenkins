


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > CLI</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.cli</a>
</div>

<h1>Coverage Summary for Class: CLI (hudson.cli)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CLI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/204)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CLI$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$1Authenticator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$1CLIEndpoint</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$ClientSideImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$ClientSideImpl$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$Mode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CLI$NotTalkingToJenkinsException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/257)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.cli;
&nbsp;
&nbsp;import static java.util.logging.Level.FINE;
&nbsp;import static java.util.logging.Level.parse;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.cli.client.Messages;
&nbsp;import jakarta.websocket.ClientEndpointConfig;
&nbsp;import jakarta.websocket.Endpoint;
&nbsp;import jakarta.websocket.EndpointConfig;
&nbsp;import jakarta.websocket.Session;
&nbsp;import java.io.DataInputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLConnection;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.security.GeneralSecurityException;
&nbsp;import java.security.KeyPair;
&nbsp;import java.security.SecureRandom;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Properties;
&nbsp;import java.util.logging.Handler;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import javax.net.ssl.HttpsURLConnection;
&nbsp;import javax.net.ssl.SSLContext;
&nbsp;import javax.net.ssl.TrustManager;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.glassfish.tyrus.client.ClientManager;
&nbsp;import org.glassfish.tyrus.client.ClientProperties;
&nbsp;import org.glassfish.tyrus.client.SslEngineConfigurator;
&nbsp;import org.glassfish.tyrus.container.jdk.client.JdkClientContainer;
&nbsp;
&nbsp;/**
&nbsp; * CLI entry point to Jenkins.
&nbsp; */
&nbsp;@SuppressFBWarnings(value = &quot;CRLF_INJECTION_LOGS&quot;, justification = &quot;We don&#39;t care about this behavior&quot;)
&nbsp;public class CLI {
&nbsp;
&nbsp;    private CLI() {}
&nbsp;
&nbsp;    /**
&nbsp;     * Make sure the connection is open against Jenkins server.
&nbsp;     *
&nbsp;     * @param c The open connection.
&nbsp;     * @throws IOException in case of communication problem.
&nbsp;     * @throws NotTalkingToJenkinsException when connection is not made to Jenkins service.
&nbsp;     */
&nbsp;    /*package*/ static void verifyJenkinsConnection(URLConnection c) throws IOException {
<b class="nc">&nbsp;        if (c.getHeaderField(&quot;X-Hudson&quot;) == null &amp;&amp; c.getHeaderField(&quot;X-Jenkins&quot;) == null)</b>
<b class="nc">&nbsp;            throw new NotTalkingToJenkinsException(c);</b>
&nbsp;    }
&nbsp;
&nbsp;    /*package*/ static final class NotTalkingToJenkinsException extends IOException {
&nbsp;        NotTalkingToJenkinsException(String s) {
<b class="nc">&nbsp;            super(s);</b>
&nbsp;        }
&nbsp;
&nbsp;        NotTalkingToJenkinsException(URLConnection c) {
<b class="nc">&nbsp;            super(&quot;There&#39;s no Jenkins running at &quot; + c.getURL().toString());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void main(final String[] _args) throws Exception {
&nbsp;        try {
<b class="nc">&nbsp;            System.exit(_main(_args));</b>
<b class="nc">&nbsp;        } catch (NotTalkingToJenkinsException ex) {</b>
<b class="nc">&nbsp;            System.err.println(ex.getMessage());</b>
<b class="nc">&nbsp;            System.exit(3);</b>
<b class="nc">&nbsp;        } catch (Throwable t) {</b>
&nbsp;            // if the CLI main thread die, make sure to kill the JVM.
<b class="nc">&nbsp;            t.printStackTrace();</b>
<b class="nc">&nbsp;            System.exit(-1);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private enum Mode { HTTP, SSH, WEB_SOCKET }</b>
&nbsp;
&nbsp;    public static int _main(String[] _args) throws Exception {
<b class="nc">&nbsp;        List&lt;String&gt; args = Arrays.asList(_args);</b>
<b class="nc">&nbsp;        PrivateKeyProvider provider = new PrivateKeyProvider();</b>
&nbsp;
<b class="nc">&nbsp;        String url = System.getenv(&quot;JENKINS_URL&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        if (url == null)</b>
<b class="nc">&nbsp;            url = System.getenv(&quot;HUDSON_URL&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        boolean noKeyAuth = false;</b>
&nbsp;
<b class="nc">&nbsp;        Mode mode = null;</b>
&nbsp;
<b class="nc">&nbsp;        String user = null;</b>
<b class="nc">&nbsp;        String auth = null;</b>
<b class="nc">&nbsp;        String bearer = null;</b>
&nbsp;
<b class="nc">&nbsp;        String userIdEnv = System.getenv(&quot;JENKINS_USER_ID&quot;);</b>
<b class="nc">&nbsp;        String tokenEnv = System.getenv(&quot;JENKINS_API_TOKEN&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        boolean strictHostKey = false;</b>
<b class="nc">&nbsp;        boolean noCertificateCheck = false;</b>
&nbsp;
<b class="nc">&nbsp;        while (!args.isEmpty()) {</b>
<b class="nc">&nbsp;            String head = args.get(0);</b>
<b class="nc">&nbsp;            if (head.equals(&quot;-version&quot;)) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;Version: &quot; + computeVersion());</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-http&quot;)) {</b>
<b class="nc">&nbsp;                if (mode != null) {</b>
<b class="nc">&nbsp;                    printUsage(&quot;-http clashes with previously defined mode &quot; + mode);</b>
<b class="nc">&nbsp;                    return -1;</b>
&nbsp;                }
<b class="nc">&nbsp;                mode = Mode.HTTP;</b>
<b class="nc">&nbsp;                args = args.subList(1, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-ssh&quot;)) {</b>
<b class="nc">&nbsp;                if (mode != null) {</b>
<b class="nc">&nbsp;                    printUsage(&quot;-ssh clashes with previously defined mode &quot; + mode);</b>
<b class="nc">&nbsp;                    return -1;</b>
&nbsp;                }
<b class="nc">&nbsp;                mode = Mode.SSH;</b>
<b class="nc">&nbsp;                args = args.subList(1, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-webSocket&quot;)) {</b>
<b class="nc">&nbsp;                if (mode != null) {</b>
<b class="nc">&nbsp;                    printUsage(&quot;-webSocket clashes with previously defined mode &quot; + mode);</b>
<b class="nc">&nbsp;                    return -1;</b>
&nbsp;                }
<b class="nc">&nbsp;                mode = Mode.WEB_SOCKET;</b>
<b class="nc">&nbsp;                args = args.subList(1, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-remoting&quot;)) {</b>
<b class="nc">&nbsp;                printUsage(&quot;-remoting mode is no longer supported&quot;);</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-s&quot;) &amp;&amp; args.size() &gt;= 2) {</b>
<b class="nc">&nbsp;                url = args.get(1);</b>
<b class="nc">&nbsp;                args = args.subList(2, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-noCertificateCheck&quot;)) {</b>
<b class="nc">&nbsp;                LOGGER.info(&quot;Skipping HTTPS certificate checks altogether. Note that this is not secure at all.&quot;);</b>
<b class="nc">&nbsp;                noCertificateCheck = true;</b>
<b class="nc">&nbsp;                args = args.subList(1, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-noKeyAuth&quot;)) {</b>
<b class="nc">&nbsp;                noKeyAuth = true;</b>
<b class="nc">&nbsp;                args = args.subList(1, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-i&quot;) &amp;&amp; args.size() &gt;= 2) {</b>
<b class="nc">&nbsp;                File f = getFileFromArguments(args);</b>
<b class="nc">&nbsp;                if (!f.exists()) {</b>
<b class="nc">&nbsp;                    printUsage(Messages.CLI_NoSuchFileExists(f));</b>
<b class="nc">&nbsp;                    return -1;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                provider.readFrom(f);</b>
&nbsp;
<b class="nc">&nbsp;                args = args.subList(2, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-strictHostKey&quot;)) {</b>
<b class="nc">&nbsp;                strictHostKey = true;</b>
<b class="nc">&nbsp;                args = args.subList(1, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-user&quot;) &amp;&amp; args.size() &gt;= 2) {</b>
<b class="nc">&nbsp;                user = args.get(1);</b>
<b class="nc">&nbsp;                args = args.subList(2, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-auth&quot;) &amp;&amp; args.size() &gt;= 2) {</b>
<b class="nc">&nbsp;                auth = args.get(1);</b>
<b class="nc">&nbsp;                args = args.subList(2, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-bearer&quot;) &amp;&amp; args.size() &gt;= 2) {</b>
<b class="nc">&nbsp;                bearer = args.get(1);</b>
<b class="nc">&nbsp;                args = args.subList(2, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (head.equals(&quot;-logger&quot;) &amp;&amp; args.size() &gt;= 2) {</b>
<b class="nc">&nbsp;                Level level = parse(args.get(1));</b>
<b class="nc">&nbsp;                for (Handler h : Logger.getLogger(&quot;&quot;).getHandlers()) {</b>
<b class="nc">&nbsp;                    h.setLevel(level);</b>
&nbsp;                }
<b class="nc">&nbsp;                for (Logger logger : new Logger[] {LOGGER, FullDuplexHttpStream.LOGGER, PlainCLIProtocol.LOGGER, Logger.getLogger(&quot;org.apache.sshd&quot;)}) { // perhaps also Channel</b>
<b class="nc">&nbsp;                    logger.setLevel(level);</b>
&nbsp;                }
<b class="nc">&nbsp;                args = args.subList(2, args.size());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;            break;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (url == null) {</b>
<b class="nc">&nbsp;            printUsage(Messages.CLI_NoURL());</b>
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (auth != null &amp;&amp; bearer != null) {</b>
<b class="nc">&nbsp;            LOGGER.warning(&quot;-auth and -bearer are mutually exclusive&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (auth == null &amp;&amp; bearer == null) {</b>
&nbsp;            // -auth option not set
<b class="nc">&nbsp;            if (StringUtils.isNotBlank(userIdEnv) &amp;&amp; StringUtils.isNotBlank(tokenEnv)) {</b>
<b class="nc">&nbsp;                auth = StringUtils.defaultString(userIdEnv).concat(&quot;:&quot;).concat(StringUtils.defaultString(tokenEnv));</b>
<b class="nc">&nbsp;            } else if (StringUtils.isNotBlank(userIdEnv) || StringUtils.isNotBlank(tokenEnv)) {</b>
<b class="nc">&nbsp;                printUsage(Messages.CLI_BadAuth());</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            } // Otherwise, none credentials were set
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!url.endsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;            url += &#39;/&#39;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (args.isEmpty())</b>
<b class="nc">&nbsp;            args = List.of(&quot;help&quot;); // default to help</b>
&nbsp;
<b class="nc">&nbsp;        if (mode == null) {</b>
<b class="nc">&nbsp;            mode = Mode.WEB_SOCKET;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.log(FINE, &quot;using connection mode {0}&quot;, mode);</b>
&nbsp;
<b class="nc">&nbsp;        if (user != null &amp;&amp; auth != null) {</b>
<b class="nc">&nbsp;            LOGGER.warning(&quot;-user and -auth are mutually exclusive&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (mode == Mode.SSH) {</b>
<b class="nc">&nbsp;            if (user == null) {</b>
&nbsp;                // TODO SshCliAuthenticator already autodetects the user based on public key; why cannot AsynchronousCommand.getCurrentUser do the same?
<b class="nc">&nbsp;                LOGGER.warning(&quot;-user required when using -ssh&quot;);</b>
<b class="nc">&nbsp;                return -1;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!noKeyAuth &amp;&amp; !provider.hasKeys()) {</b>
<b class="nc">&nbsp;                provider.readFromDefaultLocations();</b>
&nbsp;            }
<b class="nc">&nbsp;            return SSHCLI.sshConnection(url, user, args, provider, strictHostKey);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (strictHostKey) {</b>
<b class="nc">&nbsp;            LOGGER.warning(&quot;-strictHostKey meaningful only with -ssh&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (noKeyAuth) {</b>
<b class="nc">&nbsp;            LOGGER.warning(&quot;-noKeyAuth meaningful only with -ssh&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (user != null) {</b>
<b class="nc">&nbsp;            LOGGER.warning(&quot;Warning: -user ignored unless using -ssh&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        CLIConnectionFactory factory = new CLIConnectionFactory().noCertificateCheck(noCertificateCheck);</b>
<b class="nc">&nbsp;        String userInfo = new URL(url).getUserInfo();</b>
<b class="nc">&nbsp;        if (userInfo != null) {</b>
<b class="nc">&nbsp;            factory = factory.basicAuth(userInfo);</b>
<b class="nc">&nbsp;        } else if (auth != null) {</b>
<b class="nc">&nbsp;            factory = factory.basicAuth(auth.startsWith(&quot;@&quot;) ? readAuthFromFile(auth).trim() : auth);</b>
<b class="nc">&nbsp;        } else if (bearer != null) {</b>
<b class="nc">&nbsp;            factory = factory.bearerAuth(bearer.startsWith(&quot;@&quot;) ? readAuthFromFile(bearer).trim() : bearer);</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        if (mode == Mode.HTTP) {</b>
<b class="nc">&nbsp;            return plainHttpConnection(url, args, factory);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (mode == Mode.WEB_SOCKET) {</b>
<b class="nc">&nbsp;            return webSocketConnection(url, args, factory);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new AssertionError();</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(value = {&quot;PATH_TRAVERSAL_IN&quot;, &quot;URLCONNECTION_SSRF_FD&quot;}, justification = &quot;User provided values for running the program.&quot;)
&nbsp;    private static String readAuthFromFile(String auth) throws IOException {
&nbsp;        Path path;
&nbsp;        try {
<b class="nc">&nbsp;            path = Paths.get(auth.substring(1));</b>
<b class="nc">&nbsp;        } catch (InvalidPathException e) {</b>
<b class="nc">&nbsp;            throw new IOException(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return Files.readString(path, Charset.defaultCharset());</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(value = {&quot;PATH_TRAVERSAL_IN&quot;, &quot;URLCONNECTION_SSRF_FD&quot;}, justification = &quot;User provided values for running the program.&quot;)
&nbsp;    private static File getFileFromArguments(List&lt;String&gt; args) {
<b class="nc">&nbsp;        return new File(args.get(1));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int webSocketConnection(String url, List&lt;String&gt; args, CLIConnectionFactory factory) throws Exception {
<b class="nc">&nbsp;        LOGGER.fine(() -&gt; &quot;Trying to connect to &quot; + url + &quot; via plain protocol over WebSocket&quot;);</b>
<b class="nc">&nbsp;        class CLIEndpoint extends Endpoint {</b>
&nbsp;            @Override
<b class="nc">&nbsp;            public void onOpen(Session session, EndpointConfig config) {}</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        class Authenticator extends ClientEndpointConfig.Configurator {</b>
&nbsp;            @Override
&nbsp;            public void beforeRequest(Map&lt;String, List&lt;String&gt;&gt; headers) {
<b class="nc">&nbsp;                if (factory.authorization != null) {</b>
<b class="nc">&nbsp;                    headers.put(&quot;Authorization&quot;, List.of(factory.authorization));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        ClientManager client = ClientManager.createClient(JdkClientContainer.class.getName()); // ~ ContainerProvider.getWebSocketContainer()</b>
<b class="nc">&nbsp;        client.getProperties().put(ClientProperties.REDIRECT_ENABLED, true); // https://tyrus-project.github.io/documentation/1.13.1/index/tyrus-proprietary-config.html#d0e1775</b>
<b class="nc">&nbsp;        if (factory.noCertificateCheck) {</b>
<b class="nc">&nbsp;            SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</b>
<b class="nc">&nbsp;            sslContext.init(null, new TrustManager[] {new NoCheckTrustManager()}, new SecureRandom());</b>
<b class="nc">&nbsp;            SslEngineConfigurator sslEngineConfigurator = new SslEngineConfigurator(sslContext);</b>
<b class="nc">&nbsp;            sslEngineConfigurator.setHostnameVerifier((s, sslSession) -&gt; true);</b>
<b class="nc">&nbsp;            client.getProperties().put(ClientProperties.SSL_ENGINE_CONFIGURATOR, sslEngineConfigurator);</b>
&nbsp;        }
<b class="nc">&nbsp;        Session session = client.connectToServer(new CLIEndpoint(), ClientEndpointConfig.Builder.create().configurator(new Authenticator()).build(), URI.create(url.replaceFirst(&quot;^http&quot;, &quot;ws&quot;) + &quot;cli/ws&quot;));</b>
<b class="nc">&nbsp;        PlainCLIProtocol.Output out = new PlainCLIProtocol.Output() {</b>
&nbsp;            @Override
&nbsp;            public void send(byte[] data) throws IOException {
<b class="nc">&nbsp;                session.getBasicRemote().sendBinary(ByteBuffer.wrap(data));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void close() throws IOException {
<b class="nc">&nbsp;                session.close();</b>
&nbsp;            }
&nbsp;        };
<b class="nc">&nbsp;        try (ClientSideImpl connection = new ClientSideImpl(out)) {</b>
<b class="nc">&nbsp;            session.addMessageHandler(InputStream.class, is -&gt; {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    connection.handle(new DataInputStream(is));</b>
<b class="nc">&nbsp;                } catch (IOException x) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            });
<b class="nc">&nbsp;            connection.start(args);</b>
<b class="nc">&nbsp;            return connection.exit();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static int plainHttpConnection(String url, List&lt;String&gt; args, CLIConnectionFactory factory)
&nbsp;            throws GeneralSecurityException, IOException, InterruptedException {
<b class="nc">&nbsp;        LOGGER.log(FINE, &quot;Trying to connect to {0} via plain protocol over HTTP&quot;, url);</b>
<b class="nc">&nbsp;        if (factory.noCertificateCheck) {</b>
<b class="nc">&nbsp;            SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</b>
<b class="nc">&nbsp;            sslContext.init(null, new TrustManager[] {new NoCheckTrustManager()}, new SecureRandom());</b>
<b class="nc">&nbsp;            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());</b>
<b class="nc">&nbsp;            HttpsURLConnection.setDefaultHostnameVerifier((s, sslSession) -&gt; true);</b>
&nbsp;        }
<b class="nc">&nbsp;        FullDuplexHttpStream streams = new FullDuplexHttpStream(new URL(url), &quot;cli?remoting=false&quot;, factory.authorization);</b>
<b class="nc">&nbsp;        try (ClientSideImpl connection = new ClientSideImpl(new PlainCLIProtocol.FramedOutput(streams.getOutputStream()))) {</b>
<b class="nc">&nbsp;            connection.start(args);</b>
<b class="nc">&nbsp;            InputStream is = streams.getInputStream();</b>
<b class="nc">&nbsp;            if (is.read() != 0) { // cf. FullDuplexHttpService</b>
<b class="nc">&nbsp;                throw new IOException(&quot;expected to see initial zero byte; perhaps you are connecting to an old server which does not support -http?&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            new PlainCLIProtocol.FramedReader(connection, is).start();</b>
<b class="nc">&nbsp;            new Thread(&quot;ping&quot;) { // JENKINS-46659</b>
&nbsp;                @Override
&nbsp;                public void run() {
&nbsp;                    try {
<b class="nc">&nbsp;                        Thread.sleep(PING_INTERVAL);</b>
<b class="nc">&nbsp;                        while (!connection.complete) {</b>
<b class="nc">&nbsp;                            LOGGER.fine(&quot;sending ping&quot;);</b>
<b class="nc">&nbsp;                            connection.sendEncoding(Charset.defaultCharset().name()); // no-op at this point</b>
<b class="nc">&nbsp;                            Thread.sleep(PING_INTERVAL);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (IOException | InterruptedException x) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            }.start();</b>
<b class="nc">&nbsp;            return connection.exit();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static final class ClientSideImpl extends PlainCLIProtocol.ClientSide {
&nbsp;
&nbsp;        volatile boolean complete;
<b class="nc">&nbsp;        private int exit = -1;</b>
&nbsp;
&nbsp;        ClientSideImpl(PlainCLIProtocol.Output out) {
<b class="nc">&nbsp;            super(out);</b>
&nbsp;        }
&nbsp;
&nbsp;        void start(List&lt;String&gt; args) throws IOException {
<b class="nc">&nbsp;            for (String arg : args) {</b>
<b class="nc">&nbsp;                sendArg(arg);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            sendEncoding(Charset.defaultCharset().name());</b>
<b class="nc">&nbsp;            sendLocale(Locale.getDefault().toString());</b>
<b class="nc">&nbsp;            sendStart();</b>
<b class="nc">&nbsp;            new Thread(&quot;input reader&quot;) {</b>
&nbsp;                @Override
&nbsp;                public void run() {
&nbsp;                    try {
<b class="nc">&nbsp;                        final OutputStream stdin = streamStdin();</b>
<b class="nc">&nbsp;                        byte[] buf = new byte[60_000]; // less than 64Kb frame size for WS</b>
<b class="nc">&nbsp;                        while (!complete) {</b>
<b class="nc">&nbsp;                            int len = System.in.read(buf);</b>
<b class="nc">&nbsp;                            if (len == -1) {</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                stdin.write(buf, 0, len);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        sendEndStdin();</b>
<b class="nc">&nbsp;                    } catch (IOException x) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            }.start();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected synchronized void onExit(int code) {
<b class="nc">&nbsp;            this.exit = code;</b>
<b class="nc">&nbsp;            finished();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onStdout(byte[] chunk) throws IOException {
<b class="nc">&nbsp;            System.out.write(chunk);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onStderr(byte[] chunk) throws IOException {
<b class="nc">&nbsp;            System.err.write(chunk);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void handleClose() {
<b class="nc">&nbsp;            finished();</b>
&nbsp;        }
&nbsp;
&nbsp;        private synchronized void finished() {
<b class="nc">&nbsp;            complete = true;</b>
<b class="nc">&nbsp;            notifyAll();</b>
&nbsp;        }
&nbsp;
&nbsp;        synchronized int exit() throws InterruptedException {
<b class="nc">&nbsp;            while (!complete) {</b>
<b class="nc">&nbsp;                wait();</b>
&nbsp;            }
<b class="nc">&nbsp;            return exit;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static String computeVersion() {
<b class="nc">&nbsp;        Properties props = new Properties();</b>
<b class="nc">&nbsp;        try (InputStream is = CLI.class.getResourceAsStream(&quot;/jenkins/cli/jenkins-cli-version.properties&quot;)) {</b>
<b class="nc">&nbsp;            if (is != null) {</b>
<b class="nc">&nbsp;                props.load(is);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace(); // if the version properties is missing, that&#39;s OK.</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return props.getProperty(&quot;version&quot;, &quot;?&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads RSA/DSA private key in a PEM format into {@link KeyPair}.
&nbsp;     */
&nbsp;    public static KeyPair loadKey(File f, String passwd) throws IOException, GeneralSecurityException {
<b class="nc">&nbsp;        return PrivateKeyProvider.loadKey(f, passwd);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static KeyPair loadKey(File f) throws IOException, GeneralSecurityException {
<b class="nc">&nbsp;        return loadKey(f, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads RSA/DSA private key in a PEM format into {@link KeyPair}.
&nbsp;     */
&nbsp;    public static KeyPair loadKey(String pemString, String passwd) throws IOException, GeneralSecurityException {
<b class="nc">&nbsp;        return PrivateKeyProvider.loadKey(pemString, passwd);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static KeyPair loadKey(String pemString) throws IOException, GeneralSecurityException {
<b class="nc">&nbsp;        return loadKey(pemString, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** For access from {@code HelpCommand}. */
&nbsp;    static String usage() {
<b class="nc">&nbsp;        return Messages.CLI_Usage();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void printUsage(String msg) {
<b class="nc">&nbsp;        if (msg != null)   System.out.println(msg);</b>
<b class="nc">&nbsp;        System.err.println(usage());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    static final Logger LOGGER = Logger.getLogger(CLI.class.getName());</b>
&nbsp;
<b class="nc">&nbsp;    private static final int PING_INTERVAL = Integer.getInteger(CLI.class.getName() + &quot;.pingInterval&quot;, 3_000); // JENKINS-59267</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
