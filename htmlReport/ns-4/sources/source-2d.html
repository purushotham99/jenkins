


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > PlainCLIProtocol</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.cli</a>
</div>

<h1>Coverage Summary for Class: PlainCLIProtocol (hudson.cli)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PlainCLIProtocol</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PlainCLIProtocol$ClientSide</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.7%
  </span>
  <span class="absValue">
    (11/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$EitherSide</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88%
  </span>
  <span class="absValue">
    (22/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$EitherSide$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$FramedOutput</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$FramedReader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.4%
  </span>
  <span class="absValue">
    (19/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$Op</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$Output</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$ProtocolException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PlainCLIProtocol$ServerSide</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (12/20)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    78.9%
  </span>
  <span class="absValue">
    (30/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.1%
  </span>
  <span class="absValue">
    (85/123)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright 2017 CloudBees, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.cli;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.Closeable;
&nbsp;import java.io.DataInputStream;
&nbsp;import java.io.DataOutputStream;
&nbsp;import java.io.EOFException;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.nio.channels.ClosedChannelException;
&nbsp;import java.nio.channels.ReadPendingException;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import org.apache.commons.io.IOUtils;
&nbsp;import org.apache.commons.io.input.BoundedInputStream;
&nbsp;import org.apache.commons.io.input.CountingInputStream;
&nbsp;
&nbsp;/**
&nbsp; * CLI protocol working over a plain socket-like connection, without SSH or Remoting.
&nbsp; * Each side consists of frames starting with an {@code int} length,
&nbsp; * then a {@code byte} opcode, then any opcode-specific data.
&nbsp; * The length does not count the length field itself nor the opcode, so it is nonnegative.
&nbsp; */
&nbsp;class PlainCLIProtocol {
&nbsp;
<b class="fc">&nbsp;    static final Logger LOGGER = Logger.getLogger(PlainCLIProtocol.class.getName());</b>
&nbsp;
&nbsp;    /** One-byte operation to send to the other side. */
<b class="fc">&nbsp;    private enum Op {</b>
&nbsp;        /** UTF-8 command name or argument. */
<b class="fc">&nbsp;        ARG(true),</b>
&nbsp;        /** UTF-8 locale identifier. */
<b class="fc">&nbsp;        LOCALE(true),</b>
&nbsp;        /** UTF-8 client encoding. */
<b class="fc">&nbsp;        ENCODING(true),</b>
&nbsp;        /** Start running command. */
<b class="fc">&nbsp;        START(true),</b>
&nbsp;        /** Exit code, as int. */
<b class="fc">&nbsp;        EXIT(false),</b>
&nbsp;        /** Chunk of stdin, as int length followed by bytes. */
<b class="fc">&nbsp;        STDIN(true),</b>
&nbsp;        /** EOF on stdin. */
<b class="fc">&nbsp;        END_STDIN(true),</b>
&nbsp;        /** Chunk of stdout. */
<b class="fc">&nbsp;        STDOUT(false),</b>
&nbsp;        /** Chunk of stderr. */
<b class="fc">&nbsp;        STDERR(false);</b>
&nbsp;        /** True if sent from the client to the server; false if sent from the server to the client. */
&nbsp;        final boolean clientSide;
&nbsp;
<b class="fc">&nbsp;        Op(boolean clientSide) {</b>
<b class="fc">&nbsp;            this.clientSide = clientSide;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    interface Output extends Closeable {
&nbsp;        void send(byte[] data) throws IOException;
&nbsp;    }
&nbsp;
&nbsp;    static final class FramedOutput implements Output {
&nbsp;
&nbsp;        private final DataOutputStream dos;
&nbsp;
<b class="fc">&nbsp;        FramedOutput(OutputStream os) {</b>
<b class="fc">&nbsp;            dos = new DataOutputStream(os);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void send(byte[] data) throws IOException {
<b class="fc">&nbsp;            dos.writeInt(data.length - 1); // not counting the opcode</b>
<b class="fc">&nbsp;            dos.write(data);</b>
<b class="fc">&nbsp;            dos.flush();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void close() throws IOException {
<b class="nc">&nbsp;            dos.close();</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    static final class FramedReader extends Thread {
&nbsp;
&nbsp;        private final EitherSide side;
&nbsp;        private final CountingInputStream cis;
&nbsp;        private final FlightRecorderInputStream flightRecorder;
&nbsp;        private final DataInputStream dis;
&nbsp;
&nbsp;        FramedReader(EitherSide side, InputStream is) {
<b class="fc">&nbsp;            super(&quot;PlainCLIProtocol&quot;); // TODO set distinctive Thread.name</b>
<b class="fc">&nbsp;            this.side = side;</b>
<b class="fc">&nbsp;            cis = new CountingInputStream(is);</b>
<b class="fc">&nbsp;            flightRecorder = new FlightRecorderInputStream(cis);</b>
<b class="fc">&nbsp;            dis = new DataInputStream(flightRecorder);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
&nbsp;                while (true) {
<b class="fc">&nbsp;                    LOGGER.finest(&quot;reading frame&quot;);</b>
&nbsp;                    int framelen;
&nbsp;                    try {
<b class="fc">&nbsp;                        framelen = dis.readInt();</b>
<b class="nc">&nbsp;                    } catch (EOFException x) {</b>
<b class="nc">&nbsp;                        side.handleClose();</b>
<b class="nc">&nbsp;                        break; // TODO verify that we hit EOF immediately, not partway into framelen</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    if (framelen &lt; 0) {</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;corrupt stream: negative frame length&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    LOGGER.finest(&quot;read frame length &quot; + framelen);</b>
<b class="fc">&nbsp;                    long start = cis.getByteCount();</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        side.handle(new DataInputStream(new BoundedInputStream(dis, /* op byte not counted */framelen + 1)));</b>
<b class="fc">&nbsp;                    } catch (ProtocolException x) {</b>
<b class="fc">&nbsp;                        LOGGER.log(Level.WARNING, null, x);</b>
&nbsp;                        // but read another frame
&nbsp;                    } finally {
<b class="fc">&nbsp;                        long actuallyRead = cis.getByteCount() - start;</b>
<b class="fc">&nbsp;                        long unread = framelen + 1 - actuallyRead;</b>
<b class="fc">&nbsp;                        if (unread &gt; 0) {</b>
<b class="nc">&nbsp;                            LOGGER.warning(() -&gt; &quot;Did not read &quot; + unread + &quot; bytes&quot;);</b>
<b class="nc">&nbsp;                            IOUtils.skipFully(dis, unread);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (ClosedChannelException x) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, null, x);</b>
<b class="nc">&nbsp;                side.handleClose();</b>
<b class="nc">&nbsp;            } catch (IOException x) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, null, flightRecorder.analyzeCrash(x, &quot;broken stream&quot;));</b>
<b class="nc">&nbsp;            } catch (ReadPendingException x) {</b>
&nbsp;                // in case trick in CLIAction does not work
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, null, x);</b>
<b class="nc">&nbsp;                side.handleClose();</b>
<b class="nc">&nbsp;            } catch (RuntimeException x) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;                side.handleClose();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static final class ProtocolException extends IOException {
&nbsp;        ProtocolException(String message) {
<b class="fc">&nbsp;            super(message);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    abstract static class EitherSide implements Closeable {
&nbsp;
&nbsp;        private final Output out;
&nbsp;
<b class="fc">&nbsp;        protected EitherSide(Output out) {</b>
<b class="fc">&nbsp;            this.out = out;</b>
&nbsp;        }
&nbsp;
&nbsp;        protected abstract void handleClose();
&nbsp;
&nbsp;        final void handle(DataInputStream dis) throws IOException {
<b class="fc">&nbsp;            byte b = dis.readByte();</b>
<b class="fc">&nbsp;            if (b &lt; 0) { // i.e., &gt;127</b>
<b class="nc">&nbsp;                throw new IOException(&quot;corrupt stream: negative operation code&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (b &gt;= Op.values().length) {</b>
<b class="fc">&nbsp;                throw new ProtocolException(&quot;unknown operation #&quot; + b);</b>
&nbsp;            }
<b class="fc">&nbsp;            Op op = Op.values()[b];</b>
<b class="fc">&nbsp;            LOGGER.finest(() -&gt; &quot;handling frame with &quot; + op);</b>
<b class="fc">&nbsp;            if (!handle(op, dis)) {</b>
<b class="nc">&nbsp;                throw new ProtocolException(&quot;unhandled: &quot; + op);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected abstract boolean handle(Op op, DataInputStream dis) throws IOException;
&nbsp;
&nbsp;        protected final synchronized void send(Op op) throws IOException {
<b class="fc">&nbsp;            send(op, new byte[0], 0, 0);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final synchronized void send(Op op, int v) throws IOException {
<b class="fc">&nbsp;            ByteArrayOutputStream baos = new ByteArrayOutputStream(4);</b>
<b class="fc">&nbsp;            new DataOutputStream(baos).writeInt(v);</b>
<b class="fc">&nbsp;            send(op, baos.toByteArray());</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final synchronized void send(Op op, byte[] chunk, int off, int len) throws IOException {
<b class="fc">&nbsp;            byte[] data = new byte[len + 1];</b>
<b class="fc">&nbsp;            data[0] = (byte) op.ordinal();</b>
<b class="fc">&nbsp;            System.arraycopy(chunk, off, data, 1, len);</b>
<b class="fc">&nbsp;            out.send(data);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final void send(Op op, byte[] chunk) throws IOException {
<b class="fc">&nbsp;            send(op, chunk, 0, chunk.length);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final void send(Op op, String text) throws IOException {
<b class="fc">&nbsp;            ByteArrayOutputStream buf = new ByteArrayOutputStream();</b>
<b class="fc">&nbsp;            new DataOutputStream(buf).writeUTF(text);</b>
<b class="fc">&nbsp;            send(op, buf.toByteArray());</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final OutputStream stream(final Op op) {
<b class="fc">&nbsp;            return new OutputStream() {</b>
&nbsp;                @Override
&nbsp;                public void write(int b) throws IOException {
<b class="nc">&nbsp;                    send(op, new byte[] {(byte) b});</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void write(@NonNull byte[] b, int off, int len) throws IOException {
<b class="nc">&nbsp;                    send(op, b, off, len);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void write(@NonNull byte[] b) throws IOException {
<b class="fc">&nbsp;                    send(op, b);</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public synchronized void close() throws IOException {
<b class="nc">&nbsp;            out.close();</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    abstract static class ServerSide extends EitherSide {</b>
&nbsp;
&nbsp;        ServerSide(Output out) {
<b class="fc">&nbsp;            super(out);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected final boolean handle(Op op, DataInputStream dis) throws IOException {
<b class="fc">&nbsp;            assert op.clientSide;</b>
<b class="fc">&nbsp;            switch (op) {</b>
&nbsp;            case ARG:
<b class="fc">&nbsp;                onArg(dis.readUTF());</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case LOCALE:
<b class="nc">&nbsp;                onLocale(dis.readUTF());</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            case ENCODING:
<b class="nc">&nbsp;                onEncoding(dis.readUTF());</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            case START:
<b class="fc">&nbsp;                onStart();</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case STDIN:
<b class="fc">&nbsp;                onStdin(dis.readAllBytes());</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case END_STDIN:
<b class="nc">&nbsp;                onEndStdin();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected abstract void onArg(String text);
&nbsp;
&nbsp;        protected abstract void onLocale(String text);
&nbsp;
&nbsp;        protected abstract void onEncoding(String text);
&nbsp;
&nbsp;        protected abstract void onStart();
&nbsp;
&nbsp;        protected abstract void onStdin(byte[] chunk) throws IOException;
&nbsp;
&nbsp;        protected abstract void onEndStdin() throws IOException;
&nbsp;
&nbsp;        public final void sendExit(int code) throws IOException {
<b class="fc">&nbsp;            send(Op.EXIT, code);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final OutputStream streamStdout() {
<b class="fc">&nbsp;            return stream(Op.STDOUT);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final OutputStream streamStderr() {
<b class="nc">&nbsp;            return stream(Op.STDERR);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    abstract static class ClientSide extends EitherSide {</b>
&nbsp;
&nbsp;        ClientSide(Output out) {
<b class="fc">&nbsp;            super(out);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected boolean handle(Op op, DataInputStream dis) throws IOException {
<b class="fc">&nbsp;            assert !op.clientSide;</b>
<b class="fc">&nbsp;            switch (op) {</b>
&nbsp;            case EXIT:
<b class="fc">&nbsp;                onExit(dis.readInt());</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case STDOUT:
<b class="fc">&nbsp;                onStdout(dis.readAllBytes());</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            case STDERR:
<b class="nc">&nbsp;                onStderr(dis.readAllBytes());</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            default:
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected abstract void onExit(int code);
&nbsp;
&nbsp;        // TODO more efficient to change signature to InputStream, then use IOUtils.copy
&nbsp;        protected abstract void onStdout(byte[] chunk) throws IOException;
&nbsp;
&nbsp;        protected abstract void onStderr(byte[] chunk) throws IOException;
&nbsp;
&nbsp;        public final void sendArg(String text) throws IOException {
<b class="fc">&nbsp;            send(Op.ARG, text);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final void sendLocale(String text) throws IOException {
<b class="nc">&nbsp;            send(Op.LOCALE, text);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final void sendEncoding(String text) throws IOException {
<b class="nc">&nbsp;            send(Op.ENCODING, text);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final void sendStart() throws IOException {
<b class="fc">&nbsp;            send(Op.START);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final OutputStream streamStdin() {
<b class="fc">&nbsp;            return stream(Op.STDIN);</b>
&nbsp;        }
&nbsp;
&nbsp;        public final void sendEndStdin() throws IOException {
<b class="nc">&nbsp;            send(Op.END_STDIN);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private PlainCLIProtocol() {}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
