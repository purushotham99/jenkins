


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FormValidation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.util</a>
</div>

<h1>Coverage Summary for Class: FormValidation (hudson.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FormValidation</td>
<td class="coverageStat">
  <span class="percent">
    53.3%
  </span>
  <span class="absValue">
    (16/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (35/84)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FormValidation$1</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$2</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$CheckMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$FileValidator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$FileValidator$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$Kind</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FormValidation$URLCheck</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34.3%
  </span>
  <span class="absValue">
    (12/35)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (25/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31%
  </span>
  <span class="absValue">
    (57/184)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.util;
&nbsp;
&nbsp;import static hudson.Functions.jsStringEscape;
&nbsp;import static hudson.Util.singleQuote;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.FilePath;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Launcher;
&nbsp;import hudson.ProxyConfiguration;
&nbsp;import hudson.RelativePath;
&nbsp;import hudson.Util;
&nbsp;import hudson.model.AbstractBuild;
&nbsp;import hudson.model.BuildListener;
&nbsp;import hudson.model.Descriptor;
&nbsp;import hudson.tasks.Builder;
&nbsp;import hudson.util.ReflectionUtils.Parameter;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.HttpURLConnection;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLConnection;
&nbsp;import java.net.http.HttpClient;
&nbsp;import java.net.http.HttpRequest;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Base64;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.stream.Stream;
&nbsp;import javax.servlet.ServletException;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;
&nbsp;/**
&nbsp; * Represents the result of the form field validation.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Use one of the factory methods to create an instance, then return it from your {@code doCheckXyz}
&nbsp; * method. (Via {@link HttpResponse}, the returned object will render the result into {@link StaplerResponse}.)
&nbsp; * This way of designing form field validation allows you to reuse {@code doCheckXyz()} methods
&nbsp; * programmatically as well (by using {@link #kind}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * For typical validation needs, this class offers a number of {@code validateXXX(...)} methods, such as
&nbsp; * {@link #validateExecutable(String)}. {@link FilePath} also has a number of {@code validateXXX(...)} methods
&nbsp; * that you may be able to reuse.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Also see {@code doCheckCvsRoot} in {@code CVSSCM} as an example.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This class extends {@link IOException} so that it can be thrown from a method. This allows one to reuse
&nbsp; * the checking logic as a part of the real computation, such as:
&nbsp; *
&nbsp; * &lt;pre&gt;
&nbsp; * String getAntVersion(File antHome) throws FormValidation {
&nbsp; *    if (!antHome.isDirectory())
&nbsp; *        throw FormValidation.error(antHome+&quot; doesn&#39;t look like a home directory&quot;);
&nbsp; *    ...
&nbsp; *    return IOUtils.toString(new File(antHome,&quot;version&quot;));
&nbsp; * }
&nbsp; *
&nbsp; * ...
&nbsp; *
&nbsp; * public FormValidation doCheckAntVersion(@QueryParameter String f) {
&nbsp; *     try {
&nbsp; *         return ok(getAntVersion(new File(f)));
&nbsp; *     } catch (FormValidation f) {
&nbsp; *         return f;
&nbsp; *     }
&nbsp; * }
&nbsp; *
&nbsp; * ...
&nbsp; *
&nbsp; * public void {@linkplain Builder#perform(AbstractBuild, Launcher, BuildListener) perform}(...) {
&nbsp; *     String version = getAntVersion(antHome);
&nbsp; *     ...
&nbsp; * }
&nbsp; * &lt;/pre&gt;
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @since 1.294
&nbsp; */
&nbsp;public abstract class FormValidation extends IOException implements HttpResponse {
<b class="fc">&nbsp;    /* package */ static /* non-final for Groovy */ boolean APPLY_CONTENT_SECURITY_POLICY_HEADERS = SystemProperties.getBoolean(FormValidation.class.getName() + &quot;.applyContentSecurityPolicyHeaders&quot;, true);</b>
&nbsp;    /**
&nbsp;     * Indicates the kind of result.
&nbsp;     */
&nbsp;
<b class="fc">&nbsp;    public enum Kind {</b>
&nbsp;        /**
&nbsp;         * Form field value was OK and no problem was detected.
&nbsp;         */
<b class="fc">&nbsp;        OK,</b>
&nbsp;        /**
&nbsp;         * Form field value contained something suspicious. For some limited use cases
&nbsp;         * the value could be valid, but we suspect the user made a mistake.
&nbsp;         */
<b class="fc">&nbsp;        WARNING,</b>
&nbsp;        /**
&nbsp;         * Form field value contained a problem that should be corrected.
&nbsp;         */
<b class="fc">&nbsp;        ERROR</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out a string error message that indicates an error.
&nbsp;     *
&nbsp;     * @param message
&nbsp;     *      Human readable message to be sent. {@code error(null)}
&nbsp;     *      can be used as {@code ok()}.
&nbsp;     */
&nbsp;    public static FormValidation error(String message) {
<b class="fc">&nbsp;        return errorWithMarkup(message == null ? null : Util.escape(message));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation warning(String message) {
<b class="fc">&nbsp;        return warningWithMarkup(message == null ? null : Util.escape(message));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation ok(String message) {
<b class="fc">&nbsp;        return okWithMarkup(message == null ? null : Util.escape(message));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Singleton instance that represents &quot;OK&quot;.
&nbsp;     */
<b class="fc">&nbsp;    private static final FormValidation OK = respond(Kind.OK, &quot;&lt;div/&gt;&quot;);</b>
&nbsp;
&nbsp;    public static FormValidation ok() {
<b class="fc">&nbsp;        return OK;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out a string error message that indicates an error,
&nbsp;     * by formatting it with {@link String#format(String, Object[])}
&nbsp;     */
&nbsp;    public static FormValidation error(String format, Object... args) {
<b class="nc">&nbsp;        return error(String.format(format, args));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation warning(String format, Object... args) {
<b class="nc">&nbsp;        return warning(String.format(format, args));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation ok(String format, Object... args) {
<b class="nc">&nbsp;        return ok(String.format(format, args));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out a string error message, with optional &quot;show details&quot; link that expands to the full stack trace.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Use this with caution, so that anonymous users do not gain too much insights into the state of the system,
&nbsp;     * as error stack trace often reveals a lot of information. Consider if a check operation needs to be exposed
&nbsp;     * to everyone or just those who have higher access to job/hudson/etc.
&nbsp;     */
&nbsp;    public static FormValidation error(Throwable e, String message) {
<b class="fc">&nbsp;        return _error(Kind.ERROR, e, message);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation warning(Throwable e, String message) {
<b class="nc">&nbsp;        return _error(Kind.WARNING, e, message);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static FormValidation _error(Kind kind, Throwable e, String message) {
<b class="fc">&nbsp;        if (e == null)    return _errorWithMarkup(Util.escape(message), kind);</b>
&nbsp;
<b class="fc">&nbsp;        return _errorWithMarkup(Util.escape(message) +</b>
&nbsp;            &quot; &lt;/div&gt;&lt;div&gt;&lt;a href=&#39;#&#39; class=&#39;showDetails&#39;&gt;&quot;
<b class="fc">&nbsp;            + Messages.FormValidation_Error_Details()</b>
&nbsp;            + &quot;&lt;/a&gt;&lt;pre style=&#39;display:none&#39;&gt;&quot;
<b class="fc">&nbsp;            + Util.escape(Functions.printThrowable(e)) +</b>
&nbsp;            &quot;&lt;/pre&gt;&quot;, kind
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation error(Throwable e, String format, Object... args) {
<b class="nc">&nbsp;        return error(e, String.format(format, args));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation warning(Throwable e, String format, Object... args) {
<b class="nc">&nbsp;        return warning(e, String.format(format, args));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Aggregate multiple validations into one.
&nbsp;     *
&nbsp;     * @return Validation of the least successful kind aggregating all child messages.
&nbsp;     * @since 1.590
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;POTENTIAL_XML_INJECTION&quot;, justification = &quot;intentional; caller&#39;s responsibility to escape HTML&quot;)
&nbsp;    public static @NonNull FormValidation aggregate(@NonNull Collection&lt;FormValidation&gt; validations) {
<b class="fc">&nbsp;        if (validations == null || validations.isEmpty()) return FormValidation.ok();</b>
&nbsp;
<b class="fc">&nbsp;        if (validations.size() == 1) return validations.iterator().next();</b>
&nbsp;
<b class="fc">&nbsp;        final StringBuilder sb = new StringBuilder(&quot;&lt;ul style=&#39;list-style-type: none; padding-left: 0; margin: 0&#39;&gt;&quot;);</b>
<b class="fc">&nbsp;        FormValidation.Kind worst = Kind.OK;</b>
<b class="fc">&nbsp;        for (FormValidation validation : validations) {</b>
<b class="fc">&nbsp;            sb.append(&quot;&lt;li&gt;&quot;).append(validation.renderHtml()).append(&quot;&lt;/li&gt;&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            if (validation.kind.ordinal() &gt; worst.ordinal()) {</b>
<b class="fc">&nbsp;                worst = validation.kind;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        sb.append(&quot;&lt;/ul&gt;&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        return respond(worst, sb.toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out an HTML fragment that indicates an error.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method must be used with care to avoid cross-site scripting
&nbsp;     * attack.
&nbsp;     *
&nbsp;     * @param message
&nbsp;     *      Human readable message to be sent. {@code error(null)}
&nbsp;     *      can be used as {@code ok()}.
&nbsp;     */
&nbsp;    public static FormValidation errorWithMarkup(String message) {
<b class="fc">&nbsp;        return _errorWithMarkup(message, Kind.ERROR);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation warningWithMarkup(String message) {
<b class="fc">&nbsp;        return _errorWithMarkup(message, Kind.WARNING);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static FormValidation okWithMarkup(String message) {
<b class="fc">&nbsp;        return _errorWithMarkup(message, Kind.OK);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static FormValidation _errorWithMarkup(final String message, final Kind kind) {
<b class="fc">&nbsp;        if (message == null)</b>
<b class="nc">&nbsp;            return ok();</b>
<b class="fc">&nbsp;        return new FormValidation(kind, message) {</b>
&nbsp;            @Override
&nbsp;            public String renderHtml() {
<b class="fc">&nbsp;                StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="fc">&nbsp;                if (req == null) { // being called from some other context</b>
<b class="fc">&nbsp;                    return message;</b>
&nbsp;                }
<b class="nc">&nbsp;                return &quot;&lt;div class=\&quot;&quot; + kind.name().toLowerCase(Locale.ENGLISH) + &quot;\&quot;&gt;&quot; +</b>
&nbsp;                        message + &quot;&lt;/div&gt;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            @Override public String toString() {
<b class="nc">&nbsp;                return kind + &quot;: &quot; + message;</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out an arbitrary HTML fragment as the output.
&nbsp;     */
&nbsp;    public static FormValidation respond(Kind kind, final String html) {
<b class="fc">&nbsp;        return new FormValidation(kind) {</b>
&nbsp;            @Override
&nbsp;            public String renderHtml() {
<b class="fc">&nbsp;                return html;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override public String toString() {
<b class="nc">&nbsp;                return kind + &quot;: &quot; + html;</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs an application-specific validation on the given file.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is used as a piece in a bigger validation effort.
&nbsp;     */
<b class="nc">&nbsp;    public abstract static class FileValidator {</b>
&nbsp;        public abstract FormValidation validate(File f);
&nbsp;
&nbsp;        /**
&nbsp;         * Singleton instance that does no check.
&nbsp;         */
<b class="nc">&nbsp;        public static final FileValidator NOOP = new FileValidator() {</b>
&nbsp;            @Override
&nbsp;            public FormValidation validate(File f) {
<b class="nc">&nbsp;                return ok();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given string points to an executable file.
&nbsp;     */
&nbsp;    public static FormValidation validateExecutable(String exe) {
<b class="nc">&nbsp;        return validateExecutable(exe, FileValidator.NOOP);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given string points to an executable file.
&nbsp;     *
&nbsp;     * @param exeValidator
&nbsp;     *      If the validation process discovers a valid executable program on the given path,
&nbsp;     *      the specified {@link FileValidator} can perform additional checks (such as making sure
&nbsp;     *      that it has the right version, etc.)
&nbsp;     */
&nbsp;    public static FormValidation validateExecutable(String exe, FileValidator exeValidator) {
&nbsp;        // insufficient permission to perform validation?
<b class="nc">&nbsp;        if (!Jenkins.get().hasPermission(Jenkins.ADMINISTER)) return ok();</b>
<b class="nc">&nbsp;        final FormValidation[] result = {null};</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            DOSToUnixPathHelper.iteratePath(exe, new DOSToUnixPathHelper.Helper() {</b>
&nbsp;                @Override
&nbsp;                public void ok() {
<b class="nc">&nbsp;                    result[0] = FormValidation.ok();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void checkExecutable(File fexe) {
<b class="nc">&nbsp;                    result[0] = exeValidator.validate(fexe);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void error(String string) {
<b class="nc">&nbsp;                    result[0] = FormValidation.error(string);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void validate(File fexe) {
<b class="nc">&nbsp;                    result[0] = exeValidator.validate(fexe);</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            return result[0];</b>
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            return FormValidation.error(e, &quot;Unexpected error&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given string is a non-negative integer.
&nbsp;     */
&nbsp;    public static FormValidation validateNonNegativeInteger(String value) {
&nbsp;        try {
<b class="nc">&nbsp;            if (Integer.parseInt(value) &lt; 0)</b>
<b class="nc">&nbsp;                return error(hudson.model.Messages.Hudson_NotANonNegativeNumber());</b>
<b class="nc">&nbsp;            return ok();</b>
<b class="nc">&nbsp;        } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;            return error(hudson.model.Messages.Hudson_NotANumber());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Make sure that the given string is an integer in the range specified by the lower and upper bounds (both inclusive)
&nbsp;     *
&nbsp;     * @param value the value to check
&nbsp;     * @param lower the lower bound (inclusive)
&nbsp;     * @param upper the upper bound (inclusive)
&nbsp;     *
&nbsp;     * @since 2.104
&nbsp;     */
&nbsp;    public static FormValidation validateIntegerInRange(String value, int lower, int upper) {
&nbsp;        try {
<b class="nc">&nbsp;            int intValue = Integer.parseInt(value);</b>
<b class="nc">&nbsp;            if (intValue &lt; lower) {</b>
<b class="nc">&nbsp;                return error(hudson.model.Messages.Hudson_MustBeAtLeast(lower));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (intValue &gt; upper) {</b>
<b class="nc">&nbsp;                return error(hudson.model.Messages.Hudson_MustBeAtMost(upper));</b>
&nbsp;            }
<b class="nc">&nbsp;            return ok();</b>
<b class="nc">&nbsp;        } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;            return error(hudson.model.Messages.Hudson_NotANumber());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given string is a positive integer.
&nbsp;     */
&nbsp;    public static FormValidation validatePositiveInteger(String value) {
&nbsp;        try {
<b class="nc">&nbsp;            if (Integer.parseInt(value) &lt;= 0)</b>
<b class="nc">&nbsp;                return error(hudson.model.Messages.Hudson_NotAPositiveNumber());</b>
<b class="nc">&nbsp;            return ok();</b>
<b class="nc">&nbsp;        } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;            return error(hudson.model.Messages.Hudson_NotANumber());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given string is not null or empty.
&nbsp;     */
&nbsp;    public static FormValidation validateRequired(String value) {
<b class="fc">&nbsp;        if (Util.fixEmptyAndTrim(value) == null)</b>
<b class="fc">&nbsp;            return error(Messages.FormValidation_ValidateRequired());</b>
<b class="fc">&nbsp;        return ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given string is a base64 encoded text.
&nbsp;     *
&nbsp;     * @param allowWhitespace
&nbsp;     *      if you allow whitespace (CR,LF,etc) in base64 encoding
&nbsp;     * @param allowEmpty
&nbsp;     *      Is empty string allowed?
&nbsp;     * @param errorMessage
&nbsp;     *      Error message.
&nbsp;     * @since 1.305
&nbsp;     */
&nbsp;    public static FormValidation validateBase64(String value, boolean allowWhitespace, boolean allowEmpty, String errorMessage) {
&nbsp;        try {
<b class="nc">&nbsp;            String v = value;</b>
<b class="nc">&nbsp;            if (!allowWhitespace) {</b>
<b class="nc">&nbsp;                if (v.indexOf(&#39; &#39;) &gt;= 0 || v.indexOf(&#39;\n&#39;) &gt;= 0)</b>
<b class="nc">&nbsp;                    return error(errorMessage);</b>
&nbsp;            }
<b class="nc">&nbsp;            v = v.trim();</b>
<b class="nc">&nbsp;            if (!allowEmpty &amp;&amp; v.isEmpty())</b>
<b class="nc">&nbsp;                return error(errorMessage);</b>
&nbsp;
<b class="nc">&nbsp;            Base64.getDecoder().decode(v.getBytes(StandardCharsets.UTF_8));</b>
<b class="nc">&nbsp;            return ok();</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            return error(errorMessage);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenient base class for checking the validity of URLs.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This allows the check method to call various utility methods in a concise syntax.
&nbsp;     */
<b class="fc">&nbsp;    public abstract static class URLCheck {</b>
&nbsp;        /**
&nbsp;         * Open the given URI and read text content from it. This method honors the Content-type
&nbsp;         * header.
&nbsp;         *
&nbsp;         * @throws IOException if the URI scheme is not supported, the connection was interrupted,
&nbsp;         *     or the response was an error
&nbsp;         * @since 2.382
&nbsp;         */
&nbsp;        protected Stream&lt;String&gt; open(URI uri) throws IOException {
<b class="fc">&nbsp;            HttpClient httpClient = ProxyConfiguration.newHttpClient();</b>
&nbsp;            HttpRequest httpRequest;
&nbsp;            try {
<b class="fc">&nbsp;                httpRequest = ProxyConfiguration.newHttpRequestBuilder(uri).GET().build();</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;                throw new IOException(e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            java.net.http.HttpResponse&lt;Stream&lt;String&gt;&gt; httpResponse;
&nbsp;            try {
<b class="fc">&nbsp;                httpResponse =</b>
<b class="fc">&nbsp;                        httpClient.send(httpRequest, java.net.http.HttpResponse.BodyHandlers.ofLines());</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                throw new IOException(e);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (httpResponse.statusCode() != HttpURLConnection.HTTP_OK) {</b>
<b class="nc">&nbsp;                throw new IOException(</b>
&nbsp;                        &quot;Server returned HTTP response code &quot;
<b class="nc">&nbsp;                                + httpResponse.statusCode()</b>
&nbsp;                                + &quot; for URI &quot;
&nbsp;                                + uri);
&nbsp;            }
<b class="fc">&nbsp;            return httpResponse.body();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Opens the given URL and reads text content from it.
&nbsp;         * This method honors Content-type header.
&nbsp;         *
&nbsp;         * @deprecated use {@link #open(URI)}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        protected BufferedReader open(URL url) throws IOException {
&nbsp;            // use HTTP content type to find out the charset.
<b class="nc">&nbsp;            URLConnection con = ProxyConfiguration.open(url);</b>
<b class="nc">&nbsp;            if (con == null) { // TODO is this even permitted by URL.openConnection?</b>
<b class="nc">&nbsp;                throw new IOException(url.toExternalForm());</b>
&nbsp;            }
<b class="nc">&nbsp;            return new BufferedReader(</b>
<b class="nc">&nbsp;                new InputStreamReader(con.getInputStream(), getCharset(con)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Find the string literal from the given stream of lines.
&nbsp;         *
&nbsp;         * @return true if found, false otherwise
&nbsp;         * @since 2.382
&nbsp;         */
&nbsp;        protected boolean findText(Stream&lt;String&gt; in, String literal) {
<b class="fc">&nbsp;            try (in) {</b>
<b class="fc">&nbsp;                return in.anyMatch(line -&gt; line.contains(literal));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Finds the string literal from the given reader.
&nbsp;         * @return
&nbsp;         *      true if found, false otherwise.
&nbsp;         * @deprecated use {@link #findText(Stream, String)}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        protected boolean findText(BufferedReader in, String literal) throws IOException {
&nbsp;            String line;
<b class="nc">&nbsp;            while ((line = in.readLine()) != null)</b>
<b class="nc">&nbsp;                if (line.contains(literal))</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Calls the {@link FormValidation#error(String)} method with a reasonable error message.
&nbsp;         * Use this method when the {@link #open(URL)} or {@link #findText(BufferedReader, String)} fails.
&nbsp;         *
&nbsp;         * @param url
&nbsp;         *      Pass in the URL that was connected. Used for error diagnosis.
&nbsp;         */
&nbsp;        protected FormValidation handleIOException(String url, IOException e) throws IOException, ServletException {
&nbsp;            // any invalid URL comes here
<b class="nc">&nbsp;            if (e.getMessage().equals(url))</b>
&nbsp;                // Sun JRE (and probably others too) often return just the URL in the error.
<b class="nc">&nbsp;                return error(&quot;Unable to connect &quot; + url, e);</b>
&nbsp;            else
<b class="nc">&nbsp;                return error(e.getMessage(), e);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Figures out the charset from the content-type header.
&nbsp;         */
&nbsp;        private String getCharset(URLConnection con) {
<b class="nc">&nbsp;            for (String t : con.getContentType().split(&quot;;&quot;)) {</b>
<b class="nc">&nbsp;                t = t.trim().toLowerCase(Locale.ENGLISH);</b>
<b class="nc">&nbsp;                if (t.startsWith(&quot;charset=&quot;))</b>
<b class="nc">&nbsp;                    return t.substring(8);</b>
&nbsp;            }
&nbsp;            // couldn&#39;t find it. HTML spec says default is US-ASCII,
&nbsp;            // but UTF-8 is a better choice since
&nbsp;            // (1) it&#39;s compatible with US-ASCII
&nbsp;            // (2) a well-written web applications tend to use UTF-8
<b class="nc">&nbsp;            return &quot;UTF-8&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implement the actual form validation logic, by using other convenience methods defined in this class.
&nbsp;         * If you are not using any of those, you don&#39;t need to extend from this class.
&nbsp;         */
&nbsp;        protected abstract FormValidation check() throws IOException, ServletException;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    public final Kind kind;
&nbsp;
&nbsp;    /**
&nbsp;     * Instances should be created via one of the factory methods above.
&nbsp;     */
<b class="fc">&nbsp;    private FormValidation(Kind kind) {</b>
<b class="fc">&nbsp;        this.kind = kind;</b>
&nbsp;    }
&nbsp;
&nbsp;    private FormValidation(Kind kind, String message) {
<b class="fc">&nbsp;        super(message);</b>
<b class="fc">&nbsp;        this.kind = kind;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {
<b class="nc">&nbsp;        respond(rsp, renderHtml());</b>
&nbsp;    }
&nbsp;
&nbsp;    public abstract String renderHtml();
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out an arbitrary HTML fragment as the output.
&nbsp;     */
&nbsp;    protected void respond(StaplerResponse rsp, String html) throws IOException, ServletException {
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/html;charset=UTF-8&quot;);</b>
<b class="nc">&nbsp;        if (APPLY_CONTENT_SECURITY_POLICY_HEADERS) {</b>
<b class="nc">&nbsp;            for (String header : new String[]{&quot;Content-Security-Policy&quot;, &quot;X-WebKit-CSP&quot;, &quot;X-Content-Security-Policy&quot;}) {</b>
<b class="nc">&nbsp;                rsp.setHeader(header, &quot;sandbox; default-src &#39;none&#39;;&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        rsp.getWriter().print(html);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds up the check URL for the client-side JavaScript to call back.
&nbsp;     */
&nbsp;    public static class CheckMethod {
&nbsp;        private final Descriptor descriptor;
&nbsp;        private final Method method;
&nbsp;        private final String capitalizedFieldName;
&nbsp;
&nbsp;        /**
&nbsp;         * Names of the parameters to pass from the client.
&nbsp;         */
&nbsp;        private final List&lt;String&gt; names;
&nbsp;
&nbsp;        private volatile String checkUrl;    // cached once computed
&nbsp;        private volatile String dependsOn;  //  cached once computed
&nbsp;
<b class="nc">&nbsp;        public CheckMethod(Descriptor descriptor, String fieldName) {</b>
<b class="nc">&nbsp;            this.descriptor = descriptor;</b>
<b class="nc">&nbsp;            this.capitalizedFieldName = StringUtils.capitalize(fieldName);</b>
&nbsp;
<b class="nc">&nbsp;            method = ReflectionUtils.getPublicMethodNamed(descriptor.getClass(), &quot;doCheck&quot; + capitalizedFieldName);</b>
<b class="nc">&nbsp;            if (method != null) {</b>
<b class="nc">&nbsp;                names = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                findParameters(method);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                names = null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Builds query parameter line by figuring out what should be submitted
&nbsp;         */
&nbsp;        private void findParameters(Method method) {
<b class="nc">&nbsp;            for (Parameter p : ReflectionUtils.getParameters(method)) {</b>
<b class="nc">&nbsp;                QueryParameter qp = p.annotation(QueryParameter.class);</b>
<b class="nc">&nbsp;                if (qp != null) {</b>
<b class="nc">&nbsp;                    String name = qp.value();</b>
<b class="nc">&nbsp;                    if (name.isEmpty()) name = p.name();</b>
<b class="nc">&nbsp;                    if (name == null || name.isEmpty())</b>
<b class="nc">&nbsp;                        continue;   // unknown parameter name. we&#39;ll report the error when the form is submitted.</b>
<b class="nc">&nbsp;                    if (name.equals(&quot;value&quot;))</b>
<b class="nc">&nbsp;                        continue;   // &#39;value&#39; parameter is implicit</b>
&nbsp;
<b class="nc">&nbsp;                    RelativePath rp = p.annotation(RelativePath.class);</b>
<b class="nc">&nbsp;                    if (rp != null)</b>
<b class="nc">&nbsp;                        name = rp.value() + &#39;/&#39; + name;</b>
&nbsp;
<b class="nc">&nbsp;                    names.add(name);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Method m = ReflectionUtils.getPublicMethodNamed(p.type(), &quot;fromStapler&quot;);</b>
<b class="nc">&nbsp;                if (m != null)    findParameters(m);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Obtains the 1.526-compatible single string representation.
&nbsp;         *
&nbsp;         * This method computes JavaScript expression, which evaluates to the URL that the client should request
&nbsp;         * the validation to.
&nbsp;         * A modern version depends on {@link #toStemUrl()} and {@link #getDependsOn()}
&nbsp;         */
&nbsp;        public String toCheckUrl() {
<b class="nc">&nbsp;            if (names == null)    return null;</b>
&nbsp;
<b class="nc">&nbsp;            if (checkUrl == null) {</b>
<b class="nc">&nbsp;                StringBuilder buf = new StringBuilder(singleQuote(relativePath()));</b>
<b class="nc">&nbsp;                if (!names.isEmpty()) {</b>
<b class="nc">&nbsp;                    buf.append(&quot;+qs(this).addThis()&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                    for (String name : names) {</b>
<b class="nc">&nbsp;                        buf.append(&quot;.nearBy(&#39;&quot;).append(name).append(&quot;&#39;)&quot;);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    buf.append(&quot;.toString()&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                checkUrl = buf.toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            // put this under the right contextual umbrella.
&nbsp;            // &#39;a&#39; in getCurrentDescriptorByNameUrl is always non-null because we already have Hudson as the sentinel
<b class="nc">&nbsp;            return &#39;\&#39;&#39; + jsStringEscape(Descriptor.getCurrentDescriptorByNameUrl()) + &quot;/&#39;+&quot; + checkUrl;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the URL that the JavaScript should hit to perform form validation, except
&nbsp;         * the query string portion (which is built on the client side.)
&nbsp;         */
&nbsp;        public String toStemUrl() {
<b class="nc">&nbsp;            if (names == null)    return null;</b>
<b class="nc">&nbsp;            return Descriptor.getCurrentDescriptorByNameUrl() + &#39;/&#39; + relativePath();</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getDependsOn() {
<b class="nc">&nbsp;            if (names == null)    return null;</b>
&nbsp;
<b class="nc">&nbsp;            if (dependsOn == null)</b>
<b class="nc">&nbsp;                dependsOn = String.join(&quot; &quot;, names);</b>
<b class="nc">&nbsp;            return dependsOn;</b>
&nbsp;        }
&nbsp;
&nbsp;        private String relativePath() {
<b class="nc">&nbsp;            return descriptor.getDescriptorUrl() + &quot;/check&quot; + capitalizedFieldName;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
