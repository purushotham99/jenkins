


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ProcessTree</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.util</a>
</div>

<h1>Coverage Summary for Class: ProcessTree (hudson.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ProcessTree</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.1%
  </span>
  <span class="absValue">
    (22/61)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ProcessTree$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$AIX</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$AIX$AIXProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/96)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Darwin</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Darwin$DarwinProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Darwin$DarwinProcess$1StringArrayMemory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$DoVetoersExist</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$FreeBSD</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$FreeBSD$FreeBSDProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Linux</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Linux$LinuxProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$ListAll</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Local</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$OSProcess</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15%
  </span>
  <span class="absValue">
    (6/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$OSProcess$CheckVetoes</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$ProcessCallable</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$ProcfsUnix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Remote</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (5/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Remote$RemoteProcess</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$SerializedProcess</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Solaris</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Solaris$SolarisProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/84)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Unix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$UnixProcess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$Windows</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.9%
  </span>
  <span class="absValue">
    (7/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$WindowsOSProcess</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    23.5%
  </span>
  <span class="absValue">
    (12/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessTree$WindowsOSProcessException</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    23.6%
  </span>
  <span class="absValue">
    (29/123)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.6%
  </span>
  <span class="absValue">
    (65/680)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.util;
&nbsp;
&nbsp;import static com.sun.jna.Pointer.NULL;
&nbsp;import static hudson.util.jna.GNUCLibrary.LIBC;
&nbsp;import static java.util.logging.Level.FINER;
&nbsp;import static java.util.logging.Level.FINEST;
&nbsp;
&nbsp;import com.sun.jna.LastErrorException;
&nbsp;import com.sun.jna.Memory;
&nbsp;import com.sun.jna.Native;
&nbsp;import com.sun.jna.NativeLong;
&nbsp;import com.sun.jna.ptr.IntByReference;
&nbsp;import com.sun.jna.ptr.NativeLongByReference;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.EnvVars;
&nbsp;import hudson.FilePath;
&nbsp;import hudson.Util;
&nbsp;import hudson.remoting.Channel;
&nbsp;import hudson.remoting.VirtualChannel;
&nbsp;import hudson.util.ProcessKillingVeto.VetoCause;
&nbsp;import hudson.util.ProcessTree.OSProcess;
&nbsp;import hudson.util.ProcessTreeRemoting.IOSProcess;
&nbsp;import hudson.util.ProcessTreeRemoting.IProcessTree;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.ByteArrayOutputStream;
&nbsp;import java.io.DataInputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectStreamException;
&nbsp;import java.io.RandomAccessFile;
&nbsp;import java.io.Serializable;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.nio.file.Files;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.function.Consumer;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import jenkins.agents.AgentComputerUtil;
&nbsp;import jenkins.security.SlaveToMasterCallable;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import org.jenkinsci.remoting.SerializableOnlyOverRemoting;
&nbsp;import org.jvnet.winp.WinProcess;
&nbsp;import org.jvnet.winp.WinpException;
&nbsp;
&nbsp;/**
&nbsp; * Represents a snapshot of the process tree of the current system.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * A {@link ProcessTree} is really conceptually a map from process ID to a {@link OSProcess} object.
&nbsp; * When Hudson runs on platforms that support process introspection, this allows you to introspect
&nbsp; * and do some useful things on processes. On other platforms, the implementation falls back to
&nbsp; * &quot;do nothing&quot; behavior.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * {@link ProcessTree} is remotable.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @since 1.315
&nbsp; */
&nbsp;public abstract class ProcessTree implements Iterable&lt;OSProcess&gt;, IProcessTree, SerializableOnlyOverRemoting {
&nbsp;    /**
&nbsp;     * To be filled in the constructor of the derived type.
&nbsp;     */
<b class="fc">&nbsp;    protected final Map&lt;Integer/*pid*/, OSProcess&gt; processes = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Lazily obtained {@link ProcessKiller}s to be applied on this process tree.
&nbsp;     */
&nbsp;    private transient volatile List&lt;ProcessKiller&gt; killers;
&nbsp;
&nbsp;    /**
&nbsp;     * Flag to skip the veto check since there aren&#39;t any.
&nbsp;     */
&nbsp;    private boolean skipVetoes;
&nbsp;
&nbsp;    // instantiation only allowed for subtypes in this class
<b class="fc">&nbsp;    private ProcessTree() {</b>
<b class="fc">&nbsp;       skipVetoes = false;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private ProcessTree(boolean vetoesExist) {</b>
<b class="fc">&nbsp;        skipVetoes = !vetoesExist;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the process given a specific ID, or null if no such process exists.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public final OSProcess get(int pid) {
<b class="fc">&nbsp;        return processes.get(pid);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Lists all the processes in the system.
&nbsp;     */
&nbsp;    @Override
&nbsp;    @NonNull
&nbsp;    public final Iterator&lt;OSProcess&gt; iterator() {
<b class="fc">&nbsp;        return processes.values().iterator();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Try to convert {@link Process} into this process object
&nbsp;     * or null if it fails (for example, maybe the snapshot is taken after
&nbsp;     * this process has already finished.)
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public abstract OSProcess get(@NonNull Process proc);
&nbsp;
&nbsp;    /**
&nbsp;     * Kills all the processes that have matching environment variables.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * In this method, the method is given a
&nbsp;     * &quot;model environment variables&quot;, which is a list of environment variables
&nbsp;     * and their values that are characteristic to the launched process.
&nbsp;     * The implementation is expected to find processes
&nbsp;     * in the system that inherit these environment variables, and kill
&nbsp;     * them all. This is suitable for locating daemon processes
&nbsp;     * that cannot be tracked by the regular ancestor/descendant relationship.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public abstract void killAll(@NonNull Map&lt;String, String&gt; modelEnvVars) throws InterruptedException;
&nbsp;
&nbsp;    /**
&nbsp;     * The time to wait between sending Ctrl+C and killing the process. (JENKINS-17116)
&nbsp;     *
&nbsp;     * The default is 5 seconds. Careful! There are other timers in the system that may
&nbsp;     * interfere with this value here, e.g. in org.jenkinsci.plugins.workflow.cps.CpsThread.stop
&nbsp;     */
<b class="fc">&nbsp;    private final long softKillWaitSeconds = Integer.getInteger(&quot;SoftKillWaitSeconds&quot;, 5);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience method that does {@link #killAll(Map)} and {@link OSProcess#killRecursively()}.
&nbsp;     * This is necessary to reliably kill the process and its descendants, as some OS
&nbsp;     * may not implement {@link #killAll(Map)}.
&nbsp;     *
&nbsp;     * Either of the parameter can be null.
&nbsp;     */
&nbsp;    public void killAll(@CheckForNull Process proc, @CheckForNull Map&lt;String, String&gt; modelEnvVars) throws InterruptedException {
<b class="nc">&nbsp;        LOGGER.fine(&quot;killAll: process=&quot; + proc + &quot; and envs=&quot; + modelEnvVars);</b>
&nbsp;
<b class="nc">&nbsp;        if (proc != null) {</b>
<b class="nc">&nbsp;            OSProcess p = get(proc);</b>
<b class="nc">&nbsp;            if (p != null) p.killRecursively();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (modelEnvVars != null)</b>
<b class="nc">&nbsp;            killAll(modelEnvVars);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains the list of killers.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    /*package*/ final List&lt;ProcessKiller&gt; getKillers() throws InterruptedException {
<b class="nc">&nbsp;        if (killers == null)</b>
&nbsp;            try {
<b class="nc">&nbsp;                VirtualChannel channelToController = AgentComputerUtil.getChannelToController();</b>
<b class="nc">&nbsp;                if (channelToController != null) {</b>
<b class="nc">&nbsp;                    killers = channelToController.call(new ListAll());</b>
&nbsp;                } else {
&nbsp;                    // used in an environment that doesn&#39;t support talk-back to the master.
&nbsp;                    // let&#39;s do with what we have.
<b class="nc">&nbsp;                    killers = Collections.emptyList();</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IOException | Error e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to obtain killers&quot;, e);</b>
<b class="nc">&nbsp;                killers = Collections.emptyList();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        return killers;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class ListAll extends SlaveToMasterCallable&lt;List&lt;ProcessKiller&gt;, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public List&lt;ProcessKiller&gt; call() throws IOException {
<b class="nc">&nbsp;            return new ArrayList&lt;&gt;(ProcessKiller.all());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a process.
&nbsp;     */
&nbsp;    public abstract class OSProcess implements IOSProcess, Serializable {
&nbsp;        final int pid;
&nbsp;
&nbsp;        // instantiation only allowed for subtypes in this class
<b class="fc">&nbsp;        private OSProcess(int pid) {</b>
<b class="fc">&nbsp;            this.pid = pid;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public final int getPid() {
<b class="fc">&nbsp;            return pid;</b>
&nbsp;        }
&nbsp;        /**
&nbsp;         * Gets the parent process. This method may return null, because
&nbsp;         * there&#39;s no guarantee that we are getting a consistent snapshot
&nbsp;         * of the whole system state.
&nbsp;         */
&nbsp;
&nbsp;        @Override
&nbsp;        @CheckForNull
&nbsp;        public abstract OSProcess getParent();
&nbsp;
&nbsp;        /*package*/ final ProcessTree getTree() {
<b class="fc">&nbsp;            return ProcessTree.this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Immediate child processes.
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public final List&lt;OSProcess&gt; getChildren() {
<b class="nc">&nbsp;            List&lt;OSProcess&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (OSProcess p : ProcessTree.this)</b>
<b class="nc">&nbsp;                if (p.getParent() == this)</b>
<b class="nc">&nbsp;                    r.add(p);</b>
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Kills this process.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public abstract void kill() throws InterruptedException;
&nbsp;
&nbsp;        void killByKiller() throws InterruptedException {
<b class="nc">&nbsp;            for (ProcessKiller killer : getKillers())</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (killer.kill(this)) {</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IOException | Error e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to kill pid=&quot; + getPid(), e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Kills this process and all the descendants.
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the notion of &quot;descendants&quot; is somewhat vague,
&nbsp;         * in the presence of such things like daemons. On platforms
&nbsp;         * where the recursive operation is not supported, this just kills
&nbsp;         * the current process.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public abstract void killRecursively() throws InterruptedException;
&nbsp;
&nbsp;        /**
&nbsp;         * @return The first non-null {@link VetoCause} provided by a process killing veto extension for this OSProcess.
&nbsp;         * null if no one objects killing the process.
&nbsp;         */
&nbsp;        protected @CheckForNull VetoCause getVeto() {
<b class="nc">&nbsp;            String causeMessage = null;</b>
&nbsp;
&nbsp;            // Quick check, does anything exist to check against
<b class="nc">&nbsp;            if (!skipVetoes) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    VirtualChannel channelToController = AgentComputerUtil.getChannelToController();</b>
<b class="nc">&nbsp;                    if (channelToController != null) {</b>
<b class="nc">&nbsp;                        CheckVetoes vetoCheck = new CheckVetoes(this);</b>
<b class="nc">&nbsp;                        causeMessage = channelToController.call(vetoCheck);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IOException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;I/O Exception while checking for vetoes&quot;, e);</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Interrupted Exception while checking for vetoes&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (causeMessage != null) {</b>
<b class="nc">&nbsp;                return new VetoCause(causeMessage);</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets the command-line arguments of this process.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * On Windows, where the OS models command-line arguments as a single string, this method
&nbsp;         * computes the approximated tokenization.
&nbsp;         */
&nbsp;        @Override
&nbsp;        @NonNull
&nbsp;        public abstract List&lt;String&gt; getArguments();
&nbsp;
&nbsp;        /**
&nbsp;         * Obtains the environment variables of this process.
&nbsp;         *
&nbsp;         * @return
&nbsp;         *      empty map if failed (for example because the process is already dead,
&nbsp;         *      or the permission was denied.)
&nbsp;         */
&nbsp;        @Override
&nbsp;        @NonNull
&nbsp;        public abstract EnvVars getEnvironmentVariables();
&nbsp;
&nbsp;        /**
&nbsp;         * Given the environment variable of a process and the &quot;model environment variable&quot; that Hudson
&nbsp;         * used for launching the build, returns true if there&#39;s a match (which means the process should
&nbsp;         * be considered a descendant of a build.)
&nbsp;         */
&nbsp;        public final boolean hasMatchingEnvVars(Map&lt;String, String&gt; modelEnvVar) {
<b class="nc">&nbsp;            if (modelEnvVar.isEmpty())</b>
&nbsp;                // sanity check so that we don&#39;t start rampage.
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="nc">&nbsp;            SortedMap&lt;String, String&gt; envs = getEnvironmentVariables();</b>
<b class="nc">&nbsp;            for (Map.Entry&lt;String, String&gt; e : modelEnvVar.entrySet()) {</b>
<b class="nc">&nbsp;                String v = envs.get(e.getKey());</b>
<b class="nc">&nbsp;                if (v == null || !v.equals(e.getValue()))</b>
<b class="nc">&nbsp;                    return false;   // no match</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Executes a chunk of code at the same machine where this process resides.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public &lt;T&gt; T act(ProcessCallable&lt;T&gt; callable) throws IOException, InterruptedException {
<b class="fc">&nbsp;            return callable.invoke(this, FilePath.localChannel);</b>
&nbsp;        }
&nbsp;
&nbsp;        Object writeReplace() {
<b class="fc">&nbsp;            return new SerializedProcess(pid);</b>
&nbsp;        }
&nbsp;
&nbsp;        private class CheckVetoes extends SlaveToMasterCallable&lt;String, IOException&gt; {
&nbsp;            private IOSProcess process;
&nbsp;
<b class="nc">&nbsp;            CheckVetoes(IOSProcess processToCheck) {</b>
<b class="nc">&nbsp;                process = processToCheck;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String call() throws IOException {
<b class="nc">&nbsp;                for (ProcessKillingVeto vetoExtension : ProcessKillingVeto.all()) {</b>
<b class="nc">&nbsp;                    VetoCause cause = vetoExtension.vetoProcessKilling(process);</b>
<b class="nc">&nbsp;                    if (cause != null) {</b>
<b class="nc">&nbsp;                        if (LOGGER.isLoggable(FINEST))</b>
<b class="nc">&nbsp;                            LOGGER.info(&quot;Killing of pid &quot; + getPid() + &quot; vetoed by &quot; + vetoExtension.getClass().getName() + &quot;: &quot; + cause.getMessage());</b>
<b class="nc">&nbsp;                        return cause.getMessage();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Serialized form of {@link OSProcess} is the PID and {@link ProcessTree}
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;SE_INNER_CLASS&quot;, justification = &quot;Serializing the outer instance is intended&quot;)
&nbsp;    private final class SerializedProcess implements Serializable {
&nbsp;        private final int pid;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
<b class="fc">&nbsp;        private SerializedProcess(int pid) {</b>
<b class="fc">&nbsp;            this.pid = pid;</b>
&nbsp;        }
&nbsp;
&nbsp;        Object readResolve() {
<b class="fc">&nbsp;            return get(pid);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Code that gets executed on the machine where the {@link OSProcess} is local.
&nbsp;     * Used to act on {@link OSProcess}.
&nbsp;     *
&nbsp;     * @see ProcessTree.OSProcess#act(ProcessTree.ProcessCallable)
&nbsp;     */
&nbsp;    public interface ProcessCallable&lt;T&gt; extends Serializable {
&nbsp;        /**
&nbsp;         * Performs the computational task on the node where the data is located.
&nbsp;         *
&nbsp;         * @param process
&nbsp;         *      {@link OSProcess} that represents the local process.
&nbsp;         * @param channel
&nbsp;         *      The &quot;back pointer&quot; of the {@link Channel} that represents the communication
&nbsp;         *      with the node from where the code was sent.
&nbsp;         */
&nbsp;        T invoke(OSProcess process, VirtualChannel channel) throws IOException;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /* package */ static volatile Boolean vetoersExist;
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link ProcessTree} of the current system
&nbsp;     * that JVM runs in, or in the worst case return the default one
&nbsp;     * that&#39;s not capable of killing descendants at all.
&nbsp;     */
&nbsp;    public static ProcessTree get() {
<b class="fc">&nbsp;        if (!enabled)</b>
<b class="nc">&nbsp;            return DEFAULT;</b>
&nbsp;
&nbsp;        // Check for the existence of vetoers if I don&#39;t know already
<b class="fc">&nbsp;        if (vetoersExist == null) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                VirtualChannel channelToController = AgentComputerUtil.getChannelToController();</b>
<b class="fc">&nbsp;                if (channelToController != null) {</b>
<b class="nc">&nbsp;                    vetoersExist = channelToController.call(new DoVetoersExist());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            catch (InterruptedException ie) {</b>
&nbsp;                // If we receive an InterruptedException here, we probably can&#39;t do much anyway.
&nbsp;                // Perhaps we should just return at this point since we probably can&#39;t do anything else.
&nbsp;                // It might make sense to introduce retries, but it&#39;s probably not going to get better.
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;Caught InterruptedException while checking if vetoers exist: &quot;, ie);</b>
<b class="nc">&nbsp;                Thread.interrupted(); // Clear the interrupt flag and just accept that no known vetoers exist.</b>
&nbsp;            }
<b class="nc">&nbsp;            catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;Error while determining if vetoers exist&quot;, e);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        // Null-check in case the previous call worked
<b class="fc">&nbsp;        boolean vetoes = vetoersExist == null ? true : vetoersExist;</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            if (File.pathSeparatorChar == &#39;;&#39;)</b>
<b class="fc">&nbsp;                return new Windows(vetoes);</b>
&nbsp;
<b class="nc">&nbsp;            String os = Util.fixNull(System.getProperty(&quot;os.name&quot;));</b>
<b class="nc">&nbsp;            if (os.equals(&quot;Linux&quot;))</b>
<b class="nc">&nbsp;                return new Linux(vetoes);</b>
<b class="nc">&nbsp;            if (os.equals(&quot;AIX&quot;))</b>
<b class="nc">&nbsp;                return new AIX(vetoes);</b>
<b class="nc">&nbsp;            if (os.equals(&quot;SunOS&quot;))</b>
<b class="nc">&nbsp;                return new Solaris(vetoes);</b>
<b class="nc">&nbsp;            if (os.equals(&quot;Mac OS X&quot;))</b>
<b class="nc">&nbsp;                return new Darwin(vetoes);</b>
<b class="nc">&nbsp;            if (os.equals(&quot;FreeBSD&quot;))</b>
<b class="nc">&nbsp;                return new FreeBSD(vetoes);</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;Failed to load OS-specific implementation; reverting to the default&quot;, e);</b>
<b class="nc">&nbsp;            enabled = false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return DEFAULT;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class DoVetoersExist extends SlaveToMasterCallable&lt;Boolean, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public Boolean call() throws IOException {
<b class="nc">&nbsp;            return ProcessKillingVeto.all().size() &gt; 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;//
&nbsp;//
&nbsp;// implementation follows
&nbsp;//-------------------------------------------
&nbsp;//
&nbsp;
&nbsp;    /**
&nbsp;     * Empty process list as a default value if the platform doesn&#39;t support it.
&nbsp;     */
<b class="fc">&nbsp;    /*package*/ static final ProcessTree DEFAULT = new Local() {</b>
&nbsp;        @Override
&nbsp;        public OSProcess get(@NonNull final Process proc) {
<b class="nc">&nbsp;            return new OSProcess(-1) {</b>
&nbsp;                @Override
&nbsp;                @CheckForNull
&nbsp;                public OSProcess getParent() {
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void killRecursively() {
&nbsp;                    // fall back to a single process killer
<b class="nc">&nbsp;                    proc.destroy();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void kill() throws InterruptedException {
<b class="nc">&nbsp;                    if (getVeto() != null)</b>
&nbsp;                        return;
<b class="nc">&nbsp;                    proc.destroy();</b>
<b class="nc">&nbsp;                    killByKiller();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @NonNull
&nbsp;                public List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                    return Collections.emptyList();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @NonNull
&nbsp;                public EnvVars getEnvironmentVariables() {
<b class="nc">&nbsp;                    return new EnvVars();</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void killAll(@NonNull Map&lt;String, String&gt; modelEnvVars) {
&nbsp;            // no-op
<b class="nc">&nbsp;        }</b>
&nbsp;    };
&nbsp;
&nbsp;    private class WindowsOSProcess extends OSProcess {
&nbsp;
&nbsp;        private final WinProcess p;
&nbsp;        private EnvVars env;
&nbsp;        private List&lt;String&gt; args;
&nbsp;
<b class="fc">&nbsp;        WindowsOSProcess(WinProcess p) {</b>
<b class="fc">&nbsp;            super(p.getPid());</b>
<b class="fc">&nbsp;            this.p = p;</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        @Override
&nbsp;        public OSProcess getParent() {
&nbsp;            // Windows process doesn&#39;t have parent/child relationship
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void killRecursively() throws InterruptedException {
<b class="nc">&nbsp;            if (getVeto() != null)</b>
&nbsp;                return;
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(FINER, &quot;Killing recursively {0}&quot;, getPid());</b>
&nbsp;            // Firstly try to kill the root process gracefully, then do a forcekill if it does not help (algorithm is described in JENKINS-17116)
<b class="nc">&nbsp;            killSoftly();</b>
<b class="nc">&nbsp;            p.killRecursively();</b>
<b class="nc">&nbsp;            killByKiller();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void kill() throws InterruptedException {
<b class="nc">&nbsp;            if (getVeto() != null) {</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(FINER, &quot;Killing {0}&quot;, getPid());</b>
&nbsp;            // Firstly try to kill it gracefully, then do a forcekill if it does not help (algorithm is described in JENKINS-17116)
<b class="nc">&nbsp;            killSoftly();</b>
<b class="nc">&nbsp;            p.kill();</b>
<b class="nc">&nbsp;            killByKiller();</b>
&nbsp;        }
&nbsp;
&nbsp;        private void killSoftly() throws InterruptedException {
&nbsp;            // send Ctrl+C to the process
&nbsp;            try {
<b class="nc">&nbsp;                if (!p.sendCtrlC()) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            catch (WinpException e) {</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Failed to send CTRL+C to pid=&quot; + getPid(), e);</b>
&nbsp;                }
&nbsp;                return;
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // after that wait for it to cease to exist
<b class="nc">&nbsp;            long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(softKillWaitSeconds);</b>
<b class="nc">&nbsp;            int sleepTime = 10; // initially we sleep briefly, then sleep up to 1sec</b>
&nbsp;            do {
<b class="nc">&nbsp;                if (!p.isRunning()) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Thread.sleep(sleepTime);</b>
<b class="nc">&nbsp;                sleepTime = Math.min(sleepTime * 2, 1000);</b>
<b class="nc">&nbsp;            } while (System.nanoTime() &lt; deadline);</b>
&nbsp;        }
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public synchronized List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;            if (args == null) {</b>
<b class="nc">&nbsp;                args = Arrays.asList(QuotedStringTokenizer.tokenize(p.getCommandLine()));</b>
&nbsp;            }
<b class="nc">&nbsp;            return args;</b>
&nbsp;        }
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public synchronized EnvVars getEnvironmentVariables() {
&nbsp;            try {
<b class="fc">&nbsp;               return getEnvironmentVariables2();</b>
<b class="fc">&nbsp;            } catch (WindowsOSProcessException e) {</b>
<b class="fc">&nbsp;                if (LOGGER.isLoggable(FINEST)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(FINEST, &quot;Failed to get the environment variables of process with pid=&quot; + p.getPid(), e);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return env;</b>
&nbsp;        }
&nbsp;
&nbsp;        private synchronized EnvVars getEnvironmentVariables2() throws WindowsOSProcessException {
<b class="fc">&nbsp;            if (env != null) {</b>
<b class="nc">&nbsp;              return env;</b>
&nbsp;            }
<b class="fc">&nbsp;            env = new EnvVars();</b>
&nbsp;
&nbsp;            try {
<b class="fc">&nbsp;               env.putAll(p.getEnvironmentVariables());</b>
<b class="fc">&nbsp;            } catch (WinpException e) {</b>
<b class="fc">&nbsp;               throw new WindowsOSProcessException(&quot;Failed to get the environment variables&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return env;</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean hasMatchingEnvVars2(Map&lt;String, String&gt; modelEnvVar) throws WindowsOSProcessException {
<b class="nc">&nbsp;            if (modelEnvVar.isEmpty())</b>
&nbsp;                // sanity check so that we don&#39;t start rampage.
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="nc">&nbsp;            SortedMap&lt;String, String&gt; envs = getEnvironmentVariables2();</b>
<b class="nc">&nbsp;            for (Map.Entry&lt;String, String&gt; e : modelEnvVar.entrySet()) {</b>
<b class="nc">&nbsp;                String v = envs.get(e.getKey());</b>
<b class="nc">&nbsp;                if (v == null || !v.equals(e.getValue()))</b>
<b class="nc">&nbsp;                    return false;   // no match</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //TODO: Cleanup once Winp provides proper API
&nbsp;    /**
&nbsp;     * Wrapper for runtime {@link WinpException}.
&nbsp;     */
&nbsp;    private static class WindowsOSProcessException extends Exception {
&nbsp;        WindowsOSProcessException(WinpException ex) {
<b class="nc">&nbsp;            super(ex);</b>
&nbsp;        }
&nbsp;
&nbsp;        WindowsOSProcessException(String message, WinpException ex) {
<b class="fc">&nbsp;            super(message, ex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class Windows extends Local {
&nbsp;        Windows(boolean vetoesExist) {
<b class="fc">&nbsp;            super(vetoesExist);</b>
&nbsp;
<b class="fc">&nbsp;            for (final WinProcess p : WinProcess.all()) {</b>
<b class="fc">&nbsp;                int pid = p.getPid();</b>
<b class="fc">&nbsp;                if (pid == 0 || pid == 4) continue; // skip the System Idle and System processes</b>
<b class="fc">&nbsp;                super.processes.put(pid, new WindowsOSProcess(p));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        @Override
&nbsp;        public OSProcess get(@NonNull Process proc) {
<b class="nc">&nbsp;            return get(new WinProcess(proc).getPid());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void killAll(@NonNull Map&lt;String, String&gt; modelEnvVars) throws InterruptedException {
<b class="nc">&nbsp;            for (OSProcess p : this) {</b>
<b class="nc">&nbsp;                if (p.getPid() &lt; 10)</b>
<b class="nc">&nbsp;                    continue;   // ignore system processes like &quot;idle process&quot;</b>
&nbsp;
<b class="nc">&nbsp;                LOGGER.log(FINEST, &quot;Considering to kill {0}&quot;, p.getPid());</b>
&nbsp;
&nbsp;                boolean matched;
&nbsp;                try {
<b class="nc">&nbsp;                    matched = hasMatchingEnvVars(p, modelEnvVars);</b>
<b class="nc">&nbsp;                } catch (WindowsOSProcessException e) {</b>
&nbsp;                    // likely a missing privilege
&nbsp;                    // TODO: not a minor issue - causes process termination error in JENKINS-30782
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(FINEST)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(FINEST, &quot;Failed to check environment variable match for process with pid=&quot; + p.getPid(), e);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (matched) {</b>
<b class="nc">&nbsp;                    p.killRecursively();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    LOGGER.log(Level.FINEST, &quot;Environment variable didn&#39;t match for process with pid={0}&quot;, p.getPid());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        static {
<b class="fc">&nbsp;            WinProcess.enableDebugPrivilege();</b>
&nbsp;        }
&nbsp;
&nbsp;        private static boolean hasMatchingEnvVars(@NonNull OSProcess p, @NonNull Map&lt;String, String&gt; modelEnvVars)
&nbsp;                throws WindowsOSProcessException {
<b class="nc">&nbsp;            if (p instanceof WindowsOSProcess) {</b>
<b class="nc">&nbsp;                return ((WindowsOSProcess) p).hasMatchingEnvVars2(modelEnvVars);</b>
&nbsp;            } else {
&nbsp;                // Should never happen, but there is a risk of getting such class during deserialization
&nbsp;                try {
<b class="nc">&nbsp;                    return p.hasMatchingEnvVars(modelEnvVars);</b>
<b class="nc">&nbsp;                } catch (WinpException e) {</b>
&nbsp;                    // likely a missing privilege
<b class="nc">&nbsp;                    throw new WindowsOSProcessException(e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    abstract static class Unix extends Local {
&nbsp;        Unix(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        @Override
&nbsp;        public OSProcess get(@NonNull Process proc) {
<b class="nc">&nbsp;            return get(Math.toIntExact(proc.pid()));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void killAll(@NonNull Map&lt;String, String&gt; modelEnvVars) throws InterruptedException {
<b class="nc">&nbsp;            for (OSProcess p : this)</b>
<b class="nc">&nbsp;                if (p.hasMatchingEnvVars(modelEnvVars))</b>
<b class="nc">&nbsp;                    p.killRecursively();</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * {@link ProcessTree} based on /proc.
&nbsp;     */
&nbsp;
&nbsp;    abstract static class ProcfsUnix extends Unix {
&nbsp;        ProcfsUnix(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;
<b class="nc">&nbsp;            File[] processes = new File(&quot;/proc&quot;).listFiles(File::isDirectory);</b>
<b class="nc">&nbsp;            if (processes == null) {</b>
<b class="nc">&nbsp;                LOGGER.info(&quot;No /proc&quot;);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (File p : processes) {</b>
&nbsp;                int pid;
&nbsp;                try {
<b class="nc">&nbsp;                    pid = Integer.parseInt(p.getName());</b>
<b class="nc">&nbsp;                } catch (NumberFormatException e) {</b>
&nbsp;                    // other sub-directories
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                try {
<b class="nc">&nbsp;                    this.processes.put(pid, createProcess(pid));</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // perhaps the process status has changed since we obtained a directory listing
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected abstract OSProcess createProcess(int pid) throws IOException;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A process.
&nbsp;     */
&nbsp;    public abstract class UnixProcess extends OSProcess {
<b class="nc">&nbsp;        protected UnixProcess(int pid) {</b>
<b class="nc">&nbsp;            super(pid);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected final File getFile(String relativePath) {
<b class="nc">&nbsp;            return new File(new File(&quot;/proc/&quot; + getPid()), relativePath);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Tries to kill this process.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public void kill() throws InterruptedException {
&nbsp;            // after sending SIGTERM, wait for the process to cease to exist
<b class="nc">&nbsp;            long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(softKillWaitSeconds);</b>
<b class="nc">&nbsp;            kill(deadline);</b>
&nbsp;        }
&nbsp;
&nbsp;        private void kill(long deadline) throws InterruptedException {
<b class="nc">&nbsp;            if (getVeto() != null)</b>
&nbsp;                return;
<b class="nc">&nbsp;            int pid = getPid();</b>
<b class="nc">&nbsp;            LOGGER.fine(&quot;Killing pid=&quot; + pid);</b>
<b class="nc">&nbsp;            ProcessHandle.of(pid).ifPresent(ProcessHandle::destroy);</b>
&nbsp;            // after sending SIGTERM, wait for the process to cease to exist
<b class="nc">&nbsp;            int sleepTime = 10; // initially we sleep briefly, then sleep up to 1sec</b>
<b class="nc">&nbsp;            File status = getFile(&quot;status&quot;);</b>
&nbsp;            do {
<b class="nc">&nbsp;                if (!status.exists()) {</b>
<b class="nc">&nbsp;                    break; // status is gone, process therefore as well</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Thread.sleep(sleepTime);</b>
<b class="nc">&nbsp;                sleepTime = Math.min(sleepTime * 2, 1000);</b>
<b class="nc">&nbsp;            } while (System.nanoTime() &lt; deadline);</b>
<b class="nc">&nbsp;            killByKiller();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void killRecursively() throws InterruptedException {
&nbsp;            // after sending SIGTERM, wait for the processes to cease to exist until the deadline
<b class="nc">&nbsp;            long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(softKillWaitSeconds);</b>
<b class="nc">&nbsp;            killRecursively(deadline);</b>
&nbsp;        }
&nbsp;
&nbsp;        private void killRecursively(long deadline) throws InterruptedException {
&nbsp;            // We kill individual processes of a tree, so handling vetoes inside #kill() is enough for UnixProcess es
<b class="nc">&nbsp;            LOGGER.fine(&quot;Recursively killing pid=&quot; + getPid());</b>
<b class="nc">&nbsp;            for (OSProcess p : getChildren()) {</b>
<b class="nc">&nbsp;                if (p instanceof UnixProcess) {</b>
<b class="nc">&nbsp;                    ((UnixProcess) p).killRecursively(deadline);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    p.killRecursively(); // should not happen, fallback to non-deadline version</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            kill(deadline);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Obtains the argument list of this process.
&nbsp;         *
&nbsp;         * @return
&nbsp;         *      empty list if failed (for example because the process is already dead,
&nbsp;         *      or the permission was denied.)
&nbsp;         */
&nbsp;        @Override
&nbsp;        @NonNull
&nbsp;        public abstract List&lt;String&gt; getArguments();
&nbsp;    }
&nbsp;
&nbsp;    static class Linux extends ProcfsUnix {
&nbsp;        Linux(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected LinuxProcess createProcess(int pid) throws IOException {
<b class="nc">&nbsp;            return new LinuxProcess(pid);</b>
&nbsp;        }
&nbsp;
&nbsp;        class LinuxProcess extends UnixProcess {
<b class="nc">&nbsp;            private int ppid = -1;</b>
&nbsp;            private EnvVars envVars;
&nbsp;            private List&lt;String&gt; arguments;
&nbsp;
<b class="nc">&nbsp;            LinuxProcess(int pid) throws IOException {</b>
<b class="nc">&nbsp;                super(pid);</b>
&nbsp;
<b class="nc">&nbsp;                try (BufferedReader r = Files.newBufferedReader(Util.fileToPath(getFile(&quot;status&quot;)), StandardCharsets.UTF_8)) {</b>
&nbsp;                    String line;
<b class="nc">&nbsp;                    while ((line = r.readLine()) != null) {</b>
<b class="nc">&nbsp;                        line = line.toLowerCase(Locale.ENGLISH);</b>
<b class="nc">&nbsp;                        if (line.startsWith(&quot;ppid:&quot;)) {</b>
<b class="nc">&nbsp;                            ppid = Integer.parseInt(line.substring(5).trim());</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (ppid == -1)</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to parse PPID from /proc/&quot; + pid + &quot;/status&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CheckForNull
&nbsp;            public OSProcess getParent() {
<b class="nc">&nbsp;                return get(ppid);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                if (arguments != null)</b>
<b class="nc">&nbsp;                    return arguments;</b>
<b class="nc">&nbsp;                arguments = new ArrayList&lt;&gt;();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    byte[] cmdline = Files.readAllBytes(Util.fileToPath(getFile(&quot;cmdline&quot;)));</b>
<b class="nc">&nbsp;                    int pos = 0;</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; cmdline.length; i++) {</b>
<b class="nc">&nbsp;                        byte b = cmdline[i];</b>
<b class="nc">&nbsp;                        if (b == 0) {</b>
<b class="nc">&nbsp;                            arguments.add(new String(cmdline, pos, i - pos, StandardCharsets.UTF_8));</b>
<b class="nc">&nbsp;                            pos = i + 1;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // failed to read. this can happen under normal circumstances (most notably permission denied)
&nbsp;                    // so don&#39;t report this as an error.
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                arguments = Collections.unmodifiableList(arguments);</b>
<b class="nc">&nbsp;                return arguments;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized EnvVars getEnvironmentVariables() {
<b class="nc">&nbsp;                if (envVars != null)</b>
<b class="nc">&nbsp;                    return envVars;</b>
<b class="nc">&nbsp;                envVars = new EnvVars();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    byte[] environ = Files.readAllBytes(Util.fileToPath(getFile(&quot;environ&quot;)));</b>
<b class="nc">&nbsp;                    int pos = 0;</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; environ.length; i++) {</b>
<b class="nc">&nbsp;                        byte b = environ[i];</b>
<b class="nc">&nbsp;                        if (b == 0) {</b>
<b class="nc">&nbsp;                            envVars.addLine(new String(environ, pos, i - pos, StandardCharsets.UTF_8));</b>
<b class="nc">&nbsp;                            pos = i + 1;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // failed to read. this can happen under normal circumstances (most notably permission denied)
&nbsp;                    // so don&#39;t report this as an error.
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return envVars;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implementation for AIX that uses {@code /proc}.
&nbsp;     *
&nbsp;     * /proc/PID/status contains a pstatus struct. We use it to determine if the process is 32 or 64 bit
&nbsp;     *
&nbsp;     * /proc/PID/psinfo contains a psinfo struct. We use it to determine where the
&nbsp;     *     process arguments and environment are located in PID&#39;s address space.
&nbsp;     *
&nbsp;     * /proc/PID/as contains the address space of the process we are inspecting. We can
&nbsp;     *     follow the pr_envp and pr_argv pointers from psinfo to find the vectors to the
&nbsp;     *     environment variables and process arguments, respectvely. When following pointers
&nbsp;     *     in this address space we need to make sure to use 32-bit or 64-bit pointers
&nbsp;     *     depending on what sized pointers PID uses, regardless of what size pointers
&nbsp;     *     the Java process uses.
&nbsp;     *
&nbsp;     *     Note that the size of a 64-bit address space is larger than Long.MAX_VALUE (because
&nbsp;     *     longs are signed). So normal Java utilities like RandomAccessFile and FileChannel
&nbsp;     *     (which use signed longs as offsets) are not able to read from the end of the address
&nbsp;     *     space, where envp and argv will be. Therefore we need to use LIBC.pread() directly.
&nbsp;     *     when accessing this file.
&nbsp;     */
&nbsp;    static class AIX extends ProcfsUnix {
&nbsp;        AIX(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected OSProcess createProcess(final int pid) throws IOException {
<b class="nc">&nbsp;            return new AIXProcess(pid);</b>
&nbsp;        }
&nbsp;
&nbsp;        private class AIXProcess extends UnixProcess {
&nbsp;            private static final byte PR_MODEL_ILP32 = 0;
&nbsp;            private static final byte PR_MODEL_LP64 = 1;
&nbsp;
&nbsp;            /*
&nbsp;             * An arbitrary upper-limit on how many characters readLine() will
&nbsp;             * try reading before giving up. This avoids having readLine() loop
&nbsp;             * over the entire process address space if this class has bugs.
&nbsp;             */
<b class="nc">&nbsp;            private final int LINE_LENGTH_LIMIT =</b>
<b class="nc">&nbsp;                SystemProperties.getInteger(AIX.class.getName() + &quot;.lineLimit&quot;, 10000);</b>
&nbsp;
&nbsp;            /*
&nbsp;             * True if target process is 64-bit (Java process may be different).
&nbsp;             */
&nbsp;            private final boolean b64;
&nbsp;
&nbsp;            private final int ppid;
&nbsp;
&nbsp;            private final long pr_envp;
&nbsp;            private final long pr_argp;
&nbsp;            private final int argc;
&nbsp;            private EnvVars envVars;
&nbsp;            private List&lt;String&gt; arguments;
&nbsp;
<b class="nc">&nbsp;            private AIXProcess(int pid) throws IOException {</b>
<b class="nc">&nbsp;                super(pid);</b>
&nbsp;
<b class="nc">&nbsp;                try (RandomAccessFile pstatus = new RandomAccessFile(getFile(&quot;status&quot;), &quot;r&quot;)) {</b>
&nbsp;                    // typedef struct pstatus {
&nbsp;                    //    uint32_t pr_flag;                /* process flags from proc struct p_flag */
&nbsp;                    //    uint32_t pr_flag2;               /* process flags from proc struct p_flag2 */
&nbsp;                    //    uint32_t pr_flags;               /* /proc flags */
&nbsp;                    //    uint32_t pr_nlwp;                /* number of threads in the process */
&nbsp;                    //    char     pr_stat;                /* process state from proc p_stat */
&nbsp;                    //    char     pr_dmodel;              /* data model for the process */
&nbsp;                    //    char     pr__pad1[6];            /* reserved for future use */
&nbsp;                    //    pr_sigset_t pr_sigpend;          /* set of process pending signals */
&nbsp;                    //    prptr64_t pr_brkbase;            /* address of the process heap */
&nbsp;                    //    uint64_t pr_brksize;             /* size of the process heap, in bytes */
&nbsp;                    //    prptr64_t pr_stkbase;            /* address of the process stack */
&nbsp;                    //    uint64_t pr_stksize;             /* size of the process stack, in bytes */
&nbsp;                    //    uint64_t pr_pid;                 /* process id */
&nbsp;                    //    uint64_t pr_ppid;                /* parent process id */
&nbsp;                    //    uint64_t pr_pgid;                /* process group id */
&nbsp;                    //    uint64_t pr_sid;                 /* session id */
&nbsp;                    //    pr_timestruc64_t pr_utime;       /* process user cpu time */
&nbsp;                    //    pr_timestruc64_t pr_stime;       /* process system cpu time */
&nbsp;                    //    pr_timestruc64_t pr_cutime;      /* sum of children&#39;s user times */
&nbsp;                    //    pr_timestruc64_t pr_cstime;      /* sum of children&#39;s system times */
&nbsp;                    //    pr_sigset_t pr_sigtrace;         /* mask of traced signals */
&nbsp;                    //    fltset_t pr_flttrace;            /* mask of traced hardware faults */
&nbsp;                    //    uint32_t pr_sysentry_offset;     /* offset into pstatus file of sysset_t
&nbsp;                    //                                      * identifying system calls traced on
&nbsp;                    //                                      * entry.  If 0, then no entry syscalls
&nbsp;                    //                                      * are being traced. */
&nbsp;                    //    uint32_t pr_sysexit_offset;      /* offset into pstatus file of sysset_t
&nbsp;                    //                                      * identifying system calls traced on
&nbsp;                    //                                      * exit.  If 0, then no exit syscalls
&nbsp;                    //                                      * are being traced. */
&nbsp;                    //    uint64_t pr__pad[8];             /* reserved for future use */
&nbsp;                    //    lwpstatus_t pr_lwp;              /* &quot;representative&quot; thread status */
&nbsp;                    // } pstatus_t;
&nbsp;
<b class="nc">&nbsp;                    pstatus.seek(17); // offset of pr_dmodel</b>
&nbsp;
<b class="nc">&nbsp;                    byte pr_dmodel = pstatus.readByte();</b>
&nbsp;
<b class="nc">&nbsp;                    if (pr_dmodel == PR_MODEL_ILP32) {</b>
<b class="nc">&nbsp;                        b64 = false;</b>
<b class="nc">&nbsp;                    } else if (pr_dmodel == PR_MODEL_LP64) {</b>
<b class="nc">&nbsp;                        b64 = true;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IOException(&quot;Unrecognized data model value&quot;); // sanity check</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    pstatus.seek(88); // offset of pr_pid</b>
&nbsp;
<b class="nc">&nbsp;                    if (adjust((int) pstatus.readLong()) != pid)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;pstatus PID mismatch&quot;); // sanity check</b>
&nbsp;
<b class="nc">&nbsp;                    ppid = adjust((int) pstatus.readLong()); // AIX pids are stored as a 64 bit integer,</b>
&nbsp;                                                            // but the first 4 bytes are always 0
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                try (RandomAccessFile psinfo = new RandomAccessFile(getFile(&quot;psinfo&quot;), &quot;r&quot;)) {</b>
&nbsp;                    // typedef struct psinfo {
&nbsp;                    //   uint32_t pr_flag;                /* process flags from proc struct p_flag */
&nbsp;                    //   uint32_t pr_flag2;               /* process flags from proc struct p_flag2 *
&nbsp;                    //   uint32_t pr_nlwp;                /* number of threads in process */
&nbsp;                    //   uint32_t pr__pad1;               /* reserved for future use */
&nbsp;                    //   uint64_t pr_uid;                 /* real user id */
&nbsp;                    //   uint64_t pr_euid;                /* effective user id */
&nbsp;                    //   uint64_t pr_gid;                 /* real group id */
&nbsp;                    //   uint64_t pr_egid;                /* effective group id */
&nbsp;                    //   uint64_t pr_pid;                 /* unique process id */
&nbsp;                    //   uint64_t pr_ppid;                /* process id of parent */
&nbsp;                    //   uint64_t pr_pgid;                /* pid of process group leader */
&nbsp;                    //   uint64_t pr_sid;                 /* session id */
&nbsp;                    //   uint64_t pr_ttydev;              /* controlling tty device */
&nbsp;                    //   prptr64_t   pr_addr;             /* internal address of proc struct */
&nbsp;                    //   uint64_t pr_size;                /* process image size in kb (1024) units */
&nbsp;                    //   uint64_t pr_rssize;              /* resident set size in kb (1024) units */
&nbsp;                    //   pr_timestruc64_t pr_start;       /* process start time, time since epoch */
&nbsp;                    //   pr_timestruc64_t pr_time;        /* usr+sys cpu time for this process */
&nbsp;                    //   cid_t    pr_cid;                 /* corral id */
&nbsp;                    //   ushort_t pr__pad2;               /* reserved for future use */
&nbsp;                    //   uint32_t pr_argc;                /* initial argument count */
&nbsp;                    //   prptr64_t   pr_argv;             /* address of initial argument vector in
&nbsp;                    //                                     * user process */
&nbsp;                    //   prptr64_t   pr_envp;             /* address of initial environment vector
&nbsp;                    //                                     * in user process */
&nbsp;                    //   char     pr_fname[prfnsz];       /* last component of exec()ed pathname*/
&nbsp;                    //   char     pr_psargs[prargsz];     /* initial characters of arg list */
&nbsp;                    //   uint64_t pr__pad[8];             /* reserved for future use */
&nbsp;                    //   struct   lwpsinfo pr_lwp;        /* &quot;representative&quot; thread info */
&nbsp;                    // }
&nbsp;
<b class="nc">&nbsp;                    psinfo.seek(48); // offset of pr_pid</b>
&nbsp;
<b class="nc">&nbsp;                    if (adjust((int) psinfo.readLong()) != pid)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;psinfo PID mismatch&quot;); // sanity check</b>
&nbsp;
<b class="nc">&nbsp;                    if (adjust((int) psinfo.readLong()) != ppid)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;psinfo PPID mismatch&quot;); // sanity check</b>
&nbsp;
<b class="nc">&nbsp;                    psinfo.seek(148); // offset of pr_argc</b>
&nbsp;
<b class="nc">&nbsp;                    argc = adjust(psinfo.readInt());</b>
<b class="nc">&nbsp;                    pr_argp = adjustL(psinfo.readLong());</b>
<b class="nc">&nbsp;                    pr_envp = adjustL(psinfo.readLong());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CheckForNull
&nbsp;            public OSProcess getParent() {
<b class="nc">&nbsp;                return get(ppid);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                if (arguments != null)</b>
<b class="nc">&nbsp;                    return arguments;</b>
&nbsp;
<b class="nc">&nbsp;                arguments = new ArrayList&lt;&gt;(argc);</b>
<b class="nc">&nbsp;                if (argc == 0) {</b>
<b class="nc">&nbsp;                    return arguments;</b>
&nbsp;                }
&nbsp;
&nbsp;                try {
<b class="nc">&nbsp;                    int psize = b64 ? 8 : 4;</b>
<b class="nc">&nbsp;                    Memory m = new Memory(psize);</b>
<b class="nc">&nbsp;                    int fd = LIBC.open(getFile(&quot;as&quot;).getAbsolutePath(), 0);</b>
&nbsp;
&nbsp;                    try {
&nbsp;                        // Get address of the argument vector
<b class="nc">&nbsp;                        LIBC.pread(fd, m, new NativeLong(psize), new NativeLong(pr_argp));</b>
<b class="nc">&nbsp;                        long argp = b64 ? m.getLong(0) : to64(m.getInt(0));</b>
&nbsp;
<b class="nc">&nbsp;                        if (argp == 0) // Should never happen</b>
<b class="nc">&nbsp;                            return arguments;</b>
&nbsp;
&nbsp;                        // Itterate through argument vector
<b class="nc">&nbsp;                        for (int n = 0; ; n++) {</b>
&nbsp;
<b class="nc">&nbsp;                            LIBC.pread(fd, m, new NativeLong(psize), new NativeLong(argp + (n * psize)));</b>
<b class="nc">&nbsp;                            long addr = b64 ? m.getLong(0) : to64(m.getInt(0));</b>
&nbsp;
<b class="nc">&nbsp;                            if (addr == 0) // completed the walk</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;
&nbsp;                            // now read the null-terminated string
<b class="nc">&nbsp;                            arguments.add(readLine(fd, addr, &quot;arg[&quot; + n + &quot;]&quot;));</b>
&nbsp;                        }
&nbsp;                    } finally  {
<b class="nc">&nbsp;                       LIBC.close(fd);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (IOException | LastErrorException e) {</b>
&nbsp;                    // failed to read. this can happen under normal circumstances (most notably permission denied)
&nbsp;                    // so don&#39;t report this as an error.
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                arguments = Collections.unmodifiableList(arguments);</b>
<b class="nc">&nbsp;                return arguments;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized EnvVars getEnvironmentVariables() {
<b class="nc">&nbsp;                if (envVars != null)</b>
<b class="nc">&nbsp;                    return envVars;</b>
<b class="nc">&nbsp;                envVars = new EnvVars();</b>
&nbsp;
<b class="nc">&nbsp;                if (pr_envp == 0) {</b>
<b class="nc">&nbsp;                    return envVars;</b>
&nbsp;                }
&nbsp;
&nbsp;                try {
<b class="nc">&nbsp;                    int psize = b64 ? 8 : 4;</b>
<b class="nc">&nbsp;                    Memory m = new Memory(psize);</b>
<b class="nc">&nbsp;                    int fd = LIBC.open(getFile(&quot;as&quot;).getAbsolutePath(), 0);</b>
&nbsp;
&nbsp;                    try {
&nbsp;                        // Get address of the environment vector
<b class="nc">&nbsp;                        LIBC.pread(fd, m, new NativeLong(psize), new NativeLong(pr_envp));</b>
<b class="nc">&nbsp;                        long envp = b64 ? m.getLong(0) : to64(m.getInt(0));</b>
&nbsp;
<b class="nc">&nbsp;                        if (envp == 0) // Should never happen</b>
<b class="nc">&nbsp;                            return envVars;</b>
&nbsp;
&nbsp;                        // Itterate through environment vector
<b class="nc">&nbsp;                        for (int n = 0; ; n++) {</b>
&nbsp;
<b class="nc">&nbsp;                            LIBC.pread(fd, m, new NativeLong(psize), new NativeLong(envp + (n * psize)));</b>
<b class="nc">&nbsp;                            long addr = b64 ? m.getLong(0) : to64(m.getInt(0));</b>
&nbsp;
<b class="nc">&nbsp;                            if (addr == 0) // completed the walk</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;
&nbsp;                            // now read the null-terminated string
<b class="nc">&nbsp;                            envVars.addLine(readLine(fd, addr, &quot;env[&quot; + n + &quot;]&quot;));</b>
&nbsp;                        }
&nbsp;                    } finally  {
<b class="nc">&nbsp;                       LIBC.close(fd);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (IOException | LastErrorException e) {</b>
&nbsp;                    // failed to read. this can happen under normal circumstances (most notably permission denied)
&nbsp;                    // so don&#39;t report this as an error.
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return envVars;</b>
&nbsp;            }
&nbsp;
&nbsp;            private String readLine(int fd, long addr, String prefix) throws IOException {
<b class="nc">&nbsp;                if (LOGGER.isLoggable(FINEST))</b>
<b class="nc">&nbsp;                    LOGGER.finest(&quot;Reading &quot; + prefix + &quot; at &quot; + addr);</b>
&nbsp;
<b class="nc">&nbsp;                Memory m = new Memory(1);</b>
<b class="nc">&nbsp;                byte ch = 1;</b>
<b class="nc">&nbsp;                ByteArrayOutputStream buf = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;                int i = 0;</b>
&nbsp;                while (true) {
<b class="nc">&nbsp;                    if (i++ &gt; LINE_LENGTH_LIMIT) {</b>
<b class="nc">&nbsp;                        LOGGER.finest(&quot;could not find end of line, giving up&quot;);</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;could not find end of line, giving up&quot;);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    long r = LIBC.pread(fd, m, new NativeLong(1), new NativeLong(addr));</b>
<b class="nc">&nbsp;                    ch = m.getByte(0);</b>
&nbsp;
<b class="nc">&nbsp;                    if (ch == 0)</b>
<b class="nc">&nbsp;                        break;</b>
<b class="nc">&nbsp;                    buf.write(ch);</b>
<b class="nc">&nbsp;                    addr++;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                String line = buf.toString(StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(FINEST))</b>
<b class="nc">&nbsp;                    LOGGER.finest(prefix + &quot; was &quot; + line);</b>
<b class="nc">&nbsp;                return line;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * int to long conversion with zero-padding.
&nbsp;         */
&nbsp;        private static long to64(int i) {
<b class="nc">&nbsp;            return i &amp; 0xFFFFFFFFL;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@link DataInputStream} reads a value in big-endian, so
&nbsp;         * convert it to the correct value on little-endian systems.
&nbsp;         */
&nbsp;        private static int adjust(int i) {
<b class="nc">&nbsp;            if (IS_LITTLE_ENDIAN)</b>
<b class="nc">&nbsp;                return (i &lt;&lt; 24) | ((i &lt;&lt; 8) &amp; 0x00FF0000) | ((i &gt;&gt; 8) &amp; 0x0000FF00) | (i &gt;&gt;&gt; 24);</b>
&nbsp;            else
<b class="nc">&nbsp;                return i;</b>
&nbsp;        }
&nbsp;
&nbsp;        public static long adjustL(long i) {
<b class="nc">&nbsp;            if (IS_LITTLE_ENDIAN) {</b>
<b class="nc">&nbsp;                return Long.reverseBytes(i);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return i;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implementation for Solaris that uses {@code /proc}.
&nbsp;     *
&nbsp;     * /proc/PID/psinfo contains a psinfo_t struct. We use it to determine where the
&nbsp;     *     process arguments and environment are located in PID&#39;s address space.
&nbsp;     *     Note that the psinfo_t struct is different (different sized elements) for 32-bit
&nbsp;     *     vs 64-bit processes and the kernel will provide the version of the struct that
&nbsp;     *     matches the _reader_ (this Java process) regardless of whether PID is a
&nbsp;     *     32-bit or 64-bit process.
&nbsp;     *
&nbsp;     *     Note that this means that if PID is a 64-bit process, then a 32-bit Java
&nbsp;     *     process can not get meaningful values for envp and argv out of the psinfo_t. The
&nbsp;     *     values will have been truncated to 32-bits.
&nbsp;     *
&nbsp;     * /proc/PID/as contains the address space of the process we are inspecting. We can
&nbsp;     *     follow the envp and argv pointers from psinfo_t to find the environment variables
&nbsp;     *     and process arguments. When following pointers in this address space we need to
&nbsp;     *     make sure to use 32-bit or 64-bit pointers depending on what sized pointers
&nbsp;     *     PID uses, regardless of what size pointers the Java process uses.
&nbsp;     *
&nbsp;     *     Note that the size of a 64-bit address space is larger than Long.MAX_VALUE (because
&nbsp;     *     longs are signed). So normal Java utilities like RandomAccessFile and FileChannel
&nbsp;     *     (which use signed longs as offsets) are not able to read from the end of the address
&nbsp;     *     space, where envp and argv will be. Therefore we need to use LIBC.pread() directly.
&nbsp;     *     when accessing this file.
&nbsp;     */
&nbsp;    static class Solaris extends ProcfsUnix {
&nbsp;        Solaris(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected OSProcess createProcess(final int pid) throws IOException {
<b class="nc">&nbsp;            return new SolarisProcess(pid);</b>
&nbsp;        }
&nbsp;
&nbsp;        private class SolarisProcess extends UnixProcess {
&nbsp;            private static final byte PR_MODEL_ILP32 = 1;
&nbsp;            private static final byte PR_MODEL_LP64 = 2;
&nbsp;
&nbsp;            /*
&nbsp;             * An arbitrary upper-limit on how many characters readLine() will
&nbsp;             * try reading before giving up. This avoids having readLine() loop
&nbsp;             * over the entire process address space if this class has bugs.
&nbsp;             */
<b class="nc">&nbsp;            private final int LINE_LENGTH_LIMIT =</b>
<b class="nc">&nbsp;                SystemProperties.getInteger(Solaris.class.getName() + &quot;.lineLimit&quot;, 10000);</b>
&nbsp;
&nbsp;            /*
&nbsp;             * True if target process is 64-bit (Java process may be different).
&nbsp;             */
&nbsp;            private final boolean b64;
&nbsp;
&nbsp;            private final int ppid;
&nbsp;            /**
&nbsp;             * Address of the environment vector.
&nbsp;             */
&nbsp;            private final long envp;
&nbsp;            /**
&nbsp;             * Similarly, address of the arguments vector.
&nbsp;             */
&nbsp;            private final long argp;
&nbsp;            private final int argc;
&nbsp;            private EnvVars envVars;
&nbsp;            private List&lt;String&gt; arguments;
&nbsp;
<b class="nc">&nbsp;            private SolarisProcess(int pid) throws IOException {</b>
<b class="nc">&nbsp;                super(pid);</b>
&nbsp;
<b class="nc">&nbsp;                try (RandomAccessFile psinfo = new RandomAccessFile(getFile(&quot;psinfo&quot;), &quot;r&quot;)) {</b>
&nbsp;                    // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/procfs.h
&nbsp;                    //typedef struct psinfo {
&nbsp;                    //    int    pr_flag;                  /* process flags */
&nbsp;                    //    int    pr_nlwp;                  /* number of lwps in the process */
&nbsp;                    //    pid_t    pr_pid;                 /* process id */
&nbsp;                    //    pid_t    pr_ppid;                /* process id of parent */
&nbsp;                    //    pid_t    pr_pgid;                /* process id of process group leader */
&nbsp;                    //    pid_t    pr_sid;                 /* session id */
&nbsp;                    //    uid_t    pr_uid;                 /* real user id */
&nbsp;                    //    uid_t    pr_euid;                /* effective user id */
&nbsp;                    //    gid_t    pr_gid;                 /* real group id */
&nbsp;                    //    gid_t    pr_egid;                /* effective group id */
&nbsp;                    //    uintptr_t    pr_addr;            /* address of process */
&nbsp;                    //    size_t    pr_size;               /* size of process image in Kbytes */
&nbsp;                    //    size_t    pr_rssize;             /* resident set size in Kbytes */
&nbsp;                    //    dev_t    pr_ttydev;              /* controlling tty device (or PRNODEV) */
&nbsp;                    //    ushort_t    pr_pctcpu;           /* % of recent cpu time used by all lwps */
&nbsp;                    //    ushort_t    pr_pctmem;           /* % of system memory used by process */
&nbsp;                    //    timestruc_t    pr_start;         /* process start time, from the epoch */
&nbsp;                    //    timestruc_t    pr_time;          /* cpu time for this process */
&nbsp;                    //    timestruc_t    pr_ctime;         /* cpu time for reaped children */
&nbsp;                    //    char    pr_fname[PRFNSZ];        /* name of exec&#39;ed file */
&nbsp;                    //    char    pr_psargs[PRARGSZ];      /* initial characters of arg list */
&nbsp;                    //    int    pr_wstat;                 /* if zombie, the wait() status */
&nbsp;                    //    int    pr_argc;                  /* initial argument count */
&nbsp;                    //    uintptr_t    pr_argv;            /* address of initial argument vector */
&nbsp;                    //    uintptr_t    pr_envp;            /* address of initial environment vector */
&nbsp;                    //    char    pr_dmodel;               /* data model of the process */
&nbsp;                    //    lwpsinfo_t    pr_lwp;            /* information for representative lwp */
&nbsp;                    //} psinfo_t;
&nbsp;
&nbsp;                    // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/types.h
&nbsp;                    // for the size of the various datatype.
&nbsp;
&nbsp;                    // see http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/cmd/ptools/pargs/pargs.c
&nbsp;                    // for how to read this information
&nbsp;
<b class="nc">&nbsp;                    psinfo.seek(8);</b>
<b class="nc">&nbsp;                    if (adjust(psinfo.readInt()) != pid)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;psinfo PID mismatch&quot;);   // sanity check</b>
<b class="nc">&nbsp;                    ppid = adjust(psinfo.readInt());</b>
&nbsp;
&nbsp;                    /*
&nbsp;                     * Read the remainder of psinfo_t differently depending on whether the
&nbsp;                     * Java process is 32-bit or 64-bit.
&nbsp;                     */
<b class="nc">&nbsp;                    if (Native.POINTER_SIZE == 8) {</b>
<b class="nc">&nbsp;                        psinfo.seek(236);  // offset of pr_argc</b>
<b class="nc">&nbsp;                        argc = adjust(psinfo.readInt());</b>
<b class="nc">&nbsp;                        argp = adjustL(psinfo.readLong());</b>
<b class="nc">&nbsp;                        envp = adjustL(psinfo.readLong());</b>
<b class="nc">&nbsp;                        b64 = psinfo.readByte() == PR_MODEL_LP64;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        psinfo.seek(188);  // offset of pr_argc</b>
<b class="nc">&nbsp;                        argc = adjust(psinfo.readInt());</b>
<b class="nc">&nbsp;                        argp = to64(adjust(psinfo.readInt()));</b>
<b class="nc">&nbsp;                        envp = to64(adjust(psinfo.readInt()));</b>
<b class="nc">&nbsp;                        b64 = psinfo.readByte() == PR_MODEL_LP64;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (ppid == -1)</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to parse PPID from /proc/&quot; + pid + &quot;/status&quot;);</b>
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CheckForNull
&nbsp;            public OSProcess getParent() {
<b class="nc">&nbsp;                return get(ppid);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                if (arguments != null)</b>
<b class="nc">&nbsp;                    return arguments;</b>
&nbsp;
<b class="nc">&nbsp;                arguments = new ArrayList&lt;&gt;(argc);</b>
<b class="nc">&nbsp;                if (argc == 0) {</b>
<b class="nc">&nbsp;                    return arguments;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int psize = b64 ? 8 : 4;</b>
<b class="nc">&nbsp;                Memory m = new Memory(psize);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(FINER))</b>
<b class="nc">&nbsp;                        LOGGER.finer(&quot;Reading &quot; + getFile(&quot;as&quot;));</b>
<b class="nc">&nbsp;                    int fd = LIBC.open(getFile(&quot;as&quot;).getAbsolutePath(), 0);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        for (int n = 0; n &lt; argc; n++) {</b>
&nbsp;                            // read a pointer to one entry
<b class="nc">&nbsp;                            LIBC.pread(fd, m, new NativeLong(psize), new NativeLong(argp + n * psize));</b>
<b class="nc">&nbsp;                            long addr = b64 ? m.getLong(0) : to64(m.getInt(0));</b>
&nbsp;
<b class="nc">&nbsp;                            arguments.add(readLine(fd, addr, &quot;argv[&quot; + n + &quot;]&quot;));</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        LIBC.close(fd);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (IOException | LastErrorException e) {</b>
&nbsp;                    // failed to read. this can happen under normal circumstances (most notably permission denied)
&nbsp;                    // so don&#39;t report this as an error.
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                arguments = Collections.unmodifiableList(arguments);</b>
<b class="nc">&nbsp;                return arguments;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized EnvVars getEnvironmentVariables() {
<b class="nc">&nbsp;                if (envVars != null)</b>
<b class="nc">&nbsp;                    return envVars;</b>
<b class="nc">&nbsp;                envVars = new EnvVars();</b>
&nbsp;
<b class="nc">&nbsp;                if (envp == 0) {</b>
<b class="nc">&nbsp;                    return envVars;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int psize = b64 ? 8 : 4;</b>
<b class="nc">&nbsp;                Memory m = new Memory(psize);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(FINER))</b>
<b class="nc">&nbsp;                        LOGGER.finer(&quot;Reading &quot; + getFile(&quot;as&quot;));</b>
<b class="nc">&nbsp;                    int fd = LIBC.open(getFile(&quot;as&quot;).getAbsolutePath(), 0);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        for (int n = 0; ; n++) {</b>
&nbsp;                            // read a pointer to one entry
<b class="nc">&nbsp;                            LIBC.pread(fd, m, new NativeLong(psize), new NativeLong(envp + n * psize));</b>
<b class="nc">&nbsp;                            long addr = b64 ? m.getLong(0) : to64(m.getInt(0));</b>
<b class="nc">&nbsp;                            if (addr == 0) // completed the walk</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;
&nbsp;                            // now read the null-terminated string
<b class="nc">&nbsp;                            envVars.addLine(readLine(fd, addr, &quot;env[&quot; + n + &quot;]&quot;));</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        LIBC.close(fd);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (IOException | LastErrorException e) {</b>
&nbsp;                    // failed to read. this can happen under normal circumstances (most notably permission denied)
&nbsp;                    // so don&#39;t report this as an error.
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return envVars;</b>
&nbsp;            }
&nbsp;
&nbsp;            private String readLine(int fd, long addr, String prefix) throws IOException {
<b class="nc">&nbsp;                if (LOGGER.isLoggable(FINEST))</b>
<b class="nc">&nbsp;                    LOGGER.finest(&quot;Reading &quot; + prefix + &quot; at &quot; + addr);</b>
&nbsp;
<b class="nc">&nbsp;                Memory m = new Memory(1);</b>
<b class="nc">&nbsp;                byte ch = 1;</b>
<b class="nc">&nbsp;                ByteArrayOutputStream buf = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;                int i = 0;</b>
&nbsp;                while (true) {
<b class="nc">&nbsp;                    if (i++ &gt; LINE_LENGTH_LIMIT) {</b>
<b class="nc">&nbsp;                        LOGGER.finest(&quot;could not find end of line, giving up&quot;);</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;could not find end of line, giving up&quot;);</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    LIBC.pread(fd, m, new NativeLong(1), new NativeLong(addr));</b>
<b class="nc">&nbsp;                    ch = m.getByte(0);</b>
<b class="nc">&nbsp;                    if (ch == 0)</b>
<b class="nc">&nbsp;                        break;</b>
<b class="nc">&nbsp;                    buf.write(ch);</b>
<b class="nc">&nbsp;                    addr++;</b>
&nbsp;                }
<b class="nc">&nbsp;                String line = buf.toString(StandardCharsets.UTF_8);</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(FINEST))</b>
<b class="nc">&nbsp;                    LOGGER.finest(prefix + &quot; was &quot; + line);</b>
<b class="nc">&nbsp;                return line;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * int to long conversion with zero-padding.
&nbsp;         */
&nbsp;        private static long to64(int i) {
<b class="nc">&nbsp;            return i &amp; 0xFFFFFFFFL;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@link DataInputStream} reads a value in big-endian, so
&nbsp;         * convert it to the correct value on little-endian systems.
&nbsp;         */
&nbsp;        private static int adjust(int i) {
<b class="nc">&nbsp;            if (IS_LITTLE_ENDIAN)</b>
<b class="nc">&nbsp;                return (i &lt;&lt; 24) | ((i &lt;&lt; 8) &amp; 0x00FF0000) | ((i &gt;&gt; 8) &amp; 0x0000FF00) | (i &gt;&gt;&gt; 24);</b>
&nbsp;            else
<b class="nc">&nbsp;                return i;</b>
&nbsp;        }
&nbsp;
&nbsp;        public static long adjustL(long i) {
<b class="nc">&nbsp;            if (IS_LITTLE_ENDIAN) {</b>
<b class="nc">&nbsp;                return Long.reverseBytes(i);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return i;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implementation for Mac OS X based on sysctl(3).
&nbsp;     */
&nbsp;    private static class Darwin extends Unix {
&nbsp;        Darwin(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;
<b class="nc">&nbsp;            String arch = System.getProperty(&quot;sun.arch.data.model&quot;);</b>
<b class="nc">&nbsp;            if (&quot;64&quot;.equals(arch)) {</b>
<b class="nc">&nbsp;                sizeOf_kinfo_proc = sizeOf_kinfo_proc_64;</b>
<b class="nc">&nbsp;                kinfo_proc_pid_offset = kinfo_proc_pid_offset_64;</b>
<b class="nc">&nbsp;                kinfo_proc_ppid_offset = kinfo_proc_ppid_offset_64;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sizeOf_kinfo_proc = sizeOf_kinfo_proc_32;</b>
<b class="nc">&nbsp;                kinfo_proc_pid_offset = kinfo_proc_pid_offset_32;</b>
<b class="nc">&nbsp;                kinfo_proc_ppid_offset = kinfo_proc_ppid_offset_32;</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                NativeLongByReference size = new NativeLongByReference(new NativeLong(0));</b>
&nbsp;                Memory m;
<b class="nc">&nbsp;                int nRetry = 0;</b>
&nbsp;                while (true) {
&nbsp;                    // find out how much memory we need to do this
<b class="nc">&nbsp;                    if (LIBC.sysctl(MIB_PROC_ALL, 3, NULL, size, NULL, new NativeLong(0)) != 0)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to obtain memory requirement: &quot; + LIBC.strerror(Native.getLastError()));</b>
&nbsp;
&nbsp;                    // now try the real call
<b class="nc">&nbsp;                    m = new Memory(size.getValue().longValue());</b>
<b class="nc">&nbsp;                    if (LIBC.sysctl(MIB_PROC_ALL, 3, m, size, NULL, new NativeLong(0)) != 0) {</b>
<b class="nc">&nbsp;                        if (Native.getLastError() == ENOMEM &amp;&amp; nRetry++ &lt; 16)</b>
<b class="nc">&nbsp;                            continue; // retry</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to call kern.proc.all: &quot; + LIBC.strerror(Native.getLastError()));</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int count = size.getValue().intValue() / sizeOf_kinfo_proc;</b>
<b class="nc">&nbsp;                LOGGER.fine(&quot;Found &quot; + count + &quot; processes&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                for (int base = 0; base &lt; size.getValue().intValue(); base += sizeOf_kinfo_proc) {</b>
<b class="nc">&nbsp;                    int pid = m.getInt(base + kinfo_proc_pid_offset);</b>
<b class="nc">&nbsp;                    int ppid = m.getInt(base + kinfo_proc_ppid_offset);</b>
&nbsp;
<b class="nc">&nbsp;                    super.processes.put(pid, new DarwinProcess(pid, ppid));</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to obtain process list&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        private class DarwinProcess extends UnixProcess {
&nbsp;            private final int ppid;
&nbsp;            private EnvVars envVars;
&nbsp;            private List&lt;String&gt; arguments;
&nbsp;
<b class="nc">&nbsp;            DarwinProcess(int pid, int ppid) {</b>
<b class="nc">&nbsp;                super(pid);</b>
<b class="nc">&nbsp;                this.ppid = ppid;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CheckForNull
&nbsp;            public OSProcess getParent() {
<b class="nc">&nbsp;                return get(ppid);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized EnvVars getEnvironmentVariables() {
<b class="nc">&nbsp;                if (envVars != null)</b>
<b class="nc">&nbsp;                    return envVars;</b>
<b class="nc">&nbsp;                parse();</b>
<b class="nc">&nbsp;                return envVars;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                if (arguments != null)</b>
<b class="nc">&nbsp;                    return arguments;</b>
<b class="nc">&nbsp;                parse();</b>
<b class="nc">&nbsp;                return arguments;</b>
&nbsp;            }
&nbsp;
&nbsp;            private void parse() {
&nbsp;                try {
&nbsp;// allocate them first, so that the parse error wil result in empty data
&nbsp;                    // and avoid retry.
<b class="nc">&nbsp;                    arguments = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                    envVars = new EnvVars();</b>
&nbsp;
<b class="nc">&nbsp;                    IntByReference argmaxRef = new IntByReference(0);</b>
<b class="nc">&nbsp;                    NativeLongByReference size = new NativeLongByReference(new NativeLong(sizeOfInt));</b>
&nbsp;
&nbsp;                    // for some reason, I was never able to get sysctlbyname work.
&nbsp;//        if (LIBC.sysctlbyname(&quot;kern.argmax&quot;, argmaxRef.getPointer(), size, NULL, _)!=0)
<b class="nc">&nbsp;                    if (LIBC.sysctl(new int[]{CTL_KERN, KERN_ARGMAX}, 2, argmaxRef.getPointer(), size, NULL, new NativeLong(0)) != 0)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to get kern.argmax: &quot; + LIBC.strerror(Native.getLastError()));</b>
&nbsp;
<b class="nc">&nbsp;                    int argmax = argmaxRef.getValue();</b>
&nbsp;
&nbsp;                    @SuppressFBWarnings(value = &quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;, justification = &quot;Not needed for JNA&quot;)
&nbsp;                    class StringArrayMemory extends Memory {
<b class="nc">&nbsp;                        private long offset = 0;</b>
<b class="nc">&nbsp;                        private long length = 0;</b>
&nbsp;
<b class="nc">&nbsp;                        StringArrayMemory(long l) {</b>
<b class="nc">&nbsp;                            super(l);</b>
<b class="nc">&nbsp;                            length = l;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        void setLength(long l) {
<b class="nc">&nbsp;                            length = Math.min(l, size());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        int readInt() {
<b class="nc">&nbsp;                            if (offset &gt; length - sizeOfInt)</b>
<b class="nc">&nbsp;                                return 0;</b>
<b class="nc">&nbsp;                            int r = getInt(offset);</b>
<b class="nc">&nbsp;                            offset += sizeOfInt;</b>
<b class="nc">&nbsp;                            return r;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        byte peek() {
<b class="nc">&nbsp;                            if (offset &gt;= length)</b>
<b class="nc">&nbsp;                                return 0;</b>
<b class="nc">&nbsp;                            return getByte(offset);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        String readString() {
<b class="nc">&nbsp;                            ByteArrayOutputStream baos = new ByteArrayOutputStream();</b>
&nbsp;                            byte ch;
<b class="nc">&nbsp;                            while (offset &lt; length &amp;&amp; (ch = getByte(offset++)) != &#39;\0&#39;)</b>
<b class="nc">&nbsp;                                baos.write(ch);</b>
<b class="nc">&nbsp;                            return baos.toString(StandardCharsets.UTF_8);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        void skip0() {
&nbsp;                            // skip padding &#39;\0&#39;s
<b class="nc">&nbsp;                            while (offset &lt; length &amp;&amp; getByte(offset) == &#39;\0&#39;)</b>
<b class="nc">&nbsp;                                offset++;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    StringArrayMemory m = new StringArrayMemory(argmax);</b>
<b class="nc">&nbsp;                    m.clear();</b>
<b class="nc">&nbsp;                    size.setValue(new NativeLong(argmax));</b>
<b class="nc">&nbsp;                    if (LIBC.sysctl(new int[]{CTL_KERN, KERN_PROCARGS2, pid}, 3, m, size, NULL, new NativeLong(0)) != 0)</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to obtain ken.procargs2: &quot; + LIBC.strerror(Native.getLastError()));</b>
<b class="nc">&nbsp;                    m.setLength(size.getValue().longValue());</b>
&nbsp;
&nbsp;
&nbsp;                    /*
&nbsp;                    * Make a sysctl() call to get the raw argument space of the
&nbsp;                        * process.  The layout is documented in start.s, which is part
&nbsp;                        * of the Csu project.  In summary, it looks like:
&nbsp;                        *
&nbsp;                        * /---------------\ 0x00000000
&nbsp;                        * :               :
&nbsp;                        * :               :
&nbsp;                        * |---------------|
&nbsp;                        * | argc          |
&nbsp;                        * |---------------|
&nbsp;                        * | arg[0]        |
&nbsp;                        * |---------------|
&nbsp;                        * :               :
&nbsp;                        * :               :
&nbsp;                        * |---------------|
&nbsp;                        * | arg[argc - 1] |
&nbsp;                        * |---------------|
&nbsp;                        * | 0             |
&nbsp;                        * |---------------|
&nbsp;                        * | env[0]        |
&nbsp;                        * |---------------|
&nbsp;                        * :               :
&nbsp;                        * :               :
&nbsp;                        * |---------------|
&nbsp;                        * | env[n]        |
&nbsp;                        * |---------------|
&nbsp;                        * | 0             |
&nbsp;                        * |---------------| &lt;-- Beginning of data returned by sysctl() is here.
&nbsp;                        * | argc          |
&nbsp;                        * |---------------|
&nbsp;                        * | exec_path     |
&nbsp;                        * |:::::::::::::::|
&nbsp;                        * |               |
&nbsp;                        * | String area.  |
&nbsp;                        * |               |
&nbsp;                        * |---------------| &lt;-- Top of stack.
&nbsp;                        * :               :
&nbsp;                        * :               :
&nbsp;                        * \---------------/ 0xffffffff
&nbsp;                        */
&nbsp;
&nbsp;                    // I find the Darwin source code of the &#39;ps&#39; command helpful in understanding how it does this:
&nbsp;                    // see https://opensource.apple.com/source/adv_cmds/adv_cmds-176/ps/print.c
<b class="nc">&nbsp;                    int argc = m.readInt();</b>
<b class="nc">&nbsp;                    String args0 = m.readString(); // exec path</b>
<b class="nc">&nbsp;                    m.skip0();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        for (int i = 0; i &lt; argc; i++) {</b>
<b class="nc">&nbsp;                            arguments.add(m.readString());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (IndexOutOfBoundsException e) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Failed to parse arguments: pid=&quot; + pid + &quot;, arg0=&quot; + args0 + &quot;, arguments=&quot; + arguments + &quot;, nargs=&quot; + argc + &quot;. Please see https://www.jenkins.io/redirect/troubleshooting/darwin-failed-to-parse-arguments&quot;, e);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    // read env vars that follow
<b class="nc">&nbsp;                    while (m.peek() != 0)</b>
<b class="nc">&nbsp;                        envVars.addLine(m.readString());</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // this happens with insufficient permissions, so just ignore the problem.
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // local constants
&nbsp;        private final int sizeOf_kinfo_proc;
&nbsp;        private static final int sizeOf_kinfo_proc_32 = 492; // on 32bit Mac OS X.
&nbsp;        private static final int sizeOf_kinfo_proc_64 = 648; // on 64bit Mac OS X.
&nbsp;        private final int kinfo_proc_pid_offset;
&nbsp;        private static final int kinfo_proc_pid_offset_32 = 24;
&nbsp;        private static final int kinfo_proc_pid_offset_64 = 40;
&nbsp;        private final int kinfo_proc_ppid_offset;
&nbsp;        private static final int kinfo_proc_ppid_offset_32 = 416;
&nbsp;        private static final int kinfo_proc_ppid_offset_64 = 560;
<b class="nc">&nbsp;        private static final int sizeOfInt = Native.getNativeSize(int.class);</b>
&nbsp;        private static final int CTL_KERN = 1;
&nbsp;        private static final int KERN_PROC = 14;
&nbsp;        private static final int KERN_PROC_ALL = 0;
&nbsp;        private static final int ENOMEM = 12;
<b class="nc">&nbsp;        private static int[] MIB_PROC_ALL = {CTL_KERN, KERN_PROC, KERN_PROC_ALL};</b>
&nbsp;        private static final int KERN_ARGMAX = 8;
&nbsp;        private static final int KERN_PROCARGS2 = 49;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implementation for FreeBSD based on sysctl(3).
&nbsp;     */
&nbsp;    private static class FreeBSD extends Unix {
&nbsp;
&nbsp;        // Taken from sys/errno.h
&nbsp;        private static final int ENOMEM = 12;
&nbsp;
&nbsp;        // Taken from sys/sysctl.h
&nbsp;        private static final int CTL_KERN = 1;
&nbsp;        private static final int KERN_ARGMAX = 8;
&nbsp;        private static final int KERN_PROC = 14;
&nbsp;        private static final int KERN_PROC_ALL = 0;
&nbsp;        private static final int KERN_PROC_ARGS = 7;
&nbsp;        private static final int KERN_PROC_ENV = 35;
&nbsp;
&nbsp;        // Local constants
&nbsp;        private final long sizeOf_kinfo_proc;
&nbsp;        private static final long sizeOf_kinfo_proc_32 = 768;
&nbsp;        private static final long sizeOf_kinfo_proc_64 = 1088;
&nbsp;        private final int kinfo_proc_pid_offset;
&nbsp;        private static final int kinfo_proc_pid_offset_32 = 40;
&nbsp;        private static final int kinfo_proc_pid_offset_64 = 72;
&nbsp;        private final int kinfo_proc_ppid_offset;
&nbsp;        private static final int kinfo_proc_ppid_offset_32 = 44;
&nbsp;        private static final int kinfo_proc_ppid_offset_64 = 76;
<b class="nc">&nbsp;        private static final int sizeOfInt = Native.getNativeSize(int.class);</b>
&nbsp;
&nbsp;        FreeBSD(boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;
<b class="nc">&nbsp;            String arch = System.getProperty(&quot;sun.arch.data.model&quot;);</b>
<b class="nc">&nbsp;            if (&quot;64&quot;.equals(arch)) {</b>
<b class="nc">&nbsp;                sizeOf_kinfo_proc = sizeOf_kinfo_proc_64;</b>
<b class="nc">&nbsp;                kinfo_proc_pid_offset = kinfo_proc_pid_offset_64;</b>
<b class="nc">&nbsp;                kinfo_proc_ppid_offset = kinfo_proc_ppid_offset_64;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                sizeOf_kinfo_proc = sizeOf_kinfo_proc_32;</b>
<b class="nc">&nbsp;                kinfo_proc_pid_offset = kinfo_proc_pid_offset_32;</b>
<b class="nc">&nbsp;                kinfo_proc_ppid_offset = kinfo_proc_ppid_offset_32;</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                NativeLongByReference size = new NativeLongByReference(new NativeLong(0));</b>
&nbsp;                Memory m;
<b class="nc">&nbsp;                int nRetry = 0;</b>
&nbsp;                while (true) {
&nbsp;                    // Find out how much memory we need for kern.proc.all.
<b class="nc">&nbsp;                    if (LIBC.sysctl(</b>
&nbsp;                                    new int[] {CTL_KERN, KERN_PROC, KERN_PROC_ALL},
&nbsp;                                    3,
&nbsp;                                    NULL,
&nbsp;                                    size,
&nbsp;                                    NULL,
&nbsp;                                    new NativeLong(0))
&nbsp;                            != 0) {
<b class="nc">&nbsp;                        throw new IOException(</b>
&nbsp;                                &quot;Failed to get memory requirement: &quot;
<b class="nc">&nbsp;                                        + LIBC.strerror(Native.getLastError()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // Add some padding to account for new processes.
<b class="nc">&nbsp;                    long len = size.getValue().longValue();</b>
<b class="nc">&nbsp;                    len += len / 10L;</b>
&nbsp;
&nbsp;                    // Now get kern.proc.all.
<b class="nc">&nbsp;                    m = new Memory(len);</b>
<b class="nc">&nbsp;                    size.setValue(new NativeLong(len));</b>
<b class="nc">&nbsp;                    if (LIBC.sysctl(</b>
&nbsp;                                    new int[] {CTL_KERN, KERN_PROC, KERN_PROC_ALL},
&nbsp;                                    3,
&nbsp;                                    m,
&nbsp;                                    size,
&nbsp;                                    NULL,
&nbsp;                                    new NativeLong(0))
&nbsp;                            != 0) {
<b class="nc">&nbsp;                        if (Native.getLastError() == ENOMEM &amp;&amp; nRetry++ &lt; 16) {</b>
<b class="nc">&nbsp;                            continue; // retry</b>
&nbsp;                        }
<b class="nc">&nbsp;                        throw new IOException(</b>
&nbsp;                                &quot;Failed to get kern.proc.all: &quot;
<b class="nc">&nbsp;                                        + LIBC.strerror(Native.getLastError()));</b>
&nbsp;                    }
&nbsp;                    break;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                long count = size.getValue().longValue() / sizeOf_kinfo_proc;</b>
<b class="nc">&nbsp;                LOGGER.fine(() -&gt; &quot;Found &quot; + count + &quot; processes&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                for (long base = 0; base &lt; size.getValue().longValue(); base += sizeOf_kinfo_proc) {</b>
<b class="nc">&nbsp;                    int pid = m.getInt(base + kinfo_proc_pid_offset);</b>
<b class="nc">&nbsp;                    int ppid = m.getInt(base + kinfo_proc_ppid_offset);</b>
<b class="nc">&nbsp;                    super.processes.put(pid, new FreeBSDProcess(pid, ppid));</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to obtain process list&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        private class FreeBSDProcess extends UnixProcess {
&nbsp;
&nbsp;            private final int ppid;
&nbsp;            private EnvVars envVars;
&nbsp;            private List&lt;String&gt; arguments;
&nbsp;
<b class="nc">&nbsp;            FreeBSDProcess(int pid, int ppid) {</b>
<b class="nc">&nbsp;                super(pid);</b>
<b class="nc">&nbsp;                this.ppid = ppid;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CheckForNull
&nbsp;            public OSProcess getParent() {
<b class="nc">&nbsp;                return get(ppid);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public synchronized EnvVars getEnvironmentVariables() {
<b class="nc">&nbsp;                if (envVars != null) {</b>
<b class="nc">&nbsp;                    return envVars;</b>
&nbsp;                }
&nbsp;                try {
&nbsp;                    /*
&nbsp;                     * Allocate first so that parse errors will result in empty data and avoid
&nbsp;                     * retry.
&nbsp;                     */
<b class="nc">&nbsp;                    envVars = new EnvVars();</b>
&nbsp;
<b class="nc">&nbsp;                    int argmax = getArgmax();</b>
<b class="nc">&nbsp;                    Memory m = new Memory(argmax);</b>
<b class="nc">&nbsp;                    NativeLongByReference size = new NativeLongByReference(new NativeLong(argmax));</b>
<b class="nc">&nbsp;                    if (LIBC.sysctl(</b>
&nbsp;                                    new int[] {CTL_KERN, KERN_PROC, KERN_PROC_ENV, pid},
&nbsp;                                    4,
&nbsp;                                    m,
&nbsp;                                    size,
&nbsp;                                    NULL,
&nbsp;                                    new NativeLong(0))
&nbsp;                            != 0) {
<b class="nc">&nbsp;                        throw new IOException(</b>
&nbsp;                                &quot;Failed to get kern.proc.env: &quot;
<b class="nc">&nbsp;                                        + LIBC.strerror(Native.getLastError()));</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    parse(m, size.getValue(), envVars::addLine);</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // This happens with insufficient permissions, so just ignore the problem.
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return envVars;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                if (arguments != null) {</b>
<b class="nc">&nbsp;                    return arguments;</b>
&nbsp;                }
&nbsp;                try {
&nbsp;                    /*
&nbsp;                     * Allocate first so that parse errors will result in empty data and avoid
&nbsp;                     * retry.
&nbsp;                     */
<b class="nc">&nbsp;                    arguments = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;                    int argmax = getArgmax();</b>
<b class="nc">&nbsp;                    Memory m = new Memory(argmax);</b>
<b class="nc">&nbsp;                    NativeLongByReference size = new NativeLongByReference(new NativeLong(argmax));</b>
<b class="nc">&nbsp;                    if (LIBC.sysctl(</b>
&nbsp;                                    new int[] {CTL_KERN, KERN_PROC, KERN_PROC_ARGS, pid},
&nbsp;                                    4,
&nbsp;                                    m,
&nbsp;                                    size,
&nbsp;                                    NULL,
&nbsp;                                    new NativeLong(0))
&nbsp;                            != 0) {
<b class="nc">&nbsp;                        throw new IOException(</b>
&nbsp;                                &quot;Failed to get kern.proc.args: &quot;
<b class="nc">&nbsp;                                        + LIBC.strerror(Native.getLastError()));</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    parse(m, size.getValue(), arguments::add);</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
&nbsp;                    // This happens with insufficient permissions, so just ignore the problem.
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return arguments;</b>
&nbsp;            }
&nbsp;
&nbsp;            private int getArgmax() throws IOException {
<b class="nc">&nbsp;                IntByReference argmaxRef = new IntByReference(0);</b>
<b class="nc">&nbsp;                NativeLongByReference size = new NativeLongByReference(new NativeLong(sizeOfInt));</b>
<b class="nc">&nbsp;                if (LIBC.sysctl(</b>
&nbsp;                                new int[] {CTL_KERN, KERN_ARGMAX},
&nbsp;                                2,
<b class="nc">&nbsp;                                argmaxRef.getPointer(),</b>
&nbsp;                                size,
&nbsp;                                NULL,
&nbsp;                                new NativeLong(0))
&nbsp;                        != 0) {
<b class="nc">&nbsp;                    throw new IOException(</b>
<b class="nc">&nbsp;                            &quot;Failed to get kern.argmax: &quot; + LIBC.strerror(Native.getLastError()));</b>
&nbsp;                }
<b class="nc">&nbsp;                return argmaxRef.getValue();</b>
&nbsp;            }
&nbsp;
&nbsp;            private void parse(Memory m, NativeLong size, Consumer&lt;String&gt; consumer) {
<b class="nc">&nbsp;                ByteArrayOutputStream baos = new ByteArrayOutputStream();</b>
&nbsp;                byte ch;
<b class="nc">&nbsp;                long offset = 0;</b>
<b class="nc">&nbsp;                while (offset &lt; size.longValue()) {</b>
<b class="nc">&nbsp;                    while ((ch = m.getByte(offset++)) != &#39;\0&#39;) {</b>
<b class="nc">&nbsp;                        baos.write(ch);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    consumer.accept(baos.toString(StandardCharsets.UTF_8));</b>
<b class="nc">&nbsp;                    baos.reset();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a local process tree, where this JVM and the process tree run on the same system.
&nbsp;     * (The opposite of {@link Remote}.)
&nbsp;     */
&nbsp;    public abstract static class Local extends ProcessTree {
&nbsp;        @Deprecated
<b class="fc">&nbsp;        Local() {</b>
&nbsp;        }
&nbsp;
&nbsp;        Local(boolean vetoesExist) {
<b class="fc">&nbsp;            super(vetoesExist);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a process tree over a channel.
&nbsp;     */
&nbsp;    public static class Remote extends ProcessTree {
&nbsp;        private final IProcessTree proxy;
&nbsp;
&nbsp;        @Deprecated
<b class="fc">&nbsp;        public Remote(ProcessTree proxy, Channel ch) {</b>
<b class="fc">&nbsp;            this.proxy = ch.export(IProcessTree.class, proxy);</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;Integer, OSProcess&gt; e : proxy.processes.entrySet())</b>
<b class="fc">&nbsp;                processes.put(e.getKey(), new RemoteProcess(e.getValue(), ch));</b>
&nbsp;        }
&nbsp;
&nbsp;        public Remote(ProcessTree proxy, Channel ch, boolean vetoersExist) {
<b class="nc">&nbsp;            super(vetoersExist);</b>
&nbsp;
<b class="nc">&nbsp;            this.proxy = ch.export(IProcessTree.class, proxy);</b>
<b class="nc">&nbsp;            for (Map.Entry&lt;Integer, OSProcess&gt; e : proxy.processes.entrySet())</b>
<b class="nc">&nbsp;                processes.put(e.getKey(), new RemoteProcess(e.getValue(), ch));</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        @Override
&nbsp;        public OSProcess get(@NonNull Process proc) {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void killAll(@NonNull Map&lt;String, String&gt; modelEnvVars) throws InterruptedException {
<b class="nc">&nbsp;            proxy.killAll(modelEnvVars);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        Object writeReplace() {
<b class="fc">&nbsp;            return this; // cancel out super.writeReplace()</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @SuppressFBWarnings(value = &quot;SE_INNER_CLASS&quot;, justification = &quot;Serializing the outer instance is intended&quot;)
&nbsp;        private class RemoteProcess extends OSProcess implements Serializable {
&nbsp;            private final IOSProcess proxy;
&nbsp;
<b class="fc">&nbsp;            RemoteProcess(OSProcess proxy, Channel ch) {</b>
<b class="fc">&nbsp;                super(proxy.getPid());</b>
<b class="fc">&nbsp;                this.proxy = ch.export(IOSProcess.class, proxy);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CheckForNull
&nbsp;            public OSProcess getParent() {
<b class="nc">&nbsp;                IOSProcess p = proxy.getParent();</b>
<b class="nc">&nbsp;                if (p == null)    return null;</b>
<b class="nc">&nbsp;                return get(p.getPid());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void kill() throws InterruptedException {
<b class="nc">&nbsp;                proxy.kill();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void killRecursively() throws InterruptedException {
<b class="nc">&nbsp;                proxy.killRecursively();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public List&lt;String&gt; getArguments() {
<b class="nc">&nbsp;                return proxy.getArguments();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @NonNull
&nbsp;            public EnvVars getEnvironmentVariables() {
<b class="fc">&nbsp;                return proxy.getEnvironmentVariables();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            Object writeReplace() {
<b class="fc">&nbsp;                return this; // cancel out super.writeReplace()</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public &lt;T&gt; T act(ProcessCallable&lt;T&gt; callable) throws IOException, InterruptedException {
<b class="fc">&nbsp;                return proxy.act(callable);</b>
&nbsp;            }
&nbsp;
&nbsp;
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Use {@link Remote} as the serialized form.
&nbsp;     */
&nbsp;    /*package*/ Object writeReplace() throws ObjectStreamException {
<b class="fc">&nbsp;        return new Remote(this, getChannelForSerialization());</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;        On MacOS X, there&#39;s no procfs &lt;http://www.osxbook.com/book/bonus/chapter11/procfs/&gt;
&nbsp;        instead you&#39;d do it with the sysctl &lt;http://search.cpan.org/src/DURIST/Proc-ProcessTable-0.42/os/darwin.c&gt;
&nbsp;        &lt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man3/sysctl.3.html&gt;
&nbsp;
&nbsp;        There&#39;s CLI but that doesn&#39;t seem to offer the access to per-process info
&nbsp;        &lt;http://developer.apple.com/documentation/Darwin/Reference/ManPages/man8/sysctl.8.html&gt;
&nbsp;
&nbsp;
&nbsp;
&nbsp;        On HP-UX, pstat_getcommandline get you command line, but I&#39;m not seeing any environment variables.
&nbsp;     */
&nbsp;
<b class="fc">&nbsp;    private static final boolean IS_LITTLE_ENDIAN = &quot;little&quot;.equals(System.getProperty(&quot;sun.cpu.endian&quot;));</b>
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(ProcessTree.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Flag to control this feature.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This feature involves some native code, so we are allowing the user to disable this
&nbsp;     * in case there&#39;s a fatal problem.
&nbsp;     *
&nbsp;     */
<b class="fc">&nbsp;    static boolean enabled = !SystemProperties.getBoolean(&quot;hudson.util.ProcessTreeKiller.disable&quot;)</b>
<b class="fc">&nbsp;            &amp;&amp; !SystemProperties.getBoolean(ProcessTree.class.getName() + &quot;.disable&quot;);</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
