


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Maven</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.tasks</a>
</div>

<h1>Coverage Summary for Class: Maven (hudson.tasks)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Maven</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/98)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Maven$DecideDefaultMavenCommand</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$DescriptorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstallation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstallation$ConverterImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstallation$DescriptorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstallation$GetExecutable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstallation$GetMavenVersion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstaller</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$MavenInstaller$DescriptorImpl</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Maven$ProjectWithMaven</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    1.6%
  </span>
  <span class="absValue">
    (1/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0.5%
  </span>
  <span class="absValue">
    (1/219)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, Jene Jasper, Stephen Connolly, Tom Huybrechts, Yahoo! Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.tasks;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.CopyOnWrite;
&nbsp;import hudson.EnvVars;
&nbsp;import hudson.Extension;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Launcher;
&nbsp;import hudson.Launcher.LocalLauncher;
&nbsp;import hudson.Util;
&nbsp;import hudson.model.AbstractBuild;
&nbsp;import hudson.model.AbstractProject;
&nbsp;import hudson.model.BuildListener;
&nbsp;import hudson.model.Computer;
&nbsp;import hudson.model.EnvironmentSpecific;
&nbsp;import hudson.model.Node;
&nbsp;import hudson.model.PersistentDescriptor;
&nbsp;import hudson.model.TaskListener;
&nbsp;import hudson.remoting.VirtualChannel;
&nbsp;import hudson.slaves.NodeSpecific;
&nbsp;import hudson.tasks._maven.MavenConsoleAnnotator;
&nbsp;import hudson.tools.DownloadFromUrlInstaller;
&nbsp;import hudson.tools.ToolDescriptor;
&nbsp;import hudson.tools.ToolInstallation;
&nbsp;import hudson.tools.ToolInstaller;
&nbsp;import hudson.tools.ToolProperty;
&nbsp;import hudson.util.ArgumentListBuilder;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.StreamTaskListener;
&nbsp;import hudson.util.VariableResolver;
&nbsp;import hudson.util.VariableResolver.ByMap;
&nbsp;import hudson.util.VariableResolver.Union;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Properties;
&nbsp;import java.util.Set;
&nbsp;import java.util.StringTokenizer;
&nbsp;import java.util.jar.Attributes;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.regex.Pattern;
&nbsp;import jenkins.MasterToSlaveFileCallable;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.mvn.GlobalMavenConfig;
&nbsp;import jenkins.mvn.GlobalSettingsProvider;
&nbsp;import jenkins.mvn.SettingsProvider;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.jenkinsci.Symbol;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.DataBoundConstructor;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;
&nbsp;/**
&nbsp; * Build by using Maven.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;public class Maven extends Builder {
&nbsp;    /**
&nbsp;     * The targets and other maven options.
&nbsp;     * Can be separated by SP or NL.
&nbsp;     */
&nbsp;    public final String targets;
&nbsp;
&nbsp;    /**
&nbsp;     * Identifies {@link MavenInstallation} to be used.
&nbsp;     */
&nbsp;    public final String mavenName;
&nbsp;
&nbsp;    /**
&nbsp;     * MAVEN_OPTS if not null.
&nbsp;     */
&nbsp;    public final String jvmOptions;
&nbsp;
&nbsp;    /**
&nbsp;     * Optional POM file path relative to the workspace.
&nbsp;     * Used for the Maven &#39;-f&#39; option.
&nbsp;     */
&nbsp;    public final String pom;
&nbsp;
&nbsp;    /**
&nbsp;     * Optional properties to be passed to Maven. Follows {@link Properties} syntax.
&nbsp;     */
&nbsp;    public final String properties;
&nbsp;
&nbsp;    /**
&nbsp;     * If true, the build will use its own local Maven repository
&nbsp;     * via &quot;-Dmaven.repo.local=...&quot;.
&nbsp;     * &lt;p&gt;
&nbsp;     * This would consume additional disk space, but provides isolation with other builds on the same machine,
&nbsp;     * such as mixing SNAPSHOTS. Maven also doesn&#39;t try to coordinate the concurrent access to Maven repositories
&nbsp;     * from multiple Maven process, so this helps there too.
&nbsp;     *
&nbsp;     * Identical to logic used in maven-plugin.
&nbsp;     *
&nbsp;     * @since 1.322
&nbsp;     */
&nbsp;    public boolean usePrivateRepository;
&nbsp;
&nbsp;    /**
&nbsp;     * Provides access to the settings.xml to be used for a build.
&nbsp;     * @since 1.491
&nbsp;     */
&nbsp;    private SettingsProvider settings;
&nbsp;
&nbsp;    /**
&nbsp;     * Provides access to the global settings.xml to be used for a build.
&nbsp;     * @since 1.491
&nbsp;     */
&nbsp;    private GlobalSettingsProvider globalSettings;
&nbsp;
&nbsp;    /**
&nbsp;     * Skip injecting build variables as properties into maven process.
&nbsp;     *
&nbsp;     * Defaults to false unless user requests otherwise. Old configurations are set to true to mimic the legacy behaviour.
&nbsp;     *
&nbsp;     * @since 2.12
&nbsp;     */
&nbsp;    private @NonNull Boolean injectBuildVariables;
&nbsp;
&nbsp;    private static final String MAVEN_1_INSTALLATION_COMMON_FILE = &quot;bin/maven&quot;;
&nbsp;    private static final String MAVEN_2_INSTALLATION_COMMON_FILE = &quot;bin/mvn&quot;;
&nbsp;
<b class="nc">&nbsp;    private static final Pattern S_PATTERN = Pattern.compile(&quot;(^| )-s &quot;);</b>
<b class="nc">&nbsp;    private static final Pattern GS_PATTERN = Pattern.compile(&quot;(^| )-gs &quot;);</b>
&nbsp;
&nbsp;    public Maven(String targets, String name) {
<b class="nc">&nbsp;        this(targets, name, null, null, null, false, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Maven(String targets, String name, String pom, String properties, String jvmOptions) {
<b class="nc">&nbsp;        this(targets, name, pom, properties, jvmOptions, false, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Maven(String targets, String name, String pom, String properties, String jvmOptions, boolean usePrivateRepository) {
<b class="nc">&nbsp;        this(targets, name, pom, properties, jvmOptions, usePrivateRepository, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Maven(String targets, String name, String pom, String properties, String jvmOptions, boolean usePrivateRepository, SettingsProvider settings, GlobalSettingsProvider globalSettings) {
<b class="nc">&nbsp;        this(targets, name, pom, properties, jvmOptions, usePrivateRepository, settings, globalSettings, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundConstructor
<b class="nc">&nbsp;    public Maven(String targets, String name, String pom, String properties, String jvmOptions, boolean usePrivateRepository, SettingsProvider settings, GlobalSettingsProvider globalSettings, boolean injectBuildVariables) {</b>
<b class="nc">&nbsp;        this.targets = targets;</b>
<b class="nc">&nbsp;        this.mavenName = name;</b>
<b class="nc">&nbsp;        this.pom = Util.fixEmptyAndTrim(pom);</b>
<b class="nc">&nbsp;        this.properties = Util.fixEmptyAndTrim(properties);</b>
<b class="nc">&nbsp;        this.jvmOptions = Util.fixEmptyAndTrim(jvmOptions);</b>
<b class="nc">&nbsp;        this.usePrivateRepository = usePrivateRepository;</b>
<b class="nc">&nbsp;        this.settings = settings != null ? settings : GlobalMavenConfig.get().getSettingsProvider();</b>
<b class="nc">&nbsp;        this.globalSettings = globalSettings != null ? globalSettings : GlobalMavenConfig.get().getGlobalSettingsProvider();</b>
<b class="nc">&nbsp;        this.injectBuildVariables = injectBuildVariables;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getTargets() {
<b class="nc">&nbsp;        return targets;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.491
&nbsp;     */
&nbsp;    public SettingsProvider getSettings() {
<b class="nc">&nbsp;        return settings != null ? settings : GlobalMavenConfig.get().getSettingsProvider();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setSettings(SettingsProvider settings) {
<b class="nc">&nbsp;        this.settings = settings;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.491
&nbsp;     */
&nbsp;    public GlobalSettingsProvider getGlobalSettings() {
<b class="nc">&nbsp;        return globalSettings != null ? globalSettings : GlobalMavenConfig.get().getGlobalSettingsProvider();</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void setGlobalSettings(GlobalSettingsProvider globalSettings) {
<b class="nc">&nbsp;        this.globalSettings = globalSettings;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setUsePrivateRepository(boolean usePrivateRepository) {
<b class="nc">&nbsp;        this.usePrivateRepository = usePrivateRepository;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean usesPrivateRepository() {
<b class="nc">&nbsp;        return usePrivateRepository;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class) // Exposed for view
&nbsp;    public boolean isInjectBuildVariables() {
<b class="nc">&nbsp;        return injectBuildVariables;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the Maven to invoke,
&nbsp;     * or null to invoke the default one.
&nbsp;     */
&nbsp;    public MavenInstallation getMaven() {
<b class="nc">&nbsp;        for (MavenInstallation i : getDescriptor().getInstallations()) {</b>
<b class="nc">&nbsp;            if (mavenName != null &amp;&amp; mavenName.equals(i.getName()))</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE&quot;, justification = &quot;injectBuildVariables in readResolve is needed for data migration.&quot;)
&nbsp;    private Object readResolve() {
<b class="nc">&nbsp;        if (injectBuildVariables == null) {</b>
<b class="nc">&nbsp;            injectBuildVariables = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Looks for {@code pom.xlm} or {@code project.xml} to determine the maven executable
&nbsp;     * name.
&nbsp;     */
&nbsp;    private static final class DecideDefaultMavenCommand extends MasterToSlaveFileCallable&lt;String&gt; {
&nbsp;        private static final long serialVersionUID = -2327576423452215146L;
&nbsp;        // command line arguments.
&nbsp;        private final String arguments;
&nbsp;
<b class="nc">&nbsp;        DecideDefaultMavenCommand(String arguments) {</b>
<b class="nc">&nbsp;            this.arguments = arguments;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String invoke(File ws, VirtualChannel channel) throws IOException {
<b class="nc">&nbsp;            String seed = null;</b>
&nbsp;
&nbsp;            // check for the -f option
<b class="nc">&nbsp;            StringTokenizer tokens = new StringTokenizer(arguments);</b>
<b class="nc">&nbsp;            while (tokens.hasMoreTokens()) {</b>
<b class="nc">&nbsp;                String t = tokens.nextToken();</b>
<b class="nc">&nbsp;                if (t.equals(&quot;-f&quot;) &amp;&amp; tokens.hasMoreTokens()) {</b>
<b class="nc">&nbsp;                    File file = new File(ws, tokens.nextToken());</b>
<b class="nc">&nbsp;                    if (!file.exists())</b>
<b class="nc">&nbsp;                        continue;   // looks like an error, but let the execution fail later</b>
<b class="nc">&nbsp;                    seed = file.isDirectory() ?</b>
<b class="nc">&nbsp;                        /* in M1, you specify a directory in -f */ &quot;maven&quot;</b>
<b class="nc">&nbsp;                        /* in M2, you specify a POM file name.  */ : &quot;mvn&quot;;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (seed == null) {</b>
&nbsp;                // as of 1.212 (2008 April), I think Maven2 mostly replaced Maven1, so
&nbsp;                // switching to err on M2 side.
<b class="nc">&nbsp;                seed = new File(ws, &quot;project.xml&quot;).exists() ? &quot;maven&quot; : &quot;mvn&quot;;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return seed;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean perform(AbstractBuild&lt;?, ?&gt; build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        VariableResolver&lt;String&gt; vr = build.getBuildVariableResolver();</b>
&nbsp;
<b class="nc">&nbsp;        EnvVars env = build.getEnvironment(listener);</b>
&nbsp;
<b class="nc">&nbsp;        String targets = Util.replaceMacro(this.targets, vr);</b>
<b class="nc">&nbsp;        targets = env.expand(targets);</b>
<b class="nc">&nbsp;        String pom = env.expand(this.pom);</b>
&nbsp;
<b class="nc">&nbsp;        int startIndex = 0;</b>
&nbsp;        int endIndex;
&nbsp;        do {
&nbsp;            // split targets into multiple invocations of maven separated by |
<b class="nc">&nbsp;            endIndex = targets.indexOf(&#39;|&#39;, startIndex);</b>
<b class="nc">&nbsp;            if (-1 == endIndex) {</b>
<b class="nc">&nbsp;                endIndex = targets.length();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            String normalizedTarget = targets</b>
<b class="nc">&nbsp;                    .substring(startIndex, endIndex)</b>
<b class="nc">&nbsp;                    .replaceAll(&quot;[\t\r\n]+&quot;, &quot; &quot;);</b>
&nbsp;
<b class="nc">&nbsp;            ArgumentListBuilder args = new ArgumentListBuilder();</b>
<b class="nc">&nbsp;            MavenInstallation mi = getMaven();</b>
<b class="nc">&nbsp;            if (mi == null) {</b>
<b class="nc">&nbsp;                String execName = build.getWorkspace().act(new DecideDefaultMavenCommand(normalizedTarget));</b>
<b class="nc">&nbsp;                args.add(execName);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                mi = mi.forNode(Computer.currentComputer().getNode(), listener);</b>
<b class="nc">&nbsp;                mi = mi.forEnvironment(env);</b>
<b class="nc">&nbsp;                String exec = mi.getExecutable(launcher);</b>
<b class="nc">&nbsp;                if (exec == null) {</b>
<b class="nc">&nbsp;                    listener.fatalError(Messages.Maven_NoExecutable(mi.getHome()));</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                args.add(exec);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (pom != null)</b>
<b class="nc">&nbsp;                args.add(&quot;-f&quot;, pom);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;            if (!S_PATTERN.matcher(targets).find()) { // check the given target/goals do not contain settings parameter already</b>
<b class="nc">&nbsp;                String settingsPath = SettingsProvider.getSettingsRemotePath(getSettings(), build, listener);</b>
<b class="nc">&nbsp;                if (StringUtils.isNotBlank(settingsPath)) {</b>
<b class="nc">&nbsp;                    args.add(&quot;-s&quot;, settingsPath);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!GS_PATTERN.matcher(targets).find()) {</b>
<b class="nc">&nbsp;                String settingsPath = GlobalSettingsProvider.getSettingsRemotePath(getGlobalSettings(), build, listener);</b>
<b class="nc">&nbsp;                if (StringUtils.isNotBlank(settingsPath)) {</b>
<b class="nc">&nbsp;                    args.add(&quot;-gs&quot;, settingsPath);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Set&lt;String&gt; sensitiveVars = build.getSensitiveBuildVariables();</b>
&nbsp;
&nbsp;            // Inject environment variables only if chosen to do so
<b class="nc">&nbsp;            if (isInjectBuildVariables()) {</b>
<b class="nc">&nbsp;                args.addKeyValuePairs(&quot;-D&quot;, build.getBuildVariables(), sensitiveVars);</b>
&nbsp;            }
&nbsp;
&nbsp;            // Add properties from builder configuration, AFTER the injected build variables.
<b class="nc">&nbsp;            final VariableResolver&lt;String&gt; resolver = new Union&lt;&gt;(new ByMap&lt;&gt;(env), vr);</b>
<b class="nc">&nbsp;            args.addKeyValuePairsFromPropertyString(&quot;-D&quot;, this.properties, resolver, sensitiveVars);</b>
&nbsp;
<b class="nc">&nbsp;            if (usesPrivateRepository())</b>
<b class="nc">&nbsp;                args.add(&quot;-Dmaven.repo.local=&quot; + build.getWorkspace().child(&quot;.repository&quot;));</b>
<b class="nc">&nbsp;            args.addTokenized(normalizedTarget);</b>
<b class="nc">&nbsp;            wrapUpArguments(args, normalizedTarget, build, launcher, listener);</b>
&nbsp;
<b class="nc">&nbsp;            buildEnvVars(env, mi);</b>
&nbsp;
<b class="nc">&nbsp;            if (!launcher.isUnix()) {</b>
<b class="nc">&nbsp;                args = args.toWindowsCommand();</b>
&nbsp;            }
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                MavenConsoleAnnotator mca = new MavenConsoleAnnotator(listener.getLogger(), build.getCharset());</b>
<b class="nc">&nbsp;                int r = launcher.launch().cmds(args).envs(env).stdout(mca).pwd(build.getModuleRoot()).join();</b>
<b class="nc">&nbsp;                if (0 != r) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                Util.displayIOException(e, listener);</b>
<b class="nc">&nbsp;                Functions.printStackTrace(e, listener.fatalError(Messages.Maven_ExecFailed()));</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            startIndex = endIndex + 1;</b>
<b class="nc">&nbsp;        } while (startIndex &lt; targets.length());</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows the derived type to make additional modifications to the arguments list.
&nbsp;     *
&nbsp;     * @since 1.344
&nbsp;     */
&nbsp;    protected void wrapUpArguments(ArgumentListBuilder args, String normalizedTarget, AbstractBuild&lt;?, ?&gt; build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Build up the environment variables toward the Maven launch.
&nbsp;     */
&nbsp;    protected void buildEnvVars(EnvVars env, MavenInstallation mi) throws IOException, InterruptedException {
<b class="nc">&nbsp;        if (mi != null) {</b>
&nbsp;            // if somebody has use M2_HOME they will get a classloading error
&nbsp;            // when M2_HOME points to a different version of Maven2 from
&nbsp;            // MAVEN_HOME (as Maven 2 gives M2_HOME priority.)
&nbsp;            //
&nbsp;            // The other solution would be to set M2_HOME if we are calling Maven2
&nbsp;            // and MAVEN_HOME for Maven1 (only of use for strange people that
&nbsp;            // are calling Maven2 from Maven1)
<b class="nc">&nbsp;            mi.buildEnvVars(env);</b>
&nbsp;        }
&nbsp;        // just as a precaution
&nbsp;        // see http://maven.apache.org/continuum/faqs.html#how-does-continuum-detect-a-successful-build
<b class="nc">&nbsp;        env.put(&quot;MAVEN_TERMINATE_CMD&quot;, &quot;on&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        String jvmOptions = env.expand(this.jvmOptions);</b>
<b class="nc">&nbsp;        if (jvmOptions != null)</b>
<b class="nc">&nbsp;            env.put(&quot;MAVEN_OPTS&quot;, jvmOptions.replaceAll(&quot;[\t\r\n]+&quot;, &quot; &quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public DescriptorImpl getDescriptor() {
<b class="nc">&nbsp;        return (DescriptorImpl) super.getDescriptor();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.286
&nbsp;     *      Use {@link jenkins.model.Jenkins#getDescriptorByType(Class)} to obtain the current instance.
&nbsp;     *      For compatibility, this field retains the last created {@link DescriptorImpl}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static DescriptorImpl DESCRIPTOR;
&nbsp;
&nbsp;    @Extension @Symbol(&quot;maven&quot;)
&nbsp;    public static final class DescriptorImpl extends BuildStepDescriptor&lt;Builder&gt; implements PersistentDescriptor {
<b class="nc">&nbsp;        @CopyOnWrite</b>
&nbsp;        private volatile MavenInstallation[] installations = new MavenInstallation[0];
&nbsp;
&nbsp;        @SuppressFBWarnings(value = &quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot;, justification = &quot;for backward compatibility&quot;)
<b class="nc">&nbsp;        public DescriptorImpl() {</b>
<b class="nc">&nbsp;            DESCRIPTOR = this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isApplicable(Class&lt;? extends AbstractProject&gt; jobType) {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getHelpFile(String fieldName) {
<b class="nc">&nbsp;            if (fieldName != null &amp;&amp; fieldName.equals(&quot;globalSettings&quot;)) fieldName = &quot;settings&quot;; // same help file</b>
<b class="nc">&nbsp;            return super.getHelpFile(fieldName);</b>
&nbsp;        }
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.Maven_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        public GlobalSettingsProvider getDefaultGlobalSettingsProvider() {
<b class="nc">&nbsp;            return GlobalMavenConfig.get().getGlobalSettingsProvider();</b>
&nbsp;        }
&nbsp;
&nbsp;        public SettingsProvider getDefaultSettingsProvider() {
<b class="nc">&nbsp;            return GlobalMavenConfig.get().getSettingsProvider();</b>
&nbsp;        }
&nbsp;
&nbsp;        public MavenInstallation[] getInstallations() {
<b class="nc">&nbsp;            return installations;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setInstallations(MavenInstallation... installations) {
<b class="nc">&nbsp;            List&lt;MavenInstallation&gt; tmpList = new ArrayList&lt;&gt;();</b>
&nbsp;            // remote empty Maven installation :
<b class="nc">&nbsp;            if (installations != null) {</b>
<b class="nc">&nbsp;                Collections.addAll(tmpList, installations);</b>
<b class="nc">&nbsp;                for (MavenInstallation installation : installations) {</b>
<b class="nc">&nbsp;                    if (Util.fixEmptyAndTrim(installation.getName()) == null) {</b>
<b class="nc">&nbsp;                        tmpList.remove(installation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            this.installations = tmpList.toArray(new MavenInstallation[0]);</b>
<b class="nc">&nbsp;            save();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Builder newInstance(StaplerRequest req, JSONObject formData) throws FormException {
<b class="nc">&nbsp;            if (req == null) {</b>
&nbsp;                // This state is prohibited according to the Javadoc of the super method.
<b class="nc">&nbsp;                throw new FormException(&quot;Maven Build Step new instance method is called for null Stapler request. &quot;</b>
&nbsp;                        + &quot;Such call is prohibited.&quot;, &quot;req&quot;);
&nbsp;            }
<b class="nc">&nbsp;            return req.bindJSON(Maven.class, formData);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a Maven installation in a system.
&nbsp;     */
&nbsp;    public static final class MavenInstallation extends ToolInstallation implements EnvironmentSpecific&lt;MavenInstallation&gt;, NodeSpecific&lt;MavenInstallation&gt; {
&nbsp;        /**
&nbsp;         * Constants for describing Maven versions for comparison.
&nbsp;         */
&nbsp;        public static final int MAVEN_20 = 0;
&nbsp;        public static final int MAVEN_21 = 1;
&nbsp;        public static final int MAVEN_30 = 2;
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated since 2009-02-25.
&nbsp;         */
&nbsp;        @Deprecated // kept for backward compatibility - use getHome()
&nbsp;        private transient String mavenHome;
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated as of 1.308.
&nbsp;         *      Use {@link #MavenInstallation(String, String, List)}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public MavenInstallation(String name, String home) {
<b class="nc">&nbsp;            super(name, home);</b>
&nbsp;        }
&nbsp;
&nbsp;        @DataBoundConstructor
&nbsp;        public MavenInstallation(String name, String home, List&lt;? extends ToolProperty&lt;?&gt;&gt; properties) {
<b class="nc">&nbsp;            super(Util.fixEmptyAndTrim(name), Util.fixEmptyAndTrim(home), properties);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * install directory.
&nbsp;         *
&nbsp;         * @deprecated as of 1.308. Use {@link #getHome()}.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public String getMavenHome() {
<b class="nc">&nbsp;            return getHome();</b>
&nbsp;        }
&nbsp;
&nbsp;        public File getHomeDir() {
<b class="nc">&nbsp;            return new File(getHome());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void buildEnvVars(EnvVars env) {
<b class="nc">&nbsp;            String home = getHome();</b>
<b class="nc">&nbsp;            if (home == null) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            env.put(&quot;M2_HOME&quot;, home);</b>
<b class="nc">&nbsp;            env.put(&quot;MAVEN_HOME&quot;, home);</b>
<b class="nc">&nbsp;            env.put(&quot;PATH+MAVEN&quot;, home + &quot;/bin&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Compares the version of this Maven installation to the minimum required version specified.
&nbsp;         *
&nbsp;         * @param launcher
&nbsp;         *      Represents the node on which we evaluate the path.
&nbsp;         * @param mavenReqVersion
&nbsp;         *      Represents the minimum required Maven version - constants defined above.
&nbsp;         */
&nbsp;        public boolean meetsMavenReqVersion(Launcher launcher, int mavenReqVersion) throws IOException, InterruptedException {
&nbsp;            // FIXME using similar stuff as in the maven plugin could be better
&nbsp;            // olamy : but will add a dependency on maven in core -&gt; so not so good
<b class="nc">&nbsp;            String mavenVersion = launcher.getChannel().call(new GetMavenVersion(getHome()));</b>
&nbsp;
<b class="nc">&nbsp;            if (!mavenVersion.isEmpty()) {</b>
<b class="nc">&nbsp;                if (mavenReqVersion == MAVEN_20) {</b>
<b class="nc">&nbsp;                    if (mavenVersion.startsWith(&quot;2.&quot;))</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                else if (mavenReqVersion == MAVEN_21) {</b>
<b class="nc">&nbsp;                    if (mavenVersion.startsWith(&quot;2.&quot;) &amp;&amp; !mavenVersion.startsWith(&quot;2.0&quot;))</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                else if (mavenReqVersion == MAVEN_30) {</b>
<b class="nc">&nbsp;                    if (mavenVersion.startsWith(&quot;3.&quot;))</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        private static class GetMavenVersion extends MasterToSlaveCallable&lt;String, IOException&gt; {
&nbsp;            private final String home;
&nbsp;
<b class="nc">&nbsp;            GetMavenVersion(String home) {</b>
<b class="nc">&nbsp;                this.home = home;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String call() throws IOException {
<b class="nc">&nbsp;                File[] jars = new File(home, &quot;lib&quot;).listFiles();</b>
<b class="nc">&nbsp;                if (jars != null) { // be defensive</b>
<b class="nc">&nbsp;                    for (File jar : jars) {</b>
<b class="nc">&nbsp;                        if (jar.getName().startsWith(&quot;maven-&quot;)) {</b>
<b class="nc">&nbsp;                            try (JarFile jf = new JarFile(jar)) {</b>
<b class="nc">&nbsp;                                Manifest manifest = jf.getManifest();</b>
<b class="nc">&nbsp;                                String version = manifest.getMainAttributes().getValue(Attributes.Name.IMPLEMENTATION_VERSION);</b>
<b class="nc">&nbsp;                                if (version != null) {</b>
<b class="nc">&nbsp;                                    return version;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return &quot;&quot;;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Is this Maven 2.1.x or 2.2.x - but not Maven 3.x?
&nbsp;         *
&nbsp;         * @param launcher
&nbsp;         *      Represents the node on which we evaluate the path.
&nbsp;         */
&nbsp;        public boolean isMaven2_1(Launcher launcher) throws IOException, InterruptedException {
<b class="nc">&nbsp;            return meetsMavenReqVersion(launcher, MAVEN_21);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets the executable path of this maven on the given target system.
&nbsp;         */
&nbsp;        public String getExecutable(Launcher launcher) throws IOException, InterruptedException {
<b class="nc">&nbsp;            return launcher.getChannel().call(new GetExecutable(getHome()));</b>
&nbsp;        }
&nbsp;
&nbsp;        private static class GetExecutable extends MasterToSlaveCallable&lt;String, IOException&gt; {
&nbsp;            private final String rawHome;
&nbsp;
<b class="nc">&nbsp;            GetExecutable(String rawHome) {</b>
<b class="nc">&nbsp;                this.rawHome = rawHome;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String call() throws IOException {
<b class="nc">&nbsp;                File exe = getExeFile(&quot;mvn&quot;, rawHome);</b>
<b class="nc">&nbsp;                if (exe.exists()) {</b>
<b class="nc">&nbsp;                    return exe.getPath();</b>
&nbsp;                }
<b class="nc">&nbsp;                exe = getExeFile(&quot;maven&quot;, rawHome);</b>
<b class="nc">&nbsp;                if (exe.exists()) {</b>
<b class="nc">&nbsp;                    return exe.getPath();</b>
&nbsp;                }
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static File getExeFile(String execName, String home) {
<b class="nc">&nbsp;            String m2Home = Util.replaceMacro(home, EnvVars.masterEnvVars);</b>
&nbsp;
<b class="nc">&nbsp;            if (Functions.isWindows()) {</b>
<b class="nc">&nbsp;                File exeFile = new File(m2Home, &quot;bin/&quot; + execName + &quot;.bat&quot;);</b>
&nbsp;
&nbsp;                // since Maven 3.3 .bat files are replaced with .cmd
<b class="nc">&nbsp;                if (!exeFile.exists()) {</b>
<b class="nc">&nbsp;                    return new File(m2Home, &quot;bin/&quot; + execName + &quot;.cmd&quot;);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return exeFile;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return new File(m2Home, &quot;bin/&quot; + execName);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if the executable exists.
&nbsp;         */
&nbsp;        public boolean getExists() {
&nbsp;            try {
<b class="nc">&nbsp;                return getExecutable(new LocalLauncher(new StreamTaskListener(OutputStream.nullOutputStream()))) != null;</b>
<b class="nc">&nbsp;            } catch (IOException | InterruptedException e) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        @Override
&nbsp;        public MavenInstallation forEnvironment(EnvVars environment) {
<b class="nc">&nbsp;            return new MavenInstallation(getName(), environment.expand(getHome()), getProperties().toList());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MavenInstallation forNode(Node node, TaskListener log) throws IOException, InterruptedException {
<b class="nc">&nbsp;            return new MavenInstallation(getName(), translateFor(node, log), getProperties().toList());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Extension @Symbol(&quot;maven&quot;)
<b class="nc">&nbsp;        public static class DescriptorImpl extends ToolDescriptor&lt;MavenInstallation&gt; {</b>
&nbsp;            @NonNull
&nbsp;            @Override
&nbsp;            public String getDisplayName() {
<b class="nc">&nbsp;                return &quot;Maven&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public List&lt;? extends ToolInstaller&gt; getDefaultInstallers() {
<b class="nc">&nbsp;                return List.of(new MavenInstaller(null));</b>
&nbsp;            }
&nbsp;
&nbsp;            // overriding them for backward compatibility.
&nbsp;            // newer code need not do this
&nbsp;            @Override
&nbsp;            public MavenInstallation[] getInstallations() {
<b class="nc">&nbsp;                return Jenkins.get().getDescriptorByType(Maven.DescriptorImpl.class).getInstallations();</b>
&nbsp;            }
&nbsp;
&nbsp;            // overriding them for backward compatibility.
&nbsp;            // newer code need not do this
&nbsp;            @Override
&nbsp;            public void setInstallations(MavenInstallation... installations) {
<b class="nc">&nbsp;                Jenkins.get().getDescriptorByType(Maven.DescriptorImpl.class).setInstallations(installations);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the MAVEN_HOME is valid.
&nbsp;             */
&nbsp;            @Override protected FormValidation checkHomeDirectory(File value) {
<b class="nc">&nbsp;                File maven1File = new File(value, MAVEN_1_INSTALLATION_COMMON_FILE);</b>
<b class="nc">&nbsp;                File maven2File = new File(value, MAVEN_2_INSTALLATION_COMMON_FILE);</b>
&nbsp;
<b class="nc">&nbsp;                if (!maven1File.exists() &amp;&amp; !maven2File.exists())</b>
<b class="nc">&nbsp;                    return FormValidation.error(Messages.Maven_NotMavenDirectory(value));</b>
&nbsp;
<b class="nc">&nbsp;                return FormValidation.ok();</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        public static class ConverterImpl extends ToolConverter {
<b class="nc">&nbsp;            public ConverterImpl(XStream2 xstream) { super(xstream); }</b>
&nbsp;
&nbsp;            @Override protected String oldHomeField(ToolInstallation obj) {
<b class="nc">&nbsp;                return ((MavenInstallation) obj).mavenHome;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(final Object o) {
<b class="nc">&nbsp;            if (this == o) return true;</b>
<b class="nc">&nbsp;            if (o == null || getClass() != o.getClass()) return false;</b>
&nbsp;
<b class="nc">&nbsp;            final MavenInstallation that = (MavenInstallation) o;</b>
&nbsp;
<b class="nc">&nbsp;            if (getHome() != null ? !getHome().equals(that.getHome()) : that.getHome() != null) return false;</b>
<b class="nc">&nbsp;            if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) return false;</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = getHome() != null ? getHome().hashCode() : 0;</b>
<b class="nc">&nbsp;            result = 31 * result + (getName() != null ? getName().hashCode() : 0);</b>
&nbsp;            //result = 31 * result + (getProperties() != null ? getProperties().hashCode() : 0);
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Automatic Maven installer from apache.org.
&nbsp;     */
&nbsp;    public static class MavenInstaller extends DownloadFromUrlInstaller {
&nbsp;        @DataBoundConstructor
&nbsp;        public MavenInstaller(String id) {
<b class="nc">&nbsp;            super(id);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Extension @Symbol(&quot;maven&quot;)
<b class="fc">&nbsp;        public static final class DescriptorImpl extends DownloadFromUrlInstaller.DescriptorImpl&lt;MavenInstaller&gt; {</b>
&nbsp;            @NonNull
&nbsp;            @Override
&nbsp;            public String getDisplayName() {
<b class="nc">&nbsp;                return Messages.InstallFromApache();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isApplicable(Class&lt;? extends ToolInstallation&gt; toolType) {
<b class="nc">&nbsp;                return toolType == MavenInstallation.class;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Optional interface that can be implemented by {@link AbstractProject}
&nbsp;     * that has &quot;contextual&quot; {@link MavenInstallation} associated with it.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Code like RedeployPublisher uses this interface in an attempt
&nbsp;     * to use the consistent Maven installation attached to the project.
&nbsp;     *
&nbsp;     * @since 1.235
&nbsp;     */
&nbsp;    public interface ProjectWithMaven {
&nbsp;        /**
&nbsp;         * Gets the {@link MavenInstallation} associated with the project.
&nbsp;         * Can be null.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * If the Maven installation can not be uniquely determined,
&nbsp;         * it&#39;s often better to return just one of them, rather than returning
&nbsp;         * null, since this method is currently ultimately only used to
&nbsp;         * decide where to parse {@code conf/settings.xml} from.
&nbsp;         */
&nbsp;        MavenInstallation inferMavenInstallation();
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
