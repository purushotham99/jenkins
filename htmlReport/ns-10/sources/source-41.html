


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Job</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: Job (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Job</td>
<td class="coverageStat">
  <span class="percent">
    2.3%
  </span>
  <span class="absValue">
    (2/86)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    2%
  </span>
  <span class="absValue">
    (8/395)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Job$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$1FeedItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$2</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (1/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$ChartLabel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$ChartLabelStackedAreaRenderer2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$LastItemListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Job$MockitoMock$78MgA11h</td>
  </tr>
  <tr>
    <td class="name">Job$MockitoMock$78MgA11h$auxiliary$0CtOPVq9</td>
  </tr>
  <tr>
    <td class="name">Job$MockitoMock$78MgA11h$auxiliary$suvqYv1n</td>
  </tr>
  <tr>
    <td class="name">Job$SubItemBuildsLocationImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    2.5%
  </span>
  <span class="absValue">
    (3/120)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.8%
  </span>
  <span class="absValue">
    (9/514)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Martin Eigenbrodt, Matthew R. Harrah, Red Hat, Inc., Stephen Connolly, Tom Huybrechts, CloudBees, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_NO_CONTENT;
&nbsp;
&nbsp;import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.EnvVars;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.FeedAdapter;
&nbsp;import hudson.PermalinkList;
&nbsp;import hudson.Util;
&nbsp;import hudson.cli.declarative.CLIResolver;
&nbsp;import hudson.model.Descriptor.FormException;
&nbsp;import hudson.model.Fingerprint.Range;
&nbsp;import hudson.model.Fingerprint.RangeSet;
&nbsp;import hudson.model.PermalinkProjectAction.Permalink;
&nbsp;import hudson.model.listeners.ItemListener;
&nbsp;import hudson.scm.ChangeLogSet;
&nbsp;import hudson.scm.SCM;
&nbsp;import hudson.search.QuickSilver;
&nbsp;import hudson.search.SearchIndex;
&nbsp;import hudson.search.SearchIndexBuilder;
&nbsp;import hudson.search.SearchItem;
&nbsp;import hudson.search.SearchItems;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.tasks.LogRotator;
&nbsp;import hudson.util.AlternativeUiTextProvider;
&nbsp;import hudson.util.ChartUtil;
&nbsp;import hudson.util.ColorPalette;
&nbsp;import hudson.util.CopyOnWriteList;
&nbsp;import hudson.util.DataSetBuilder;
&nbsp;import hudson.util.DescribableList;
&nbsp;import hudson.util.FormApply;
&nbsp;import hudson.util.Graph;
&nbsp;import hudson.util.ProcessTree;
&nbsp;import hudson.util.RunList;
&nbsp;import hudson.util.ShiftedCategoryAxis;
&nbsp;import hudson.util.StackedAreaRenderer2;
&nbsp;import hudson.util.TextFile;
&nbsp;import hudson.widgets.HistoryWidget;
&nbsp;import hudson.widgets.HistoryWidget.Adapter;
&nbsp;import hudson.widgets.Widget;
&nbsp;import java.awt.Color;
&nbsp;import java.awt.Paint;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.Files;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import javax.servlet.ServletException;
&nbsp;import jenkins.model.BuildDiscarder;
&nbsp;import jenkins.model.BuildDiscarderProperty;
&nbsp;import jenkins.model.DirectlyModifiableTopLevelItemGroup;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.JenkinsLocationConfiguration;
&nbsp;import jenkins.model.ModelObjectWithChildren;
&nbsp;import jenkins.model.PeepholePermalink;
&nbsp;import jenkins.model.ProjectNamingStrategy;
&nbsp;import jenkins.model.RunIdMigrator;
&nbsp;import jenkins.model.lazy.LazyBuildMixIn;
&nbsp;import jenkins.scm.RunWithSCM;
&nbsp;import jenkins.security.HexStringConfidentialKey;
&nbsp;import jenkins.triggers.SCMTriggerItem;
&nbsp;import jenkins.widgets.HasWidgets;
&nbsp;import net.sf.json.JSONException;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.io.FileUtils;
&nbsp;import org.jfree.chart.ChartFactory;
&nbsp;import org.jfree.chart.JFreeChart;
&nbsp;import org.jfree.chart.axis.CategoryAxis;
&nbsp;import org.jfree.chart.axis.CategoryLabelPositions;
&nbsp;import org.jfree.chart.axis.NumberAxis;
&nbsp;import org.jfree.chart.plot.CategoryPlot;
&nbsp;import org.jfree.chart.plot.PlotOrientation;
&nbsp;import org.jfree.chart.renderer.category.StackedAreaRenderer;
&nbsp;import org.jfree.data.category.CategoryDataset;
&nbsp;import org.jfree.ui.RectangleInsets;
&nbsp;import org.jvnet.localizer.Localizable;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.args4j.Argument;
&nbsp;import org.kohsuke.args4j.CmdLineException;
&nbsp;import org.kohsuke.stapler.StaplerOverridable;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.kohsuke.stapler.verb.POST;
&nbsp;
&nbsp;/**
&nbsp; * A job is an runnable entity under the monitoring of Hudson.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Every time it &quot;runs&quot;, it will be recorded as a {@link Run} object.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * To create a custom job type, extend {@link TopLevelItemDescriptor} and put {@link Extension} on it.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;public abstract class Job&lt;JobT extends Job&lt;JobT, RunT&gt;, RunT extends Run&lt;JobT, RunT&gt;&gt;
&nbsp;        extends AbstractItem implements ExtensionPoint, StaplerOverridable, ModelObjectWithChildren, HasWidgets {
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Job.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Next build number. Kept in a separate file because this is the only
&nbsp;     * information that gets updated often. This allows the rest of the
&nbsp;     * configuration to be in the VCS.
&nbsp;     * &lt;p&gt;
&nbsp;     * In 1.28 and earlier, this field was stored in the project configuration
&nbsp;     * file, so even though this is marked as transient, don&#39;t move it around.
&nbsp;     */
<b class="fc">&nbsp;    protected transient volatile int nextBuildNumber = 1;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Newly copied jobs get this flag set, so that Hudson doesn&#39;t try to run the job until its configuration
&nbsp;     * is saved once.
&nbsp;     */
&nbsp;    private transient volatile boolean holdOffBuildUntilSave;
&nbsp;
&nbsp;    /**
&nbsp;     * {@link ItemListener}s can, and do, modify the job with a corresponding save which will clear
&nbsp;     * {@link #holdOffBuildUntilSave} prematurely. The {@link LastItemListener} is responsible for
&nbsp;     * clearing this flag as the last item listener.
&nbsp;     */
&nbsp;    private transient volatile boolean holdOffBuildUntilUserSave;
&nbsp;
&nbsp;    /** @deprecated Replaced by {@link BuildDiscarderProperty} */
&nbsp;    @Deprecated
&nbsp;    private volatile BuildDiscarder logRotator;
&nbsp;
&nbsp;    /**
&nbsp;     * Not all plugins are good at calculating their health report quickly.
&nbsp;     * These fields are used to cache the health reports to speed up rendering
&nbsp;     * the main page.
&nbsp;     */
<b class="fc">&nbsp;    private transient Integer cachedBuildHealthReportsBuildNumber = null;</b>
<b class="fc">&nbsp;    private transient List&lt;HealthReport&gt; cachedBuildHealthReports = null;</b>
&nbsp;
&nbsp;    boolean keepDependencies;
&nbsp;
&nbsp;    /**
&nbsp;     * List of properties configured for this project.
&nbsp;     */
&nbsp;    // this should have been DescribableList but now it&#39;s too late
<b class="fc">&nbsp;    protected CopyOnWriteList&lt;JobProperty&lt;? super JobT&gt;&gt; properties = new CopyOnWriteList&lt;&gt;();</b>
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public transient RunIdMigrator runIdMigrator;
&nbsp;
&nbsp;    protected Job(ItemGroup parent, String name) {
<b class="fc">&nbsp;        super(parent, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public synchronized void save() throws IOException {
<b class="nc">&nbsp;        super.save();</b>
<b class="nc">&nbsp;        holdOffBuildUntilSave = holdOffBuildUntilUserSave;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public void onCreatedFromScratch() {
<b class="nc">&nbsp;        super.onCreatedFromScratch();</b>
<b class="nc">&nbsp;        runIdMigrator = new RunIdMigrator();</b>
<b class="nc">&nbsp;        runIdMigrator.created(getBuildDir());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onLoad(ItemGroup&lt;? extends Item&gt; parent, String name)
&nbsp;            throws IOException {
<b class="nc">&nbsp;        super.onLoad(parent, name);</b>
&nbsp;
<b class="nc">&nbsp;        File buildDir = getBuildDir();</b>
<b class="nc">&nbsp;        runIdMigrator = new RunIdMigrator();</b>
<b class="nc">&nbsp;        runIdMigrator.migrate(buildDir, Jenkins.get().getRootDir());</b>
&nbsp;
<b class="nc">&nbsp;        TextFile f = getNextBuildNumberFile();</b>
<b class="nc">&nbsp;        if (f.exists()) {</b>
&nbsp;            // starting 1.28, we store nextBuildNumber in a separate file.
&nbsp;            // but old Hudson didn&#39;t do it, so if the file doesn&#39;t exist,
&nbsp;            // assume that nextBuildNumber was read from config.xml
&nbsp;            try {
<b class="nc">&nbsp;                synchronized (this) {</b>
<b class="nc">&nbsp;                    this.nextBuildNumber = Integer.parseInt(f.readTrim());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Corruption in {0}: {1}&quot;, new Object[] {f, e});</b>
&nbsp;                //noinspection StatementWithEmptyBody
<b class="nc">&nbsp;                if (this instanceof LazyBuildMixIn.LazyLoadingJob) {</b>
&nbsp;                    // allow LazyBuildMixIn.onLoad to fix it
&nbsp;                } else {
<b class="nc">&nbsp;                    RunT lB = getLastBuild();</b>
<b class="nc">&nbsp;                    synchronized (this) {</b>
<b class="nc">&nbsp;                        this.nextBuildNumber = lB != null ? lB.getNumber() + 1 : 1;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    saveNextBuildNumber();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
&nbsp;            // From the old Hudson, or doCreateItem. Create this file now.
<b class="nc">&nbsp;            saveNextBuildNumber();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (properties == null) // didn&#39;t exist &lt; 1.72</b>
<b class="nc">&nbsp;            properties = new CopyOnWriteList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (JobProperty p : properties)</b>
<b class="nc">&nbsp;            p.setOwner(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onCopiedFrom(Item src) {
<b class="nc">&nbsp;        super.onCopiedFrom(src);</b>
<b class="nc">&nbsp;        synchronized (this) {</b>
<b class="nc">&nbsp;            this.nextBuildNumber = 1; // reset the next build number</b>
<b class="nc">&nbsp;            this.holdOffBuildUntilUserSave = true;</b>
<b class="nc">&nbsp;            this.holdOffBuildUntilSave = this.holdOffBuildUntilUserSave;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Extension(ordinal = -Double.MAX_VALUE)
<b class="nc">&nbsp;    public static class LastItemListener extends ItemListener {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onCopied(Item src, Item item) {
&nbsp;            // If any of the other ItemListeners modify the job, they effect
&nbsp;            // a save, which will clear the holdOffBuildUntilUserSave and
&nbsp;            // causing a regression of JENKINS-2494
<b class="nc">&nbsp;            if (item instanceof Job) {</b>
<b class="nc">&nbsp;                Job job = (Job) item;</b>
<b class="nc">&nbsp;                synchronized (job) {</b>
<b class="nc">&nbsp;                    job.holdOffBuildUntilUserSave = false;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*package*/ TextFile getNextBuildNumberFile() {
<b class="nc">&nbsp;        return new TextFile(new File(this.getRootDir(), &quot;nextBuildNumber&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized boolean isHoldOffBuildUntilSave() {
<b class="nc">&nbsp;        return holdOffBuildUntilSave;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected synchronized void saveNextBuildNumber() throws IOException {
<b class="nc">&nbsp;        if (nextBuildNumber == 0) { // JENKINS-3361</b>
<b class="nc">&nbsp;            nextBuildNumber = 1;</b>
&nbsp;        }
<b class="nc">&nbsp;        getNextBuildNumberFile().write(String.valueOf(nextBuildNumber) + &#39;\n&#39;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    public boolean isInQueue() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this job is in the build queue, return its item.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public Queue.Item getQueueItem() {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if a build of this project is in progress.
&nbsp;     */
&nbsp;    public boolean isBuilding() {
<b class="nc">&nbsp;        RunT b = getLastBuild();</b>
<b class="nc">&nbsp;        return b != null &amp;&amp; b.isBuilding();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the log file is still being updated.
&nbsp;     */
&nbsp;    public boolean isLogUpdated() {
<b class="nc">&nbsp;        RunT b = getLastBuild();</b>
<b class="nc">&nbsp;        return b != null &amp;&amp; b.isLogUpdated();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getPronoun() {
<b class="nc">&nbsp;        return AlternativeUiTextProvider.get(PRONOUN, this, Messages.Job_Pronoun());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether the name of this job can be changed by user.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean isNameEditable() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If true, it will keep all the build logs of dependency components.
&nbsp;     * (This really only makes sense in {@link AbstractProject} but historically it was defined here.)
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isKeepDependencies() {
<b class="nc">&nbsp;        return keepDependencies;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allocates a new buildCommand number.
&nbsp;     */
&nbsp;    public synchronized int assignBuildNumber() throws IOException {
<b class="nc">&nbsp;        int r = nextBuildNumber++;</b>
<b class="nc">&nbsp;        saveNextBuildNumber();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Peeks the next build number.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public int getNextBuildNumber() {
<b class="nc">&nbsp;        return nextBuildNumber;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds up the environment variable map that&#39;s sufficient to identify a process
&nbsp;     * as ours. This is used to kill run-away processes via {@link ProcessTree#killAll(Map)}.
&nbsp;     */
&nbsp;    public EnvVars getCharacteristicEnvVars() {
<b class="nc">&nbsp;        EnvVars env = new EnvVars();</b>
<b class="nc">&nbsp;        env.put(&quot;JENKINS_SERVER_COOKIE&quot;, SERVER_COOKIE.get());</b>
<b class="nc">&nbsp;        env.put(&quot;HUDSON_SERVER_COOKIE&quot;, SERVER_COOKIE.get()); // Legacy compatibility</b>
<b class="nc">&nbsp;        env.put(&quot;JOB_NAME&quot;, getFullName());</b>
<b class="nc">&nbsp;        env.put(&quot;JOB_BASE_NAME&quot;, getName());</b>
<b class="nc">&nbsp;        return env;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an environment variable override for launching processes for this project.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is for process launching outside the build execution (such as polling, tagging, deployment, etc.)
&nbsp;     * that happens in a context of a specific job.
&nbsp;     *
&nbsp;     * @param node
&nbsp;     *      Node to eventually run a process on. The implementation must cope with this parameter being null
&nbsp;     *      (in which case none of the node specific properties would be reflected in the resulting override.)
&nbsp;     */
&nbsp;    public @NonNull EnvVars getEnvironment(@CheckForNull Node node, @NonNull TaskListener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        EnvVars env = new EnvVars();</b>
&nbsp;
<b class="nc">&nbsp;        if (node != null) {</b>
<b class="nc">&nbsp;            final Computer computer = node.toComputer();</b>
<b class="nc">&nbsp;            if (computer != null) {</b>
&nbsp;                // we need to get computer environment to inherit platform details
<b class="nc">&nbsp;                env = computer.getEnvironment();</b>
<b class="nc">&nbsp;                env.putAll(computer.buildEnvironment(listener));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        env.putAll(getCharacteristicEnvVars());</b>
&nbsp;
&nbsp;        // servlet container may have set CLASSPATH in its launch script,
&nbsp;        // so don&#39;t let that inherit to the new child process.
&nbsp;        // see http://www.nabble.com/Run-Job-with-JDK-1.4.2-tf4468601.html
<b class="nc">&nbsp;        env.put(&quot;CLASSPATH&quot;, &quot;&quot;);</b>
&nbsp;
&nbsp;        // apply them in a reverse order so that higher ordinal ones can modify values added by lower ordinal ones
<b class="nc">&nbsp;        for (EnvironmentContributor ec : EnvironmentContributor.all().reverseView())</b>
<b class="nc">&nbsp;            ec.buildEnvironmentFor(this, env, listener);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;        return env;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Programmatically updates the next build number.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Much of Hudson assumes that the build number is unique and monotonic, so
&nbsp;     * this method can only accept a new value that&#39;s bigger than
&nbsp;     * {@link #getLastBuild()} returns. Otherwise it&#39;ll be no-op.
&nbsp;     *
&nbsp;     * @since 1.199 (before that, this method was package private.)
&nbsp;     */
&nbsp;    public synchronized void updateNextBuildNumber(int next) throws IOException {
<b class="nc">&nbsp;        RunT lb = getLastBuild();</b>
<b class="nc">&nbsp;        if (lb != null ?  next &gt; lb.getNumber() : next &gt; 0) {</b>
<b class="nc">&nbsp;            this.nextBuildNumber = next;</b>
<b class="nc">&nbsp;            saveNextBuildNumber();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the configured build discarder for this job, via {@link BuildDiscarderProperty}, or null if none.
&nbsp;     */
&nbsp;    public synchronized BuildDiscarder getBuildDiscarder() {
<b class="nc">&nbsp;        BuildDiscarderProperty prop = _getProperty(BuildDiscarderProperty.class);</b>
<b class="nc">&nbsp;        return prop != null ? prop.getStrategy() : /* settings compatibility */ logRotator;</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void setBuildDiscarder(BuildDiscarder bd) throws IOException {
<b class="nc">&nbsp;        try (BulkChange bc = new BulkChange(this)) {</b>
<b class="nc">&nbsp;            removeProperty(BuildDiscarderProperty.class);</b>
<b class="nc">&nbsp;            if (bd != null) {</b>
<b class="nc">&nbsp;                addProperty(new BuildDiscarderProperty(bd));</b>
&nbsp;            }
<b class="nc">&nbsp;            bc.commit();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Left for backward compatibility. Returns non-null if and only
&nbsp;     * if {@link LogRotator} is configured as {@link BuildDiscarder}.
&nbsp;     *
&nbsp;     * @deprecated as of 1.503
&nbsp;     *      Use {@link #getBuildDiscarder()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public LogRotator getLogRotator() {
<b class="nc">&nbsp;        BuildDiscarder buildDiscarder = getBuildDiscarder();</b>
<b class="nc">&nbsp;        return buildDiscarder instanceof LogRotator ? (LogRotator) buildDiscarder : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.503
&nbsp;     *      Use {@link #setBuildDiscarder(BuildDiscarder)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void setLogRotator(LogRotator logRotator) throws IOException {
<b class="nc">&nbsp;        setBuildDiscarder(logRotator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Perform log rotation.
&nbsp;     */
&nbsp;    public void logRotate() throws IOException, InterruptedException {
<b class="nc">&nbsp;        BuildDiscarder bd = getBuildDiscarder();</b>
<b class="nc">&nbsp;        if (bd != null)</b>
<b class="nc">&nbsp;            bd.perform(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * True if this instance supports log rotation configuration.
&nbsp;     */
&nbsp;    public boolean supportsLogRotator() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected SearchIndexBuilder makeSearchIndex() {
<b class="nc">&nbsp;        return super.makeSearchIndex().add(new SearchIndex() {</b>
&nbsp;            @Override
&nbsp;            public void find(String token, List&lt;SearchItem&gt; result) {
&nbsp;                try {
<b class="nc">&nbsp;                    if (token.startsWith(&quot;#&quot;))</b>
<b class="nc">&nbsp;                        token = token.substring(1); // ignore leading &#39;#&#39;</b>
<b class="nc">&nbsp;                    int n = Integer.parseInt(token);</b>
<b class="nc">&nbsp;                    Run b = getBuildByNumber(n);</b>
<b class="nc">&nbsp;                    if (b == null)</b>
&nbsp;                        return; // no such build
<b class="nc">&nbsp;                    result.add(SearchItems.create(&quot;#&quot; + n, &quot;&quot; + n, b));</b>
<b class="nc">&nbsp;                } catch (NumberFormatException e) {</b>
&nbsp;                    // not a number.
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void suggest(String token, List&lt;SearchItem&gt; result) {
<b class="nc">&nbsp;                find(token, result);</b>
&nbsp;            }
<b class="nc">&nbsp;        }).add(&quot;configure&quot;, &quot;config&quot;, &quot;configure&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Collection&lt;? extends Job&gt; getAllJobs() {
<b class="nc">&nbsp;        return Set.of(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds {@link JobProperty}.
&nbsp;     *
&nbsp;     * @since 1.188
&nbsp;     */
&nbsp;    public void addProperty(JobProperty&lt;? super JobT&gt; jobProp) throws IOException {
<b class="nc">&nbsp;        ((JobProperty) jobProp).setOwner(this);</b>
<b class="nc">&nbsp;        properties.add(jobProp);</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes {@link JobProperty}
&nbsp;     *
&nbsp;     * @since 1.279
&nbsp;     */
&nbsp;    public void removeProperty(JobProperty&lt;? super JobT&gt; jobProp) throws IOException {
<b class="nc">&nbsp;        properties.remove(jobProp);</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes the property of the given type.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      The property that was just removed.
&nbsp;     * @since 1.279
&nbsp;     */
&nbsp;    public &lt;T extends JobProperty&gt; T removeProperty(Class&lt;T&gt; clazz) throws IOException {
<b class="nc">&nbsp;        for (JobProperty&lt;? super JobT&gt; p : properties) {</b>
<b class="nc">&nbsp;            if (clazz.isInstance(p)) {</b>
<b class="nc">&nbsp;                removeProperty(p);</b>
<b class="nc">&nbsp;                return clazz.cast(p);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the job properties configured for this job.
&nbsp;     */
&nbsp;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;    public Map&lt;JobPropertyDescriptor, JobProperty&lt;? super JobT&gt;&gt; getProperties() {
<b class="nc">&nbsp;        Map result = Descriptor.toMap((Iterable) properties);</b>
<b class="nc">&nbsp;        if (logRotator != null) {</b>
<b class="nc">&nbsp;            result.put(Jenkins.get().getDescriptorByType(BuildDiscarderProperty.DescriptorImpl.class), new BuildDiscarderProperty(logRotator));</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List of all {@link JobProperty} exposed primarily for the remoting API.
&nbsp;     * @since 1.282
&nbsp;     */
&nbsp;    @Exported(name = &quot;property&quot;, inline = true)
&nbsp;    public List&lt;JobProperty&lt;? super JobT&gt;&gt; getAllProperties() {
<b class="nc">&nbsp;        return properties.getView();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the specific property, or null if the property is not configured for
&nbsp;     * this job.
&nbsp;     */
&nbsp;    public &lt;T extends JobProperty&gt; T getProperty(Class&lt;T&gt; clazz) {
<b class="nc">&nbsp;        if (clazz == BuildDiscarderProperty.class &amp;&amp; logRotator != null) {</b>
<b class="nc">&nbsp;            return clazz.cast(new BuildDiscarderProperty(logRotator));</b>
&nbsp;        }
<b class="nc">&nbsp;        return _getProperty(clazz);</b>
&nbsp;    }
&nbsp;
&nbsp;    private &lt;T extends JobProperty&gt; T _getProperty(Class&lt;T&gt; clazz) {
<b class="nc">&nbsp;        for (JobProperty p : properties) {</b>
<b class="nc">&nbsp;            if (clazz.isInstance(p))</b>
<b class="nc">&nbsp;                return clazz.cast(p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Bind {@link JobProperty}s to URL spaces.
&nbsp;     *
&nbsp;     * @since 1.403
&nbsp;     */
&nbsp;    public JobProperty getProperty(String className) {
<b class="nc">&nbsp;        for (JobProperty p : properties)</b>
<b class="nc">&nbsp;            if (p.getClass().getName().equals(className))</b>
<b class="nc">&nbsp;                return p;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Overrides from job properties.
&nbsp;     * @see JobProperty#getJobOverrides
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Collection&lt;?&gt; getOverrides() {
<b class="nc">&nbsp;        List&lt;Object&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (JobProperty&lt;? super JobT&gt; p : properties)</b>
<b class="nc">&nbsp;            r.addAll(p.getJobOverrides());</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated see {@link LazyBuildMixIn#createHistoryWidget()}
&nbsp;     */
&nbsp;    @Deprecated(forRemoval = true, since = &quot;2.410&quot;)
&nbsp;    protected HistoryWidget createHistoryWidget() {
<b class="nc">&nbsp;        return new HistoryWidget&lt;Job, RunT&gt;(this, getBuilds(), HISTORY_ADAPTER);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static final HistoryWidget.Adapter&lt;Run&gt; HISTORY_ADAPTER = new Adapter&lt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public int compare(Run record, String key) {
&nbsp;            try {
<b class="nc">&nbsp;                int k = Integer.parseInt(key);</b>
<b class="nc">&nbsp;                return record.getNumber() - k;</b>
<b class="nc">&nbsp;            } catch (NumberFormatException nfe) {</b>
<b class="nc">&nbsp;                return String.valueOf(record.getNumber()).compareTo(key);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getKey(Run record) {
<b class="nc">&nbsp;            return String.valueOf(record.getNumber());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isBuilding(Run record) {
<b class="nc">&nbsp;            return record.isBuilding();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getNextKey(String key) {
&nbsp;            try {
<b class="nc">&nbsp;                int k = Integer.parseInt(key);</b>
<b class="nc">&nbsp;                return String.valueOf(k + 1);</b>
<b class="nc">&nbsp;            } catch (NumberFormatException nfe) {</b>
<b class="nc">&nbsp;                return &quot;-unable to determine next key-&quot;;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * Renames a job.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void renameTo(String newName) throws IOException {
<b class="nc">&nbsp;        File oldBuildDir = getBuildDir();</b>
<b class="nc">&nbsp;        super.renameTo(newName);</b>
<b class="nc">&nbsp;        File newBuildDir = getBuildDir();</b>
<b class="nc">&nbsp;        if (Files.isDirectory(Util.fileToPath(oldBuildDir)) &amp;&amp; !Files.isDirectory(Util.fileToPath(newBuildDir))) {</b>
<b class="nc">&nbsp;            Util.createDirectories(Util.fileToPath(newBuildDir.getParentFile()));</b>
<b class="nc">&nbsp;            Files.move(Util.fileToPath(oldBuildDir), Util.fileToPath(newBuildDir));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void movedTo(DirectlyModifiableTopLevelItemGroup destination, AbstractItem newItem, File destDir) throws IOException {
<b class="nc">&nbsp;        File oldBuildDir = getBuildDir();</b>
<b class="nc">&nbsp;        super.movedTo(destination, newItem, destDir);</b>
<b class="nc">&nbsp;        File newBuildDir = getBuildDir();</b>
<b class="nc">&nbsp;        if (oldBuildDir.isDirectory()) {</b>
<b class="nc">&nbsp;            FileUtils.moveDirectory(oldBuildDir, newBuildDir);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override public void delete() throws IOException, InterruptedException {
<b class="nc">&nbsp;        super.delete();</b>
<b class="nc">&nbsp;        Util.deleteRecursive(getBuildDir());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @Extension
<b class="nc">&nbsp;    public static class SubItemBuildsLocationImpl extends ItemListener {</b>
&nbsp;        @Override
&nbsp;        public void onLocationChanged(Item item, String oldFullName, String newFullName) {
<b class="nc">&nbsp;            final Jenkins jenkins = Jenkins.get();</b>
<b class="nc">&nbsp;            if (!jenkins.isDefaultBuildDir() &amp;&amp; item instanceof Job) {</b>
<b class="nc">&nbsp;                File newBuildDir = ((Job) item).getBuildDir();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (!Util.isDescendant(item.getRootDir(), newBuildDir)) {</b>
&nbsp;                        //OK builds are stored somewhere outside of the item&#39;s root, so none of the other move operations has probably moved it.
&nbsp;                        //So let&#39;s try even though we lack some information
<b class="nc">&nbsp;                        String oldBuildsDir = Jenkins.expandVariablesForDirectory(jenkins.getRawBuildsDir(), oldFullName, &quot;&lt;NOPE&gt;&quot;);</b>
<b class="nc">&nbsp;                        if (oldBuildsDir.contains(&quot;&lt;NOPE&gt;&quot;)) {</b>
<b class="nc">&nbsp;                            LOGGER.severe(String.format(&quot;Builds directory for job %1$s appears to be outside of item root,&quot; +</b>
&nbsp;                                    &quot; but somehow still containing the item root path, which is unknown. Cannot move builds from %2$s to %1$s.&quot;, newFullName, oldFullName));
&nbsp;                        } else {
<b class="nc">&nbsp;                            File oldDir = new File(oldBuildsDir);</b>
<b class="nc">&nbsp;                            if (oldDir.isDirectory()) {</b>
&nbsp;                                try {
<b class="nc">&nbsp;                                    FileUtils.moveDirectory(oldDir, newBuildDir);</b>
<b class="nc">&nbsp;                                } catch (IOException e) {</b>
<b class="nc">&nbsp;                                    LOGGER.log(Level.SEVERE, String.format(&quot;Failed to move %s to %s&quot;, oldBuildsDir, newBuildDir.getAbsolutePath()), e);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IOException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to inspect &quot; + item.getRootDir() + &quot;. Builds might not be moved.&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if we should display &quot;build now&quot; icon
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public abstract boolean isBuildable();
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the read-only view of all the builds.
&nbsp;     *
&nbsp;     * @return never null. The first entry is the latest build.
&nbsp;     */
&nbsp;    @Exported(name = &quot;allBuilds&quot;, visibility = -2)
&nbsp;    @WithBridgeMethods(List.class)
&nbsp;    public RunList&lt;RunT&gt; getBuilds() {
<b class="nc">&nbsp;        return RunList.fromRuns(_getRuns().values());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the read-only view of the recent builds.
&nbsp;     *
&nbsp;     * @since 1.485
&nbsp;     */
&nbsp;    @Exported(name = &quot;builds&quot;)
&nbsp;    public RunList&lt;RunT&gt; getNewBuilds() {
<b class="nc">&nbsp;        return getBuilds().limit(100);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains all the {@link Run}s whose build numbers matches the given {@link RangeSet}.
&nbsp;     */
&nbsp;    public synchronized List&lt;RunT&gt; getBuilds(RangeSet rs) {
<b class="nc">&nbsp;        List&lt;RunT&gt; builds = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Range r : rs.getRanges()) {</b>
<b class="nc">&nbsp;            for (RunT b = getNearestBuild(r.start); b != null &amp;&amp; b.getNumber() &lt; r.end; b = b.getNextBuild()) {</b>
<b class="nc">&nbsp;                builds.add(b);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return builds;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the builds in a map.
&nbsp;     */
&nbsp;    public SortedMap&lt;Integer, RunT&gt; getBuildsAsMap() {
<b class="nc">&nbsp;        return Collections.unmodifiableSortedMap(_getRuns());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Looks up a build by its ID.
&nbsp;     * @see LazyBuildMixIn#getBuild
&nbsp;     */
&nbsp;    public RunT getBuild(String id) {
<b class="nc">&nbsp;        for (RunT r : _getRuns().values()) {</b>
<b class="nc">&nbsp;            if (r.getId().equals(id))</b>
<b class="nc">&nbsp;                return r;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param n
&nbsp;     *            The build number.
&nbsp;     * @return null if no such build exists.
&nbsp;     * @see Run#getNumber()
&nbsp;     * @see LazyBuildMixIn#getBuildByNumber
&nbsp;     */
&nbsp;    public RunT getBuildByNumber(int n) {
<b class="nc">&nbsp;        return _getRuns().get(n);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains a list of builds, in the descending order, that are within the specified time range [start,end).
&nbsp;     *
&nbsp;     * @return can be empty but never null.
&nbsp;     * @deprecated
&nbsp;     *      as of 1.372. Should just do {@code getBuilds().byTimestamp(s,e)} to avoid code bloat in {@link Job}.
&nbsp;     */
&nbsp;    @WithBridgeMethods(List.class)
&nbsp;    @Deprecated
&nbsp;    public RunList&lt;RunT&gt; getBuildsByTimestamp(long start, long end) {
<b class="nc">&nbsp;        return getBuilds().byTimestamp(start, end);</b>
&nbsp;    }
&nbsp;
&nbsp;    @CLIResolver
&nbsp;    public RunT getBuildForCLI(@Argument(required = true, metaVar = &quot;BUILD#&quot;, usage = &quot;Build number&quot;) String id) throws CmdLineException {
&nbsp;        try {
<b class="nc">&nbsp;            int n = Integer.parseInt(id);</b>
<b class="nc">&nbsp;            RunT r = getBuildByNumber(n);</b>
<b class="nc">&nbsp;            if (r == null)</b>
<b class="nc">&nbsp;                throw new CmdLineException(null, &quot;No such build &#39;#&quot; + n + &quot;&#39; exists&quot;);</b>
<b class="nc">&nbsp;            return r;</b>
<b class="nc">&nbsp;        } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;            throw new CmdLineException(null, id + &quot;is not a number&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the youngest build #m that satisfies {@code n&amp;lt;=m}.
&nbsp;     *
&nbsp;     * This is useful when you&#39;d like to fetch a build but the exact build might
&nbsp;     * be already gone (deleted, rotated, etc.)
&nbsp;     * @see LazyBuildMixIn#getNearestBuild
&nbsp;     */
&nbsp;    public RunT getNearestBuild(int n) {
<b class="nc">&nbsp;        SortedMap&lt;Integer, ? extends RunT&gt; m = _getRuns().headMap(n - 1); // the map should</b>
&nbsp;                                                                          // include n, so n-1
<b class="nc">&nbsp;        if (m.isEmpty())</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        return m.get(m.lastKey());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the latest build #m that satisfies {@code m&amp;lt;=n}.
&nbsp;     *
&nbsp;     * This is useful when you&#39;d like to fetch a build but the exact build might
&nbsp;     * be already gone (deleted, rotated, etc.)
&nbsp;     * @see LazyBuildMixIn#getNearestOldBuild
&nbsp;     */
&nbsp;    public RunT getNearestOldBuild(int n) {
<b class="nc">&nbsp;        SortedMap&lt;Integer, ? extends RunT&gt; m = _getRuns().tailMap(n);</b>
<b class="nc">&nbsp;        if (m.isEmpty())</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        return m.get(m.firstKey());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object getDynamic(String token, StaplerRequest req,
&nbsp;            StaplerResponse rsp) {
&nbsp;        try {
&nbsp;            // try to interpret the token as build number
<b class="nc">&nbsp;            return getBuildByNumber(Integer.parseInt(token));</b>
<b class="nc">&nbsp;        } catch (NumberFormatException e) {</b>
&nbsp;            // try to map that to widgets
<b class="nc">&nbsp;            for (Widget w : getWidgets()) {</b>
<b class="nc">&nbsp;                if (w.getUrlName().equals(token))</b>
<b class="nc">&nbsp;                    return w;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // is this a permalink?
<b class="nc">&nbsp;            for (Permalink p : getPermalinks()) {</b>
<b class="nc">&nbsp;                if (p.getId().equals(token))</b>
<b class="nc">&nbsp;                    return p.resolve(this);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return super.getDynamic(token, req, rsp);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Directory for storing {@link Run} records.
&nbsp;     * &lt;p&gt;
&nbsp;     * Some {@link Job}s may not have backing data store for {@link Run}s, but
&nbsp;     * those {@link Job}s that use file system for storing data should use this
&nbsp;     * directory for consistency.
&nbsp;     *
&nbsp;     * @see RunMap
&nbsp;     */
&nbsp;    public File getBuildDir() {
&nbsp;        // we use the null check variant so that people can write true unit tests with a mock ItemParent
&nbsp;        // and without a JenkinsRule. Such tests are of limited utility as there is a high risk of hitting
&nbsp;        // some code that needs the singleton, but for persistence migration test cases it makes sense to permit
<b class="nc">&nbsp;        Jenkins j = Jenkins.getInstanceOrNull();</b>
<b class="nc">&nbsp;        if (j == null) {</b>
<b class="nc">&nbsp;            return new File(getRootDir(), &quot;builds&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return j.getBuildDirFor(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the runs.
&nbsp;     *
&nbsp;     * The resulting map must be treated immutable (by employing copy-on-write
&nbsp;     * semantics.) The map is descending order, with newest builds at the top.
&nbsp;     * @see LazyBuildMixIn#_getRuns
&nbsp;     */
&nbsp;    protected abstract SortedMap&lt;Integer, ? extends RunT&gt; _getRuns();
&nbsp;
&nbsp;    /**
&nbsp;     * Called from {@link Run} to remove it from this job.
&nbsp;     *
&nbsp;     * The files are deleted already. So all the callee needs to do is to remove
&nbsp;     * a reference from this {@link Job}.
&nbsp;     * @see LazyBuildMixIn#removeRun
&nbsp;     */
&nbsp;    protected abstract void removeRun(RunT run);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last build.
&nbsp;     * @see LazyBuildMixIn#getLastBuild
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastBuild() {
<b class="nc">&nbsp;        SortedMap&lt;Integer, ? extends RunT&gt; runs = _getRuns();</b>
&nbsp;
<b class="nc">&nbsp;        if (runs.isEmpty())</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        return runs.get(runs.firstKey());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the oldest build in the record.
&nbsp;     * @see LazyBuildMixIn#getFirstBuild
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getFirstBuild() {
<b class="nc">&nbsp;        SortedMap&lt;Integer, ? extends RunT&gt; runs = _getRuns();</b>
&nbsp;
<b class="nc">&nbsp;        if (runs.isEmpty())</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        return runs.get(runs.lastKey());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last successful build, if any. Otherwise null. A successful build
&nbsp;     * would include either {@link Result#SUCCESS} or {@link Result#UNSTABLE}.
&nbsp;     *
&nbsp;     * @see #getLastStableBuild()
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastSuccessfulBuild() {
<b class="nc">&nbsp;        return (RunT) PeepholePermalink.LAST_SUCCESSFUL_BUILD.resolve(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last build that was anything but stable, if any. Otherwise null.
&nbsp;     * @see #getLastSuccessfulBuild
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastUnsuccessfulBuild() {
<b class="nc">&nbsp;        return (RunT) PeepholePermalink.LAST_UNSUCCESSFUL_BUILD.resolve(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last unstable build, if any. Otherwise null.
&nbsp;     * @see #getLastSuccessfulBuild
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastUnstableBuild() {
<b class="nc">&nbsp;        return (RunT) PeepholePermalink.LAST_UNSTABLE_BUILD.resolve(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last stable build, if any. Otherwise null.
&nbsp;     * @see #getLastSuccessfulBuild
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastStableBuild() {
<b class="nc">&nbsp;        return (RunT) PeepholePermalink.LAST_STABLE_BUILD.resolve(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last failed build, if any. Otherwise null.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastFailedBuild() {
<b class="nc">&nbsp;        return (RunT) PeepholePermalink.LAST_FAILED_BUILD.resolve(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last completed build, if any. Otherwise null.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @QuickSilver
&nbsp;    public RunT getLastCompletedBuild() {
<b class="nc">&nbsp;        return (RunT) PeepholePermalink.LAST_COMPLETED_BUILD.resolve(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last {@code numberOfBuilds} builds with a build result ? {@code threshold}
&nbsp;     *
&nbsp;     * @return a list with the builds. May be smaller than &#39;numberOfBuilds&#39; or even empty
&nbsp;     *   if not enough builds satisfying the threshold have been found. Never null.
&nbsp;     */
&nbsp;    public List&lt;RunT&gt; getLastBuildsOverThreshold(int numberOfBuilds, Result threshold) {
<b class="nc">&nbsp;        RunT r = getLastBuild();</b>
<b class="nc">&nbsp;        return r.getBuildsOverThreshold(numberOfBuilds, threshold);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns candidate build for calculating the estimated duration of the current run.
&nbsp;     *
&nbsp;     * Returns the 3 last successful (stable or unstable) builds, if there are any.
&nbsp;     * Failing to find 3 of those, it will return up to 3 last unsuccessful builds.
&nbsp;     *
&nbsp;     * In any case it will not go more than 6 builds into the past to avoid costly build loading.
&nbsp;     * @see LazyBuildMixIn#getEstimatedDurationCandidates
&nbsp;     */
&nbsp;    protected List&lt;RunT&gt; getEstimatedDurationCandidates() {
<b class="nc">&nbsp;        List&lt;RunT&gt; candidates = new ArrayList&lt;&gt;(3);</b>
<b class="nc">&nbsp;        RunT lastSuccessful = getLastSuccessfulBuild();</b>
<b class="nc">&nbsp;        int lastSuccessfulNumber = -1;</b>
<b class="nc">&nbsp;        if (lastSuccessful != null) {</b>
<b class="nc">&nbsp;            candidates.add(lastSuccessful);</b>
<b class="nc">&nbsp;            lastSuccessfulNumber = lastSuccessful.getNumber();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int i = 0;</b>
<b class="nc">&nbsp;        RunT r = getLastBuild();</b>
<b class="nc">&nbsp;        List&lt;RunT&gt; fallbackCandidates = new ArrayList&lt;&gt;(3);</b>
<b class="nc">&nbsp;        while (r != null &amp;&amp; candidates.size() &lt; 3 &amp;&amp; i &lt; 6) {</b>
<b class="nc">&nbsp;            if (!r.isBuilding() &amp;&amp; r.getResult() != null &amp;&amp; r.getNumber() != lastSuccessfulNumber) {</b>
<b class="nc">&nbsp;                Result result = r.getResult();</b>
<b class="nc">&nbsp;                if (result.isBetterOrEqualTo(Result.UNSTABLE)) {</b>
<b class="nc">&nbsp;                    candidates.add(r);</b>
<b class="nc">&nbsp;                } else if (result.isCompleteBuild()) {</b>
<b class="nc">&nbsp;                    fallbackCandidates.add(r);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            i++;</b>
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        while (candidates.size() &lt; 3) {</b>
<b class="nc">&nbsp;            if (fallbackCandidates.isEmpty())</b>
<b class="nc">&nbsp;                break;</b>
<b class="nc">&nbsp;            RunT run = fallbackCandidates.remove(0);</b>
<b class="nc">&nbsp;            candidates.add(run);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return candidates;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long getEstimatedDuration() {
<b class="nc">&nbsp;        List&lt;RunT&gt; builds = getEstimatedDurationCandidates();</b>
&nbsp;
<b class="nc">&nbsp;        if (builds.isEmpty())     return -1;</b>
&nbsp;
<b class="nc">&nbsp;        long totalDuration = 0;</b>
<b class="nc">&nbsp;        for (RunT b : builds) {</b>
<b class="nc">&nbsp;            totalDuration += b.getDuration();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (totalDuration == 0) return -1;</b>
&nbsp;
<b class="nc">&nbsp;        return Math.round((double) totalDuration / builds.size());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the {@link Permalink}s defined for this job.
&nbsp;     *
&nbsp;     * @return never null
&nbsp;     */
&nbsp;    public PermalinkList getPermalinks() {
<b class="nc">&nbsp;        PeepholePermalink.initialized();</b>
&nbsp;        // TODO: shall we cache this?
<b class="nc">&nbsp;        PermalinkList permalinks = new PermalinkList(Permalink.BUILTIN);</b>
<b class="nc">&nbsp;        for (PermalinkProjectAction ppa : getActions(PermalinkProjectAction.class)) {</b>
<b class="nc">&nbsp;            permalinks.addAll(ppa.getPermalinks());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return permalinks;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * RSS feed for changes in this project.
&nbsp;     *
&nbsp;     * @since 2.60
&nbsp;     */
&nbsp;    public void doRssChangelog(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
&nbsp;        class FeedItem {
&nbsp;            ChangeLogSet.Entry e;
&nbsp;            int idx;
&nbsp;
<b class="nc">&nbsp;            FeedItem(ChangeLogSet.Entry e, int idx) {</b>
<b class="nc">&nbsp;                this.e = e;</b>
<b class="nc">&nbsp;                this.idx = idx;</b>
&nbsp;            }
&nbsp;
&nbsp;            Run&lt;?, ?&gt; getBuild() {
<b class="nc">&nbsp;                return e.getParent().build;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;FeedItem&gt; entries = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        String scmDisplayName = &quot;&quot;;</b>
<b class="nc">&nbsp;        if (this instanceof SCMTriggerItem) {</b>
<b class="nc">&nbsp;            SCMTriggerItem scmItem = (SCMTriggerItem) this;</b>
<b class="nc">&nbsp;            List&lt;String&gt; scmNames = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (SCM s : scmItem.getSCMs()) {</b>
<b class="nc">&nbsp;                scmNames.add(s.getDescriptor().getDisplayName());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            scmDisplayName = &quot; &quot; + String.join(&quot;, &quot;, scmNames);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (RunT r = getLastBuild(); r != null; r = r.getPreviousBuild()) {</b>
<b class="nc">&nbsp;            int idx = 0;</b>
<b class="nc">&nbsp;            if (r instanceof RunWithSCM) {</b>
<b class="nc">&nbsp;                for (ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt; c : ((RunWithSCM&lt;?, ?&gt;) r).getChangeSets()) {</b>
<b class="nc">&nbsp;                    for (ChangeLogSet.Entry e : c) {</b>
<b class="nc">&nbsp;                        entries.add(new FeedItem(e, idx++));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        RSS.forwardToRss(</b>
<b class="nc">&nbsp;                getDisplayName() + scmDisplayName + &quot; changes&quot;,</b>
<b class="nc">&nbsp;                getUrl() + &quot;changes&quot;,</b>
<b class="nc">&nbsp;                entries, new FeedAdapter&lt;&gt;() {</b>
&nbsp;                    @Override
&nbsp;                    public String getEntryTitle(FeedItem item) {
<b class="nc">&nbsp;                        return &quot;#&quot; + item.getBuild().number + &#39; &#39; + item.e.getMsg() + &quot; (&quot; + item.e.getAuthor() + &quot;)&quot;;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getEntryUrl(FeedItem item) {
<b class="nc">&nbsp;                        return item.getBuild().getUrl() + &quot;changes#detail&quot; + item.idx;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getEntryID(FeedItem item) {
<b class="nc">&nbsp;                            return getEntryUrl(item);</b>
&nbsp;                        }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getEntryDescription(FeedItem item) {
<b class="nc">&nbsp;                        StringBuilder buf = new StringBuilder();</b>
<b class="nc">&nbsp;                        for (String path : item.e.getAffectedPaths())</b>
<b class="nc">&nbsp;                            buf.append(path).append(&#39;\n&#39;);</b>
<b class="nc">&nbsp;                        return buf.toString();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Calendar getEntryTimestamp(FeedItem item) {
<b class="nc">&nbsp;                            return item.getBuild().getTimestamp();</b>
&nbsp;                        }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public String getEntryAuthor(FeedItem entry) {
<b class="nc">&nbsp;                        return JenkinsLocationConfiguration.get().getAdminAddress();</b>
&nbsp;                    }
&nbsp;                },
&nbsp;                req, rsp);
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    @Override public ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {
&nbsp;        // not sure what would be really useful here. This needs more thoughts.
&nbsp;        // for the time being, I&#39;m starting with permalinks
<b class="nc">&nbsp;        ContextMenu menu = new ContextMenu();</b>
<b class="nc">&nbsp;        for (Permalink p : getPermalinks()) {</b>
<b class="nc">&nbsp;            if (p.resolve(this) != null) {</b>
<b class="nc">&nbsp;                menu.add(p.getId(), p.getDisplayName());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return menu;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used as the color of the status ball for the project.
&nbsp;     */
&nbsp;    @Exported(visibility = 2, name = &quot;color&quot;)
&nbsp;    public BallColor getIconColor() {
<b class="nc">&nbsp;        RunT lastBuild = getLastBuild();</b>
<b class="nc">&nbsp;        while (lastBuild != null &amp;&amp; lastBuild.hasntStartedYet())</b>
<b class="nc">&nbsp;            lastBuild = lastBuild.getPreviousBuild();</b>
&nbsp;
<b class="nc">&nbsp;        if (lastBuild != null)</b>
<b class="nc">&nbsp;            return lastBuild.getIconColor();</b>
&nbsp;        else
<b class="nc">&nbsp;            return BallColor.NOTBUILT;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the current health report for a job.
&nbsp;     *
&nbsp;     * @return the health report. Never returns null
&nbsp;     */
&nbsp;    public HealthReport getBuildHealth() {
<b class="nc">&nbsp;        List&lt;HealthReport&gt; reports = getBuildHealthReports();</b>
<b class="nc">&nbsp;        return reports.isEmpty() ? new HealthReport() : reports.get(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported(name = &quot;healthReport&quot;)
&nbsp;    public List&lt;HealthReport&gt; getBuildHealthReports() {
<b class="nc">&nbsp;        List&lt;HealthReport&gt; reports = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        RunT lastBuild = getLastBuild();</b>
&nbsp;
<b class="nc">&nbsp;        if (lastBuild != null &amp;&amp; lastBuild.isBuilding()) {</b>
&nbsp;            // show the previous build&#39;s report until the current one is
&nbsp;            // finished building.
<b class="nc">&nbsp;            lastBuild = lastBuild.getPreviousBuild();</b>
&nbsp;        }
&nbsp;
&nbsp;        // check the cache
<b class="nc">&nbsp;        if (cachedBuildHealthReportsBuildNumber != null</b>
&nbsp;                &amp;&amp; cachedBuildHealthReports != null
&nbsp;                &amp;&amp; lastBuild != null
<b class="nc">&nbsp;                &amp;&amp; cachedBuildHealthReportsBuildNumber == lastBuild</b>
<b class="nc">&nbsp;                        .getNumber()) {</b>
<b class="nc">&nbsp;            reports.addAll(cachedBuildHealthReports);</b>
<b class="nc">&nbsp;        } else if (lastBuild != null) {</b>
<b class="nc">&nbsp;            for (HealthReportingAction healthReportingAction : lastBuild</b>
<b class="nc">&nbsp;                    .getActions(HealthReportingAction.class)) {</b>
<b class="nc">&nbsp;                final HealthReport report = healthReportingAction</b>
<b class="nc">&nbsp;                        .getBuildHealth();</b>
<b class="nc">&nbsp;                if (report != null) {</b>
<b class="nc">&nbsp;                    if (report.isAggregateReport()) {</b>
<b class="nc">&nbsp;                        reports.addAll(report.getAggregatedReports());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        reports.add(report);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            final HealthReport report = getBuildStabilityHealthReport();</b>
<b class="nc">&nbsp;            if (report != null) {</b>
<b class="nc">&nbsp;                if (report.isAggregateReport()) {</b>
<b class="nc">&nbsp;                    reports.addAll(report.getAggregatedReports());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    reports.add(report);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Collections.sort(reports);</b>
&nbsp;
&nbsp;            // store the cache
<b class="nc">&nbsp;            cachedBuildHealthReportsBuildNumber = lastBuild.getNumber();</b>
<b class="nc">&nbsp;            cachedBuildHealthReports = new ArrayList&lt;&gt;(reports);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return reports;</b>
&nbsp;    }
&nbsp;
&nbsp;    private HealthReport getBuildStabilityHealthReport() {
&nbsp;        // we can give a simple view of build health from the last five builds
<b class="nc">&nbsp;        int failCount = 0;</b>
<b class="nc">&nbsp;        int totalCount = 0;</b>
<b class="nc">&nbsp;        RunT i = getLastBuild();</b>
<b class="nc">&nbsp;        RunT u = getLastFailedBuild();</b>
<b class="nc">&nbsp;        if (i != null &amp;&amp; u == null) {</b>
&nbsp;                // no failures, like ever
<b class="nc">&nbsp;                return new HealthReport(100, Messages._Job_BuildStability(Messages._Job_NoRecentBuildFailed()));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (i != null &amp;&amp; u.getNumber() &lt;= i.getNumber()) {</b>
<b class="nc">&nbsp;            SortedMap&lt;Integer, ? extends RunT&gt; runs = _getRuns();</b>
<b class="nc">&nbsp;            if (runs instanceof RunMap) {</b>
<b class="nc">&nbsp;                RunMap&lt;RunT&gt; runMap = (RunMap&lt;RunT&gt;) runs;</b>
<b class="nc">&nbsp;                for (int index = i.getNumber(); index &gt; u.getNumber() &amp;&amp; totalCount &lt; 5; index--) {</b>
<b class="nc">&nbsp;                    if (runMap.runExists(index)) {</b>
<b class="nc">&nbsp;                        totalCount++;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                if (totalCount &lt; 5) {</b>
&nbsp;                    // start loading from the first failure as we counted the rest
<b class="nc">&nbsp;                    i = u;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        while (totalCount &lt; 5 &amp;&amp; i != null) {</b>
<b class="nc">&nbsp;            switch (i.getIconColor()) {</b>
&nbsp;            case BLUE:
&nbsp;            case YELLOW:
&nbsp;                // failCount stays the same
<b class="nc">&nbsp;                totalCount++;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case RED:
<b class="nc">&nbsp;                failCount++;</b>
<b class="nc">&nbsp;                totalCount++;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;
&nbsp;            default:
&nbsp;                // do nothing as these are inconclusive statuses
&nbsp;                break;
&nbsp;            }
<b class="nc">&nbsp;            i = i.getPreviousBuild();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (totalCount &gt; 0) {</b>
<b class="nc">&nbsp;            int score = (int) ((100.0 * (totalCount - failCount)) / totalCount);</b>
&nbsp;
&nbsp;            Localizable description;
<b class="nc">&nbsp;            if (failCount == 0) {</b>
<b class="nc">&nbsp;                description = Messages._Job_NoRecentBuildFailed();</b>
<b class="nc">&nbsp;            } else if (totalCount == failCount) {</b>
&nbsp;                // this should catch the case where totalCount == 1
&nbsp;                // as failCount must be between 0 and totalCount
&nbsp;                // and we can&#39;t get here if failCount == 0
<b class="nc">&nbsp;                description = Messages._Job_AllRecentBuildFailed();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                description = Messages._Job_NOfMFailed(failCount, totalCount);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new HealthReport(score, Messages._Job_BuildStability(description));</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    //
&nbsp;    //
&nbsp;    // actions
&nbsp;    //
&nbsp;    //
&nbsp;    /**
&nbsp;     * Accepts submission from the configuration page.
&nbsp;     */
&nbsp;    @POST
&nbsp;    public synchronized void doConfigSubmit(StaplerRequest req,
&nbsp;            StaplerResponse rsp) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
&nbsp;
<b class="nc">&nbsp;        description = req.getParameter(&quot;description&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        JSONObject json = req.getSubmittedForm();</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            try (BulkChange bc = new BulkChange(this)) {</b>
<b class="nc">&nbsp;                setDisplayName(json.optString(&quot;displayNameOrNull&quot;));</b>
&nbsp;
<b class="nc">&nbsp;                logRotator = null;</b>
&nbsp;
<b class="nc">&nbsp;                DescribableList&lt;JobProperty&lt;?&gt;, JobPropertyDescriptor&gt; t = new DescribableList&lt;&gt;(NOOP, getAllProperties());</b>
<b class="nc">&nbsp;                JSONObject jsonProperties = json.optJSONObject(&quot;properties&quot;);</b>
<b class="nc">&nbsp;                if (jsonProperties != null) {</b>
<b class="nc">&nbsp;                  t.rebuild(req, jsonProperties, JobPropertyDescriptor.getPropertyDescriptors(Job.this.getClass()));</b>
&nbsp;                } else {
<b class="nc">&nbsp;                  t.clear();</b>
&nbsp;                }
<b class="nc">&nbsp;                properties.clear();</b>
<b class="nc">&nbsp;                for (JobProperty p : t) {</b>
<b class="nc">&nbsp;                    p.setOwner(this);</b>
<b class="nc">&nbsp;                    properties.add(p);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                submit(req, rsp);</b>
<b class="nc">&nbsp;                bc.commit();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            ItemListener.fireOnUpdated(this);</b>
&nbsp;
<b class="nc">&nbsp;            final ProjectNamingStrategy namingStrategy = Jenkins.get().getProjectNamingStrategy();</b>
<b class="nc">&nbsp;                if (namingStrategy.isForceExistingJobs()) {</b>
<b class="nc">&nbsp;                    namingStrategy.checkName(getParent().getFullName(), name);</b>
&nbsp;                }
<b class="nc">&nbsp;                FormApply.success(&quot;.&quot;).generateResponse(req, rsp, null);</b>
<b class="nc">&nbsp;        } catch (JSONException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;failed to parse &quot; + json, e);</b>
<b class="nc">&nbsp;            sendError(e, req, rsp);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Derived class can override this to perform additional config submission
&nbsp;     * work.
&nbsp;     */
&nbsp;    protected void submit(StaplerRequest req, StaplerResponse rsp)
&nbsp;            throws IOException, ServletException, FormException {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts and serves the job description
&nbsp;     */
&nbsp;    public void doDescription(StaplerRequest req, StaplerResponse rsp)
&nbsp;            throws IOException {
<b class="nc">&nbsp;        if (req.getMethod().equals(&quot;GET&quot;)) {</b>
&nbsp;            //read
<b class="nc">&nbsp;            rsp.setContentType(&quot;text/plain;charset=UTF-8&quot;);</b>
<b class="nc">&nbsp;            rsp.getWriter().write(Util.fixNull(this.getDescription()));</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (req.getMethod().equals(&quot;POST&quot;)) {</b>
<b class="nc">&nbsp;            checkPermission(CONFIGURE);</b>
&nbsp;
&nbsp;            // submission
<b class="nc">&nbsp;            if (req.getParameter(&quot;description&quot;) != null) {</b>
<b class="nc">&nbsp;                this.setDescription(req.getParameter(&quot;description&quot;));</b>
<b class="nc">&nbsp;                rsp.sendError(SC_NO_CONTENT);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // huh?
<b class="nc">&nbsp;        rsp.sendError(SC_BAD_REQUEST);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the image that shows the current buildCommand status.
&nbsp;     */
&nbsp;    public void doBuildStatus(StaplerRequest req, StaplerResponse rsp)
&nbsp;            throws IOException {
<b class="nc">&nbsp;        rsp.sendRedirect2(req.getContextPath() + &quot;/images/48x48/&quot; + getBuildStatusUrl());</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getBuildStatusUrl() {
<b class="nc">&nbsp;        return getIconColor().getImage();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getBuildStatusIconClassName() {
<b class="nc">&nbsp;        return getIconColor().getIconClassName();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class ChartLabel implements Comparable&lt;ChartLabel&gt; {
&nbsp;        final Run run;
&nbsp;
<b class="nc">&nbsp;        ChartLabel(Run r) {</b>
<b class="nc">&nbsp;            this.run = r;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int compareTo(ChartLabel that) {
<b class="nc">&nbsp;            return this.run.number - that.run.number;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
&nbsp;            // JENKINS-2682 workaround for Eclipse compilation bug
&nbsp;            // on (c instanceof ChartLabel)
<b class="nc">&nbsp;            if (o == null || !ChartLabel.class.isAssignableFrom(o.getClass()))  {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            ChartLabel that = (ChartLabel) o;</b>
<b class="nc">&nbsp;            return run == that.run;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Color getColor() {
&nbsp;            // TODO: consider gradation. See
&nbsp;            // http://www.javadrive.jp/java2d/shape/index9.html
<b class="nc">&nbsp;            Result r = run.getResult();</b>
<b class="nc">&nbsp;            if (r == Result.FAILURE)</b>
<b class="nc">&nbsp;                return ColorPalette.RED;</b>
<b class="nc">&nbsp;            else if (r == Result.UNSTABLE)</b>
<b class="nc">&nbsp;                return ColorPalette.YELLOW;</b>
<b class="nc">&nbsp;            else if (r == Result.ABORTED || r == Result.NOT_BUILT)</b>
<b class="nc">&nbsp;                return ColorPalette.DARK_GREY;</b>
&nbsp;            else
<b class="nc">&nbsp;                return ColorPalette.BLUE;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return run.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            String l = run.getDisplayName();</b>
<b class="nc">&nbsp;            if (run instanceof Build) {</b>
<b class="nc">&nbsp;                String s = ((Build) run).getBuiltOnStr();</b>
<b class="nc">&nbsp;                if (s != null)</b>
<b class="nc">&nbsp;                    l += &#39; &#39; + s;</b>
&nbsp;            }
<b class="nc">&nbsp;            return l;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(value = &quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;, justification = &quot;category dataset is only relevant for coloring, not equality&quot;)
&nbsp;    private static class ChartLabelStackedAreaRenderer2 extends StackedAreaRenderer2 {
&nbsp;        private final CategoryDataset categoryDataset;
&nbsp;
<b class="nc">&nbsp;        ChartLabelStackedAreaRenderer2(CategoryDataset categoryDataset) {</b>
<b class="nc">&nbsp;            this.categoryDataset = categoryDataset;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Paint getItemPaint(int row, int column) {
<b class="nc">&nbsp;            ChartLabel key = (ChartLabel) categoryDataset.getColumnKey(column);</b>
<b class="nc">&nbsp;            return key.getColor();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String generateURL(CategoryDataset dataset, int row, int column) {
<b class="nc">&nbsp;            ChartLabel label = (ChartLabel) dataset.getColumnKey(column);</b>
<b class="nc">&nbsp;            return String.valueOf(label.run.number);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String generateToolTip(CategoryDataset dataset, int row, int column) {
<b class="nc">&nbsp;            ChartLabel label = (ChartLabel) dataset.getColumnKey(column);</b>
<b class="nc">&nbsp;            return label.run.getDisplayName() + &quot; : &quot; + label.run.getDurationString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Graph getBuildTimeGraph() {
<b class="nc">&nbsp;        return new Graph(getLastBuildTime(), 500, 400) {</b>
&nbsp;            @Override
&nbsp;            protected JFreeChart createGraph() {
<b class="nc">&nbsp;                DataSetBuilder&lt;String, ChartLabel&gt; data = new DataSetBuilder&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Run r : getNewBuilds()) {</b>
<b class="nc">&nbsp;                    if (r.isBuilding())</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="nc">&nbsp;                    data.add(((double) r.getDuration()) / (1000 * 60), &quot;min&quot;,</b>
&nbsp;                            new ChartLabel(r));
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                final CategoryDataset dataset = data.build();</b>
&nbsp;
<b class="nc">&nbsp;                final JFreeChart chart = ChartFactory.createStackedAreaChart(null, // chart</b>
&nbsp;                                                                                    // title
&nbsp;                        null, // unused
<b class="nc">&nbsp;                        Messages.Job_minutes(), // range axis label</b>
&nbsp;                        dataset, // data
&nbsp;                        PlotOrientation.VERTICAL, // orientation
&nbsp;                        false, // include legend
&nbsp;                        true, // tooltips
&nbsp;                        false // urls
&nbsp;                        );
&nbsp;
<b class="nc">&nbsp;                chart.setBackgroundPaint(Color.white);</b>
&nbsp;
<b class="nc">&nbsp;                final CategoryPlot plot = chart.getCategoryPlot();</b>
&nbsp;
&nbsp;                // plot.setAxisOffset(new Spacer(Spacer.ABSOLUTE, 5.0, 5.0, 5.0, 5.0));
<b class="nc">&nbsp;                plot.setBackgroundPaint(Color.WHITE);</b>
<b class="nc">&nbsp;                plot.setOutlinePaint(null);</b>
<b class="nc">&nbsp;                plot.setForegroundAlpha(0.8f);</b>
<b class="nc">&nbsp;                plot.setRangeGridlinesVisible(true);</b>
<b class="nc">&nbsp;                plot.setRangeGridlinePaint(Color.black);</b>
&nbsp;
<b class="nc">&nbsp;                CategoryAxis domainAxis = new ShiftedCategoryAxis(null);</b>
<b class="nc">&nbsp;                plot.setDomainAxis(domainAxis);</b>
<b class="nc">&nbsp;                domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);</b>
<b class="nc">&nbsp;                domainAxis.setLowerMargin(0.0);</b>
<b class="nc">&nbsp;                domainAxis.setUpperMargin(0.0);</b>
<b class="nc">&nbsp;                domainAxis.setCategoryMargin(0.0);</b>
&nbsp;
<b class="nc">&nbsp;                final NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();</b>
<b class="nc">&nbsp;                ChartUtil.adjustChebyshev(dataset, rangeAxis);</b>
<b class="nc">&nbsp;                rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());</b>
&nbsp;
<b class="nc">&nbsp;                StackedAreaRenderer ar = new ChartLabelStackedAreaRenderer2(dataset);</b>
<b class="nc">&nbsp;                plot.setRenderer(ar);</b>
&nbsp;
&nbsp;                // crop extra space around the graph
<b class="nc">&nbsp;                plot.setInsets(new RectangleInsets(0, 0, 0, 5.0));</b>
&nbsp;
<b class="nc">&nbsp;                return chart;</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private Calendar getLastBuildTime() {
<b class="nc">&nbsp;        final RunT lastBuild = getLastBuild();</b>
<b class="nc">&nbsp;        if (lastBuild == null) {</b>
<b class="nc">&nbsp;            final GregorianCalendar neverBuiltCalendar = new GregorianCalendar();</b>
<b class="nc">&nbsp;            neverBuiltCalendar.setTimeInMillis(0);</b>
<b class="nc">&nbsp;            return neverBuiltCalendar;</b>
&nbsp;        }
<b class="nc">&nbsp;        return lastBuild.getTimestamp();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Renames this job.
&nbsp;     * @deprecated Exists for backwards compatibility, use {@link #doConfirmRename} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @RequirePOST
&nbsp;    public/* not synchronized. see renameTo() */void doDoRename(
&nbsp;            StaplerRequest req, StaplerResponse rsp) throws IOException,
&nbsp;            ServletException {
<b class="nc">&nbsp;        String newName = req.getParameter(&quot;newName&quot;);</b>
<b class="nc">&nbsp;        doConfirmRename(newName).generateResponse(req, rsp, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void checkRename(String newName) throws Failure {
<b class="nc">&nbsp;        if (isBuilding()) {</b>
<b class="nc">&nbsp;            throw new Failure(Messages.Job_NoRenameWhileBuilding());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void doRssAll(StaplerRequest req, StaplerResponse rsp)
&nbsp;            throws IOException, ServletException {
<b class="nc">&nbsp;        RSS.rss(req, rsp, &quot;Jenkins:&quot; + getDisplayName() + &quot; (all builds)&quot;, getUrl(), getBuilds().newBuilds());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doRssFailed(StaplerRequest req, StaplerResponse rsp)
&nbsp;            throws IOException, ServletException {
<b class="nc">&nbsp;        RSS.rss(req, rsp, &quot;Jenkins:&quot; + getDisplayName() + &quot; (failed builds)&quot;, getUrl(), getBuilds().failureOnly().newBuilds());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link ACL} for this object.
&nbsp;     * We need to override the identical method in AbstractItem because we won&#39;t
&nbsp;     * call getACL(Job) otherwise (single dispatch)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public ACL getACL() {
<b class="nc">&nbsp;        return Jenkins.get().getAuthorizationStrategy().getACL(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public BuildTimelineWidget getTimeline() {
<b class="nc">&nbsp;        return new BuildTimelineWidget(getBuilds());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final HexStringConfidentialKey SERVER_COOKIE = new HexStringConfidentialKey(Job.class, &quot;serverCookie&quot;, 16);</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
