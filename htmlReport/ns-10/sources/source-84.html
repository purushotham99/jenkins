


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > UpdateSite</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: UpdateSite (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">UpdateSite</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (5/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.8%
  </span>
  <span class="absValue">
    (13/132)
  </span>
</td>
</tr>
  <tr>
    <td class="name">UpdateSite$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$Data</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.4%
  </span>
  <span class="absValue">
    (37/46)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$Deprecation</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$Entry</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (18/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$IssueTracker</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$Plugin</td>
<td class="coverageStat">
  <span class="percent">
    5.9%
  </span>
  <span class="absValue">
    (2/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    19.9%
  </span>
  <span class="absValue">
    (36/181)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$Warning</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.1%
  </span>
  <span class="absValue">
    (16/57)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$WarningType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateSite$WarningVersionRange</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    21%
  </span>
  <span class="absValue">
    (21/100)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29.9%
  </span>
  <span class="absValue">
    (142/475)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Yahoo! Inc., Seiji Sogabe,
&nbsp; *                          Andrew Bayer
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static java.util.concurrent.TimeUnit.DAYS;
&nbsp;import static java.util.concurrent.TimeUnit.HOURS;
&nbsp;import static java.util.concurrent.TimeUnit.SECONDS;
&nbsp;import static jenkins.util.MemoryReductionUtil.getPresizedMutableMap;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.Nullable;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.ExtensionList;
&nbsp;import hudson.PluginManager;
&nbsp;import hudson.PluginWrapper;
&nbsp;import hudson.Util;
&nbsp;import hudson.lifecycle.Lifecycle;
&nbsp;import hudson.model.UpdateCenter.UpdateCenterJob;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.HttpResponses;
&nbsp;import hudson.util.TextFile;
&nbsp;import hudson.util.VersionNumber;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLEncoder;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.time.Instant;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Date;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.UUID;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.regex.PatternSyntaxException;
&nbsp;import java.util.stream.Stream;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.plugins.DetachedPluginsUtil;
&nbsp;import jenkins.security.UpdateSiteWarningsConfiguration;
&nbsp;import jenkins.security.UpdateSiteWarningsMonitor;
&nbsp;import jenkins.util.JSONSignatureValidator;
&nbsp;import jenkins.util.PluginLabelUtil;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import net.sf.json.JSONArray;
&nbsp;import net.sf.json.JSONException;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.DataBoundConstructor;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;
&nbsp;/**
&nbsp; * Source of the update center information, like &quot;http://jenkins-ci.org/update-center.json&quot;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Jenkins can have multiple {@link UpdateSite}s registered in the system, so that it can pick up plugins
&nbsp; * from different locations.
&nbsp; *
&nbsp; * @author Andrew Bayer
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @since 1.333
&nbsp; */
<b class="fc">&nbsp;@ExportedBean</b>
&nbsp;public class UpdateSite {
&nbsp;    /**
&nbsp;     * What&#39;s the time stamp of data file?
&nbsp;     * 0 means never.
&nbsp;     */
&nbsp;    private transient volatile long dataTimestamp;
&nbsp;
&nbsp;    /**
&nbsp;     * When was the last time we asked a browser to check the data for us?
&nbsp;     * 0 means never.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * There&#39;s normally some delay between when we send HTML that includes the check code,
&nbsp;     * until we get the data back, so this variable is used to avoid asking too many browsers
&nbsp;     * all at once.
&nbsp;     */
&nbsp;    private transient volatile long lastAttempt;
&nbsp;
&nbsp;    /**
&nbsp;     * If the attempt to fetch data fails, we progressively use longer time out before retrying,
&nbsp;     * to avoid overloading the server.
&nbsp;     */
&nbsp;    private transient volatile long retryWindow;
&nbsp;
&nbsp;    /**
&nbsp;     * Latest data as read from the data file.
&nbsp;     */
&nbsp;    private transient Data data;
&nbsp;
&nbsp;    /**
&nbsp;     * ID string for this update source.
&nbsp;     */
&nbsp;    private final String id;
&nbsp;
&nbsp;    /**
&nbsp;     * Path to {@code update-center.json}, like {@code http://jenkins-ci.org/update-center.json}.
&nbsp;     */
&nbsp;    private final String url;
&nbsp;
&nbsp;    /**
&nbsp;     * the prefix for the signature validator name
&nbsp;     */
&nbsp;    private static final String signatureValidatorPrefix = &quot;update site&quot;;
&nbsp;
<b class="fc">&nbsp;    private static final Set&lt;String&gt; warnedMissing = Collections.synchronizedSet(new HashSet&lt;&gt;());</b>
&nbsp;
<b class="fc">&nbsp;    public UpdateSite(String id, String url) {</b>
<b class="fc">&nbsp;        this.id = id;</b>
<b class="fc">&nbsp;        this.url = url;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get ID string.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public String getId() {
<b class="nc">&nbsp;        return id;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    public long getDataTimestamp() {
<b class="nc">&nbsp;        assert dataTimestamp &gt;= 0;</b>
<b class="nc">&nbsp;        return dataTimestamp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update the data file from the given URL if the file
&nbsp;     * does not exist, or is otherwise due for update.
&nbsp;     * Accepted formats are JSONP or HTML with {@code postMessage}, not raw JSON.
&nbsp;     * @return null if no updates are necessary, or the future result
&nbsp;     * @since 2.222
&nbsp;     */
&nbsp;    public @CheckForNull Future&lt;FormValidation&gt; updateDirectly() {
<b class="nc">&nbsp;        return updateDirectly(DownloadService.signatureCheck);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update the data file from the given URL if the file
&nbsp;     * does not exist, or is otherwise due for update.
&nbsp;     * Accepted formats are JSONP or HTML with {@code postMessage}, not raw JSON.
&nbsp;     * @param signatureCheck whether to enforce the signature (may be off only for testing!)
&nbsp;     * @return null if no updates are necessary, or the future result
&nbsp;     * @since 1.502
&nbsp;     * @deprecated use {@linkplain #updateDirectly()}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public @CheckForNull Future&lt;FormValidation&gt; updateDirectly(final boolean signatureCheck) {
<b class="nc">&nbsp;        if (! getDataFile().exists() || isDue()) {</b>
<b class="nc">&nbsp;            return Jenkins.get().getUpdateCenter().updateService.submit(new Callable&lt;FormValidation&gt;() {</b>
&nbsp;                @Override public FormValidation call() throws Exception {
<b class="nc">&nbsp;                    return updateDirectlyNow(signatureCheck);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Forces an update of the data file from the configured URL, irrespective of the last time the data was retrieved.
&nbsp;     * @return A {@code FormValidation} indicating the if the update metadata was successfully downloaded from the configured update site
&nbsp;     * @since 2.222
&nbsp;     * @throws IOException if there was an error downloading or saving the file.
&nbsp;     */
&nbsp;    public @NonNull FormValidation updateDirectlyNow() throws IOException {
<b class="nc">&nbsp;        return updateDirectlyNow(DownloadService.signatureCheck);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public @NonNull FormValidation updateDirectlyNow(boolean signatureCheck) throws IOException {
<b class="nc">&nbsp;        return updateData(DownloadService.loadJSON(new URL(getUrl() + &quot;?id=&quot; + URLEncoder.encode(getId(), StandardCharsets.UTF_8) + &quot;&amp;version=&quot; + URLEncoder.encode(Jenkins.VERSION, StandardCharsets.UTF_8))), signatureCheck);</b>
&nbsp;    }
&nbsp;
&nbsp;    private FormValidation updateData(String json, boolean signatureCheck)
&nbsp;            throws IOException {
&nbsp;
<b class="nc">&nbsp;        dataTimestamp = System.currentTimeMillis();</b>
&nbsp;
<b class="nc">&nbsp;        JSONObject o = JSONObject.fromObject(json);</b>
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            int v = o.getInt(&quot;updateCenterVersion&quot;);</b>
<b class="nc">&nbsp;            if (v != 1) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Unrecognized update center version: &quot; + v);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (JSONException x) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Could not find (numeric) updateCenterVersion in &quot; + json, x);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (signatureCheck) {</b>
<b class="nc">&nbsp;            FormValidation e = verifySignatureInternal(o);</b>
<b class="nc">&nbsp;            if (e.kind != FormValidation.Kind.OK) {</b>
<b class="nc">&nbsp;                LOGGER.severe(e.toString());</b>
<b class="nc">&nbsp;                return e;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.fine(() -&gt; &quot;Obtained the latest update center data file for UpdateSource &quot; + id);</b>
<b class="nc">&nbsp;        retryWindow = 0;</b>
<b class="nc">&nbsp;        getDataFile().write(json);</b>
<b class="nc">&nbsp;        data = new Data(o);</b>
<b class="nc">&nbsp;        return FormValidation.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    public FormValidation doVerifySignature() throws IOException {
<b class="nc">&nbsp;        return verifySignatureInternal(getJSONObject());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extension point to allow implementations of {@link UpdateSite} to create a custom
&nbsp;     * {@link UpdateCenter.InstallationJob}.
&nbsp;     *
&nbsp;     * @param plugin      the plugin to create the {@link UpdateCenter.InstallationJob} for.
&nbsp;     * @param uc          the {@link UpdateCenter}.
&nbsp;     * @param dynamicLoad {@code true} if the plugin should be attempted to be dynamically loaded.
&nbsp;     * @return the {@link UpdateCenter.InstallationJob}.
&nbsp;     * @since 2.9
&nbsp;     */
&nbsp;    protected UpdateCenter.InstallationJob createInstallationJob(Plugin plugin, UpdateCenter uc, boolean dynamicLoad) {
<b class="nc">&nbsp;        return uc.new InstallationJob(plugin, this, Jenkins.getAuthentication2(), dynamicLoad);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies the signature in the update center data file.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public final FormValidation verifySignatureInternal(JSONObject o) throws IOException {
<b class="nc">&nbsp;        return getJsonSignatureValidator().verifySignature(o);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Let sub-classes of UpdateSite provide their own signature validator.
&nbsp;     * @return the signature validator.
&nbsp;     * @deprecated use {@link #getJsonSignatureValidator(String)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @NonNull
&nbsp;    protected JSONSignatureValidator getJsonSignatureValidator() {
<b class="nc">&nbsp;        return getJsonSignatureValidator(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Let sub-classes of UpdateSite provide their own signature validator.
&nbsp;     * @param name the name for the JSON signature Validator object.
&nbsp;     *              if name is null, then the default name will be used,
&nbsp;     *              which is &quot;update site&quot; followed by the update site id
&nbsp;     * @return the signature validator.
&nbsp;     * @since 2.21
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    protected JSONSignatureValidator getJsonSignatureValidator(@CheckForNull String name) {
<b class="nc">&nbsp;        if (name == null) {</b>
<b class="nc">&nbsp;            name = signatureValidatorPrefix + &quot; &#39;&quot; + id + &quot;&#39;&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new JSONSignatureValidator(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if it&#39;s time for us to check for new version.
&nbsp;     */
&nbsp;    public synchronized boolean isDue() {
<b class="nc">&nbsp;        if (neverUpdate)     return false;</b>
<b class="nc">&nbsp;        if (dataTimestamp == 0)</b>
<b class="nc">&nbsp;            dataTimestamp = getDataFile().file.lastModified();</b>
<b class="nc">&nbsp;        long now = System.currentTimeMillis();</b>
&nbsp;
<b class="nc">&nbsp;        retryWindow = Math.max(retryWindow, SECONDS.toMillis(15));</b>
&nbsp;
<b class="nc">&nbsp;        boolean due = now - dataTimestamp &gt; DAY &amp;&amp; now - lastAttempt &gt; retryWindow;</b>
<b class="nc">&nbsp;        if (due) {</b>
<b class="nc">&nbsp;            lastAttempt = now;</b>
<b class="nc">&nbsp;            retryWindow = Math.min(retryWindow * 2, HOURS.toMillis(1)); // exponential back off but at most 1 hour</b>
&nbsp;        }
<b class="nc">&nbsp;        return due;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invalidates the cached data and force retrieval.
&nbsp;     *
&nbsp;     * @since 1.432
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doInvalidateData() {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        dataTimestamp = 0;</b>
<b class="nc">&nbsp;        data = null;</b>
<b class="nc">&nbsp;        return HttpResponses.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the update center data, if any.
&nbsp;     *
&nbsp;     * @return  null if no data is available.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public Data getData() {
<b class="nc">&nbsp;        if (data == null) {</b>
<b class="nc">&nbsp;            JSONObject o = getJSONObject();</b>
<b class="nc">&nbsp;            if (o != null) {</b>
<b class="nc">&nbsp;                data = new Data(o);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return data;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Whether {@link #getData} might be blocking.
&nbsp;     */
&nbsp;    // Internal use only
&nbsp;    boolean hasUnparsedData() {
<b class="nc">&nbsp;        return data == null &amp;&amp; getDataFile().exists();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the raw update center JSON data.
&nbsp;     */
&nbsp;    public JSONObject getJSONObject() {
<b class="nc">&nbsp;        TextFile df = getDataFile();</b>
<b class="nc">&nbsp;        if (df.exists()) {</b>
<b class="nc">&nbsp;            long start = System.nanoTime();</b>
&nbsp;            try {
<b class="nc">&nbsp;                JSONObject o = JSONObject.fromObject(df.read());</b>
<b class="nc">&nbsp;                LOGGER.fine(() -&gt; String.format(&quot;Loaded and parsed %s in %.01fs&quot;, df, (System.nanoTime() - start) / 1_000_000_000.0));</b>
<b class="nc">&nbsp;                return o;</b>
<b class="nc">&nbsp;            } catch (JSONException | IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to parse &quot; + df, e);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    df.delete(); // if we keep this file, it will cause repeated failures</b>
<b class="nc">&nbsp;                } catch (IOException e2) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.SEVERE, &quot;Failed to delete &quot; + df, e2);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of plugins that should be shown in the &quot;available&quot; tab.
&nbsp;     * These are &quot;all plugins - installed plugins&quot;.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public List&lt;Plugin&gt; getAvailables() {
<b class="nc">&nbsp;        List&lt;Plugin&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        Data data = getData();</b>
<b class="nc">&nbsp;        if (data == null)     return Collections.emptyList();</b>
<b class="nc">&nbsp;        for (Plugin p : data.plugins.values()) {</b>
<b class="nc">&nbsp;            if (p.getInstalled() == null)</b>
<b class="nc">&nbsp;                r.add(p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        r.sort((plugin, t1) -&gt; {</b>
<b class="nc">&nbsp;            final int pop = t1.popularity.compareTo(plugin.popularity);</b>
<b class="nc">&nbsp;            if (pop != 0) {</b>
<b class="nc">&nbsp;                return pop; // highest popularity first</b>
&nbsp;            }
<b class="nc">&nbsp;            return plugin.getDisplayName().compareTo(t1.getDisplayName());</b>
&nbsp;        });
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the information about a specific plugin.
&nbsp;     *
&nbsp;     * @param artifactId
&nbsp;     *      The short name of the plugin. Corresponds to {@link PluginWrapper#getShortName()}.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      {@code null} if no such information is found.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public Plugin getPlugin(String artifactId) {
<b class="nc">&nbsp;        Data dt = getData();</b>
<b class="nc">&nbsp;        if (dt == null)    return null;</b>
<b class="nc">&nbsp;        return dt.plugins.get(artifactId);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a URL for the Internet connection check.
&nbsp;     * @return  an &quot;always up&quot; server for Internet connectivity testing, or {@code null} if we are going to skip the test.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @CheckForNull
&nbsp;    public String getConnectionCheckUrl() {
<b class="nc">&nbsp;        Data dt = getData();</b>
<b class="nc">&nbsp;        if (dt == null)    return &quot;http://www.google.com/&quot;;</b>
<b class="nc">&nbsp;        return dt.connectionCheckUrl;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This is where we store the update center data.
&nbsp;     */
&nbsp;    private TextFile getDataFile() {
<b class="nc">&nbsp;        return new TextFile(new File(Jenkins.get().getRootDir(),</b>
<b class="nc">&nbsp;                                     &quot;updates/&quot; + getId() + &quot;.json&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the list of plugins that are updates to currently installed ones.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      can be empty but never null.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public List&lt;Plugin&gt; getUpdates() {
<b class="nc">&nbsp;        Data data = getData();</b>
<b class="nc">&nbsp;        if (data == null)      return Collections.emptyList(); // fail to determine</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;Plugin&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (PluginWrapper pw : Jenkins.get().getPluginManager().getPlugins()) {</b>
<b class="nc">&nbsp;            Plugin p = pw.getUpdateInfo();</b>
<b class="nc">&nbsp;            if (p != null) r.add(p);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does any of the plugin has updates?
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean hasUpdates() {
<b class="nc">&nbsp;        Data data = getData();</b>
<b class="nc">&nbsp;        if (data == null)      return false;</b>
&nbsp;
<b class="nc">&nbsp;        for (PluginWrapper pw : Jenkins.get().getPluginManager().getPlugins()) {</b>
<b class="nc">&nbsp;            if (!pw.isBundled() &amp;&amp; pw.getUpdateInfo() != null)</b>
&nbsp;                // do not advertize updates to bundled plugins, since we generally want users to get them
&nbsp;                // as a part of jenkins.war updates. This also avoids unnecessary pinning of plugins.
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Exposed to get rid of hardcoding of the URL that serves up update-center.json
&nbsp;     * in JavaScript.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public String getUrl() {
<b class="nc">&nbsp;        return url;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * @return the URL used by {@link jenkins.install.SetupWizard} for suggested plugins to install at setup time
&nbsp;     * @since TODO
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public String getSuggestedPluginsUrl() {
<b class="nc">&nbsp;        String updateCenterJsonUrl = getUrl();</b>
<b class="nc">&nbsp;        return updateCenterJsonUrl.replace(&quot;/update-center.json&quot;, &quot;/platform-plugins.json&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * URL which exposes the metadata location in a specific update site.
&nbsp;     * @param downloadable the downloadable id of a specific metatadata json (e.g. hudson.tasks.Maven.MavenInstaller.json)
&nbsp;     * @return the location
&nbsp;     * @since 2.20
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public String getMetadataUrlForDownloadable(String downloadable) {
<b class="nc">&nbsp;        String siteUrl = getUrl();</b>
<b class="nc">&nbsp;        String updateSiteMetadataUrl = null;</b>
<b class="nc">&nbsp;        int baseUrlEnd = siteUrl.indexOf(&quot;update-center.json&quot;);</b>
<b class="nc">&nbsp;        if (baseUrlEnd != -1) {</b>
<b class="nc">&nbsp;            String siteBaseUrl = siteUrl.substring(0, baseUrlEnd);</b>
<b class="nc">&nbsp;            updateSiteMetadataUrl = siteBaseUrl + &quot;updates/&quot; + downloadable;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;Url {0} does not look like an update center:&quot;, siteUrl);</b>
&nbsp;        }
<b class="nc">&nbsp;        return updateSiteMetadataUrl;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Where to actually download the update center?
&nbsp;     *
&nbsp;     * @deprecated
&nbsp;     *      Exposed only for UI.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public String getDownloadUrl() {
<b class="nc">&nbsp;        return url;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is this the legacy default update center site?
&nbsp;     * @deprecated
&nbsp;     *      Will be removed, currently returns always false.
&nbsp;     * @since 2.343
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public boolean isLegacyDefault() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * In-memory representation of the update center data.
&nbsp;     */
&nbsp;    public final class Data {
&nbsp;        /**
&nbsp;         * The {@link UpdateSite} ID.
&nbsp;         */
&nbsp;        public final String sourceId;
&nbsp;
&nbsp;        /**
&nbsp;         * The latest jenkins.war.
&nbsp;         */
&nbsp;        public final Entry core;
&nbsp;        /**
&nbsp;         * Plugins in the repository, keyed by their artifact IDs.
&nbsp;         */
<b class="fc">&nbsp;        public final Map&lt;String, Plugin&gt; plugins = new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</b>
&nbsp;        /**
&nbsp;         * List of warnings (mostly security) published with the update site.
&nbsp;         *
&nbsp;         * @since 2.40
&nbsp;         */
<b class="fc">&nbsp;        private final Set&lt;Warning&gt; warnings = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Mapping of plugin IDs to deprecation notices
&nbsp;         *
&nbsp;         * @since 2.246
&nbsp;         */
<b class="fc">&nbsp;        private final Map&lt;String, Deprecation&gt; deprecations = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * If this is non-null, Jenkins is going to check the connectivity to this URL to make sure
&nbsp;         * the network connection is up. Null to skip the check.
&nbsp;         */
&nbsp;        public final String connectionCheckUrl;
&nbsp;
<b class="fc">&nbsp;        Data(JSONObject o) {</b>
<b class="fc">&nbsp;            this.sourceId = Util.intern((String) o.get(&quot;id&quot;));</b>
<b class="fc">&nbsp;            JSONObject c = o.optJSONObject(&quot;core&quot;);</b>
<b class="fc">&nbsp;            if (c != null) {</b>
<b class="fc">&nbsp;                core = new Entry(sourceId, c, url);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                core = null;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            JSONArray w = o.optJSONArray(&quot;warnings&quot;);</b>
<b class="fc">&nbsp;            if (w != null) {</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; w.size(); i++) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        warnings.add(new Warning(w.getJSONObject(i)));</b>
<b class="nc">&nbsp;                    } catch (JSONException ex) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, &quot;Failed to parse JSON for warning&quot;, ex);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            JSONObject deprecations = o.optJSONObject(&quot;deprecations&quot;);</b>
<b class="fc">&nbsp;            if (deprecations != null) {</b>
<b class="fc">&nbsp;                for (Iterator it = deprecations.keys(); it.hasNext(); ) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        String pluginId = it.next().toString();</b>
<b class="fc">&nbsp;                        JSONObject entry = deprecations.getJSONObject(pluginId); // additional level of indirection to support future extensibility</b>
<b class="fc">&nbsp;                        if (entry != null) {</b>
<b class="fc">&nbsp;                            String referenceUrl = entry.getString(&quot;url&quot;);</b>
<b class="fc">&nbsp;                            if (referenceUrl != null) {</b>
<b class="fc">&nbsp;                                this.deprecations.put(pluginId, new Deprecation(referenceUrl));</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, &quot;Failed to parse JSON for deprecation&quot;, ex);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            for (Map.Entry&lt;String, JSONObject&gt; e : (Set&lt;Map.Entry&lt;String, JSONObject&gt;&gt;) o.getJSONObject(&quot;plugins&quot;).entrySet()) {</b>
<b class="fc">&nbsp;                Plugin p = new Plugin(sourceId, e.getValue());</b>
&nbsp;                // JENKINS-33308 - include implied dependencies for older plugins that may need them
<b class="fc">&nbsp;                List&lt;PluginWrapper.Dependency&gt; implicitDeps = DetachedPluginsUtil.getImpliedDependencies(p.name, p.requiredCore);</b>
<b class="fc">&nbsp;                if (!implicitDeps.isEmpty()) {</b>
<b class="fc">&nbsp;                    for (PluginWrapper.Dependency dep : implicitDeps) {</b>
<b class="fc">&nbsp;                        if (!p.dependencies.containsKey(dep.shortName)) {</b>
<b class="fc">&nbsp;                            p.dependencies.put(dep.shortName, dep.version);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                plugins.put(Util.intern(e.getKey()), p);</b>
&nbsp;
&nbsp;                // compatibility with update sites that have no separate &#39;deprecated&#39; top-level entry.
&nbsp;                // Also do this even if there are deprecations to potentially allow limiting the top-level entry to overridden URLs.
<b class="fc">&nbsp;                if (p.hasCategory(&quot;deprecated&quot;)) {</b>
<b class="fc">&nbsp;                    if (!this.deprecations.containsKey(p.name)) {</b>
<b class="fc">&nbsp;                        this.deprecations.put(p.name, new Deprecation(p.wiki));</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            connectionCheckUrl = (String) o.get(&quot;connectionCheckUrl&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the set of warnings
&nbsp;         * @return the set of warnings
&nbsp;         * @since 2.40
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public Set&lt;Warning&gt; getWarnings() {
<b class="nc">&nbsp;            return this.warnings;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the deprecations provided by the update site
&nbsp;         * @return the deprecations provided by the update site
&nbsp;         * @since 2.246
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public Map&lt;String, Deprecation&gt; getDeprecations() {
<b class="nc">&nbsp;            return this.deprecations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Is there a new version of the core?
&nbsp;         */
&nbsp;        public boolean hasCoreUpdates() {
<b class="nc">&nbsp;            return core != null &amp;&amp; core.isNewerThan(Jenkins.VERSION);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Do we support upgrade?
&nbsp;         */
&nbsp;        public boolean canUpgrade() {
<b class="nc">&nbsp;            return Lifecycle.get().canRewriteHudsonWar();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @ExportedBean
&nbsp;    public static class Entry {
&nbsp;        /**
&nbsp;         * {@link UpdateSite} ID.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String sourceId;
&nbsp;
&nbsp;        /**
&nbsp;         * Artifact ID.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String name;
&nbsp;        /**
&nbsp;         * The version.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String version;
&nbsp;        /**
&nbsp;         * Download URL.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String url;
&nbsp;
&nbsp;        /**
&nbsp;         * Size of the file in bytes, or {@code null} if unknown.
&nbsp;         */
&nbsp;        private final Long size;
&nbsp;
&nbsp;        // non-private, non-final for test
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        /* final */ String sha1;
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        /* final */ String sha256;
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        /* final */ String sha512;
&nbsp;
&nbsp;        public Entry(String sourceId, JSONObject o) {
<b class="fc">&nbsp;            this(sourceId, o, null);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Entry(String sourceId, JSONObject o, String baseURL) {</b>
<b class="fc">&nbsp;            this.sourceId = sourceId;</b>
<b class="fc">&nbsp;            this.name = Util.intern(o.getString(&quot;name&quot;));</b>
<b class="fc">&nbsp;            this.version = Util.intern(o.getString(&quot;version&quot;));</b>
&nbsp;
&nbsp;            // Trim this to prevent issues when the other end used Base64.encodeBase64String that added newlines
&nbsp;            // to the end in old commons-codec. Not the case on updates.jenkins-ci.org, but let&#39;s be safe.
<b class="fc">&nbsp;            this.sha1 = Util.fixEmptyAndTrim(o.optString(&quot;sha1&quot;));</b>
<b class="fc">&nbsp;            this.sha256 = Util.fixEmptyAndTrim(o.optString(&quot;sha256&quot;));</b>
<b class="fc">&nbsp;            this.sha512 = Util.fixEmptyAndTrim(o.optString(&quot;sha512&quot;));</b>
&nbsp;
<b class="fc">&nbsp;            Long fileSize = null;</b>
<b class="fc">&nbsp;            if (o.has(&quot;size&quot;)) {</b>
<b class="fc">&nbsp;                fileSize = o.getLong(&quot;size&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            this.size = fileSize;</b>
&nbsp;
<b class="fc">&nbsp;            String url = o.getString(&quot;url&quot;);</b>
<b class="fc">&nbsp;            if (!URI.create(url).isAbsolute()) {</b>
<b class="nc">&nbsp;                if (baseURL == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot resolve &quot; + url + &quot; without a base URL&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                url = URI.create(baseURL).resolve(url).toString();</b>
&nbsp;            }
<b class="fc">&nbsp;            this.url = url;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The base64 encoded binary SHA-1 checksum of the file.
&nbsp;         * Can be null if not provided by the update site.
&nbsp;         * @since 1.641 (and 1.625.3 LTS)
&nbsp;         */
&nbsp;        // TODO @Exported assuming we want this in the API
&nbsp;        public String getSha1() {
<b class="fc">&nbsp;            return sha1;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The base64 encoded SHA-256 checksum of the file.
&nbsp;         * Can be null if not provided by the update site.
&nbsp;         * @since 2.130
&nbsp;         */
&nbsp;        public String getSha256() {
<b class="fc">&nbsp;            return sha256;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The base64 encoded SHA-512 checksum of the file.
&nbsp;         * Can be null if not provided by the update site.
&nbsp;         * @since 2.130
&nbsp;         */
&nbsp;        public String getSha512() {
<b class="fc">&nbsp;            return sha512;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the specified &quot;current version&quot; is older than the version of this entry.
&nbsp;         *
&nbsp;         * @param currentVersion
&nbsp;         *      The string that represents the version number to be compared.
&nbsp;         * @return
&nbsp;         *      true if the version listed in this entry is newer.
&nbsp;         *      false otherwise, including the situation where the strings couldn&#39;t be parsed as version numbers.
&nbsp;         */
&nbsp;        public boolean isNewerThan(String currentVersion) {
&nbsp;            try {
<b class="nc">&nbsp;                return new VersionNumber(currentVersion).compareTo(new VersionNumber(version)) &lt; 0;</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // couldn&#39;t parse as the version number.
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public Api getApi() {
<b class="nc">&nbsp;            return new Api(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Size of the file being advertised in bytes, or {@code null} if unspecified/unknown.
&nbsp;         * @return size of the file if known, {@code null} otherwise.
&nbsp;         *
&nbsp;         * @since 2.325
&nbsp;         */
&nbsp;        // @Exported -- TODO unsure
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public Long getFileSize() {
<b class="nc">&nbsp;            return size;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A version range for {@code Warning}s indicates which versions of a given plugin are affected
&nbsp;     * by it.
&nbsp;     *
&nbsp;     * {@link #name}, {@link #firstVersion} and {@link #lastVersion} fields are only used for administrator notices.
&nbsp;     *
&nbsp;     * The {@link #pattern} is used to determine whether a given warning applies to the current installation.
&nbsp;     *
&nbsp;     * @since 2.40
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static final class WarningVersionRange {
&nbsp;        /**
&nbsp;         * Human-readable English name for this version range, e.g. &#39;regular&#39;, &#39;LTS&#39;, &#39;2.6 line&#39;.
&nbsp;         */
&nbsp;        @Nullable
&nbsp;        public final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * First version in this version range to be subject to the warning.
&nbsp;         */
&nbsp;        @Nullable
&nbsp;        public final String firstVersion;
&nbsp;
&nbsp;        /**
&nbsp;         * Last version in this version range to be subject to the warning.
&nbsp;         */
&nbsp;        @Nullable
&nbsp;        public final String lastVersion;
&nbsp;
&nbsp;        /**
&nbsp;         * Regular expression pattern for this version range that matches all included version numbers.
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        private final Pattern pattern;
&nbsp;
<b class="fc">&nbsp;        public WarningVersionRange(JSONObject o) {</b>
<b class="fc">&nbsp;            this.name = Util.fixEmpty(o.optString(&quot;name&quot;));</b>
<b class="fc">&nbsp;            this.firstVersion = Util.intern(Util.fixEmpty(o.optString(&quot;firstVersion&quot;)));</b>
<b class="fc">&nbsp;            this.lastVersion = Util.intern(Util.fixEmpty(o.optString(&quot;lastVersion&quot;)));</b>
&nbsp;            Pattern p;
&nbsp;            try {
<b class="fc">&nbsp;                p = Pattern.compile(o.getString(&quot;pattern&quot;));</b>
<b class="nc">&nbsp;            } catch (PatternSyntaxException ex) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to compile pattern &#39;&quot; + o.getString(&quot;pattern&quot;) + &quot;&#39;, using &#39;.*&#39; instead&quot;, ex);</b>
<b class="nc">&nbsp;                p = Pattern.compile(&quot;.*&quot;);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            this.pattern = p;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean includes(VersionNumber number) {
<b class="nc">&nbsp;            return pattern.matcher(number.toString()).matches();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a deprecation of a certain component. Jenkins project policy determines exactly what it means.
&nbsp;     *
&nbsp;     * @since 2.246
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static final class Deprecation {
&nbsp;        /**
&nbsp;         * URL for this deprecation.
&nbsp;         *
&nbsp;         * Jenkins will show a link to this URL when displaying the deprecation message.
&nbsp;         */
&nbsp;        public final String url;
&nbsp;
<b class="fc">&nbsp;        public Deprecation(String url) {</b>
<b class="fc">&nbsp;            this.url = url;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="nc">&nbsp;            if (this == o) return true;</b>
<b class="nc">&nbsp;            if (o == null || getClass() != o.getClass()) return false;</b>
<b class="nc">&nbsp;            Deprecation that = (Deprecation) o;</b>
<b class="nc">&nbsp;            return Objects.equals(url, that.url);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return Objects.hash(url);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    @Restricted(NoExternalUse.class)</b>
&nbsp;    public enum WarningType {
<b class="fc">&nbsp;        CORE,</b>
<b class="fc">&nbsp;        PLUGIN,</b>
<b class="fc">&nbsp;        UNKNOWN</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a warning about a certain component, mostly related to known security issues.
&nbsp;     *
&nbsp;     * @see UpdateSiteWarningsConfiguration
&nbsp;     * @see jenkins.security.UpdateSiteWarningsMonitor
&nbsp;     *
&nbsp;     * @since 2.40
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public final class Warning {
&nbsp;
&nbsp;        /**
&nbsp;         * The type classifier for this warning.
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public /* final */ WarningType type;
&nbsp;
&nbsp;        /**
&nbsp;         * The globally unique ID of this warning.
&nbsp;         *
&nbsp;         * &lt;p&gt;This is typically the CVE identifier or SECURITY issue (Jenkins project);
&nbsp;         * possibly with a unique suffix (e.g. artifactId) if either applies to multiple components.&lt;/p&gt;
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public final String id;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the affected component.
&nbsp;         * &lt;ul&gt;
&nbsp;         *   &lt;li&gt;If type is &#39;core&#39;, this is &#39;core&#39; by convention.
&nbsp;         *   &lt;li&gt;If type is &#39;plugin&#39;, this is the artifactId of the affected plugin
&nbsp;         * &lt;/ul&gt;
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public final String component;
&nbsp;
&nbsp;        /**
&nbsp;         * A short, English language explanation for this warning.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public final String message;
&nbsp;
&nbsp;        /**
&nbsp;         * A URL with more information about this, typically a security advisory. For use in administrator notices
&nbsp;         * only, so
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public final String url;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of named version ranges specifying which versions of the named component this warning applies to.
&nbsp;         *
&nbsp;         * If this list is empty, all versions of the component are considered to be affected by this warning.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public final List&lt;WarningVersionRange&gt; versionRanges;
&nbsp;
&nbsp;        /**
&nbsp;         *
&nbsp;         * @param o the {@link JSONObject} representing the warning
&nbsp;         * @throws JSONException if the argument does not match the expected format
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
<b class="fc">&nbsp;        public Warning(JSONObject o) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                this.type = WarningType.valueOf(o.getString(&quot;type&quot;).toUpperCase(Locale.US));</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException ex) {</b>
<b class="nc">&nbsp;                this.type = WarningType.UNKNOWN;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            this.id = o.getString(&quot;id&quot;);</b>
<b class="fc">&nbsp;            this.component = Util.intern(o.getString(&quot;name&quot;));</b>
<b class="fc">&nbsp;            this.message = o.getString(&quot;message&quot;);</b>
<b class="fc">&nbsp;            this.url = o.getString(&quot;url&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            if (o.has(&quot;versions&quot;)) {</b>
<b class="fc">&nbsp;                JSONArray versions = o.getJSONArray(&quot;versions&quot;);</b>
<b class="fc">&nbsp;                List&lt;WarningVersionRange&gt; ranges = new ArrayList&lt;&gt;(versions.size());</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; versions.size(); i++) {</b>
<b class="fc">&nbsp;                    WarningVersionRange range = new WarningVersionRange(versions.getJSONObject(i));</b>
<b class="fc">&nbsp;                    ranges.add(range);</b>
&nbsp;                }
<b class="fc">&nbsp;                this.versionRanges = Collections.unmodifiableList(ranges);</b>
<b class="fc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                this.versionRanges = Collections.emptyList();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Two objects are considered equal if they are the same type and have the same ID.
&nbsp;         *
&nbsp;         * @param o the other object
&nbsp;         * @return true iff this object and the argument are considered equal
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="nc">&nbsp;            if (this == o) return true;</b>
<b class="nc">&nbsp;            if (!(o instanceof Warning)) return false;</b>
&nbsp;
<b class="nc">&nbsp;            Warning warning = (Warning) o;</b>
&nbsp;
<b class="nc">&nbsp;            return id.equals(warning.id);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return id.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPluginWarning(@NonNull String pluginName) {
<b class="nc">&nbsp;            return type == WarningType.PLUGIN &amp;&amp; pluginName.equals(this.component);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if this warning is relevant to the current configuration
&nbsp;         * @return true if this warning is relevant to the current configuration
&nbsp;         */
&nbsp;        public boolean isRelevant() {
<b class="nc">&nbsp;            switch (this.type) {</b>
&nbsp;                case CORE:
<b class="nc">&nbsp;                    VersionNumber current = Jenkins.getVersion();</b>
<b class="nc">&nbsp;                    return isRelevantToVersion(current);</b>
&nbsp;                case PLUGIN:
&nbsp;
&nbsp;                    // check whether plugin is installed
<b class="nc">&nbsp;                    PluginWrapper plugin = Jenkins.get().getPluginManager().getPlugin(this.component);</b>
<b class="nc">&nbsp;                    if (plugin == null) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // check whether warning is relevant to installed version
<b class="nc">&nbsp;                    VersionNumber currentCore = plugin.getVersionNumber();</b>
<b class="nc">&nbsp;                    if (!isRelevantToVersion(currentCore)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                case UNKNOWN:
&nbsp;                default:
<b class="nc">&nbsp;                    return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns whether this warning is fixable by updating the affected component.
&nbsp;         * @return {@code true} if the warning does not apply to the latest offered version of core or the affected plugin;
&nbsp;         * {@code false} if it does; and {@code null} when the affected component isn&#39;t being offered, or it&#39;s a warning
&nbsp;         * for something other than core or a plugin.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_BOOLEAN_RETURN_NULL&quot;)
&nbsp;        public Boolean isFixable() {
<b class="nc">&nbsp;            final Data data = UpdateSite.this.data;</b>
<b class="nc">&nbsp;            if (data == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            switch (this.type) {</b>
&nbsp;                case CORE: {
<b class="nc">&nbsp;                    final Entry core = data.core;</b>
<b class="nc">&nbsp;                    if (core == null) {</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final VersionNumber latestCoreVersion = new VersionNumber(core.version);</b>
<b class="nc">&nbsp;                    return !isRelevantToVersion(latestCoreVersion);</b>
&nbsp;                }
&nbsp;                case PLUGIN: {
<b class="nc">&nbsp;                    final Entry plugin = data.plugins.get(component);</b>
<b class="nc">&nbsp;                    if (plugin == null) {</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    final VersionNumber latestCoreVersion = new VersionNumber(plugin.version);</b>
<b class="nc">&nbsp;                    return !isRelevantToVersion(latestCoreVersion);</b>
&nbsp;                }
&nbsp;                default:
<b class="nc">&nbsp;                    return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRelevantToVersion(@NonNull VersionNumber version) {
<b class="nc">&nbsp;            if (this.versionRanges.isEmpty()) {</b>
&nbsp;                // no version ranges specified, so all versions are affected
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (UpdateSite.WarningVersionRange range : this.versionRanges) {</b>
<b class="nc">&nbsp;                if (range.includes(version)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static String get(JSONObject o, String prop) {
<b class="fc">&nbsp;        if (o.has(prop))</b>
<b class="fc">&nbsp;            return o.getString(prop);</b>
&nbsp;        else
<b class="fc">&nbsp;            return null;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static final Predicate&lt;Object&gt; IS_DEP_PREDICATE = x -&gt; x instanceof JSONObject &amp;&amp; get((JSONObject) x, &quot;name&quot;) != null;</b>
<b class="fc">&nbsp;    static final Predicate&lt;Object&gt; IS_NOT_OPTIONAL = x -&gt; &quot;false&quot;.equals(get((JSONObject) x, &quot;optional&quot;));</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Metadata for one issue tracker provided by the update site.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static final class IssueTracker {
&nbsp;        /**
&nbsp;         * A string specifying the type of issue tracker.
&nbsp;         */
&nbsp;        public final String type;
&nbsp;        /**
&nbsp;         * Issue tracker URL that can be used to view previously reported issues.
&nbsp;         */
&nbsp;        public final String viewUrl;
&nbsp;        /**
&nbsp;         * Issue tracker URL that can be used to report a new issue.
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        public final String reportUrl;
&nbsp;
<b class="fc">&nbsp;        public IssueTracker(@NonNull String type, @NonNull String viewUrl, @CheckForNull String reportUrl) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.viewUrl = viewUrl;</b>
<b class="fc">&nbsp;            this.reportUrl = reportUrl;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static IssueTracker createFromJSONObject(Object o) {
<b class="fc">&nbsp;            if (o instanceof JSONObject) {</b>
<b class="fc">&nbsp;                JSONObject jsonObject = (JSONObject) o;</b>
<b class="fc">&nbsp;                if (jsonObject.has(&quot;type&quot;) &amp;&amp; jsonObject.has(&quot;viewUrl&quot;) &amp;&amp; jsonObject.has(&quot;reportUrl&quot;)) {</b>
<b class="fc">&nbsp;                    return new IssueTracker(jsonObject.getString(&quot;type&quot;), jsonObject.getString(&quot;viewUrl&quot;), jsonObject.getString(&quot;reportUrl&quot;));</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public final class Plugin extends Entry {
&nbsp;        /**
&nbsp;         * Optional URL to the Wiki page that discusses this plugin.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String wiki;
&nbsp;        /**
&nbsp;         * Human readable title of the plugin, taken from Wiki page.
&nbsp;         * Can be null.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * beware of XSS vulnerability since this data comes from Wiki
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String title;
&nbsp;        /**
&nbsp;         * Optional excerpt string.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String excerpt;
&nbsp;        /**
&nbsp;         * Optional version # from which this plugin release is configuration-compatible.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String compatibleSinceVersion;
&nbsp;        /**
&nbsp;         * Version of Jenkins core this plugin was compiled against.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final String requiredCore;
&nbsp;        /**
&nbsp;         * Categories for grouping plugins, taken from labels assigned to wiki page.
&nbsp;         * Can be {@code null} if the update center does not return categories.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @CheckForNull
&nbsp;        public final String[] categories;
&nbsp;
&nbsp;        /**
&nbsp;         * Dependencies of this plugin, a name -&amp;gt; version mapping.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final Map&lt;String, String&gt; dependencies;
&nbsp;
&nbsp;        /**
&nbsp;         * Optional dependencies of this plugin.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final Map&lt;String, String&gt; optionalDependencies;
&nbsp;
&nbsp;        /**
&nbsp;         * Set of plugins, this plugin is a incompatible dependency to.
&nbsp;         */
&nbsp;        private Set&lt;Plugin&gt; incompatibleParentPlugins;
&nbsp;
&nbsp;        /**
&nbsp;         * Date when this plugin was released.
&nbsp;         * @since 2.224
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final Date releaseTimestamp;
&nbsp;
&nbsp;        /**
&nbsp;         * Popularity of this plugin.
&nbsp;         *
&nbsp;         * @since 2.233
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public final Double popularity;
&nbsp;
&nbsp;        /**
&nbsp;         * Issue trackers associated with this plugin.
&nbsp;         * This list is sorted by preference in descending order, meaning a UI
&nbsp;         * supporting only one issue tracker should reference the first one
&nbsp;         * supporting the desired behavior (like having a {@code reportUrl}).
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public IssueTracker[] issueTrackers;
&nbsp;
&nbsp;        @DataBoundConstructor
<b class="fc">&nbsp;        public Plugin(String sourceId, JSONObject o) {</b>
<b class="fc">&nbsp;            super(sourceId, o, UpdateSite.this.url);</b>
<b class="fc">&nbsp;            this.wiki = get(o, &quot;wiki&quot;);</b>
<b class="fc">&nbsp;            this.title = get(o, &quot;title&quot;);</b>
<b class="fc">&nbsp;            this.excerpt = get(o, &quot;excerpt&quot;);</b>
<b class="fc">&nbsp;            this.compatibleSinceVersion = Util.intern(get(o, &quot;compatibleSinceVersion&quot;));</b>
<b class="fc">&nbsp;            this.requiredCore = Util.intern(get(o, &quot;requiredCore&quot;));</b>
<b class="fc">&nbsp;            final String releaseTimestamp = get(o, &quot;releaseTimestamp&quot;);</b>
<b class="fc">&nbsp;            Date date = null;</b>
<b class="fc">&nbsp;            if (releaseTimestamp != null) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    date = Date.from(Instant.parse(releaseTimestamp));</b>
<b class="nc">&nbsp;                } catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Failed to parse releaseTimestamp for &quot; + title + &quot; from &quot; + sourceId, ex);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            final String popularityFromJson = get(o, &quot;popularity&quot;);</b>
<b class="fc">&nbsp;            double popularity = 0.0;</b>
<b class="fc">&nbsp;            if (popularityFromJson != null) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    popularity = Double.parseDouble(popularityFromJson);</b>
<b class="nc">&nbsp;                } catch (NumberFormatException nfe) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Failed to parse popularity: &#39;&quot; + popularityFromJson + &quot;&#39; for plugin &quot; + this.title);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            this.popularity = popularity;</b>
<b class="fc">&nbsp;            this.releaseTimestamp = date;</b>
<b class="fc">&nbsp;            this.categories = o.has(&quot;labels&quot;) ? PluginLabelUtil.canonicalLabels(o.getJSONArray(&quot;labels&quot;)) : null;</b>
<b class="fc">&nbsp;            this.issueTrackers = o.has(&quot;issueTrackers&quot;) ? o.getJSONArray(&quot;issueTrackers&quot;).stream().map(IssueTracker::createFromJSONObject).filter(Objects::nonNull).toArray(IssueTracker[]::new) : null;</b>
&nbsp;
<b class="fc">&nbsp;            JSONArray ja = o.getJSONArray(&quot;dependencies&quot;);</b>
<b class="fc">&nbsp;            int depCount = (int) ja.stream().filter(IS_DEP_PREDICATE.and(IS_NOT_OPTIONAL)).count();</b>
<b class="fc">&nbsp;            int optionalDepCount = (int) ja.stream().filter(IS_DEP_PREDICATE.and(IS_NOT_OPTIONAL.negate())).count();</b>
<b class="fc">&nbsp;            dependencies = getPresizedMutableMap(depCount);</b>
<b class="fc">&nbsp;            optionalDependencies = getPresizedMutableMap(optionalDepCount);</b>
&nbsp;
<b class="fc">&nbsp;            for (Object jo : o.getJSONArray(&quot;dependencies&quot;)) {</b>
<b class="fc">&nbsp;                JSONObject depObj = (JSONObject) jo;</b>
&nbsp;                // Make sure there&#39;s a name attribute and that the optional value isn&#39;t true.
<b class="fc">&nbsp;                String depName = Util.intern(get(depObj, &quot;name&quot;));</b>
<b class="fc">&nbsp;                if (depName != null) {</b>
<b class="fc">&nbsp;                    if (get(depObj, &quot;optional&quot;).equals(&quot;false&quot;)) {</b>
<b class="fc">&nbsp;                        dependencies.put(depName, Util.intern(get(depObj, &quot;version&quot;)));</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        optionalDependencies.put(depName, Util.intern(get(depObj, &quot;version&quot;)));</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public boolean isDeprecated() {
<b class="nc">&nbsp;            return getDeprecation() != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public UpdateSite.Deprecation getDeprecation() {
<b class="nc">&nbsp;            return Jenkins.get().getUpdateCenter().getSite(sourceId).getData().getDeprecations().get(this.name);</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getDisplayName() {
&nbsp;            String displayName;
<b class="nc">&nbsp;            if (title != null)</b>
<b class="nc">&nbsp;                displayName = title;</b>
&nbsp;            else
<b class="nc">&nbsp;                displayName = name;</b>
<b class="nc">&nbsp;            return StringUtils.removeStart(displayName, &quot;Jenkins &quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If some version of this plugin is currently installed, return {@link PluginWrapper}.
&nbsp;         * Otherwise null.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public PluginWrapper getInstalled() {
<b class="nc">&nbsp;            PluginManager pm = Jenkins.get().getPluginManager();</b>
<b class="nc">&nbsp;            return pm.getPlugin(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if the plugin and its dependencies are fully compatible with the current installation
&nbsp;         * This is set to restricted for now, since it is only being used by Jenkins UI or Restful API at the moment.
&nbsp;         *
&nbsp;         * @since 2.175
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        @Exported
&nbsp;        public boolean isCompatible() {
<b class="nc">&nbsp;            return isCompatible(new PluginManager.MetadataCache());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class) // table.jelly
&nbsp;        public boolean isCompatible(PluginManager.MetadataCache cache) {
<b class="nc">&nbsp;            return isCompatibleWithInstalledVersion() &amp;&amp; !isForNewerHudson() &amp;&amp;</b>
<b class="nc">&nbsp;                    isNeededDependenciesCompatibleWithInstalledVersion(cache) &amp;&amp;</b>
<b class="nc">&nbsp;                    !isNeededDependenciesForNewerJenkins(cache);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If the plugin is already installed, and the new version of the plugin has a &quot;compatibleSinceVersion&quot;
&nbsp;         * value (i.e., it&#39;s only directly compatible with that version or later), this will check to
&nbsp;         * see if the installed version is older than the compatible-since version. If it is older, it&#39;ll return false.
&nbsp;         * If it&#39;s not older, or it&#39;s not installed, or it&#39;s installed but there&#39;s no compatibleSinceVersion
&nbsp;         * specified, it&#39;ll return true.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public boolean isCompatibleWithInstalledVersion() {
<b class="nc">&nbsp;            PluginWrapper installedVersion = getInstalled();</b>
<b class="nc">&nbsp;            if (installedVersion != null) {</b>
<b class="nc">&nbsp;                if (compatibleSinceVersion != null) {</b>
<b class="nc">&nbsp;                    if (new VersionNumber(installedVersion.getVersion())</b>
<b class="nc">&nbsp;                            .isOlderThan(new VersionNumber(compatibleSinceVersion))) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a list of dependent plugins which need to be installed or upgraded for this plugin to work.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public List&lt;Plugin&gt; getNeededDependencies() {
<b class="nc">&nbsp;            List&lt;Plugin&gt; deps = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            for (Map.Entry&lt;String, String&gt; e : dependencies.entrySet()) {</b>
<b class="nc">&nbsp;                VersionNumber requiredVersion = e.getValue() != null ? new VersionNumber(e.getValue()) : null;</b>
<b class="nc">&nbsp;                Plugin depPlugin = Jenkins.get().getUpdateCenter().getPlugin(e.getKey(), requiredVersion);</b>
<b class="nc">&nbsp;                if (depPlugin == null) {</b>
<b class="nc">&nbsp;                    LOGGER.log(warnedMissing.add(e.getKey()) ? Level.WARNING : Level.FINE, &quot;Could not find dependency {0} of {1}&quot;, new Object[] {e.getKey(), name});</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Is the plugin installed already? If not, add it.
<b class="nc">&nbsp;                PluginWrapper current = depPlugin.getInstalled();</b>
&nbsp;
<b class="nc">&nbsp;                if (current == null) {</b>
<b class="nc">&nbsp;                    deps.add(depPlugin);</b>
&nbsp;                }
&nbsp;                // If the dependency plugin is installed, is the version we depend on newer than
&nbsp;                // what&#39;s installed? If so, upgrade.
<b class="nc">&nbsp;                else if (current.isOlderThan(requiredVersion)) {</b>
<b class="nc">&nbsp;                    deps.add(depPlugin);</b>
&nbsp;                }
&nbsp;                // JENKINS-34494 - or if the plugin is disabled, this will allow us to enable it
<b class="nc">&nbsp;                else if (!current.isEnabled()) {</b>
<b class="nc">&nbsp;                    deps.add(depPlugin);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            for (Map.Entry&lt;String, String&gt; e : optionalDependencies.entrySet()) {</b>
<b class="nc">&nbsp;                VersionNumber requiredVersion = e.getValue() != null ? new VersionNumber(e.getValue()) : null;</b>
<b class="nc">&nbsp;                Plugin depPlugin = Jenkins.get().getUpdateCenter().getPlugin(e.getKey(), requiredVersion);</b>
<b class="nc">&nbsp;                if (depPlugin == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                PluginWrapper current = depPlugin.getInstalled();</b>
&nbsp;
&nbsp;                // If the optional dependency plugin is installed, is the version we depend on newer than
&nbsp;                // what&#39;s installed? If so, upgrade.
<b class="nc">&nbsp;                if (current != null &amp;&amp; current.isOlderThan(requiredVersion)) {</b>
<b class="nc">&nbsp;                    deps.add(depPlugin);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return deps;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isForNewerHudson() {
&nbsp;            try {
<b class="nc">&nbsp;                return requiredCore != null &amp;&amp; new VersionNumber(requiredCore).isNewerThan(</b>
<b class="nc">&nbsp;                  new VersionNumber(Jenkins.VERSION.replaceFirst(&quot;SHOT *\\(private.*\\)&quot;, &quot;SHOT&quot;)));</b>
<b class="nc">&nbsp;            } catch (NumberFormatException nfe) {</b>
<b class="nc">&nbsp;                return true;  // If unable to parse version</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public VersionNumber getNeededDependenciesRequiredCore() {
<b class="nc">&nbsp;            VersionNumber versionNumber = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                versionNumber = requiredCore == null ? null : new VersionNumber(requiredCore);</b>
<b class="nc">&nbsp;            } catch (NumberFormatException nfe) {</b>
&nbsp;                // unable to parse version
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            for (Plugin p : getNeededDependencies()) {</b>
<b class="nc">&nbsp;                VersionNumber v = p.getNeededDependenciesRequiredCore();</b>
<b class="nc">&nbsp;                if (versionNumber == null || v.isNewerThan(versionNumber)) versionNumber = v;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return versionNumber;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNeededDependenciesForNewerJenkins() {
<b class="nc">&nbsp;            return isNeededDependenciesForNewerJenkins(new PluginManager.MetadataCache());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class) // table.jelly
&nbsp;        public boolean isNeededDependenciesForNewerJenkins(PluginManager.MetadataCache cache) {
<b class="nc">&nbsp;            return cache.of(&quot;isNeededDependenciesForNewerJenkins:&quot; + name, Boolean.class, () -&gt; {</b>
<b class="nc">&nbsp;                for (Plugin p : getNeededDependencies()) {</b>
<b class="nc">&nbsp;                    if (p.isForNewerHudson() || p.isNeededDependenciesForNewerJenkins()) {</b>
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If at least some of the plugin&#39;s needed dependencies are already installed, and the new version of the
&nbsp;         * needed dependencies plugin have a &quot;compatibleSinceVersion&quot;
&nbsp;         * value (i.e., it&#39;s only directly compatible with that version or later), this will check to
&nbsp;         * see if the installed version is older than the compatible-since version. If it is older, it&#39;ll return false.
&nbsp;         * If it&#39;s not older, or it&#39;s not installed, or it&#39;s installed but there&#39;s no compatibleSinceVersion
&nbsp;         * specified, it&#39;ll return true.
&nbsp;         */
&nbsp;        public boolean isNeededDependenciesCompatibleWithInstalledVersion() {
<b class="nc">&nbsp;            return isNeededDependenciesCompatibleWithInstalledVersion(new PluginManager.MetadataCache());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class) // table.jelly
&nbsp;        public boolean isNeededDependenciesCompatibleWithInstalledVersion(PluginManager.MetadataCache cache) {
<b class="nc">&nbsp;            return getDependenciesIncompatibleWithInstalledVersion(cache).isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if and only if this update addressed a currently active security vulnerability.
&nbsp;         *
&nbsp;         * @return true if and only if this update addressed a currently active security vulnerability.
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class) // Jelly
&nbsp;        public boolean fixesSecurityVulnerabilities() {
<b class="nc">&nbsp;            final PluginWrapper installed = getInstalled();</b>
<b class="nc">&nbsp;            if (installed == null) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean allWarningsStillApply = true;</b>
<b class="nc">&nbsp;            for (Warning warning : ExtensionList.lookupSingleton(UpdateSiteWarningsMonitor.class).getActivePluginWarningsByPlugin().getOrDefault(installed, Collections.emptyList())) {</b>
<b class="nc">&nbsp;                boolean thisWarningApplies = false;</b>
<b class="nc">&nbsp;                for (WarningVersionRange range : warning.versionRanges) {</b>
<b class="nc">&nbsp;                    if (range.includes(new VersionNumber(version))) {</b>
<b class="nc">&nbsp;                        thisWarningApplies = true;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (!thisWarningApplies) {</b>
<b class="nc">&nbsp;                    allWarningsStillApply = false;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return !allWarningsStillApply;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get the list of incompatible dependencies (if there are any, as determined by isNeededDependenciesCompatibleWithInstalledVersion)
&nbsp;         *
&nbsp;         * @since 2.203
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class) // table.jelly
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public List&lt;Plugin&gt; getDependenciesIncompatibleWithInstalledVersion(PluginManager.MetadataCache cache) {
<b class="nc">&nbsp;            return cache.of(&quot;getDependenciesIncompatibleWithInstalledVersion:&quot; + name, List.class, () -&gt; {</b>
<b class="nc">&nbsp;                List&lt;Plugin&gt; incompatiblePlugins = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Plugin p : getNeededDependencies()) {</b>
<b class="nc">&nbsp;                    if (!p.isCompatibleWithInstalledVersion() || !p.isNeededDependenciesCompatibleWithInstalledVersion()) {</b>
<b class="nc">&nbsp;                        incompatiblePlugins.add(p);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return incompatiblePlugins;</b>
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        public void setIncompatibleParentPlugins(Set&lt;Plugin&gt; incompatibleParentPlugins) {
<b class="nc">&nbsp;            this.incompatibleParentPlugins = incompatibleParentPlugins;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class) // table.jelly
&nbsp;        public Set&lt;Plugin&gt; getIncompatibleParentPlugins() {
<b class="nc">&nbsp;            return this.incompatibleParentPlugins;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class) // table.jelly
&nbsp;        public boolean hasIncompatibleParentPlugins() {
<b class="nc">&nbsp;            return this.incompatibleParentPlugins != null &amp;&amp; !this.incompatibleParentPlugins.isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @since 2.40
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public Set&lt;Warning&gt; getWarnings() {
<b class="nc">&nbsp;            UpdateSiteWarningsConfiguration configuration = ExtensionList.lookupSingleton(UpdateSiteWarningsConfiguration.class);</b>
<b class="nc">&nbsp;            Set&lt;Warning&gt; warnings = new HashSet&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            for (Warning warning : configuration.getAllWarnings()) {</b>
<b class="nc">&nbsp;                if (configuration.isIgnored(warning)) {</b>
&nbsp;                    // warning is currently being ignored
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!warning.isPluginWarning(this.name)) {</b>
&nbsp;                    // warning is not about this plugin
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (!warning.isRelevantToVersion(new VersionNumber(this.version))) {</b>
&nbsp;                    // warning is not relevant to this version
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                warnings.add(warning);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return warnings;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks whether a plugin has a desired category
&nbsp;         * @since 2.272
&nbsp;         */
&nbsp;        public boolean hasCategory(String category) {
<b class="fc">&nbsp;            if (categories == null) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // TODO: cache it in a hashset for performance improvements
<b class="fc">&nbsp;            return Arrays.asList(categories).contains(category);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Get categories stream for further search.
&nbsp;         * @since 2.272
&nbsp;         */
&nbsp;        public Stream&lt;String&gt; getCategoriesStream() {
<b class="nc">&nbsp;            return categories != null ? Arrays.stream(categories) : Stream.empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @since 2.40
&nbsp;         */
&nbsp;        @Restricted(DoNotUse.class)
&nbsp;        public boolean hasWarnings() {
<b class="nc">&nbsp;            return getWarnings().size() &gt; 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated as of 1.326
&nbsp;         *      Use {@link #deploy()}.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public void install() {
<b class="nc">&nbsp;            deploy();</b>
&nbsp;        }
&nbsp;
&nbsp;        public Future&lt;UpdateCenterJob&gt; deploy() {
<b class="nc">&nbsp;            return deploy(false);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Schedules the installation of this plugin.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This is mainly intended to be called from the UI. The actual installation work happens
&nbsp;         * asynchronously in another thread.
&nbsp;         *
&nbsp;         * @param dynamicLoad
&nbsp;         *      If true, the plugin will be dynamically loaded into this Jenkins. If false,
&nbsp;         *      the plugin will only take effect after the reboot.
&nbsp;         *      See {@link UpdateCenter#isRestartRequiredForCompletion()}
&nbsp;         */
&nbsp;        public Future&lt;UpdateCenterJob&gt; deploy(boolean dynamicLoad) {
<b class="nc">&nbsp;            return deploy(dynamicLoad, null, null, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Schedules the installation of this plugin.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This is mainly intended to be called from the UI. The actual installation work happens
&nbsp;         * asynchronously in another thread.
&nbsp;         *
&nbsp;         * @param dynamicLoad
&nbsp;         *      If true, the plugin will be dynamically loaded into this Jenkins. If false,
&nbsp;         *      the plugin will only take effect after the reboot.
&nbsp;         *      See {@link UpdateCenter#isRestartRequiredForCompletion()}
&nbsp;         * @param correlationId A correlation ID to be set on the job.
&nbsp;         * @param batch if defined, a list of plugins to add to, which will be started later
&nbsp;         * @param hasEnabledDependents
&nbsp;         *      If true, this plugin will be enabled if this plugin is disabled.
&nbsp;         *      If false, this plugin will remain the current status.
&nbsp;         */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public Future&lt;UpdateCenterJob&gt; deploy(boolean dynamicLoad, @CheckForNull UUID correlationId, @CheckForNull List&lt;PluginWrapper&gt; batch, boolean hasEnabledDependents) {
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;            UpdateCenter uc = Jenkins.get().getUpdateCenter();</b>
<b class="nc">&nbsp;            PluginWrapper pw = getInstalled();</b>
<b class="nc">&nbsp;            for (Plugin dep : getNeededDependencies()) {</b>
<b class="nc">&nbsp;                UpdateCenter.InstallationJob job = uc.getJob(dep);</b>
<b class="nc">&nbsp;                if (job == null || job.status instanceof UpdateCenter.DownloadJob.Failure) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.INFO, &quot;Adding dependent install of &quot; + dep.name + &quot; for plugin &quot; + name);</b>
<b class="nc">&nbsp;                    if (pw == null) {</b>
<b class="nc">&nbsp;                        dep.deploy(dynamicLoad, /* UpdateCenterPluginInstallTest.test_installKnownPlugins specifically asks that these not be correlated */ null, batch, true);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        dep.deploy(dynamicLoad, null, batch, pw.isEnabled());</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Dependent install of {0} for plugin {1} already added, skipping&quot;, new Object[] {dep.name, name});</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (pw != null) { // JENKINS-34494 - check for this plugin being disabled</b>
<b class="nc">&nbsp;                Future&lt;UpdateCenterJob&gt; enableJob = null;</b>
<b class="nc">&nbsp;                if (!pw.isEnabled() &amp;&amp; hasEnabledDependents) {</b>
<b class="nc">&nbsp;                    UpdateCenter.EnableJob job = uc.new EnableJob(UpdateSite.this, null, this, dynamicLoad);</b>
<b class="nc">&nbsp;                    job.setCorrelationId(correlationId);</b>
<b class="nc">&nbsp;                    enableJob = uc.addJob(job);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (pw.getVersionNumber().equals(new VersionNumber(version))) {</b>
<b class="nc">&nbsp;                    return enableJob != null ? enableJob : uc.addJob(uc.new NoOpJob(UpdateSite.this, null, this));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            UpdateCenter.InstallationJob job = createInstallationJob(this, uc, dynamicLoad);</b>
<b class="nc">&nbsp;            job.setCorrelationId(correlationId);</b>
<b class="nc">&nbsp;            job.setBatch(batch);</b>
<b class="nc">&nbsp;            return uc.addJob(job);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Schedules the downgrade of this plugin.
&nbsp;         */
&nbsp;        public Future&lt;UpdateCenterJob&gt; deployBackup() {
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;            UpdateCenter uc = Jenkins.get().getUpdateCenter();</b>
<b class="nc">&nbsp;            return uc.addJob(uc.new PluginDowngradeJob(this, UpdateSite.this, Jenkins.getAuthentication2()));</b>
&nbsp;        }
&nbsp;        /**
&nbsp;         * Making the installation web bound.
&nbsp;         */
&nbsp;
&nbsp;        @RequirePOST
&nbsp;        public HttpResponse doInstall() throws IOException {
<b class="nc">&nbsp;            deploy(false);</b>
<b class="nc">&nbsp;            return HttpResponses.redirectTo(&quot;../..&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @RequirePOST
&nbsp;        public HttpResponse doInstallNow() throws IOException {
<b class="nc">&nbsp;            deploy(true);</b>
<b class="nc">&nbsp;            return HttpResponses.redirectTo(&quot;../..&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Performs the downgrade of the plugin.
&nbsp;         */
&nbsp;        @RequirePOST
&nbsp;        public HttpResponse doDowngrade() throws IOException {
<b class="nc">&nbsp;            deployBackup();</b>
<b class="nc">&nbsp;            return HttpResponses.redirectTo(&quot;../..&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final long DAY = DAYS.toMillis(1);</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(UpdateSite.class.getName());</b>
&nbsp;
&nbsp;    // The name uses UpdateCenter for compatibility reason.
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static boolean neverUpdate = SystemProperties.getBoolean(UpdateCenter.class.getName() + &quot;.never&quot;);</b>
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
