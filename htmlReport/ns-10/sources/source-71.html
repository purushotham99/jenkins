


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Slave</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: Slave (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Slave</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/128)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Slave$GetClockDifference1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Slave$GetClockDifference2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Slave$GetClockDifference3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Slave$JnlpJar</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Slave$SlaveDescriptor</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    13%
  </span>
  <span class="absValue">
    (3/23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    3.3%
  </span>
  <span class="absValue">
    (2/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1.4%
  </span>
  <span class="absValue">
    (3/207)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Erik Ramfelt, Martin Eigenbrodt, Stephen Connolly, Tom Huybrechts
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import hudson.DescriptorExtensionList;
&nbsp;import hudson.EnvVars;
&nbsp;import hudson.FilePath;
&nbsp;import hudson.Launcher;
&nbsp;import hudson.Launcher.RemoteLauncher;
&nbsp;import hudson.RestrictedSince;
&nbsp;import hudson.Util;
&nbsp;import hudson.cli.CLI;
&nbsp;import hudson.model.Descriptor.FormException;
&nbsp;import hudson.model.labels.LabelAtom;
&nbsp;import hudson.remoting.Callable;
&nbsp;import hudson.remoting.Channel;
&nbsp;import hudson.remoting.Which;
&nbsp;import hudson.slaves.ComputerLauncher;
&nbsp;import hudson.slaves.DumbSlave;
&nbsp;import hudson.slaves.JNLPLauncher;
&nbsp;import hudson.slaves.NodeDescriptor;
&nbsp;import hudson.slaves.NodeProperty;
&nbsp;import hudson.slaves.NodePropertyDescriptor;
&nbsp;import hudson.slaves.RetentionStrategy;
&nbsp;import hudson.slaves.SlaveComputer;
&nbsp;import hudson.util.ClockDifference;
&nbsp;import hudson.util.DescribableList;
&nbsp;import hudson.util.FormValidation;
&nbsp;import java.io.File;
&nbsp;import java.io.FileNotFoundException;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLConnection;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Set;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import javax.servlet.ServletException;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import jenkins.slaves.WorkspaceLocator;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.DataBoundSetter;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;
&nbsp;/**
&nbsp; * Information about a Hudson agent node.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Ideally this would have been in the {@code hudson.slaves} package,
&nbsp; * but for compatibility reasons, it can&#39;t.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * TODO: move out more stuff to {@link DumbSlave}.
&nbsp; *
&nbsp; * On February, 2016 a general renaming was done internally: the &quot;slave&quot; term was replaced by
&nbsp; * &quot;Agent&quot;. This change was applied in: UI labels/HTML pages, javadocs and log messages.
&nbsp; * Java classes, fields, methods, etc were not renamed to avoid compatibility issues.
&nbsp; * See &lt;a href=&quot;https://www.jenkins.io/issue/27268&quot;&gt;JENKINS-27268&lt;/a&gt;.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
<b class="nc">&nbsp;public abstract class Slave extends Node implements Serializable {</b>
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Slave.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Name of this agent node.
&nbsp;     */
&nbsp;    protected String name;
&nbsp;
&nbsp;    /**
&nbsp;     * Description of this node.
&nbsp;     */
&nbsp;    private String description;
&nbsp;
&nbsp;    /**
&nbsp;     * Path to the root of the workspace from the view point of this node, such as &quot;/hudson&quot;, this need not
&nbsp;     * be absolute provided that the launcher establishes a consistent working directory, such as &quot;./.jenkins-agent&quot;
&nbsp;     * when used with an SSH launcher.
&nbsp;     *
&nbsp;     * NOTE: if the administrator is using a relative path they are responsible for ensuring that the launcher used
&nbsp;     * provides a consistent working directory
&nbsp;     */
&nbsp;    protected final String remoteFS;
&nbsp;
&nbsp;    /**
&nbsp;     * Number of executors of this node.
&nbsp;     */
<b class="nc">&nbsp;    private int numExecutors = 1;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Job allocation strategy.
&nbsp;     */
<b class="nc">&nbsp;    private Mode mode = Mode.NORMAL;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Agent availability strategy.
&nbsp;     */
&nbsp;    private RetentionStrategy retentionStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * The starter that will startup this agent.
&nbsp;     */
&nbsp;    private ComputerLauncher launcher;
&nbsp;
&nbsp;    /**
&nbsp;     * Whitespace-separated labels.
&nbsp;     */
<b class="nc">&nbsp;    private String label = &quot;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;    private /*almost final*/ DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; nodeProperties =</b>
&nbsp;            new DescribableList&lt;&gt;(this);
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Removed with no replacement.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    private transient String userId;
&nbsp;
&nbsp;    /**
&nbsp;     * Use {@link #Slave(String, String, ComputerLauncher)} and set the rest through setters.
&nbsp;     * @deprecated since 2.184
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    protected Slave(String name, String nodeDescription, String remoteFS, String numExecutors,
&nbsp;                 Mode mode, String labelString, ComputerLauncher launcher, RetentionStrategy retentionStrategy, List&lt;? extends NodeProperty&lt;?&gt;&gt; nodeProperties) throws FormException, IOException {
<b class="nc">&nbsp;        this(name, nodeDescription, remoteFS, Util.tryParseNumber(numExecutors, 1).intValue(), mode, labelString, launcher, retentionStrategy, nodeProperties);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated since 2009-02-20.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    protected Slave(String name, String nodeDescription, String remoteFS, int numExecutors,
&nbsp;            Mode mode, String labelString, ComputerLauncher launcher, RetentionStrategy retentionStrategy) throws FormException, IOException {
<b class="nc">&nbsp;        this(name, nodeDescription, remoteFS, numExecutors, mode, labelString, launcher, retentionStrategy, new ArrayList());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected Slave(@NonNull String name, String remoteFS, ComputerLauncher launcher) throws FormException, IOException {</b>
<b class="nc">&nbsp;        this.name = name;</b>
<b class="nc">&nbsp;        this.remoteFS = remoteFS;</b>
<b class="nc">&nbsp;        this.launcher = launcher;</b>
<b class="nc">&nbsp;        this.labelAtomSet = Collections.unmodifiableSet(Label.parse(label));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 2.2
&nbsp;     *      Use {@link #Slave(String, String, ComputerLauncher)} and set the rest through setters.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    protected Slave(@NonNull String name, String nodeDescription, String remoteFS, int numExecutors,
<b class="nc">&nbsp;                 Mode mode, String labelString, ComputerLauncher launcher, RetentionStrategy retentionStrategy, List&lt;? extends NodeProperty&lt;?&gt;&gt; nodeProperties) throws FormException, IOException {</b>
<b class="nc">&nbsp;        this.name = name;</b>
<b class="nc">&nbsp;        this.description = nodeDescription;</b>
<b class="nc">&nbsp;        this.numExecutors = numExecutors;</b>
<b class="nc">&nbsp;        this.mode = mode;</b>
<b class="nc">&nbsp;        this.remoteFS = Util.fixNull(remoteFS).trim();</b>
<b class="nc">&nbsp;        _setLabelString(labelString);</b>
<b class="nc">&nbsp;        this.launcher = launcher;</b>
<b class="nc">&nbsp;        this.retentionStrategy = retentionStrategy;</b>
<b class="nc">&nbsp;        getAssignedLabels();    // compute labels now</b>
&nbsp;
<b class="nc">&nbsp;        this.nodeProperties.replaceBy(nodeProperties);</b>
&nbsp;
<b class="nc">&nbsp;        if (name.isEmpty())</b>
<b class="nc">&nbsp;            throw new FormException(Messages.Slave_InvalidConfig_NoName(), null);</b>
&nbsp;
<b class="nc">&nbsp;        if (this.numExecutors &lt;= 0)</b>
<b class="nc">&nbsp;            throw new FormException(Messages.Slave_InvalidConfig_Executors(name), null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return id of user which created this agent
&nbsp;     *
&nbsp;     * @return id of user
&nbsp;     *
&nbsp;     * @deprecated Removed with no replacement
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    @RestrictedSince(&quot;2.220&quot;)
&nbsp;    public String getUserId() {
<b class="nc">&nbsp;        return userId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method no longer does anything.
&nbsp;     *
&nbsp;     * @deprecated Removed with no replacement
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    @RestrictedSince(&quot;2.220&quot;)
&nbsp;    public void setUserId(String userId){
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public ComputerLauncher getLauncher() {
<b class="nc">&nbsp;        if (launcher == null &amp;&amp; agentCommand != null &amp;&amp; !agentCommand.isEmpty()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                launcher = (ComputerLauncher) Jenkins.get().getPluginManager().uberClassLoader.loadClass(&quot;hudson.slaves.CommandLauncher&quot;).getConstructor(String.class, EnvVars.class).newInstance(agentCommand, null);</b>
<b class="nc">&nbsp;                agentCommand = null;</b>
<b class="nc">&nbsp;                save();</b>
<b class="nc">&nbsp;            } catch (Exception x) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;could not update historical agentCommand setting to CommandLauncher&quot;, x);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return launcher == null ? new JNLPLauncher() : launcher;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLauncher(ComputerLauncher launcher) {
<b class="nc">&nbsp;        this.launcher = launcher;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getRemoteFS() {
<b class="nc">&nbsp;        return remoteFS;</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public String getNodeName() {
<b class="nc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String toString() {
<b class="nc">&nbsp;        return getClass().getName() + &quot;[&quot; + name + &quot;]&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setNodeName(String name) {
<b class="nc">&nbsp;        this.name = name;</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundSetter
&nbsp;    public void setNodeDescription(String value) {
<b class="nc">&nbsp;        this.description = value;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getNodeDescription() {
<b class="nc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getNumExecutors() {
<b class="nc">&nbsp;        return numExecutors;</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundSetter
&nbsp;    public void setNumExecutors(int n) {
<b class="nc">&nbsp;        this.numExecutors = n;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Mode getMode() {
<b class="nc">&nbsp;        return mode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundSetter
&nbsp;    public void setMode(Mode mode) {
<b class="nc">&nbsp;        this.mode = mode;</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; getNodeProperties() {
<b class="nc">&nbsp;        assert nodeProperties != null;</b>
<b class="nc">&nbsp;        return nodeProperties;</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundSetter
&nbsp;    public void setNodeProperties(List&lt;? extends NodeProperty&lt;?&gt;&gt; properties) throws IOException {
<b class="nc">&nbsp;        if (nodeProperties == null) {</b>
<b class="nc">&nbsp;            warnPlugin();</b>
<b class="nc">&nbsp;            nodeProperties = new DescribableList&lt;&gt;(this);</b>
&nbsp;        }
<b class="nc">&nbsp;        nodeProperties.replaceBy(properties);</b>
&nbsp;    }
&nbsp;
&nbsp;    public RetentionStrategy getRetentionStrategy() {
<b class="nc">&nbsp;        return retentionStrategy == null ? RetentionStrategy.Always.INSTANCE : retentionStrategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundSetter
&nbsp;    public void setRetentionStrategy(RetentionStrategy availabilityStrategy) {
<b class="nc">&nbsp;        this.retentionStrategy = availabilityStrategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getLabelString() {
<b class="nc">&nbsp;        return Util.fixNull(label).trim();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @DataBoundSetter
&nbsp;    public void setLabelString(String labelString) throws IOException {
<b class="nc">&nbsp;        _setLabelString(labelString);</b>
&nbsp;        // Compute labels now.
<b class="nc">&nbsp;        getAssignedLabels();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _setLabelString(String labelString) {
<b class="nc">&nbsp;        this.label = Util.fixNull(labelString).trim();</b>
<b class="nc">&nbsp;        this.labelAtomSet = Collections.unmodifiableSet(Label.parse(label));</b>
&nbsp;    }
&nbsp;
&nbsp;    @CheckForNull // should be @NonNull, but we&#39;ve seen plugins overriding readResolve() without calling super.
&nbsp;    private transient Set&lt;LabelAtom&gt; labelAtomSet;
&nbsp;
&nbsp;    @Override
&nbsp;    protected Set&lt;LabelAtom&gt; getLabelAtomSet() {
<b class="nc">&nbsp;        if (labelAtomSet == null) {</b>
<b class="nc">&nbsp;            warnPlugin();</b>
<b class="nc">&nbsp;            this.labelAtomSet = Collections.unmodifiableSet(Label.parse(label));</b>
&nbsp;        }
<b class="nc">&nbsp;        return labelAtomSet;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void warnPlugin() {
<b class="nc">&nbsp;        LOGGER.log(Level.WARNING, () -&gt; getClass().getName() + &quot; or one of its superclass overrides readResolve() without calling super implementation.&quot; +</b>
<b class="nc">&nbsp;                &quot;Please file an issue against the plugin implementing it: &quot; + Jenkins.get().getPluginManager().whichPlugin(getClass()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Callable&lt;ClockDifference, IOException&gt; getClockDifferenceCallable() {
<b class="nc">&nbsp;        return new GetClockDifference1();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Computer createComputer() {
<b class="nc">&nbsp;        return new SlaveComputer(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public FilePath getWorkspaceFor(TopLevelItem item) {
<b class="nc">&nbsp;        for (WorkspaceLocator l : WorkspaceLocator.all()) {</b>
<b class="nc">&nbsp;            FilePath workspace = l.locate(item, this);</b>
<b class="nc">&nbsp;            if (workspace != null) {</b>
<b class="nc">&nbsp;                return workspace;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        FilePath r = getWorkspaceRoot();</b>
<b class="nc">&nbsp;        if (r == null)     return null;    // offline</b>
<b class="nc">&nbsp;        return r.child(item.getFullName());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @CheckForNull
&nbsp;    public FilePath getRootPath() {
<b class="nc">&nbsp;        final SlaveComputer computer = getComputer();</b>
<b class="nc">&nbsp;        if (computer == null) {</b>
&nbsp;            // if computer is null then channel is null and thus we were going to return null anyway
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return createPath(StringUtils.defaultString(computer.getAbsoluteRemoteFs(), remoteFS));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Root directory on this agent where all the job workspaces are laid out.
&nbsp;     * @return
&nbsp;     *      null if not connected.
&nbsp;     */
&nbsp;    public @CheckForNull FilePath getWorkspaceRoot() {
<b class="nc">&nbsp;        FilePath r = getRootPath();</b>
<b class="nc">&nbsp;        if (r == null) return null;</b>
<b class="nc">&nbsp;        return r.child(WORKSPACE_ROOT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Web-bound object used to serve jar files for inbound connections.
&nbsp;     */
&nbsp;    public static final class JnlpJar implements HttpResponse {
&nbsp;        private final String fileName;
&nbsp;
<b class="nc">&nbsp;        public JnlpJar(String fileName) {</b>
<b class="nc">&nbsp;            this.fileName = fileName;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void doIndex(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;            URLConnection con = connect();</b>
&nbsp;            // since we end up redirecting users to jnlpJars/foo.jar/, set the content disposition
&nbsp;            // so that browsers can download them in the right file name.
&nbsp;            // see http://support.microsoft.com/kb/260519 and http://www.boutell.com/newfaq/creating/forcedownload.html
<b class="nc">&nbsp;            rsp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fileName);</b>
<b class="nc">&nbsp;            try (InputStream in = con.getInputStream()) {</b>
<b class="nc">&nbsp;                rsp.serveFile(req, in, con.getLastModified(), con.getContentLengthLong(), &quot;*.jar&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {
<b class="nc">&nbsp;            doIndex(req, rsp);</b>
&nbsp;        }
&nbsp;
&nbsp;        private URLConnection connect() throws IOException {
<b class="nc">&nbsp;            URL res = getURL();</b>
<b class="nc">&nbsp;            return res.openConnection();</b>
&nbsp;        }
&nbsp;
&nbsp;        public URL getURL() throws IOException {
<b class="nc">&nbsp;            String name = fileName;</b>
&nbsp;
&nbsp;            // Prevent the access to war contents &amp; prevent the folder escaping (SECURITY-195)
<b class="nc">&nbsp;            if (!ALLOWED_JNLPJARS_FILES.contains(name)) {</b>
<b class="nc">&nbsp;                throw new MalformedURLException(&quot;The specified file path &quot; + fileName + &quot; is not allowed due to security reasons&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Class&lt;?&gt; owner = null;</b>
<b class="nc">&nbsp;            if (name.equals(&quot;hudson-cli.jar&quot;) || name.equals(&quot;jenkins-cli.jar&quot;))  {</b>
<b class="nc">&nbsp;                owner = CLI.class;</b>
<b class="nc">&nbsp;            } else if (name.equals(&quot;agent.jar&quot;) || name.equals(&quot;slave.jar&quot;) || name.equals(&quot;remoting.jar&quot;)) {</b>
<b class="nc">&nbsp;                owner = hudson.remoting.Launcher.class;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (owner != null) {</b>
<b class="nc">&nbsp;                File jar = Which.jarFile(owner);</b>
<b class="nc">&nbsp;                if (jar.isFile()) {</b>
<b class="nc">&nbsp;                    name = &quot;lib/&quot; + jar.getName();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    URL res = findExecutableJar(jar, owner);</b>
<b class="nc">&nbsp;                    if (res != null) {</b>
<b class="nc">&nbsp;                        return res;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            URL res = Jenkins.get().servletContext.getResource(&quot;/WEB-INF/&quot; + name);</b>
<b class="nc">&nbsp;            if (res == null) {</b>
<b class="nc">&nbsp;                throw new FileNotFoundException(name); // giving up</b>
&nbsp;            } else {
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;found {0}&quot;, res);</b>
&nbsp;            }
<b class="nc">&nbsp;            return res;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Useful for {@code JenkinsRule.createSlave}, {@code mvn jetty:run}, etc. */
&nbsp;        private @CheckForNull URL findExecutableJar(File notActuallyJAR, Class&lt;?&gt; mainClass) throws IOException {
<b class="nc">&nbsp;            if (notActuallyJAR.getName().equals(&quot;classes&quot;)) {</b>
<b class="nc">&nbsp;                File[] siblings = notActuallyJAR.getParentFile().listFiles();</b>
<b class="nc">&nbsp;                if (siblings != null) {</b>
<b class="nc">&nbsp;                    for (File actualJar : siblings) {</b>
<b class="nc">&nbsp;                        if (actualJar.getName().endsWith(&quot;.jar&quot;)) {</b>
<b class="nc">&nbsp;                            try (JarFile jf = new JarFile(actualJar, false)) {</b>
<b class="nc">&nbsp;                                Manifest mf = jf.getManifest();</b>
<b class="nc">&nbsp;                                if (mf != null &amp;&amp; mainClass.getName().equals(mf.getMainAttributes().getValue(&quot;Main-Class&quot;))) {</b>
<b class="nc">&nbsp;                                    LOGGER.log(Level.FINE, &quot;found {0}&quot;, actualJar);</b>
<b class="nc">&nbsp;                                    return actualJar.toURI().toURL();</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        public byte[] readFully() throws IOException {
<b class="nc">&nbsp;            try (InputStream in = connect().getInputStream()) {</b>
<b class="nc">&nbsp;                return in.readAllBytes();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a launcher for the agent.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      If there is no computer it will return a {@link hudson.Launcher.DummyLauncher}, otherwise it
&nbsp;     *      will return a {@link hudson.Launcher.RemoteLauncher} instead.
&nbsp;     */
&nbsp;    @Override
&nbsp;    @NonNull
&nbsp;    public Launcher createLauncher(TaskListener listener) {
<b class="nc">&nbsp;        SlaveComputer c = getComputer();</b>
<b class="nc">&nbsp;        if (c == null) {</b>
<b class="nc">&nbsp;            listener.error(&quot;Issue with creating launcher for agent &quot; + name + &quot;. Computer has been disconnected&quot;);</b>
<b class="nc">&nbsp;            return new Launcher.DummyLauncher(listener);</b>
&nbsp;        } else {
&nbsp;            // TODO: ideally all the logic below should be inside the SlaveComputer class with proper locking to prevent race conditions,
&nbsp;            // but so far there is no locks for setNode() hence it requires serious refactoring
&nbsp;
&nbsp;            // Ensure that the Computer instance still points to this node
&nbsp;            // Otherwise we may end up running the command on a wrong (reconnected) Node instance.
<b class="nc">&nbsp;            Slave node = c.getNode();</b>
<b class="nc">&nbsp;            if (node != this) {</b>
<b class="nc">&nbsp;                String message = &quot;Issue with creating launcher for agent &quot; + name + &quot;. Computer has been reconnected&quot;;</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(Level.WARNING)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, message, new IllegalStateException(&quot;Computer has been reconnected, this Node instance cannot be used anymore&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                return new Launcher.DummyLauncher(listener);</b>
&nbsp;            }
&nbsp;
&nbsp;            // RemoteLauncher requires an active Channel instance to operate correctly
<b class="nc">&nbsp;            final Channel channel = c.getChannel();</b>
<b class="nc">&nbsp;            if (channel == null) {</b>
<b class="nc">&nbsp;                reportLauncherCreateError(&quot;The agent has not been fully initialized yet&quot;,</b>
&nbsp;                                         &quot;No remoting channel to the agent OR it has not been fully initialized yet&quot;, listener);
<b class="nc">&nbsp;                return new Launcher.DummyLauncher(listener);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (channel.isClosingOrClosed()) {</b>
<b class="nc">&nbsp;                reportLauncherCreateError(&quot;The agent is being disconnected&quot;,</b>
&nbsp;                                         &quot;Remoting channel is either in the process of closing down or has closed down&quot;, listener);
<b class="nc">&nbsp;                return new Launcher.DummyLauncher(listener);</b>
&nbsp;            }
<b class="nc">&nbsp;            final Boolean isUnix = c.isUnix();</b>
<b class="nc">&nbsp;            if (isUnix == null) {</b>
&nbsp;                // isUnix is always set when the channel is not null, so it should never happen
<b class="nc">&nbsp;                reportLauncherCreateError(&quot;The agent has not been fully initialized yet&quot;,</b>
&nbsp;                                         &quot;Cannot determine if the agent is a Unix one, the System status request has not completed yet. &quot; +
&nbsp;                                         &quot;It is an invalid channel state, please report a bug to Jenkins if you see it.&quot;,
&nbsp;                                         listener);
<b class="nc">&nbsp;                return new Launcher.DummyLauncher(listener);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return new RemoteLauncher(listener, channel, isUnix).decorateFor(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void reportLauncherCreateError(@NonNull String humanReadableMsg, @CheckForNull String exceptionDetails, @NonNull TaskListener listener) {
<b class="nc">&nbsp;        String message = &quot;Issue with creating launcher for agent &quot; + name + &quot;. &quot; + humanReadableMsg;</b>
<b class="nc">&nbsp;        listener.error(message);</b>
<b class="nc">&nbsp;        if (LOGGER.isLoggable(Level.WARNING)) {</b>
&nbsp;            // Send stacktrace to the log as well in order to diagnose the root cause of issues like JENKINS-38527
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, message</b>
&nbsp;                    + &quot;Probably there is a race condition with Agent reconnection or disconnection, check other log entries&quot;,
<b class="nc">&nbsp;                    new IllegalStateException(exceptionDetails != null ? exceptionDetails : humanReadableMsg));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the corresponding computer object.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      this method can return null if there&#39;s no {@link Computer} object for this node,
&nbsp;     *      such as when this node has no executors at all.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public SlaveComputer getComputer() {
<b class="nc">&nbsp;        return (SlaveComputer) toComputer();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="nc">&nbsp;        if (this == o) return true;</b>
<b class="nc">&nbsp;        if (o == null || getClass() != o.getClass()) return false;</b>
&nbsp;
<b class="nc">&nbsp;        final Slave that = (Slave) o;</b>
&nbsp;
<b class="nc">&nbsp;        return name.equals(that.name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="nc">&nbsp;        return name.hashCode();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invoked by XStream when this object is read into memory.
&nbsp;     */
&nbsp;    protected Object readResolve() {
<b class="nc">&nbsp;        if (nodeProperties == null)</b>
<b class="nc">&nbsp;            nodeProperties = new DescribableList&lt;&gt;(this);</b>
<b class="nc">&nbsp;        _setLabelString(label);</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SlaveDescriptor getDescriptor() {
<b class="nc">&nbsp;        Descriptor d = Jenkins.get().getDescriptorOrDie(getClass());</b>
<b class="nc">&nbsp;        if (d instanceof SlaveDescriptor)</b>
<b class="nc">&nbsp;            return (SlaveDescriptor) d;</b>
<b class="nc">&nbsp;        throw new IllegalStateException(d.getClass() + &quot; needs to extend from SlaveDescriptor&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public abstract static class SlaveDescriptor extends NodeDescriptor {</b>
&nbsp;        public FormValidation doCheckNumExecutors(@QueryParameter String value) {
<b class="nc">&nbsp;            return FormValidation.validatePositiveInteger(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Performs syntactical check on the remote FS for agents.
&nbsp;         */
&nbsp;        public FormValidation doCheckRemoteFS(@QueryParameter String value) throws IOException, ServletException {
<b class="nc">&nbsp;            if (Util.fixEmptyAndTrim(value) == null)</b>
<b class="nc">&nbsp;                return FormValidation.error(Messages.Slave_Remote_Director_Mandatory());</b>
&nbsp;
<b class="nc">&nbsp;            if (value.startsWith(&quot;\\\\&quot;) || value.startsWith(&quot;/net/&quot;))</b>
<b class="nc">&nbsp;                return FormValidation.warning(Messages.Slave_Network_Mounted_File_System_Warning());</b>
&nbsp;
<b class="nc">&nbsp;            if (Util.isRelativePath(value)) {</b>
<b class="nc">&nbsp;                return FormValidation.warning(Messages.Slave_Remote_Relative_Path_Warning());</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the list of {@link ComputerLauncher} descriptors appropriate to the supplied {@link Slave}.
&nbsp;         *
&nbsp;         * @param it the {@link Slave} or {@code null} to assume the agent is of type {@link #clazz}.
&nbsp;         * @return the filtered list
&nbsp;         * @since 2.12
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        @Restricted(NoExternalUse.class) // intended for use by Jelly EL only (plus hack in DelegatingComputerLauncher)
&nbsp;        public final List&lt;Descriptor&lt;ComputerLauncher&gt;&gt; computerLauncherDescriptors(@CheckForNull Slave it) {
&nbsp;            DescriptorExtensionList&lt;ComputerLauncher, Descriptor&lt;ComputerLauncher&gt;&gt; all =
<b class="fc">&nbsp;                    Jenkins.get().getDescriptorList(</b>
&nbsp;                            ComputerLauncher.class);
<b class="fc">&nbsp;            return it == null ? DescriptorVisibilityFilter.applyType(clazz, all)</b>
<b class="nc">&nbsp;                    : DescriptorVisibilityFilter.apply(it, all);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the list of {@link RetentionStrategy} descriptors appropriate to the supplied {@link Slave}.
&nbsp;         *
&nbsp;         * @param it the {@link Slave} or {@code null} to assume the slave is of type {@link #clazz}.
&nbsp;         * @return the filtered list
&nbsp;         * @since 2.12
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        @Restricted(NoExternalUse.class) // used by Jelly EL only
&nbsp;        public final List&lt;Descriptor&lt;RetentionStrategy&lt;?&gt;&gt;&gt; retentionStrategyDescriptors(@CheckForNull Slave it) {
<b class="nc">&nbsp;            return it == null ? DescriptorVisibilityFilter.applyType(clazz, RetentionStrategy.all())</b>
<b class="nc">&nbsp;                    : DescriptorVisibilityFilter.apply(it, RetentionStrategy.all());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the list of {@link NodePropertyDescriptor} appropriate to the supplied {@link Slave}.
&nbsp;         *
&nbsp;         * @param it the {@link Slave} or {@code null} to assume the agent is of type {@link #clazz}.
&nbsp;         * @return the filtered list
&nbsp;         * @since 2.12
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;) // used by Jelly EL only
&nbsp;        @Restricted(NoExternalUse.class) // used by Jelly EL only
&nbsp;        public final List&lt;NodePropertyDescriptor&gt; nodePropertyDescriptors(@CheckForNull Slave it) {
<b class="nc">&nbsp;            List&lt;NodePropertyDescriptor&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;            Collection&lt;NodePropertyDescriptor&gt; list =
<b class="nc">&nbsp;                    (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);</b>
<b class="nc">&nbsp;            for (NodePropertyDescriptor npd : it == null</b>
<b class="nc">&nbsp;                    ? DescriptorVisibilityFilter.applyType(clazz, list)</b>
<b class="nc">&nbsp;                    : DescriptorVisibilityFilter.apply(it, list)) {</b>
<b class="nc">&nbsp;                if (npd.isApplicable(clazz)) {</b>
<b class="nc">&nbsp;                    result.add(npd);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;//
&nbsp;// backward compatibility
&nbsp;//
&nbsp;    /**
&nbsp;     * Command line to launch the agent, like
&nbsp;     * &quot;ssh myagent java -jar /path/to/hudson-remoting.jar&quot;
&nbsp;     * @deprecated in 1.216
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    private transient String agentCommand; // this was called &#39;agentCommand&#39; from the beginning; not an accidental 2016 rename
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains the clock difference between this side and that side of the channel.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is a hack to wrap the whole thing into a simple {@link Callable}.
&nbsp;     *
&nbsp;     * &lt;ol&gt;
&nbsp;     *     &lt;li&gt;When the callable is sent to remote, we capture the time (on this side) in {@link GetClockDifference2#startTime}
&nbsp;     *     &lt;li&gt;When the other side receives the callable it is {@link GetClockDifference2}.
&nbsp;     *     &lt;li&gt;We capture the time on the other side and {@link GetClockDifference3} gets sent from the other side
&nbsp;     *     &lt;li&gt;When it&#39;s read on this side as a return value, it morphs itself into {@link ClockDifference}.
&nbsp;     * &lt;/ol&gt;
&nbsp;     */
<b class="nc">&nbsp;    private static final class GetClockDifference1 extends MasterToSlaveCallable&lt;ClockDifference, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public ClockDifference call() {
&nbsp;            // this method must be being invoked locally, which means the clock is in sync
<b class="nc">&nbsp;            return new ClockDifference(0);</b>
&nbsp;        }
&nbsp;
&nbsp;        private Object writeReplace() {
<b class="nc">&nbsp;            return new GetClockDifference2();</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static final class GetClockDifference2 extends MasterToSlaveCallable&lt;GetClockDifference3, IOException&gt; {</b>
&nbsp;        /**
&nbsp;         * Capture the time on the controller when this object is sent to remote, which is when
&nbsp;         * {@link GetClockDifference1#writeReplace()} is run.
&nbsp;         */
<b class="nc">&nbsp;        private final long startTime = System.currentTimeMillis();</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public GetClockDifference3 call() {
<b class="nc">&nbsp;            return new GetClockDifference3(startTime);</b>
&nbsp;        }
&nbsp;
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    private static final class GetClockDifference3 implements Serializable {
<b class="nc">&nbsp;        private final long remoteTime = System.currentTimeMillis();</b>
&nbsp;        private final long startTime;
&nbsp;
<b class="nc">&nbsp;        GetClockDifference3(long startTime) {</b>
<b class="nc">&nbsp;            this.startTime = startTime;</b>
&nbsp;        }
&nbsp;
&nbsp;        private Object readResolve() {
<b class="nc">&nbsp;            long endTime = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            return new ClockDifference((startTime + endTime) / 2 - remoteTime);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the workspace root file name for those who really really need the shortest possible path name.
&nbsp;     */
<b class="nc">&nbsp;    private static final String WORKSPACE_ROOT = SystemProperties.getString(Slave.class.getName() + &quot;.workspaceRoot&quot;, &quot;workspace&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Provides a collection of file names, which are accessible via /jnlpJars link.
&nbsp;     */
<b class="nc">&nbsp;    private static final Set&lt;String&gt; ALLOWED_JNLPJARS_FILES = Set.of(&quot;agent.jar&quot;, &quot;slave.jar&quot;, &quot;remoting.jar&quot;, &quot;jenkins-cli.jar&quot;, &quot;hudson-cli.jar&quot;);</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
