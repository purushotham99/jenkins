


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Run</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: Run (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Run</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (25/125)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.2%
  </span>
  <span class="absValue">
    (121/666)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Run$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$AddArtifacts</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$Artifact</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (2/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.9%
  </span>
  <span class="absValue">
    (7/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$ArtifactList</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.4%
  </span>
  <span class="absValue">
    (31/46)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$DefaultFeedAdapter</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$KeepLogBuildBadge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$MockitoMock$wXmh2TYM</td>
  </tr>
  <tr>
    <td class="name">Run$MockitoMock$wXmh2TYM$auxiliary$0MgljIcz</td>
  </tr>
  <tr>
    <td class="name">Run$MockitoMock$wXmh2TYM$auxiliary$YDY6fZnJ</td>
  </tr>
  <tr>
    <td class="name">Run$RedirectUp</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$Replacer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$RunExecution</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$RunExecution$CheckpointSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$Runner</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$RunnerAbortedException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$SerializableArtifact</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$SerializableArtifactList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$State</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$StatusSummarizer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Run$Summary</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    20.7%
  </span>
  <span class="absValue">
    (37/179)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.1%
  </span>
  <span class="absValue">
    (171/810)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2012, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Daniel Dyer, Red Hat, Inc., Tom Huybrechts, Romain Seguy, Yahoo! Inc.,
&nbsp; * Darek Ostolski, CloudBees, Inc.
&nbsp; * Copyright (c) 2012, Martin Schroeder, Intel Mobile Communications GmbH
&nbsp; * Copyright (c) 2019 Intel Corporation
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static java.util.logging.Level.FINE;
&nbsp;import static java.util.logging.Level.FINER;
&nbsp;import static java.util.logging.Level.SEVERE;
&nbsp;import static java.util.logging.Level.WARNING;
&nbsp;
&nbsp;import com.jcraft.jzlib.GZIPInputStream;
&nbsp;import com.thoughtworks.xstream.XStream;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.AbortException;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.EnvVars;
&nbsp;import hudson.ExtensionList;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.FeedAdapter;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Util;
&nbsp;import hudson.XmlFile;
&nbsp;import hudson.cli.declarative.CLIMethod;
&nbsp;import hudson.console.AnnotatedLargeText;
&nbsp;import hudson.console.ConsoleLogFilter;
&nbsp;import hudson.console.ConsoleNote;
&nbsp;import hudson.console.ModelHyperlinkNote;
&nbsp;import hudson.console.PlainTextConsoleOutputStream;
&nbsp;import hudson.model.Descriptor.FormException;
&nbsp;import hudson.model.listeners.RunListener;
&nbsp;import hudson.model.listeners.SaveableListener;
&nbsp;import hudson.model.queue.SubTask;
&nbsp;import hudson.search.SearchIndexBuilder;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.security.Permission;
&nbsp;import hudson.security.PermissionGroup;
&nbsp;import hudson.security.PermissionScope;
&nbsp;import hudson.tasks.BuildWrapper;
&nbsp;import hudson.tasks.Fingerprinter.FingerprintAction;
&nbsp;import hudson.util.FormApply;
&nbsp;import hudson.util.LogTaskListener;
&nbsp;import hudson.util.ProcessTree;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.BufferedInputStream;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.PrintWriter;
&nbsp;import java.io.RandomAccessFile;
&nbsp;import java.io.Reader;
&nbsp;import java.io.Serializable;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.StandardCopyOption;
&nbsp;import java.nio.file.StandardOpenOption;
&nbsp;import java.text.DateFormat;
&nbsp;import java.text.SimpleDateFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Date;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.servlet.http.HttpServletResponse;
&nbsp;import jenkins.model.ArtifactManager;
&nbsp;import jenkins.model.ArtifactManagerConfiguration;
&nbsp;import jenkins.model.ArtifactManagerFactory;
&nbsp;import jenkins.model.BuildDiscarder;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.JenkinsLocationConfiguration;
&nbsp;import jenkins.model.RunAction2;
&nbsp;import jenkins.model.StandardArtifactManager;
&nbsp;import jenkins.model.lazy.BuildReference;
&nbsp;import jenkins.model.lazy.LazyBuildMixIn;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.VirtualFile;
&nbsp;import jenkins.util.io.OnMaster;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.io.IOUtils;
&nbsp;import org.apache.commons.jelly.XMLOutput;
&nbsp;import org.apache.commons.lang.ArrayUtils;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;import org.kohsuke.stapler.StaplerProxy;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.kohsuke.stapler.verb.POST;
&nbsp;import org.springframework.security.access.AccessDeniedException;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;
&nbsp;/**
&nbsp; * A particular execution of {@link Job}.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Custom {@link Run} type is always used in conjunction with
&nbsp; * a custom {@link Job} type, so there&#39;s no separate registration
&nbsp; * mechanism for custom {@link Run} types.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see RunListener
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public abstract class Run&lt;JobT extends Job&lt;JobT, RunT&gt;, RunT extends Run&lt;JobT, RunT&gt;&gt;
&nbsp;        extends Actionable implements ExtensionPoint, Comparable&lt;RunT&gt;, AccessControlled, PersistenceRoot, DescriptorByNameOwner, OnMaster, StaplerProxy {
&nbsp;
&nbsp;    /**
&nbsp;     * The original {@link Queue.Item#getId()} has not yet been mapped onto the {@link Run} instance.
&nbsp;     * @since 1.601
&nbsp;     */
&nbsp;    public static final long QUEUE_ID_UNKNOWN = -1;
&nbsp;
&nbsp;    /**
&nbsp;     * Target size limit for truncated {@link #description}s in the Build History Widget.
&nbsp;     * This is applied to the raw, unformatted description. Especially complex formatting
&nbsp;     * like hyperlinks can result in much less text being shown than this might imply.
&nbsp;     * Negative values will disable truncation, {@code 0} will enforce empty strings.
&nbsp;     * @since 2.223
&nbsp;     */
<b class="fc">&nbsp;    private static /* non-final for Groovy */ int TRUNCATED_DESCRIPTION_LIMIT = SystemProperties.getInteger(&quot;historyWidget.descriptionLimit&quot;, 100);</b>
&nbsp;
&nbsp;    protected final transient @NonNull JobT project;
&nbsp;
&nbsp;    /**
&nbsp;     * Build number.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * In earlier versions &amp;lt; 1.24, this number is not unique nor continuous,
&nbsp;     * but going forward, it will, and this really replaces the build id.
&nbsp;     */
&nbsp;    public transient /*final*/ int number;
&nbsp;
&nbsp;    /**
&nbsp;     * The original Queue task ID from where this Run instance originated.
&nbsp;     */
<b class="fc">&nbsp;    private long queueId = Run.QUEUE_ID_UNKNOWN;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Previous build. Can be null.
&nbsp;     * TODO JENKINS-22052 this is not actually implemented any more
&nbsp;     *
&nbsp;     * External code should use {@link #getPreviousBuild()}
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    protected transient volatile RunT previousBuild;
&nbsp;
&nbsp;    /**
&nbsp;     * Next build. Can be null.
&nbsp;     *
&nbsp;     * External code should use {@link #getNextBuild()}
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    protected transient volatile RunT nextBuild;
&nbsp;
&nbsp;    /**
&nbsp;     * Pointer to the next younger build in progress. This data structure is lazily updated,
&nbsp;     * so it may point to the build that&#39;s already completed. This pointer is set to &#39;this&#39;
&nbsp;     * if the computation determines that everything earlier than this build is already completed.
&nbsp;     */
&nbsp;    /* does not compile on JDK 7: private*/ transient volatile RunT previousBuildInProgress;
&nbsp;
&nbsp;    /** ID as used for historical build records; otherwise null. */
&nbsp;    private @CheckForNull String id;
&nbsp;
&nbsp;    /**
&nbsp;     * When the build is scheduled.
&nbsp;     */
&nbsp;    protected /*final*/ long timestamp;
&nbsp;
&nbsp;    /**
&nbsp;     * When the build has started running.
&nbsp;     *
&nbsp;     * For historical reasons, 0 means no value is recorded.
&nbsp;     *
&nbsp;     * @see #getStartTimeInMillis()
&nbsp;     */
&nbsp;    private long startTime;
&nbsp;
&nbsp;    /**
&nbsp;     * The build result.
&nbsp;     * This value may change while the state is in {@link Run.State#BUILDING}.
&nbsp;     */
&nbsp;    protected volatile Result result;
&nbsp;
&nbsp;    /**
&nbsp;     * Human-readable description which is used on the main build page.
&nbsp;     * It can also be quite long, and it may use markup in a format defined by a {@link hudson.markup.MarkupFormatter}.
&nbsp;     * {@link #getTruncatedDescription()} may be used to retrieve a size-limited description,
&nbsp;     * but it implies some limitations.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    protected volatile String description;
&nbsp;
&nbsp;    /**
&nbsp;     * Human-readable name of this build. Can be null.
&nbsp;     * If non-null, this text is displayed instead of &quot;#NNN&quot;, which is the default.
&nbsp;     * @since 1.390
&nbsp;     */
&nbsp;    private volatile String displayName;
&nbsp;
&nbsp;    /**
&nbsp;     * The current build state.
&nbsp;     */
&nbsp;    private transient volatile State state;
&nbsp;
<b class="fc">&nbsp;    private enum State {</b>
&nbsp;        /**
&nbsp;         * Build is created/queued but we haven&#39;t started building it.
&nbsp;         */
<b class="fc">&nbsp;        NOT_STARTED,</b>
&nbsp;        /**
&nbsp;         * Build is in progress.
&nbsp;         */
<b class="fc">&nbsp;        BUILDING,</b>
&nbsp;        /**
&nbsp;         * Build is completed now, and the status is determined,
&nbsp;         * but log files are still being updated.
&nbsp;         *
&nbsp;         * The significance of this state is that Jenkins
&nbsp;         * will now see this build as completed. Things like
&nbsp;         * &quot;triggering other builds&quot; requires this as pre-condition.
&nbsp;         * See JENKINS-980.
&nbsp;         */
<b class="fc">&nbsp;        POST_PRODUCTION,</b>
&nbsp;        /**
&nbsp;         * Build is completed now, and log file is closed.
&nbsp;         */
<b class="fc">&nbsp;        COMPLETED</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Number of milli-seconds it took to run this build.
&nbsp;     */
&nbsp;    protected long duration;
&nbsp;
&nbsp;    /**
&nbsp;     * Charset in which the log file is written.
&nbsp;     * For compatibility reason, this field may be null.
&nbsp;     * For persistence, this field is string and not {@link Charset}.
&nbsp;     *
&nbsp;     * @see #getCharset()
&nbsp;     * @since 1.257
&nbsp;     */
&nbsp;    protected String charset;
&nbsp;
&nbsp;    /**
&nbsp;     * Keeps this build.
&nbsp;     */
&nbsp;    private boolean keepLog;
&nbsp;
&nbsp;    /**
&nbsp;     * If the build is in progress, remember {@link RunExecution} that&#39;s running it.
&nbsp;     * This field is not persisted.
&nbsp;     */
&nbsp;    private transient volatile RunExecution runner;
&nbsp;
&nbsp;    /**
&nbsp;     * Artifact manager associated with this build, if any.
&nbsp;     * @since 1.532
&nbsp;     */
&nbsp;    private @CheckForNull ArtifactManager artifactManager;
&nbsp;
&nbsp;    /**
&nbsp;     * If the build is pending delete.
&nbsp;     */
&nbsp;    private transient boolean isPendingDelete;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link Run}.
&nbsp;     * @param job Owner job
&nbsp;     * @see LazyBuildMixIn#newBuild
&nbsp;     */
&nbsp;    protected Run(@NonNull JobT job) throws IOException {
<b class="fc">&nbsp;        this(job, System.currentTimeMillis());</b>
<b class="fc">&nbsp;        this.number = project.assignBuildNumber();</b>
<b class="fc">&nbsp;        LOGGER.log(FINER, &quot;new {0} @{1}&quot;, new Object[] {this, hashCode()});</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for creating a {@link Run} object in
&nbsp;     * an arbitrary state.
&nbsp;     * {@link #number} must be set manually.
&nbsp;     * &lt;p&gt;May be used in a {@link SubTask#createExecutable} (instead of calling {@link LazyBuildMixIn#newBuild}).
&nbsp;     * For example, {@code MatrixConfiguration.newBuild} does this
&nbsp;     * so that the {@link #timestamp} as well as {@link #number} are shared with the parent build.
&nbsp;     */
&nbsp;    protected Run(@NonNull JobT job, @NonNull Calendar timestamp) {
<b class="fc">&nbsp;        this(job, timestamp.getTimeInMillis());</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @see #Run(Job, Calendar) */
<b class="fc">&nbsp;    protected Run(@NonNull JobT job, long timestamp) {</b>
<b class="fc">&nbsp;        this.project = job;</b>
<b class="fc">&nbsp;        this.timestamp = timestamp;</b>
<b class="fc">&nbsp;        this.state = State.NOT_STARTED;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a run from a log file.
&nbsp;     * @see LazyBuildMixIn#loadBuild
&nbsp;     */
<b class="nc">&nbsp;    protected Run(@NonNull JobT project, @NonNull File buildDir) throws IOException {</b>
<b class="nc">&nbsp;        this.project = project;</b>
<b class="nc">&nbsp;        this.previousBuildInProgress = _this(); // loaded builds are always completed</b>
<b class="nc">&nbsp;        number = Integer.parseInt(buildDir.getName());</b>
<b class="nc">&nbsp;        reload();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reloads the build record from disk.
&nbsp;     *
&nbsp;     * @since 1.410
&nbsp;     */
&nbsp;    public void reload() throws IOException {
<b class="nc">&nbsp;        this.state = State.COMPLETED;</b>
&nbsp;        // TODO ABORTED would perhaps make more sense than FAILURE:
<b class="nc">&nbsp;        this.result = Result.FAILURE;  // defensive measure. value should be overwritten by unmarshal, but just in case the saved data is inconsistent</b>
<b class="nc">&nbsp;        getDataFile().unmarshal(this); // load the rest of the data</b>
&nbsp;
<b class="nc">&nbsp;        if (state == State.COMPLETED) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINER, &quot;reload {0} @{1}&quot;, new Object[] {this, hashCode()});</b>
&nbsp;        } else {
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;reload {0} @{1} with anomalous state {2}&quot;, new Object[] {this, hashCode(), state});</b>
&nbsp;        }
&nbsp;
&nbsp;        // not calling onLoad upon reload. partly because we don&#39;t want to call that from Run constructor,
&nbsp;        // and partly because some existing use of onLoad isn&#39;t assuming that it can be invoked multiple times.
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called after the build is loaded and the object is added to the build list.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    protected void onLoad() {
<b class="nc">&nbsp;        for (Action a : getAllActions()) {</b>
<b class="nc">&nbsp;            if (a instanceof RunAction2) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    ((RunAction2) a).onLoad(this);</b>
<b class="nc">&nbsp;                } catch (RuntimeException x) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;failed to load &quot; + a + &quot; from &quot; + getDataFile(), x);</b>
<b class="nc">&nbsp;                    removeAction(a); // if possible; might be in an inconsistent state</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } else if (a instanceof RunAction) {</b>
<b class="nc">&nbsp;                ((RunAction) a).onLoad();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (artifactManager != null) {</b>
<b class="nc">&nbsp;            artifactManager.onLoad(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return all transient actions associated with this build.
&nbsp;     *
&nbsp;     * @return the list can be empty but never null. read only.
&nbsp;     * @deprecated Use {@link #getAllActions} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public List&lt;Action&gt; getTransientActions() {
<b class="nc">&nbsp;        List&lt;Action&gt; actions = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (TransientBuildActionFactory factory : TransientBuildActionFactory.all()) {</b>
<b class="nc">&nbsp;            for (Action created : factory.createFor(this)) {</b>
<b class="nc">&nbsp;                if (created == null) {</b>
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;null action added by {0}&quot;, factory);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                actions.add(created);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return Collections.unmodifiableList(actions);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     * A {@link RunAction2} is handled specially.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    @Override
&nbsp;    public void addAction(@NonNull Action a) {
<b class="fc">&nbsp;        super.addAction(a);</b>
<b class="fc">&nbsp;        if (a instanceof RunAction2) {</b>
<b class="fc">&nbsp;            ((RunAction2) a).onAttached(this);</b>
<b class="nc">&nbsp;        } else if (a instanceof RunAction) {</b>
<b class="nc">&nbsp;            ((RunAction) a).onAttached(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains &#39;this&#39; in a more type safe signature.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    protected @NonNull RunT _this() {
<b class="nc">&nbsp;        return (RunT) this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Ordering based on build numbers.
&nbsp;     * If numbers are equal order based on names of parent projects.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int compareTo(@NonNull RunT that) {
<b class="fc">&nbsp;        final int res = this.number - that.number;</b>
<b class="fc">&nbsp;        if (res == 0)</b>
<b class="fc">&nbsp;            return this.getParent().getFullName().compareTo(that.getParent().getFullName());</b>
&nbsp;
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the {@link Queue.Item#getId()} of the original queue item from where this Run instance
&nbsp;     * originated.
&nbsp;     * @return The queue item ID.
&nbsp;     * @since 1.601
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public long getQueueId() {
<b class="fc">&nbsp;        return queueId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the queue item ID.
&nbsp;     * &lt;p&gt;
&nbsp;     * Mapped from the {@link Queue.Item#getId()}.
&nbsp;     * @param queueId The queue item ID.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void setQueueId(long queueId) {
<b class="nc">&nbsp;        this.queueId = queueId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the build result.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When a build is {@link #isBuilding() in progress}, this method
&nbsp;     * returns an intermediate result.
&nbsp;     * @return The status of the build, if it has completed or some build step has set a status; may be null if the build is ongoing.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @CheckForNull Result getResult() {
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the {@link #getResult} of this build.
&nbsp;     * Has no effect when the result is already set and worse than the proposed result.
&nbsp;     * May only be called after the build has started and before it has moved into post-production
&nbsp;     * (normally meaning both {@link #isInProgress} and {@link #isBuilding} are true).
&nbsp;     * @param r the proposed new result
&nbsp;     * @throws IllegalStateException if the build has not yet started, is in post-production, or is complete
&nbsp;     */
&nbsp;    public void setResult(@NonNull Result r) {
<b class="nc">&nbsp;        if (state != State.BUILDING) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;cannot change build result while in &quot; + state);</b>
&nbsp;        }
&nbsp;
&nbsp;        // result can only get worse
<b class="nc">&nbsp;        if (result == null || r.isWorseThan(result)) {</b>
<b class="nc">&nbsp;            result = r;</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, this + &quot; in &quot; + getRootDir() + &quot;: result is set to &quot; + r, LOGGER.isLoggable(Level.FINER) ? new Exception() : null);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the subset of {@link #getActions()} that consists of {@link BuildBadgeAction}s.
&nbsp;     */
&nbsp;    public @NonNull List&lt;BuildBadgeAction&gt; getBadgeActions() {
<b class="nc">&nbsp;        List&lt;BuildBadgeAction&gt; r = getActions(BuildBadgeAction.class);</b>
<b class="nc">&nbsp;        if (isKeepLog()) {</b>
<b class="nc">&nbsp;            r = new ArrayList&lt;&gt;(r);</b>
<b class="nc">&nbsp;            r.add(new KeepLogBuildBadge());</b>
&nbsp;        }
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the build is not completed yet.
&nbsp;     * This includes &quot;not started yet&quot; state.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isBuilding() {
<b class="fc">&nbsp;        return state.compareTo(State.POST_PRODUCTION) &lt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determine whether the run is being build right now.
&nbsp;     * @return true if after started and before completed.
&nbsp;     * @since 1.538
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isInProgress() {
<b class="nc">&nbsp;        return state.equals(State.BUILDING) || state.equals(State.POST_PRODUCTION);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the log file is still being updated.
&nbsp;     */
&nbsp;    public boolean isLogUpdated() {
<b class="nc">&nbsp;        return state.compareTo(State.COMPLETED) &lt; 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Executor} building this job, if it&#39;s being built.
&nbsp;     * Otherwise null.
&nbsp;     *
&nbsp;     * This method looks for {@link Executor} who&#39;s {@linkplain Executor#getCurrentExecutable() assigned to this build},
&nbsp;     * and because of that this might not be necessarily in sync with the return value of {@link #isBuilding()} &amp;mdash;
&nbsp;     * an executor holds on to {@link Run} some more time even after the build is finished (for example to
&nbsp;     * perform {@linkplain Run.State#POST_PRODUCTION post-production processing}.)
&nbsp;     * @see Executor#of
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @CheckForNull Executor getExecutor() {
<b class="nc">&nbsp;        return this instanceof Queue.Executable ? Executor.of((Queue.Executable) this) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the one off {@link Executor} building this job, if it&#39;s being built.
&nbsp;     * Otherwise null.
&nbsp;     * @since 1.433
&nbsp;     */
&nbsp;    public @CheckForNull Executor getOneOffExecutor() {
<b class="nc">&nbsp;        for (Computer c : Jenkins.get().getComputers()) {</b>
<b class="nc">&nbsp;            for (Executor e : c.getOneOffExecutors()) {</b>
<b class="nc">&nbsp;                if (e.getCurrentExecutable() == this)</b>
<b class="nc">&nbsp;                    return e;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the charset in which the log file is written.
&nbsp;     * @return never null.
&nbsp;     * @since 1.257
&nbsp;     */
&nbsp;    public final @NonNull Charset getCharset() {
<b class="fc">&nbsp;        if (charset == null)   return Charset.defaultCharset();</b>
<b class="nc">&nbsp;        return Charset.forName(charset);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link Cause}s that triggered a build.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * If a build sits in the queue for a long time, multiple build requests made during this period
&nbsp;     * are all rolled up into one build, hence this method may return a list.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      can be empty but never null. read-only.
&nbsp;     * @since 1.321
&nbsp;     */
&nbsp;    public @NonNull List&lt;Cause&gt; getCauses() {
<b class="nc">&nbsp;        CauseAction a = getAction(CauseAction.class);</b>
<b class="nc">&nbsp;        if (a == null)    return Collections.emptyList();</b>
<b class="nc">&nbsp;        return Collections.unmodifiableList(a.getCauses());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a {@link Cause} of a particular type.
&nbsp;     *
&nbsp;     * @since 1.362
&nbsp;     */
&nbsp;    public @CheckForNull &lt;T extends Cause&gt; T getCause(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        for (Cause c : getCauses())</b>
<b class="nc">&nbsp;            if (type.isInstance(c))</b>
<b class="nc">&nbsp;                return type.cast(c);</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this build should be kept and not deleted.
&nbsp;     * (Despite the name, this refers to the entire build, not merely the log file.)
&nbsp;     * This is used as a signal to the {@link BuildDiscarder}.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public final boolean isKeepLog() {
<b class="nc">&nbsp;        return getWhyKeepLog() != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If {@link #isKeepLog()} returns true, returns a short, human-readable
&nbsp;     * sentence that explains why it&#39;s being kept.
&nbsp;     */
&nbsp;    public @CheckForNull String getWhyKeepLog() {
<b class="nc">&nbsp;        if (keepLog)</b>
<b class="nc">&nbsp;            return Messages.Run_MarkedExplicitly();</b>
<b class="nc">&nbsp;        return null;    // not marked at all</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The project this build is for.
&nbsp;     */
&nbsp;    public @NonNull JobT getParent() {
<b class="fc">&nbsp;        return project;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When the build is scheduled.
&nbsp;     *
&nbsp;     * @see #getStartTimeInMillis()
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @NonNull Calendar getTimestamp() {
<b class="nc">&nbsp;        GregorianCalendar c = new GregorianCalendar();</b>
<b class="nc">&nbsp;        c.setTimeInMillis(timestamp);</b>
<b class="nc">&nbsp;        return c;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #getTimestamp()} but in a different type.
&nbsp;     */
&nbsp;    public final @NonNull Date getTime() {
<b class="nc">&nbsp;        return new Date(timestamp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #getTimestamp()} but in a different type, that is since the time of the epoch.
&nbsp;     */
&nbsp;    public final long getTimeInMillis() {
<b class="nc">&nbsp;        return timestamp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When the build has started running in an executor.
&nbsp;     *
&nbsp;     * For example, if a build is scheduled 1pm, and stayed in the queue for 1 hour (say, no idle agents),
&nbsp;     * then this method returns 2pm, which is the time the job moved from the queue to the building state.
&nbsp;     *
&nbsp;     * @see #getTimestamp()
&nbsp;     */
&nbsp;    public final long getStartTimeInMillis() {
<b class="nc">&nbsp;        if (startTime == 0)   return timestamp;   // fallback: approximate by the queuing time</b>
<b class="nc">&nbsp;        return startTime;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    @CheckForNull
&nbsp;    public String getDescription() {
<b class="fc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the length-limited description.
&nbsp;     * The method tries to take HTML tags within the description into account, but it is a best-effort attempt.
&nbsp;     * Also, the method will likely not work properly if a non-HTML {@link hudson.markup.MarkupFormatter} is used.
&nbsp;     * @return The length-limited description.
&nbsp;     * @deprecated truncated description based on the {@link #TRUNCATED_DESCRIPTION_LIMIT} setting.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public @CheckForNull String getTruncatedDescription() {
<b class="nc">&nbsp;        if (TRUNCATED_DESCRIPTION_LIMIT &lt; 0) { // disabled</b>
<b class="nc">&nbsp;            return description;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (TRUNCATED_DESCRIPTION_LIMIT == 0) { // Someone wants to suppress descriptions, why not?</b>
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int maxDescrLength = TRUNCATED_DESCRIPTION_LIMIT;</b>
<b class="nc">&nbsp;        final String localDescription = description;</b>
<b class="nc">&nbsp;        if (localDescription == null || localDescription.length() &lt; maxDescrLength) {</b>
<b class="nc">&nbsp;            return localDescription;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final String ending = &quot;...&quot;;</b>
<b class="nc">&nbsp;        final int sz = localDescription.length(), maxTruncLength = maxDescrLength - ending.length();</b>
&nbsp;
<b class="nc">&nbsp;        boolean inTag = false;</b>
<b class="nc">&nbsp;        int displayChars = 0;</b>
<b class="nc">&nbsp;        int lastTruncatablePoint = -1;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;            char ch = localDescription.charAt(i);</b>
<b class="nc">&nbsp;            if (ch == &#39;&lt;&#39;) {</b>
<b class="nc">&nbsp;                inTag = true;</b>
<b class="nc">&nbsp;            } else if (ch == &#39;&gt;&#39;) {</b>
<b class="nc">&nbsp;                inTag = false;</b>
<b class="nc">&nbsp;                if (displayChars &lt;= maxTruncLength) {</b>
<b class="nc">&nbsp;                    lastTruncatablePoint = i + 1;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (!inTag) {</b>
<b class="nc">&nbsp;                displayChars++;</b>
<b class="nc">&nbsp;                if (displayChars &lt;= maxTruncLength &amp;&amp; ch == &#39; &#39;) {</b>
<b class="nc">&nbsp;                    lastTruncatablePoint = i;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String truncDesc = localDescription;</b>
&nbsp;
&nbsp;        // Could not find a preferred truncatable index, force a trunc at maxTruncLength
<b class="nc">&nbsp;        if (lastTruncatablePoint == -1)</b>
<b class="nc">&nbsp;            lastTruncatablePoint = maxTruncLength;</b>
&nbsp;
<b class="nc">&nbsp;        if (displayChars &gt;= maxDescrLength) {</b>
<b class="nc">&nbsp;            truncDesc = truncDesc.substring(0, lastTruncatablePoint) + ending;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return truncDesc;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the string that says how long since this build has started.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      string like &quot;3 minutes&quot; &quot;1 day&quot; etc.
&nbsp;     */
&nbsp;    public @NonNull String getTimestampString() {
<b class="nc">&nbsp;        long duration = new GregorianCalendar().getTimeInMillis() - timestamp;</b>
<b class="nc">&nbsp;        return Util.getTimeSpanString(duration);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the timestamp formatted in xs:dateTime.
&nbsp;     */
&nbsp;    public @NonNull String getTimestampString2() {
<b class="nc">&nbsp;        return Util.XS_DATETIME_FORMATTER.format(new Date(timestamp));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the string that says how long the build took to run.
&nbsp;     */
&nbsp;    public @NonNull String getDurationString() {
<b class="fc">&nbsp;        if (hasntStartedYet()) {</b>
<b class="fc">&nbsp;            return Messages.Run_NotStartedYet();</b>
<b class="fc">&nbsp;        } else if (isBuilding()) {</b>
<b class="fc">&nbsp;            return Messages.Run_InProgressDuration(</b>
<b class="fc">&nbsp;                    Util.getTimeSpanString(System.currentTimeMillis() - startTime));</b>
&nbsp;        }
<b class="fc">&nbsp;        return Util.getTimeSpanString(duration);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the millisecond it took to build.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public long getDuration() {
<b class="nc">&nbsp;        return duration;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the icon color for display.
&nbsp;     */
&nbsp;    public @NonNull BallColor getIconColor() {
<b class="nc">&nbsp;        if (!isBuilding()) {</b>
&nbsp;            // already built
<b class="nc">&nbsp;            return getResult().color;</b>
&nbsp;        }
&nbsp;
&nbsp;        // a new build is in progress
&nbsp;        BallColor baseColor;
<b class="nc">&nbsp;        RunT pb = getPreviousBuild();</b>
<b class="nc">&nbsp;        if (pb == null)</b>
<b class="nc">&nbsp;            baseColor = BallColor.NOTBUILT;</b>
&nbsp;        else
<b class="nc">&nbsp;            baseColor = pb.getIconColor();</b>
&nbsp;
<b class="nc">&nbsp;        return baseColor.anime();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the build is still queued and hasn&#39;t started yet.
&nbsp;     */
&nbsp;    public boolean hasntStartedYet() {
<b class="fc">&nbsp;        return state == State.NOT_STARTED;</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE&quot;, justification = &quot;see JENKINS-45892&quot;)
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="fc">&nbsp;        if (project == null) {</b>
<b class="nc">&nbsp;            return &quot;&lt;broken data JENKINS-45892&gt;&quot;;</b>
&nbsp;        }
<b class="fc">&nbsp;        return project.getFullName() + &quot; #&quot; + number;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    public String getFullDisplayName() {
<b class="nc">&nbsp;        return project.getFullDisplayName() + &#39; &#39; + getDisplayName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Exported
&nbsp;    public String getDisplayName() {
<b class="fc">&nbsp;        return displayName != null ? displayName : &quot;#&quot; + number;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasCustomDisplayName() {
<b class="nc">&nbsp;        return displayName != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param value
&nbsp;     *      Set to null to revert back to the default &quot;#NNN&quot;.
&nbsp;     */
&nbsp;    public void setDisplayName(String value) throws IOException {
<b class="nc">&nbsp;        checkPermission(UPDATE);</b>
<b class="nc">&nbsp;        this.displayName = value;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported(visibility = 2)
&nbsp;    public int getNumber() {
<b class="nc">&nbsp;        return number;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called by {@link RunMap} to obtain a reference to this run.
&nbsp;     * @return Reference to the build. Never null
&nbsp;     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#createReference
&nbsp;     * @since 1.556
&nbsp;     */
&nbsp;    protected @NonNull BuildReference&lt;RunT&gt; createReference() {
<b class="nc">&nbsp;        return new BuildReference&lt;&gt;(getId(), _this());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called by {@link RunMap} to drop bi-directional links in preparation for
&nbsp;     * deleting a build.
&nbsp;     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#dropLinks
&nbsp;     * @since 1.556
&nbsp;     */
&nbsp;    protected void dropLinks() {
<b class="nc">&nbsp;        if (nextBuild != null)</b>
<b class="nc">&nbsp;            nextBuild.previousBuild = previousBuild;</b>
<b class="nc">&nbsp;        if (previousBuild != null)</b>
<b class="nc">&nbsp;            previousBuild.nextBuild = nextBuild;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#getPreviousBuild
&nbsp;     */
&nbsp;    public @CheckForNull RunT getPreviousBuild() {
<b class="nc">&nbsp;        return previousBuild;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the most recent {@linkplain #isBuilding() completed} build excluding &#39;this&#39; Run itself.
&nbsp;     */
&nbsp;    public final @CheckForNull RunT getPreviousCompletedBuild() {
<b class="nc">&nbsp;        RunT r = getPreviousBuild();</b>
<b class="nc">&nbsp;        while (r != null &amp;&amp; r.isBuilding())</b>
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains the next younger build in progress. It uses a skip-pointer so that we can compute this without
&nbsp;     * O(n) computation time. This method also fixes up the skip list as we go, in a way that&#39;s concurrency safe.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * We basically follow the existing skip list, and wherever we find a non-optimal pointer, we remember them
&nbsp;     * in &#39;fixUp&#39; and update them later.
&nbsp;     */
&nbsp;    public final @CheckForNull RunT getPreviousBuildInProgress() {
<b class="nc">&nbsp;        if (previousBuildInProgress == this)   return null;    // the most common case</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;RunT&gt; fixUp = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        RunT r = _this(); // &#39;r&#39; is the source of the pointer (so that we can add it to fix up if we find that the target of the pointer is inefficient.)</b>
&nbsp;        RunT answer;
&nbsp;        while (true) {
<b class="nc">&nbsp;            RunT n = r.previousBuildInProgress;</b>
<b class="nc">&nbsp;            if (n == null) { // no field computed yet.</b>
<b class="nc">&nbsp;                n = r.getPreviousBuild();</b>
<b class="nc">&nbsp;                fixUp.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (r == n || n == null) {</b>
&nbsp;                // this indicates that we know there&#39;s no build in progress beyond this point
<b class="nc">&nbsp;                answer = null;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (n.isBuilding()) {</b>
&nbsp;                // we now know &#39;n&#39; is the target we wanted
<b class="nc">&nbsp;                answer = n;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            fixUp.add(r);   // r contains the stale &#39;previousBuildInProgress&#39; back pointer</b>
<b class="nc">&nbsp;            r = n;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // fix up so that the next look up will run faster
<b class="nc">&nbsp;        for (RunT f : fixUp)</b>
<b class="nc">&nbsp;            f.previousBuildInProgress = answer == null ? f : answer;</b>
<b class="nc">&nbsp;        return answer;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last build that was actually built - i.e., skipping any with Result.NOT_BUILT
&nbsp;     */
&nbsp;    public @CheckForNull RunT getPreviousBuiltBuild() {
<b class="nc">&nbsp;        RunT r = getPreviousBuild();</b>
&nbsp;        // in certain situations (aborted m2 builds) r.getResult() can still be null, although it should theoretically never happen
<b class="nc">&nbsp;        while (r != null &amp;&amp; (r.getResult() == null || r.getResult() == Result.NOT_BUILT))</b>
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last build that didn&#39;t fail before this build.
&nbsp;     */
&nbsp;    public @CheckForNull RunT getPreviousNotFailedBuild() {
<b class="nc">&nbsp;        RunT r = getPreviousBuild();</b>
<b class="nc">&nbsp;        while (r != null &amp;&amp; r.getResult() == Result.FAILURE)</b>
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last failed build before this build.
&nbsp;     */
&nbsp;    public @CheckForNull RunT getPreviousFailedBuild() {
<b class="nc">&nbsp;        RunT r = getPreviousBuild();</b>
<b class="nc">&nbsp;        while (r != null &amp;&amp; r.getResult() != Result.FAILURE)</b>
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last successful build before this build.
&nbsp;     * @since 1.383
&nbsp;     */
&nbsp;    public @CheckForNull RunT getPreviousSuccessfulBuild() {
<b class="nc">&nbsp;        RunT r = getPreviousBuild();</b>
<b class="nc">&nbsp;        while (r != null &amp;&amp; r.getResult() != Result.SUCCESS)</b>
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last {@code numberOfBuilds} builds with a build result ? {@code threshold}.
&nbsp;     *
&nbsp;     * @param numberOfBuilds the desired number of builds
&nbsp;     * @param threshold the build result threshold
&nbsp;     * @return a list with the builds (youngest build first).
&nbsp;     *   May be smaller than &#39;numberOfBuilds&#39; or even empty
&nbsp;     *   if not enough builds satisfying the threshold have been found. Never null.
&nbsp;     * @since 1.383
&nbsp;     */
&nbsp;    public @NonNull List&lt;RunT&gt; getPreviousBuildsOverThreshold(int numberOfBuilds, @NonNull Result threshold) {
<b class="nc">&nbsp;        RunT r = getPreviousBuild();</b>
<b class="nc">&nbsp;        if (r != null) {</b>
<b class="nc">&nbsp;            return r.getBuildsOverThreshold(numberOfBuilds, threshold);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(numberOfBuilds);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the last {@code numberOfBuilds} builds with a build result ? {@code threshold}.
&nbsp;     *
&nbsp;     * @param numberOfBuilds the desired number of builds
&nbsp;     * @param threshold the build result threshold
&nbsp;     * @return a list with the builds (youngest build first).
&nbsp;     *   May be smaller than &#39;numberOfBuilds&#39; or even empty
&nbsp;     *   if not enough builds satisfying the threshold have been found. Never null.
&nbsp;     * @since 2.202
&nbsp;     */
&nbsp;    protected @NonNull List&lt;RunT&gt; getBuildsOverThreshold(int numberOfBuilds, @NonNull Result threshold) {
<b class="nc">&nbsp;        List&lt;RunT&gt; builds = new ArrayList&lt;&gt;(numberOfBuilds);</b>
&nbsp;
<b class="nc">&nbsp;        RunT r = _this();</b>
<b class="nc">&nbsp;        while (r != null &amp;&amp; builds.size() &lt; numberOfBuilds) {</b>
<b class="nc">&nbsp;            if (!r.isBuilding() &amp;&amp;</b>
<b class="nc">&nbsp;                 r.getResult() != null &amp;&amp; r.getResult().isBetterOrEqualTo(threshold)) {</b>
<b class="nc">&nbsp;                builds.add(r);</b>
&nbsp;            }
<b class="nc">&nbsp;            r = r.getPreviousBuild();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return builds;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @see jenkins.model.lazy.LazyBuildMixIn.RunMixIn#getNextBuild
&nbsp;     */
&nbsp;    public @CheckForNull RunT getNextBuild() {
<b class="nc">&nbsp;        return nextBuild;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the URL of this {@link Run}, relative to the context root of Hudson.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      String like &quot;job/foo/32/&quot; with trailing slash but no leading slash.
&nbsp;     */
&nbsp;    // I really messed this up. I&#39;m hoping to fix this some time
&nbsp;    // it shouldn&#39;t have trailing &#39;/&#39;, and instead it should have leading &#39;/&#39;
&nbsp;    public @NonNull String getUrl() {
&nbsp;
&nbsp;        // RUN may be accessed using permalinks, as &quot;/lastSuccessful&quot; or other, so try to retrieve this base URL
&nbsp;        // looking for &quot;this&quot; in the current request ancestors
&nbsp;        // @see also {@link AbstractItem#getUrl}
<b class="nc">&nbsp;        StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="nc">&nbsp;        if (req != null) {</b>
<b class="nc">&nbsp;            String seed = Functions.getNearestAncestorUrl(req, this);</b>
<b class="nc">&nbsp;            if (seed != null) {</b>
&nbsp;                // trim off the context path portion and leading &#39;/&#39;, but add trailing &#39;/&#39;
<b class="nc">&nbsp;                return seed.substring(req.getContextPath().length() + 1) + &#39;/&#39;;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return project.getUrl() + getNumber() + &#39;/&#39;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains the absolute URL to this build.
&nbsp;     *
&nbsp;     * @deprecated
&nbsp;     *      This method shall &lt;b&gt;NEVER&lt;/b&gt; be used during HTML page rendering, as it&#39;s too easy for
&nbsp;     *      misconfiguration to break this value, with network set up like Apache reverse proxy.
&nbsp;     *      This method is only intended for the remote API clients who cannot resolve relative references.
&nbsp;     */
&nbsp;    @Exported(visibility = 2, name = &quot;url&quot;)
&nbsp;    @Deprecated
&nbsp;    public final @NonNull String getAbsoluteUrl() {
<b class="nc">&nbsp;        return project.getAbsoluteUrl() + getNumber() + &#39;/&#39;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final @NonNull String getSearchUrl() {
<b class="nc">&nbsp;        return getNumber() + &quot;/&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Unique ID of this build.
&nbsp;     * Usually the decimal form of {@link #number}, but may be a formatted timestamp for historical builds.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @NonNull String getId() {
<b class="fc">&nbsp;        return id != null ? id : Integer.toString(number);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the root directory of this {@link Run} on the controller.
&nbsp;     * Files related to this {@link Run} should be stored below this directory.
&nbsp;     * @return Root directory of this {@link Run} on the controller. Never null
&nbsp;     */
&nbsp;    @Override
&nbsp;    public @NonNull File getRootDir() {
<b class="fc">&nbsp;        return new File(project.getBuildDir(), Integer.toString(number));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets an object responsible for storing and retrieving build artifacts.
&nbsp;     * If {@link #pickArtifactManager} has previously been called on this build,
&nbsp;     * and a nondefault manager selected, that will be returned.
&nbsp;     * Otherwise (including if we are loading a historical build created prior to this feature) {@link StandardArtifactManager} is used.
&nbsp;     * &lt;p&gt;This method should be used when existing artifacts are to be loaded, displayed, or removed.
&nbsp;     * If adding artifacts, use {@link #pickArtifactManager} instead.
&nbsp;     * @return an appropriate artifact manager
&nbsp;     * @since 1.532
&nbsp;     */
&nbsp;    public final @NonNull ArtifactManager getArtifactManager() {
<b class="nc">&nbsp;        return artifactManager != null ? artifactManager : new StandardArtifactManager(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects an object responsible for storing and retrieving build artifacts.
&nbsp;     * The first time this is called on a running build, {@link ArtifactManagerConfiguration} is checked
&nbsp;     * to see if one will handle this build.
&nbsp;     * If so, that manager is saved in the build and it will be used henceforth.
&nbsp;     * If no manager claimed the build, {@link StandardArtifactManager} is used.
&nbsp;     * &lt;p&gt;This method should be used when a build step expects to archive some artifacts.
&nbsp;     * If only displaying existing artifacts, use {@link #getArtifactManager} instead.
&nbsp;     * @return an appropriate artifact manager
&nbsp;     * @throws IOException if a custom manager was selected but the selection could not be saved
&nbsp;     * @since 1.532
&nbsp;     */
&nbsp;    public final synchronized @NonNull ArtifactManager pickArtifactManager() throws IOException {
<b class="nc">&nbsp;        if (artifactManager != null) {</b>
<b class="nc">&nbsp;            return artifactManager;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            for (ArtifactManagerFactory f : ArtifactManagerConfiguration.get().getArtifactManagerFactories()) {</b>
<b class="nc">&nbsp;                ArtifactManager mgr = f.managerFor(this);</b>
<b class="nc">&nbsp;                if (mgr != null) {</b>
<b class="nc">&nbsp;                    artifactManager = mgr;</b>
<b class="nc">&nbsp;                    save();</b>
<b class="nc">&nbsp;                    return mgr;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return new StandardArtifactManager(this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the directory where the artifacts are archived.
&nbsp;     * @deprecated Should only be used from {@link StandardArtifactManager} or subclasses.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public File getArtifactsDir() {
<b class="nc">&nbsp;        return new File(getRootDir(), &quot;archive&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the artifacts (relative to {@link #getArtifactsDir()}.
&nbsp;     * @return The list can be empty but never null
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @NonNull List&lt;Artifact&gt; getArtifacts() {
<b class="nc">&nbsp;        return getArtifactsUpTo(Integer.MAX_VALUE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the first N artifacts.
&nbsp;     * @return The list can be empty but never null
&nbsp;     */
&nbsp;    public @NonNull List&lt;Artifact&gt; getArtifactsUpTo(int artifactsNumber) {
&nbsp;        SerializableArtifactList sal;
<b class="nc">&nbsp;        VirtualFile root = getArtifactManager().root();</b>
&nbsp;        try {
<b class="nc">&nbsp;            sal = root.run(new AddArtifacts(root, artifactsNumber));</b>
<b class="nc">&nbsp;        } catch (IOException x) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;            sal = new SerializableArtifactList();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        ArtifactList r = new ArtifactList();</b>
<b class="nc">&nbsp;        r.updateFrom(sal);</b>
<b class="nc">&nbsp;        r.computeDisplayName();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the {@link Run} contains artifacts.
&nbsp;     * The strange method name is so that we can access it from EL.
&nbsp;     * @return true if this run has any artifacts
&nbsp;     */
&nbsp;    public boolean getHasArtifacts() {
<b class="nc">&nbsp;        return !getArtifactsUpTo(1).isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static final class AddArtifacts extends MasterToSlaveCallable&lt;SerializableArtifactList, IOException&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final VirtualFile root;
&nbsp;        private final int artifactsNumber;
&nbsp;
<b class="nc">&nbsp;        AddArtifacts(VirtualFile root, int artifactsNumber) {</b>
<b class="nc">&nbsp;            this.root = root;</b>
<b class="nc">&nbsp;            this.artifactsNumber = artifactsNumber;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public SerializableArtifactList call() throws IOException {
<b class="nc">&nbsp;            SerializableArtifactList sal = new SerializableArtifactList();</b>
<b class="nc">&nbsp;            addArtifacts(root, &quot;&quot;, &quot;&quot;, sal, null, artifactsNumber);</b>
<b class="nc">&nbsp;            return sal;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static int addArtifacts(@NonNull VirtualFile dir,
&nbsp;            @NonNull String path, @NonNull String pathHref,
&nbsp;            @NonNull SerializableArtifactList r, @CheckForNull SerializableArtifact parent, int upTo) throws IOException {
<b class="nc">&nbsp;        VirtualFile[] kids = dir.list();</b>
<b class="nc">&nbsp;        Arrays.sort(kids);</b>
&nbsp;
<b class="nc">&nbsp;        int n = 0;</b>
<b class="nc">&nbsp;        for (VirtualFile sub : kids) {</b>
<b class="nc">&nbsp;            String child = sub.getName();</b>
<b class="nc">&nbsp;            String childPath = path + child;</b>
<b class="nc">&nbsp;            String childHref = pathHref + Util.rawEncode(child);</b>
<b class="nc">&nbsp;            String length = sub.isFile() ? String.valueOf(sub.length()) : &quot;&quot;;</b>
<b class="nc">&nbsp;            boolean collapsed = kids.length == 1 &amp;&amp; parent != null;</b>
&nbsp;            SerializableArtifact a;
<b class="nc">&nbsp;            if (collapsed) {</b>
&nbsp;                // Collapse single items into parent node where possible:
<b class="nc">&nbsp;                a = new SerializableArtifact(parent.name + &#39;/&#39; + child, childPath,</b>
<b class="nc">&nbsp;                                 sub.isDirectory() ? null : childHref, length,</b>
&nbsp;                                 parent.treeNodeId);
<b class="nc">&nbsp;                r.tree.put(a, r.tree.remove(parent));</b>
&nbsp;            } else {
&nbsp;                // Use null href for a directory:
<b class="nc">&nbsp;                a = new SerializableArtifact(child, childPath,</b>
<b class="nc">&nbsp;                                 sub.isDirectory() ? null : childHref, length,</b>
&nbsp;                                 &quot;n&quot; + ++r.idSeq);
<b class="nc">&nbsp;                r.tree.put(a, parent != null ? parent.treeNodeId : null);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (sub.isDirectory()) {</b>
<b class="nc">&nbsp;                n += addArtifacts(sub, childPath + &#39;/&#39;, childHref + &#39;/&#39;, r, a, upTo - n);</b>
<b class="nc">&nbsp;                if (n &gt;= upTo) break;</b>
&nbsp;            } else {
&nbsp;                // Don&#39;t store collapsed path in ArrayList (for correct data in external API)
<b class="nc">&nbsp;                r.add(collapsed ? new SerializableArtifact(child, a.relativePath, a.href, length, a.treeNodeId) : a);</b>
<b class="nc">&nbsp;                if (++n &gt;= upTo) break;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maximum number of artifacts to list before using switching to the tree view.
&nbsp;     */
<b class="fc">&nbsp;    public static final int LIST_CUTOFF = Integer.parseInt(SystemProperties.getString(&quot;hudson.model.Run.ArtifactList.listCutoff&quot;, &quot;20&quot;));</b>
&nbsp;
&nbsp;    // ..and then &quot;too many&quot;
&nbsp;
&nbsp;    /** {@link Run.Artifact} without the implicit link to {@link Run} */
&nbsp;    private static final class SerializableArtifact implements Serializable {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        final String name;
&nbsp;        final String relativePath;
&nbsp;        final String href;
&nbsp;        final String length;
&nbsp;        final String treeNodeId;
&nbsp;
<b class="nc">&nbsp;        SerializableArtifact(String name, String relativePath, String href, String length, String treeNodeId) {</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.relativePath = relativePath;</b>
<b class="nc">&nbsp;            this.href = href;</b>
<b class="nc">&nbsp;            this.length = length;</b>
<b class="nc">&nbsp;            this.treeNodeId = treeNodeId;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** {@link Run.ArtifactList} without the implicit link to {@link Run} */
<b class="nc">&nbsp;    private static final class SerializableArtifactList extends ArrayList&lt;SerializableArtifact&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
<b class="nc">&nbsp;        private LinkedHashMap&lt;SerializableArtifact, String&gt; tree = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        private int idSeq = 0;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public final class ArtifactList extends ArrayList&lt;Artifact&gt; {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        /**
&nbsp;         * Map of Artifact to treeNodeId of parent node in tree view.
&nbsp;         * Contains Artifact objects for directories and files (the ArrayList contains only files).
&nbsp;         */
<b class="fc">&nbsp;        private LinkedHashMap&lt;Artifact, String&gt; tree = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        void updateFrom(SerializableArtifactList clone) {
<b class="nc">&nbsp;            Map&lt;String, Artifact&gt; artifacts = new HashMap&lt;&gt;(); // need to share objects between tree and list, since computeDisplayName mutates displayPath</b>
<b class="nc">&nbsp;            for (SerializableArtifact sa : clone) {</b>
<b class="nc">&nbsp;                Artifact a = new Artifact(sa);</b>
<b class="nc">&nbsp;                artifacts.put(a.relativePath, a);</b>
<b class="nc">&nbsp;                add(a);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            tree = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Map.Entry&lt;SerializableArtifact, String&gt; entry : clone.tree.entrySet()) {</b>
<b class="nc">&nbsp;                SerializableArtifact sa = entry.getKey();</b>
<b class="nc">&nbsp;                Artifact a = artifacts.get(sa.relativePath);</b>
<b class="nc">&nbsp;                if (a == null) {</b>
<b class="nc">&nbsp;                    a = new Artifact(sa);</b>
&nbsp;                }
<b class="nc">&nbsp;                tree.put(a, entry.getValue());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;Artifact, String&gt; getTree() {
<b class="nc">&nbsp;            return tree;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void computeDisplayName() {
<b class="fc">&nbsp;            if (size() &gt; LIST_CUTOFF)   return; // we are not going to display file names, so no point in computing this</b>
&nbsp;
<b class="fc">&nbsp;            int maxDepth = 0;</b>
<b class="fc">&nbsp;            int[] len = new int[size()];</b>
<b class="fc">&nbsp;            String[][] tokens = new String[size()][];</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; tokens.length; i++) {</b>
<b class="fc">&nbsp;                tokens[i] = get(i).relativePath.split(&quot;[\\\\/]+&quot;);</b>
<b class="fc">&nbsp;                maxDepth = Math.max(maxDepth, tokens[i].length);</b>
<b class="fc">&nbsp;                len[i] = 1;</b>
&nbsp;            }
&nbsp;
&nbsp;            boolean collision;
<b class="fc">&nbsp;            int depth = 0;</b>
&nbsp;            do {
<b class="fc">&nbsp;                collision = false;</b>
<b class="fc">&nbsp;                Map&lt;String, Integer/*index*/&gt; names = new HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; tokens.length; i++) {</b>
<b class="fc">&nbsp;                    String[] token = tokens[i];</b>
<b class="fc">&nbsp;                    String displayName = combineLast(token, len[i]);</b>
<b class="fc">&nbsp;                    Integer j = names.put(displayName, i);</b>
<b class="fc">&nbsp;                    if (j != null) {</b>
<b class="fc">&nbsp;                        collision = true;</b>
<b class="fc">&nbsp;                        if (j &gt;= 0)</b>
<b class="fc">&nbsp;                            len[j]++;</b>
<b class="fc">&nbsp;                        len[i]++;</b>
<b class="fc">&nbsp;                        names.put(displayName, -1);  // occupy this name but don&#39;t let len[i] incremented with additional collisions</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            } while (collision &amp;&amp; depth++ &lt; maxDepth);</b>
&nbsp;
<b class="fc">&nbsp;            for (int i = 0; i &lt; tokens.length; i++)</b>
<b class="fc">&nbsp;                get(i).displayPath = combineLast(tokens[i], len[i]);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Combines last N token into the &quot;a/b/c&quot; form.
&nbsp;         */
&nbsp;        private String combineLast(String[] token, int n) {
<b class="fc">&nbsp;            StringBuilder buf = new StringBuilder();</b>
<b class="fc">&nbsp;            for (int i = Math.max(0, token.length - n); i &lt; token.length; i++) {</b>
<b class="fc">&nbsp;                if (buf.length() &gt; 0)  buf.append(&#39;/&#39;);</b>
<b class="fc">&nbsp;                buf.append(token[i]);</b>
&nbsp;            }
<b class="fc">&nbsp;            return buf.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A build artifact.
&nbsp;     */
&nbsp;    @ExportedBean
&nbsp;    public class Artifact {
&nbsp;        /**
&nbsp;         * Relative path name from artifacts root.
&nbsp;         */
&nbsp;        @Exported(visibility = 3)
&nbsp;        public final String relativePath;
&nbsp;
&nbsp;        /**
&nbsp;         * Truncated form of {@link #relativePath} just enough
&nbsp;         * to disambiguate {@link Artifact}s.
&nbsp;         */
&nbsp;        /*package*/ String displayPath;
&nbsp;
&nbsp;        /**
&nbsp;         * The filename of the artifact.
&nbsp;         * (though when directories with single items are collapsed for tree view, name may
&nbsp;         *  include multiple path components, like &quot;dist/pkg/mypkg&quot;)
&nbsp;         */
&nbsp;        private String name;
&nbsp;
&nbsp;        /**
&nbsp;         * Properly encoded relativePath for use in URLs.  This field is null for directories.
&nbsp;         */
&nbsp;        private String href;
&nbsp;
&nbsp;        /**
&nbsp;         * Id of this node for use in tree view.
&nbsp;         */
&nbsp;        private String treeNodeId;
&nbsp;
&nbsp;        /**
&nbsp;         * length of this artifact for files.
&nbsp;         */
&nbsp;        private String length;
&nbsp;
&nbsp;        Artifact(SerializableArtifact clone) {
<b class="nc">&nbsp;            this(clone.name, clone.relativePath, clone.href, clone.length, clone.treeNodeId);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        /*package for test*/ Artifact(String name, String relativePath, String href, String len, String treeNodeId) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.relativePath = relativePath;</b>
<b class="fc">&nbsp;            this.href = href;</b>
<b class="fc">&nbsp;            this.treeNodeId = treeNodeId;</b>
<b class="fc">&nbsp;            this.length = len;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets the artifact file.
&nbsp;         * @deprecated May not be meaningful with custom artifact managers. Use {@link ArtifactManager#root} plus {@link VirtualFile#child} with {@link #relativePath} instead.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public @NonNull File getFile() {
<b class="nc">&nbsp;            return new File(getArtifactsDir(), relativePath);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns just the file name portion, without the path.
&nbsp;         */
&nbsp;        @Exported(visibility = 3)
&nbsp;        public String getFileName() {
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported(visibility = 3)
&nbsp;        public String getDisplayPath() {
<b class="fc">&nbsp;            return displayPath;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getHref() {
<b class="nc">&nbsp;            return href;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getLength() {
<b class="nc">&nbsp;            return length;</b>
&nbsp;        }
&nbsp;
&nbsp;        public long getFileSize() {
&nbsp;            try {
<b class="nc">&nbsp;                return Long.decode(length);</b>
&nbsp;            }
<b class="nc">&nbsp;            catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(FINE, &quot;Cannot determine file size of the artifact {0}. The length {1} is not a valid long value&quot;, new Object[] {this, length});</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String getTreeNodeId() {
<b class="nc">&nbsp;            return treeNodeId;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return relativePath;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * get the fingerprints associated with this build
&nbsp;     *
&nbsp;     * @return The fingerprints
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    @Exported(name = &quot;fingerprint&quot;, inline = true, visibility = -1)
&nbsp;    public Collection&lt;Fingerprint&gt; getBuildFingerprints() {
<b class="nc">&nbsp;        FingerprintAction fingerprintAction = getAction(FingerprintAction.class);</b>
<b class="nc">&nbsp;        if (fingerprintAction != null) {</b>
<b class="nc">&nbsp;            return fingerprintAction.getFingerprints().values();</b>
&nbsp;        }
<b class="nc">&nbsp;        return Collections.emptyList();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the log file.
&nbsp;     * @return The file may reference both uncompressed or compressed logs
&nbsp;     * @deprecated Assumes file-based storage of the log, which is not necessarily the case for Pipelines after JEP-210.
&nbsp;     *     Use other methods giving various kinds of streams such as {@link Run#getLogReader()}, {@link Run#getLogInputStream()}, or {@link Run#getLogText()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public @NonNull File getLogFile() {
<b class="fc">&nbsp;        File rawF = new File(getRootDir(), &quot;log&quot;);</b>
<b class="fc">&nbsp;        if (rawF.isFile()) {</b>
<b class="fc">&nbsp;            return rawF;</b>
&nbsp;        }
<b class="fc">&nbsp;        File gzF = new File(getRootDir(), &quot;log.gz&quot;);</b>
<b class="fc">&nbsp;        if (gzF.isFile()) {</b>
<b class="nc">&nbsp;            return gzF;</b>
&nbsp;        }
&nbsp;        //If both fail, return the standard, uncompressed log file
<b class="fc">&nbsp;        return rawF;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an input stream that reads from the log file.
&nbsp;     * It will use a gzip-compressed log file (log.gz) if that exists.
&nbsp;     *
&nbsp;     * @return An input stream from the log file.
&nbsp;     *   If the log file does not exist, the error message will be returned to the output.
&nbsp;     * @since 1.349
&nbsp;     */
&nbsp;    public @NonNull InputStream getLogInputStream() throws IOException {
<b class="nc">&nbsp;        File logFile = getLogFile();</b>
&nbsp;
<b class="nc">&nbsp;        if (logFile.exists()) {</b>
&nbsp;            // Checking if a &quot;.gz&quot; file was return
&nbsp;            try {
<b class="nc">&nbsp;                InputStream fis = Files.newInputStream(logFile.toPath());</b>
<b class="nc">&nbsp;                if (logFile.getName().endsWith(&quot;.gz&quot;)) {</b>
<b class="nc">&nbsp;                    return new GZIPInputStream(fis);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return fis;</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (InvalidPathException e) {</b>
<b class="nc">&nbsp;                throw new IOException(e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String message = &quot;No such file: &quot; + logFile;</b>
<b class="nc">&nbsp;        return new ByteArrayInputStream(charset != null ? message.getBytes(charset) : message.getBytes(Charset.defaultCharset()));</b>
&nbsp;    }
&nbsp;
&nbsp;    public @NonNull Reader getLogReader() throws IOException {
<b class="nc">&nbsp;        if (charset == null)  return new InputStreamReader(getLogInputStream(), Charset.defaultCharset());</b>
<b class="nc">&nbsp;        else                return new InputStreamReader(getLogInputStream(), charset);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used from {@code console.jelly} to write annotated log to the given output.
&nbsp;     *
&nbsp;     * @since 1.349
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;RV_RETURN_VALUE_IGNORED&quot;, justification = &quot;method signature does not permit plumbing through the return value&quot;)
&nbsp;    public void writeLogTo(long offset, @NonNull XMLOutput out) throws IOException {
<b class="fc">&nbsp;        long start = offset;</b>
<b class="fc">&nbsp;        if (offset &gt; 0) {</b>
<b class="fc">&nbsp;            try (BufferedInputStream bufferedInputStream = new BufferedInputStream(getLogInputStream())) {</b>
<b class="fc">&nbsp;                if (offset == bufferedInputStream.skip(offset)) {</b>
&nbsp;                    int r;
&nbsp;                    do {
<b class="fc">&nbsp;                        r = bufferedInputStream.read();</b>
<b class="fc">&nbsp;                        start = r == -1 ? 0 : start + 1;</b>
<b class="fc">&nbsp;                    } while (r != -1 &amp;&amp; r != &#39;\n&#39;);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        getLogText().writeHtmlTo(start, out.asWriter());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes the complete log from the start to finish to the {@link OutputStream}.
&nbsp;     *
&nbsp;     * If someone is still writing to the log, this method will not return until the whole log
&nbsp;     * file gets written out.
&nbsp;     * &lt;p&gt;
&nbsp;     * The method does not close the {@link OutputStream}.
&nbsp;     */
&nbsp;    public void writeWholeLogTo(@NonNull OutputStream out) throws IOException, InterruptedException {
<b class="nc">&nbsp;        long pos = 0;</b>
&nbsp;        AnnotatedLargeText logText;
<b class="nc">&nbsp;        logText = getLogText();</b>
<b class="nc">&nbsp;        pos = logText.writeLogTo(pos, out);</b>
&nbsp;
<b class="nc">&nbsp;        while (!logText.isComplete()) {</b>
&nbsp;            // Instead of us hitting the log file as many times as possible, instead we get the information once every
&nbsp;            // second to avoid CPU usage getting very high.
<b class="nc">&nbsp;            Thread.sleep(1000);</b>
<b class="nc">&nbsp;            logText = getLogText();</b>
<b class="nc">&nbsp;            pos = logText.writeLogTo(pos, out);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to URL-bind {@link AnnotatedLargeText}.
&nbsp;     * @return A {@link Run} log with annotations
&nbsp;     */
&nbsp;    public @NonNull AnnotatedLargeText getLogText() {
<b class="nc">&nbsp;        return new AnnotatedLargeText(getLogFile(), getCharset(), !isLogUpdated(), this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected @NonNull SearchIndexBuilder makeSearchIndex() {
<b class="nc">&nbsp;        SearchIndexBuilder builder = super.makeSearchIndex()</b>
<b class="nc">&nbsp;                .add(&quot;console&quot;)</b>
<b class="nc">&nbsp;                .add(&quot;changes&quot;);</b>
<b class="nc">&nbsp;        for (Action a : getAllActions()) {</b>
<b class="nc">&nbsp;            if (a.getIconFileName() != null)</b>
<b class="nc">&nbsp;                builder.add(a.getUrlName());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    public @NonNull Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public ACL getACL() {
&nbsp;        // for now, don&#39;t maintain ACL per run, and do it at project level
<b class="nc">&nbsp;        return getParent().getACL();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this build&#39;s artifacts.
&nbsp;     *
&nbsp;     * @throws IOException
&nbsp;     *      if we fail to delete.
&nbsp;     *
&nbsp;     * @since 1.350
&nbsp;     */
&nbsp;    public synchronized void deleteArtifacts() throws IOException {
&nbsp;        try {
<b class="nc">&nbsp;            getArtifactManager().delete();</b>
<b class="nc">&nbsp;        } catch (InterruptedException x) {</b>
<b class="nc">&nbsp;            throw new IOException(x);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this build and its entire log
&nbsp;     *
&nbsp;     * @throws IOException
&nbsp;     *      if we fail to delete.
&nbsp;     */
&nbsp;    public void delete() throws IOException {
<b class="nc">&nbsp;        synchronized (this) {</b>
&nbsp;            // Avoid concurrent delete. See https://issues.jenkins.io/browse/JENKINS-61687
<b class="nc">&nbsp;            if (isPendingDelete) {</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            isPendingDelete = true;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        File rootDir = getRootDir();</b>
<b class="nc">&nbsp;        if (!rootDir.isDirectory()) {</b>
&nbsp;            //No root directory found to delete. Somebody seems to have nuked
&nbsp;            //it externally. Logging a warning before dropping the build
<b class="nc">&nbsp;            LOGGER.warning(String.format(</b>
&nbsp;                    &quot;%s: %s looks to have already been deleted, assuming build dir was already cleaned up&quot;,
&nbsp;                    this, rootDir
&nbsp;            ));
&nbsp;            //Still firing the delete listeners; just no need to clean up rootDir
<b class="nc">&nbsp;            RunListener.fireDeleted(this);</b>
<b class="nc">&nbsp;            synchronized (this) { // avoid holding a lock while calling plugin impls of onDeleted</b>
<b class="nc">&nbsp;                removeRunFromParent();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        //The root dir exists and is a directory that needs to be purged
<b class="nc">&nbsp;        RunListener.fireDeleted(this);</b>
&nbsp;
<b class="nc">&nbsp;        if (artifactManager != null) {</b>
<b class="nc">&nbsp;            deleteArtifacts();</b>
&nbsp;        } // for StandardArtifactManager, deleting the whole build dir suffices
&nbsp;
<b class="nc">&nbsp;        synchronized (this) { // avoid holding a lock while calling plugin impls of onDeleted</b>
<b class="nc">&nbsp;            File tmp = new File(rootDir.getParentFile(), &#39;.&#39; + rootDir.getName());</b>
&nbsp;
<b class="nc">&nbsp;            if (tmp.exists()) {</b>
<b class="nc">&nbsp;                Util.deleteRecursive(tmp);</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                Files.move(</b>
<b class="nc">&nbsp;                        Util.fileToPath(rootDir),</b>
<b class="nc">&nbsp;                        Util.fileToPath(tmp),</b>
&nbsp;                        StandardCopyOption.ATOMIC_MOVE
&nbsp;                );
<b class="nc">&nbsp;            } catch (UnsupportedOperationException | SecurityException ex) {</b>
<b class="nc">&nbsp;                throw new IOException(rootDir + &quot; is in use&quot;, ex);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            Util.deleteRecursive(tmp);</b>
&nbsp;            // some user reported that they see some left-over .xyz files in the workspace,
&nbsp;            // so just to make sure we&#39;ve really deleted it, schedule the deletion on VM exit, too.
<b class="nc">&nbsp;            if (tmp.exists()) {</b>
<b class="nc">&nbsp;                tmp.deleteOnExit();</b>
&nbsp;            }
<b class="nc">&nbsp;            LOGGER.log(FINE, &quot;{0}: {1} successfully deleted&quot;, new Object[] {this, rootDir});</b>
<b class="nc">&nbsp;            removeRunFromParent();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // seems this is too clever for Java&#39;s type system?
&nbsp;    private void removeRunFromParent() {
<b class="nc">&nbsp;        getParent().removeRun((RunT) this);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * @see CheckPoint#report()
&nbsp;     */
&nbsp;    /*package*/ static void reportCheckpoint(@NonNull CheckPoint id) {
<b class="nc">&nbsp;        Run&lt;?, ?&gt;.RunExecution exec = RunnerStack.INSTANCE.peek();</b>
<b class="nc">&nbsp;        if (exec == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        exec.checkpoints.report(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @see CheckPoint#block()
&nbsp;     */
&nbsp;    /*package*/ static void waitForCheckpoint(@NonNull CheckPoint id, @CheckForNull BuildListener listener, @CheckForNull String waiter) throws InterruptedException {
&nbsp;        while (true) {
<b class="nc">&nbsp;            Run&lt;?, ?&gt;.RunExecution exec = RunnerStack.INSTANCE.peek();</b>
<b class="nc">&nbsp;            if (exec == null) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            Run b = exec.getBuild().getPreviousBuildInProgress();</b>
<b class="nc">&nbsp;            if (b == null)     return; // no pending earlier build</b>
<b class="nc">&nbsp;            Run.RunExecution runner = b.runner;</b>
<b class="nc">&nbsp;            if (runner == null) {</b>
&nbsp;                // polled at the wrong moment. try again.
<b class="nc">&nbsp;                Thread.sleep(0);</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (runner.checkpoints.waitForCheckPoint(id, listener, waiter))</b>
&nbsp;                return; // confirmed that the previous build reached the check point
&nbsp;
&nbsp;            // the previous build finished without ever reaching the check point. try again.
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.467
&nbsp;     *      Please use {@link RunExecution}
&nbsp;     */
&nbsp;    @Deprecated
<b class="nc">&nbsp;    protected abstract class Runner extends RunExecution {}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Object that lives while the build is executed, to keep track of things that
&nbsp;     * are needed only during the build.
&nbsp;     */
<b class="nc">&nbsp;    public abstract class RunExecution {</b>
&nbsp;        /**
&nbsp;         * Keeps track of the check points attained by a build, and abstracts away the synchronization needed to
&nbsp;         * maintain this data structure.
&nbsp;         */
<b class="nc">&nbsp;        private final class CheckpointSet {</b>
&nbsp;            /**
&nbsp;             * Stages of the builds that this runner has completed. This is used for concurrent {@link RunExecution}s to
&nbsp;             * coordinate and serialize their executions where necessary.
&nbsp;             */
<b class="nc">&nbsp;            private final Set&lt;CheckPoint&gt; checkpoints = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;            private boolean allDone;
&nbsp;
&nbsp;            protected synchronized void report(@NonNull CheckPoint identifier) {
<b class="nc">&nbsp;                checkpoints.add(identifier);</b>
<b class="nc">&nbsp;                notifyAll();</b>
&nbsp;            }
&nbsp;
&nbsp;            protected synchronized boolean waitForCheckPoint(@NonNull CheckPoint identifier, @CheckForNull BuildListener listener, @CheckForNull String waiter) throws InterruptedException {
<b class="nc">&nbsp;                final Thread t = Thread.currentThread();</b>
<b class="nc">&nbsp;                final String oldName = t.getName();</b>
<b class="nc">&nbsp;                t.setName(oldName + &quot; : waiting for &quot; + identifier + &quot; on &quot; + getFullDisplayName() + &quot; from &quot; + waiter);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    boolean first = true;</b>
<b class="nc">&nbsp;                    while (!allDone &amp;&amp; !checkpoints.contains(identifier)) {</b>
<b class="nc">&nbsp;                        if (first &amp;&amp; listener != null &amp;&amp; waiter != null) {</b>
<b class="nc">&nbsp;                            listener.getLogger().println(Messages.Run__is_waiting_for_a_checkpoint_on_(waiter, getFullDisplayName()));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        wait();</b>
<b class="nc">&nbsp;                        first = false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return checkpoints.contains(identifier);</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    t.setName(oldName);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Notifies that the build is fully completed and all the checkpoint locks be released.
&nbsp;             */
&nbsp;            private synchronized void allDone() {
<b class="nc">&nbsp;                allDone = true;</b>
<b class="nc">&nbsp;                notifyAll();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        private final CheckpointSet checkpoints = new CheckpointSet();</b>
&nbsp;
<b class="nc">&nbsp;        private final Map&lt;Object, Object&gt; attributes = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Performs the main build and returns the status code.
&nbsp;         *
&nbsp;         * @throws Exception
&nbsp;         *      exception will be recorded and the build will be considered a failure.
&nbsp;         */
&nbsp;        public abstract @NonNull Result run(@NonNull BuildListener listener) throws Exception;
&nbsp;
&nbsp;        /**
&nbsp;         * Performs the post-build action.
&nbsp;         * &lt;p&gt;
&nbsp;         * This method is called after {@linkplain #run(BuildListener) the main portion of the build is completed.}
&nbsp;         * This is a good opportunity to do notifications based on the result
&nbsp;         * of the build. When this method is called, the build is not really
&nbsp;         * finalized yet, and the build is still considered in progress --- for example,
&nbsp;         * even if the build is successful, this build still won&#39;t be picked up
&nbsp;         * by {@link Job#getLastSuccessfulBuild()}.
&nbsp;         */
&nbsp;        public abstract void post(@NonNull BuildListener listener) throws Exception;
&nbsp;
&nbsp;        /**
&nbsp;         * Performs final clean up action.
&nbsp;         * &lt;p&gt;
&nbsp;         * This method is called after {@link #post(BuildListener)},
&nbsp;         * after the build result is fully finalized. This is the point
&nbsp;         * where the build is already considered completed.
&nbsp;         * &lt;p&gt;
&nbsp;         * Among other things, this is often a necessary pre-condition
&nbsp;         * before invoking other builds that depend on this build.
&nbsp;         */
&nbsp;        public abstract void cleanUp(@NonNull BuildListener listener) throws Exception;
&nbsp;
&nbsp;        public @NonNull RunT getBuild() {
<b class="nc">&nbsp;            return _this();</b>
&nbsp;        }
&nbsp;
&nbsp;        public @NonNull JobT getProject() {
<b class="nc">&nbsp;            return _this().getParent();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Bag of stuff to allow plugins to store state for the duration of a build
&nbsp;         * without persisting it.
&nbsp;         *
&nbsp;         * @since 1.473
&nbsp;         */
&nbsp;        public @NonNull Map&lt;Object, Object&gt; getAttributes() {
<b class="nc">&nbsp;            return attributes;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used in {@link Run.RunExecution#run} to indicates that a fatal error in a build
&nbsp;     * is reported to {@link BuildListener} and the build should be simply aborted
&nbsp;     * without further recording a stack trace.
&nbsp;     */
<b class="nc">&nbsp;    public static final class RunnerAbortedException extends RuntimeException {</b>
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.467
&nbsp;     *      Use {@link #execute(hudson.model.Run.RunExecution)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    protected final void run(@NonNull Runner job) {
<b class="nc">&nbsp;        execute(job);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected final void execute(@NonNull RunExecution job) {
<b class="nc">&nbsp;        if (result != null)</b>
&nbsp;            return;     // already built.
&nbsp;
<b class="nc">&nbsp;        OutputStream logger = null;</b>
<b class="nc">&nbsp;        StreamBuildListener listener = null;</b>
&nbsp;
<b class="nc">&nbsp;        runner = job;</b>
<b class="nc">&nbsp;        onStartBuilding();</b>
&nbsp;        try {
&nbsp;            // to set the state to COMPLETE in the end, even if the thread dies abnormally.
&nbsp;            // otherwise the queue state becomes inconsistent
&nbsp;
<b class="nc">&nbsp;            long start = System.currentTimeMillis();</b>
&nbsp;
&nbsp;            try {
&nbsp;                try {
<b class="nc">&nbsp;                    Computer computer = Computer.currentComputer();</b>
<b class="nc">&nbsp;                    Charset charset = null;</b>
<b class="nc">&nbsp;                    if (computer != null) {</b>
<b class="nc">&nbsp;                        charset = computer.getDefaultCharset();</b>
<b class="nc">&nbsp;                        this.charset = charset.name();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    logger = createLogger();</b>
<b class="nc">&nbsp;                    listener = createBuildListener(job, logger, charset);</b>
<b class="nc">&nbsp;                    listener.started(getCauses());</b>
&nbsp;
<b class="nc">&nbsp;                    Authentication auth = Jenkins.getAuthentication2();</b>
<b class="nc">&nbsp;                    if (auth.equals(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                        listener.getLogger().println(Messages.Run_running_as_SYSTEM());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        String id = auth.getName();</b>
<b class="nc">&nbsp;                        if (!auth.equals(Jenkins.ANONYMOUS2)) {</b>
<b class="nc">&nbsp;                            final User usr = User.getById(id, false);</b>
<b class="nc">&nbsp;                            if (usr != null) { // Encode user hyperlink for existing users</b>
<b class="nc">&nbsp;                                id = ModelHyperlinkNote.encodeTo(usr);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        listener.getLogger().println(Messages.Run_running_as_(id));</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    RunListener.fireStarted(this, listener);</b>
&nbsp;
<b class="nc">&nbsp;                    setResult(job.run(listener));</b>
&nbsp;
<b class="nc">&nbsp;                    LOGGER.log(FINE, &quot;{0} main build action completed: {1}&quot;, new Object[] {this, result});</b>
<b class="nc">&nbsp;                    CheckPoint.MAIN_COMPLETED.report();</b>
<b class="nc">&nbsp;                } catch (AbortException e) { // orderly abortion.</b>
<b class="nc">&nbsp;                    result = Result.FAILURE;</b>
<b class="nc">&nbsp;                    listener.error(e.getMessage());</b>
<b class="nc">&nbsp;                    LOGGER.log(FINE, &quot;Build &quot; + this + &quot; aborted&quot;, e);</b>
<b class="nc">&nbsp;                } catch (RunnerAbortedException e) { // orderly abortion.</b>
<b class="nc">&nbsp;                    result = Result.FAILURE;</b>
<b class="nc">&nbsp;                    LOGGER.log(FINE, &quot;Build &quot; + this + &quot; aborted&quot;, e);</b>
<b class="nc">&nbsp;                } catch (InterruptedException e) {</b>
&nbsp;                    // aborted
<b class="nc">&nbsp;                    result = Executor.currentExecutor().abortResult();</b>
<b class="nc">&nbsp;                    listener.getLogger().println(Messages.Run_BuildAborted());</b>
<b class="nc">&nbsp;                    Executor.currentExecutor().recordCauseOfInterruption(Run.this, listener);</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.INFO, this + &quot; aborted&quot;, e);</b>
<b class="nc">&nbsp;                } catch (Throwable e) {</b>
<b class="nc">&nbsp;                    handleFatalBuildProblem(listener, e);</b>
<b class="nc">&nbsp;                    result = Result.FAILURE;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                // even if the main build fails fatally, try to run post build processing
<b class="nc">&nbsp;                job.post(Objects.requireNonNull(listener));</b>
&nbsp;
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                handleFatalBuildProblem(listener, e);</b>
<b class="nc">&nbsp;                result = Result.FAILURE;</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                long end = System.currentTimeMillis();</b>
<b class="nc">&nbsp;                duration = Math.max(end - start, 0);  // @see JENKINS-5844</b>
&nbsp;
&nbsp;                // advance the state.
&nbsp;                // the significance of doing this is that Jenkins
&nbsp;                // will now see this build as completed.
&nbsp;                // things like triggering other builds requires this as pre-condition.
&nbsp;                // see issue JENKINS-980.
<b class="nc">&nbsp;                LOGGER.log(FINER, &quot;moving into POST_PRODUCTION on {0}&quot;, this);</b>
<b class="nc">&nbsp;                state = State.POST_PRODUCTION;</b>
&nbsp;
<b class="nc">&nbsp;                if (listener != null) {</b>
<b class="nc">&nbsp;                    RunListener.fireCompleted(this, listener);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        job.cleanUp(listener);</b>
<b class="nc">&nbsp;                    } catch (Exception e) {</b>
<b class="nc">&nbsp;                        handleFatalBuildProblem(listener, e);</b>
&nbsp;                        // too late to update the result now
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    listener.finished(result);</b>
<b class="nc">&nbsp;                    listener.closeQuietly();</b>
&nbsp;                }
&nbsp;
&nbsp;                try {
<b class="nc">&nbsp;                    save();</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.SEVERE, &quot;Failed to save build record&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                getParent().logRotate();</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to rotate log&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            onEndBuilding();</b>
<b class="nc">&nbsp;            if (logger != null) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    logger.close();</b>
<b class="nc">&nbsp;                } catch (IOException x) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;failed to close log for &quot; + Run.this, x);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private OutputStream createLogger() throws IOException {
&nbsp;        // don&#39;t do buffering so that what&#39;s written to the listener
&nbsp;        // gets reflected to the file immediately, which can then be
&nbsp;        // served to the browser immediately
&nbsp;        try {
<b class="nc">&nbsp;            return Files.newOutputStream(getLogFile().toPath(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);</b>
<b class="nc">&nbsp;        } catch (InvalidPathException e) {</b>
<b class="nc">&nbsp;            throw new IOException(e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private StreamBuildListener createBuildListener(@NonNull RunExecution job, OutputStream logger, Charset charset) throws IOException, InterruptedException {
<b class="nc">&nbsp;        RunT build = job.getBuild();</b>
&nbsp;
&nbsp;        // Global log filters
<b class="nc">&nbsp;        for (ConsoleLogFilter filter : ConsoleLogFilter.all()) {</b>
<b class="nc">&nbsp;            logger = filter.decorateLogger(build, logger);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // Project specific log filters
<b class="nc">&nbsp;        if (project instanceof BuildableItemWithBuildWrappers &amp;&amp; build instanceof AbstractBuild) {</b>
<b class="nc">&nbsp;            BuildableItemWithBuildWrappers biwbw = (BuildableItemWithBuildWrappers) project;</b>
<b class="nc">&nbsp;            for (BuildWrapper bw : biwbw.getBuildWrappersList()) {</b>
<b class="nc">&nbsp;                logger = bw.decorateLogger((AbstractBuild) build, logger);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new StreamBuildListener(logger, charset);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated After JENKINS-37862 this no longer does anything.
&nbsp;     */
&nbsp;    @Deprecated
<b class="nc">&nbsp;    public final void updateSymlinks(@NonNull TaskListener listener) throws InterruptedException {}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Handles a fatal build problem (exception) that occurred during the build.
&nbsp;     */
&nbsp;    private void handleFatalBuildProblem(@NonNull BuildListener listener, @NonNull Throwable e) {
<b class="nc">&nbsp;        if (listener != null) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, getDisplayName() + &quot; failed to build&quot;, e);</b>
&nbsp;
<b class="nc">&nbsp;            if (e instanceof IOException)</b>
<b class="nc">&nbsp;                Util.displayIOException((IOException) e, listener);</b>
&nbsp;
<b class="nc">&nbsp;            Functions.printStackTrace(e, listener.fatalError(e.getMessage()));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            LOGGER.log(SEVERE, getDisplayName() + &quot; failed to build and we don&#39;t even have a listener&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called when a job started building.
&nbsp;     */
&nbsp;    protected void onStartBuilding() {
<b class="fc">&nbsp;        LOGGER.log(FINER, &quot;moving to BUILDING on {0}&quot;, this);</b>
<b class="fc">&nbsp;        state = State.BUILDING;</b>
<b class="fc">&nbsp;        startTime = System.currentTimeMillis();</b>
<b class="fc">&nbsp;        if (runner != null)</b>
<b class="nc">&nbsp;            RunnerStack.INSTANCE.push(runner);</b>
<b class="fc">&nbsp;        RunListener.fireInitialize(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called when a job finished building normally or abnormally.
&nbsp;     */
&nbsp;    protected void onEndBuilding() {
&nbsp;        // signal that we&#39;ve finished building.
<b class="fc">&nbsp;        state = State.COMPLETED;</b>
<b class="fc">&nbsp;        LOGGER.log(FINER, &quot;moving to COMPLETED on {0}&quot;, this);</b>
<b class="fc">&nbsp;        if (runner != null) {</b>
&nbsp;            // MavenBuilds may be created without their corresponding runners.
<b class="nc">&nbsp;            runner.checkpoints.allDone();</b>
<b class="nc">&nbsp;            runner = null;</b>
<b class="nc">&nbsp;            RunnerStack.INSTANCE.pop();</b>
&nbsp;        }
<b class="fc">&nbsp;        if (result == null) {</b>
<b class="fc">&nbsp;            result = Result.FAILURE;</b>
<b class="fc">&nbsp;            LOGGER.log(WARNING, &quot;{0}: No build result is set, so marking as failure. This should not happen.&quot;, this);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        RunListener.fireFinalized(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Save the settings to a file.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void save() throws IOException {
<b class="nc">&nbsp;        if (BulkChange.contains(this))   return;</b>
<b class="nc">&nbsp;        getDataFile().write(this);</b>
<b class="nc">&nbsp;        SaveableListener.fireOnChange(this, getDataFile());</b>
&nbsp;    }
&nbsp;
&nbsp;    private @NonNull XmlFile getDataFile() {
<b class="nc">&nbsp;        return new XmlFile(XSTREAM, new File(getRootDir(), &quot;build.xml&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Object writeReplace() {
<b class="nc">&nbsp;        return XmlFile.replaceIfNotAtTopLevel(this, () -&gt; new Replacer(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Replacer {
&nbsp;        private final String id;
&nbsp;
<b class="nc">&nbsp;        Replacer(Run&lt;?, ?&gt; r) {</b>
<b class="nc">&nbsp;            id = r.getExternalizableId();</b>
&nbsp;        }
&nbsp;
&nbsp;        private Object readResolve() {
<b class="nc">&nbsp;            return fromExternalizableId(id);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the log of the build as a string.
&nbsp;     * @return Returns the log or an empty string if it has not been found
&nbsp;     * @deprecated since 2007-11-11.
&nbsp;     *     Use {@link #getLog(int)} instead as it avoids loading
&nbsp;     *     the whole log into memory unnecessarily.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public @NonNull String getLog() throws IOException {
<b class="nc">&nbsp;        return Util.loadFile(getLogFile(), getCharset());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the log of the build as a list of strings (one per log line).
&nbsp;     * The number of lines returned is constrained by the maxLines parameter.
&nbsp;     *
&nbsp;     * @param maxLines The maximum number of log lines to return.  If the log
&nbsp;     * is bigger than this, only the most recent lines are returned.
&nbsp;     * @return A list of log lines.  Will have no more than maxLines elements.
&nbsp;     * @throws IOException If there is a problem reading the log file.
&nbsp;     */
&nbsp;    public @NonNull List&lt;String&gt; getLog(int maxLines) throws IOException {
<b class="fc">&nbsp;        if (maxLines == 0) {</b>
<b class="fc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int lines = 0;</b>
&nbsp;        long filePointer;
<b class="fc">&nbsp;        final List&lt;String&gt; lastLines = new ArrayList&lt;&gt;(Math.min(maxLines, 128));</b>
<b class="fc">&nbsp;        final List&lt;Byte&gt; bytes = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;        try (RandomAccessFile fileHandler = new RandomAccessFile(getLogFile(), &quot;r&quot;)) {</b>
<b class="fc">&nbsp;            long fileLength = fileHandler.length() - 1;</b>
&nbsp;
<b class="fc">&nbsp;            for (filePointer = fileLength; filePointer != -1 &amp;&amp; maxLines != lines; filePointer--) {</b>
<b class="fc">&nbsp;                fileHandler.seek(filePointer);</b>
<b class="fc">&nbsp;                byte readByte = fileHandler.readByte();</b>
&nbsp;
<b class="fc">&nbsp;                if (readByte == 0x0A) {</b>
<b class="fc">&nbsp;                    if (filePointer &lt; fileLength) {</b>
<b class="fc">&nbsp;                        lines = lines + 1;</b>
<b class="fc">&nbsp;                        lastLines.add(convertBytesToString(bytes));</b>
<b class="fc">&nbsp;                        bytes.clear();</b>
&nbsp;                    }
<b class="fc">&nbsp;                } else if (readByte != 0xD) {</b>
<b class="fc">&nbsp;                    bytes.add(readByte);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        if (lines != maxLines) {</b>
<b class="fc">&nbsp;            lastLines.add(convertBytesToString(bytes));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        Collections.reverse(lastLines);</b>
&nbsp;
&nbsp;        // If the log has been truncated, include that information.
&nbsp;        // Use set (replaces the first element) rather than add so that
&nbsp;        // the list doesn&#39;t grow beyond the specified maximum number of lines.
<b class="fc">&nbsp;        if (lines == maxLines) {</b>
<b class="fc">&nbsp;            lastLines.set(0, &quot;[...truncated &quot; + Functions.humanReadableByteSize(filePointer) + &quot;...]&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return ConsoleNote.removeNotes(lastLines);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String convertBytesToString(List&lt;Byte&gt; bytes) {
<b class="fc">&nbsp;        Collections.reverse(bytes);</b>
<b class="fc">&nbsp;        Byte[] byteArray = bytes.toArray(new Byte[0]);</b>
<b class="fc">&nbsp;        return new String(ArrayUtils.toPrimitive(byteArray), getCharset());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doBuildStatus(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        rsp.sendRedirect2(req.getContextPath() + &quot;/images/48x48/&quot; + getBuildStatusUrl());</b>
&nbsp;    }
&nbsp;
&nbsp;    public @NonNull String getBuildStatusUrl() {
<b class="nc">&nbsp;        return getIconColor().getImage();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getBuildStatusIconClassName() {
<b class="nc">&nbsp;        return getIconColor().getIconClassName();</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Summary {
&nbsp;        /**
&nbsp;         * Is this build worse or better, compared to the previous build?
&nbsp;         */
&nbsp;        public boolean isWorse;
&nbsp;        public String message;
&nbsp;
<b class="fc">&nbsp;        public Summary(boolean worse, String message) {</b>
<b class="fc">&nbsp;            this.isWorse = worse;</b>
<b class="fc">&nbsp;            this.message = message;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to implement {@link #getBuildStatusSummary}.
&nbsp;     * @since 1.575
&nbsp;     */
<b class="nc">&nbsp;    public abstract static class StatusSummarizer implements ExtensionPoint {</b>
&nbsp;        /**
&nbsp;         * Possibly summarizes the reasons for a builds status.
&nbsp;         * @param run a completed build
&nbsp;         * @param trend the result of {@link ResultTrend#getResultTrend(hudson.model.Run)} on {@code run} (precomputed for efficiency)
&nbsp;         * @return a summary, or null to fall back to other summarizers or built-in behavior
&nbsp;         */
&nbsp;        public abstract @CheckForNull Summary summarize(@NonNull Run&lt;?, ?&gt; run, @NonNull ResultTrend trend);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets an object which represents the single line summary of the status of this build
&nbsp;     * (especially in comparison with the previous build.)
&nbsp;     * @see StatusSummarizer
&nbsp;     */
&nbsp;    public @NonNull Summary getBuildStatusSummary() {
<b class="fc">&nbsp;        if (isBuilding()) {</b>
<b class="fc">&nbsp;            return new Summary(false, Messages.Run_Summary_Unknown());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        ResultTrend trend = ResultTrend.getResultTrend(this);</b>
&nbsp;
<b class="fc">&nbsp;        for (StatusSummarizer summarizer : ExtensionList.lookup(StatusSummarizer.class)) {</b>
<b class="nc">&nbsp;            Summary summary = summarizer.summarize(this, trend);</b>
<b class="nc">&nbsp;            if (summary != null) {</b>
<b class="nc">&nbsp;                return summary;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        switch (trend) {</b>
<b class="fc">&nbsp;            case ABORTED: return new Summary(false, Messages.Run_Summary_Aborted());</b>
&nbsp;
<b class="fc">&nbsp;            case NOT_BUILT: return new Summary(false, Messages.Run_Summary_NotBuilt());</b>
&nbsp;
<b class="fc">&nbsp;            case FAILURE: return new Summary(true, Messages.Run_Summary_BrokenSinceThisBuild());</b>
&nbsp;
&nbsp;            case STILL_FAILING:
<b class="fc">&nbsp;                RunT since = getPreviousNotFailedBuild();</b>
<b class="fc">&nbsp;                if (since == null)</b>
<b class="fc">&nbsp;                    return new Summary(false, Messages.Run_Summary_BrokenForALongTime());</b>
<b class="fc">&nbsp;                RunT failedBuild = since.getNextBuild();</b>
<b class="fc">&nbsp;                return new Summary(false, Messages.Run_Summary_BrokenSince(failedBuild.getDisplayName()));</b>
&nbsp;
&nbsp;            case NOW_UNSTABLE:
&nbsp;            case STILL_UNSTABLE:
<b class="fc">&nbsp;                return new Summary(false, Messages.Run_Summary_Unstable());</b>
&nbsp;            case UNSTABLE:
<b class="fc">&nbsp;                return new Summary(true, Messages.Run_Summary_Unstable());</b>
&nbsp;
&nbsp;            case SUCCESS:
<b class="fc">&nbsp;                return new Summary(false, Messages.Run_Summary_Stable());</b>
&nbsp;
&nbsp;            case FIXED:
<b class="fc">&nbsp;                return new Summary(false, Messages.Run_Summary_BackToNormal());</b>
&nbsp;
&nbsp;            default:
<b class="nc">&nbsp;                return new Summary(false, Messages.Run_Summary_Unknown());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Serves the artifacts.
&nbsp;     * @throws AccessDeniedException Access denied
&nbsp;     */
&nbsp;    public @NonNull DirectoryBrowserSupport doArtifact() {
<b class="nc">&nbsp;        if (Functions.isArtifactsPermissionEnabled()) {</b>
<b class="nc">&nbsp;          checkPermission(ARTIFACTS);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new DirectoryBrowserSupport(this, getArtifactManager().root(), Messages.Run_ArtifactsBrowserTitle(project.getDisplayName(), getDisplayName()), &quot;package.png&quot;, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the build number in the body.
&nbsp;     */
&nbsp;    public void doBuildNumber(StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/plain&quot;);</b>
<b class="nc">&nbsp;        rsp.setCharacterEncoding(&quot;US-ASCII&quot;);</b>
<b class="nc">&nbsp;        rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;        rsp.getWriter().print(number);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the build time stamp in the body.
&nbsp;     */
&nbsp;    public void doBuildTimestamp(StaplerRequest req, StaplerResponse rsp, @QueryParameter String format) throws IOException {
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/plain&quot;);</b>
<b class="nc">&nbsp;        rsp.setCharacterEncoding(&quot;US-ASCII&quot;);</b>
<b class="nc">&nbsp;        rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;        DateFormat df = format == null ?</b>
<b class="nc">&nbsp;                DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, Locale.ENGLISH) :</b>
<b class="nc">&nbsp;                new SimpleDateFormat(format, req.getLocale());</b>
<b class="nc">&nbsp;        rsp.getWriter().print(df.format(getTime()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sends out the raw console output.
&nbsp;     */
&nbsp;    public void doConsoleText(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/plain;charset=UTF-8&quot;);</b>
<b class="nc">&nbsp;        try (InputStream input = getLogInputStream();</b>
<b class="nc">&nbsp;             OutputStream os = rsp.getCompressedOutputStream(req);</b>
<b class="nc">&nbsp;             PlainTextConsoleOutputStream out = new PlainTextConsoleOutputStream(os)) {</b>
<b class="nc">&nbsp;            IOUtils.copy(input, out);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handles incremental log output.
&nbsp;     * @deprecated as of 1.352
&nbsp;     *      Use {@code getLogText().doProgressiveText(req,rsp)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void doProgressiveLog(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        getLogText().doProgressText(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether keep status can be toggled.
&nbsp;     * Normally it can, but if there is a complex reason (from subclasses) why this build must be kept, the toggle is meaningless.
&nbsp;     * @return true if {@link #doToggleLogKeep} and {@link #keepLog(boolean)} and {@link #keepLog()} are options
&nbsp;     * @since 1.510
&nbsp;     */
&nbsp;    public boolean canToggleLogKeep() {
<b class="nc">&nbsp;        if (!keepLog &amp;&amp; isKeepLog()) {</b>
&nbsp;            // Definitely prevented.
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;        // TODO may be that keepLog is on (perhaps toggler earlier) yet isKeepLog() would be true anyway.
&nbsp;        // In such a case this will incorrectly return true and logKeep.jelly will allow the toggle.
&nbsp;        // However at least then (after redirecting to the same page) the toggle button will correctly disappear.
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    public void doToggleLogKeep(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        keepLog(!keepLog);</b>
<b class="nc">&nbsp;        rsp.forwardToPreviousPage(req);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks this build to be kept.
&nbsp;     */
&nbsp;    @CLIMethod(name = &quot;keep-build&quot;)
&nbsp;    public final void keepLog() throws IOException {
<b class="nc">&nbsp;        keepLog(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void keepLog(boolean newValue) throws IOException {
<b class="nc">&nbsp;        checkPermission(newValue ? UPDATE : DELETE);</b>
<b class="nc">&nbsp;        keepLog = newValue;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes the build when the button is pressed.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        checkPermission(DELETE);</b>
&nbsp;
&nbsp;        // We should not simply delete the build if it has been explicitly
&nbsp;        // marked to be preserved, or if the build should not be deleted
&nbsp;        // due to dependencies!
<b class="nc">&nbsp;        String why = getWhyKeepLog();</b>
<b class="nc">&nbsp;        if (why != null) {</b>
<b class="nc">&nbsp;            sendError(Messages.Run_UnableToDelete(getFullDisplayName(), why), req, rsp);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            delete();</b>
&nbsp;        }
<b class="nc">&nbsp;        catch (IOException ex) {</b>
<b class="nc">&nbsp;            req.setAttribute(&quot;stackTraces&quot;, Functions.printThrowable(ex));</b>
<b class="nc">&nbsp;            req.getView(this, &quot;delete-retry.jelly&quot;).forward(req, rsp);</b>
&nbsp;            return;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        rsp.sendRedirect2(req.getContextPath() + &#39;/&#39; + getParent().getUrl());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDescription(String description) throws IOException {
<b class="nc">&nbsp;        checkPermission(UPDATE);</b>
<b class="nc">&nbsp;        this.description = description;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts the new description.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized void doSubmitDescription(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        setDescription(req.getParameter(&quot;description&quot;));</b>
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;.&quot;);  // go to the top page</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.292
&nbsp;     *      Use {@link #getEnvironment(TaskListener)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public Map&lt;String, String&gt; getEnvVars() {
<b class="nc">&nbsp;        LOGGER.log(WARNING, &quot;deprecated call to Run.getEnvVars\n\tat {0}&quot;, new Throwable().getStackTrace()[1]);</b>
&nbsp;        try {
<b class="nc">&nbsp;            return getEnvironment(new LogTaskListener(LOGGER, Level.INFO));</b>
<b class="nc">&nbsp;        } catch (IOException | InterruptedException e) {</b>
<b class="nc">&nbsp;            return new EnvVars();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.305 use {@link #getEnvironment(TaskListener)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public EnvVars getEnvironment() throws IOException, InterruptedException {
<b class="nc">&nbsp;        LOGGER.log(WARNING, &quot;deprecated call to Run.getEnvironment\n\tat {0}&quot;, new Throwable().getStackTrace()[1]);</b>
<b class="nc">&nbsp;        return getEnvironment(new LogTaskListener(LOGGER, Level.INFO));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the map that contains environmental variables to be used for launching
&nbsp;     * processes for this build.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link hudson.tasks.BuildStep}s that invoke external processes should use this.
&nbsp;     * This allows {@link BuildWrapper}s and other project configurations (such as JDK selection)
&nbsp;     * to take effect.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Unlike earlier {@link #getEnvVars()}, this map contains the whole environment,
&nbsp;     * not just the overrides, so one can introspect values to change its behavior.
&nbsp;     *
&nbsp;     * @return the map with the environmental variables.
&nbsp;     * @since 1.305
&nbsp;     */
&nbsp;    public @NonNull EnvVars getEnvironment(@NonNull TaskListener listener) throws IOException, InterruptedException {
<b class="nc">&nbsp;        Computer c = Computer.currentComputer();</b>
<b class="nc">&nbsp;        Node n = c == null ? null : c.getNode();</b>
&nbsp;
<b class="nc">&nbsp;        EnvVars env = getParent().getEnvironment(n, listener);</b>
<b class="nc">&nbsp;        env.putAll(getCharacteristicEnvVars());</b>
&nbsp;
&nbsp;        // apply them in a reverse order so that higher ordinal ones can modify values added by lower ordinal ones
<b class="nc">&nbsp;        for (EnvironmentContributor ec : EnvironmentContributor.all().reverseView())</b>
<b class="nc">&nbsp;            ec.buildEnvironmentFor(this, env, listener);</b>
&nbsp;
<b class="nc">&nbsp;        if (!(this instanceof AbstractBuild)) {</b>
<b class="nc">&nbsp;            for (EnvironmentContributingAction a : getActions(EnvironmentContributingAction.class)) {</b>
<b class="nc">&nbsp;                a.buildEnvironment(this, env);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } // else for compatibility reasons, handled in override after buildEnvironments
&nbsp;
<b class="nc">&nbsp;        return env;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds up the environment variable map that&#39;s sufficient to identify a process
&nbsp;     * as ours. This is used to kill run-away processes via {@link ProcessTree#killAll(Map)}.
&nbsp;     */
&nbsp;    public @NonNull final EnvVars getCharacteristicEnvVars() {
<b class="nc">&nbsp;        EnvVars env = getParent().getCharacteristicEnvVars();</b>
<b class="nc">&nbsp;        env.put(&quot;BUILD_NUMBER&quot;, String.valueOf(number));</b>
<b class="nc">&nbsp;        env.put(&quot;BUILD_ID&quot;, getId());</b>
<b class="nc">&nbsp;        env.put(&quot;BUILD_TAG&quot;, &quot;jenkins-&quot; + getParent().getFullName().replace(&#39;/&#39;, &#39;-&#39;) + &quot;-&quot; + number);</b>
<b class="nc">&nbsp;        return env;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Produces an identifier for this run unique in the system.
&nbsp;     * @return the {@link Job#getFullName}, then {@code #}, then {@link #getNumber}
&nbsp;     * @see #fromExternalizableId
&nbsp;     */
&nbsp;    public @NonNull String getExternalizableId() {
<b class="nc">&nbsp;        return project.getFullName() + &quot;#&quot; + getNumber();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to find a run from an persisted identifier.
&nbsp;     * @param id as produced by {@link #getExternalizableId}
&nbsp;     * @return the same run, or null if the job or run was not found
&nbsp;     * @throws IllegalArgumentException if the ID is malformed
&nbsp;     * @throws AccessDeniedException as per {@link ItemGroup#getItem}
&nbsp;     */
&nbsp;    public @CheckForNull static Run&lt;?, ?&gt; fromExternalizableId(String id) throws IllegalArgumentException, AccessDeniedException {
<b class="nc">&nbsp;        int hash = id.lastIndexOf(&#39;#&#39;);</b>
<b class="nc">&nbsp;        if (hash &lt;= 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Invalid id&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        String jobName = id.substring(0, hash);</b>
&nbsp;        int number;
&nbsp;        try {
<b class="nc">&nbsp;            number = Integer.parseInt(id.substring(hash + 1));</b>
<b class="nc">&nbsp;        } catch (NumberFormatException x) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(x);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Jenkins j = Jenkins.getInstanceOrNull();</b>
<b class="nc">&nbsp;        if (j == null) {</b>
<b class="nc">&nbsp;            LOGGER.fine(() -&gt; &quot;Jenkins not running&quot;);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Job&lt;?, ?&gt; job = j.getItemByFullName(jobName, Job.class);</b>
<b class="nc">&nbsp;        if (job == null) {</b>
<b class="nc">&nbsp;            LOGGER.fine(() -&gt; &quot;no such job &quot; + jobName + &quot; when running as &quot; + Jenkins.getAuthentication2().getName());</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return job.getBuildByNumber(number);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the estimated duration for this run if it is currently running.
&nbsp;     * Default to {@link Job#getEstimatedDuration()}, may be overridden in subclasses
&nbsp;     * if duration may depend on run specific parameters (like incremental Maven builds).
&nbsp;     *
&nbsp;     * @return the estimated duration in milliseconds
&nbsp;     * @since 1.383
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public long getEstimatedDuration() {
<b class="nc">&nbsp;        return project.getEstimatedDuration();</b>
&nbsp;    }
&nbsp;
&nbsp;    @POST
&nbsp;    public @NonNull HttpResponse doConfigSubmit(StaplerRequest req) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;        checkPermission(UPDATE);</b>
<b class="nc">&nbsp;        try (BulkChange bc = new BulkChange(this)) {</b>
<b class="nc">&nbsp;            JSONObject json = req.getSubmittedForm();</b>
<b class="nc">&nbsp;            submit(json);</b>
<b class="nc">&nbsp;            bc.commit();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return FormApply.success(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void submit(JSONObject json) throws IOException {
<b class="nc">&nbsp;        setDisplayName(Util.fixEmptyAndTrim(json.getString(&quot;displayName&quot;)));</b>
<b class="nc">&nbsp;        setDescription(json.getString(&quot;description&quot;));</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static final XStream XSTREAM = new XStream2();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.
&nbsp;     */
<b class="fc">&nbsp;    public static final XStream2 XSTREAM2 = (XStream2) XSTREAM;</b>
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        XSTREAM.alias(&quot;build&quot;, FreeStyleBuild.class);</b>
<b class="fc">&nbsp;        XSTREAM.registerConverter(Result.conv);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Run.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Sort by date. Newer ones first.
&nbsp;     */
<b class="fc">&nbsp;    public static final Comparator&lt;Run&gt; ORDER_BY_DATE = new Comparator&lt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public int compare(@NonNull Run lhs, @NonNull Run rhs) {
<b class="nc">&nbsp;            long lt = lhs.getTimeInMillis();</b>
<b class="nc">&nbsp;            long rt = rhs.getTimeInMillis();</b>
<b class="nc">&nbsp;            return Long.compare(rt, lt);</b>
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * {@link FeedAdapter} to produce feed from the summary of this build.
&nbsp;     */
<b class="fc">&nbsp;    public static final FeedAdapter&lt;Run&gt; FEED_ADAPTER = new DefaultFeedAdapter();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link FeedAdapter} to produce feeds to show one build per project.
&nbsp;     */
<b class="fc">&nbsp;    public static final FeedAdapter&lt;Run&gt; FEED_ADAPTER_LATEST = new DefaultFeedAdapter() {</b>
&nbsp;        /**
&nbsp;         * The entry unique ID needs to be tied to a project, so that
&nbsp;         * new builds will replace the old result.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public String getEntryID(Run e) {
&nbsp;            // can&#39;t use a meaningful year field unless we remember when the job was created.
<b class="nc">&nbsp;            return &quot;tag:hudson.dev.java.net,2008:&quot; + e.getParent().getAbsoluteUrl();</b>
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * {@link BuildBadgeAction} that shows the build is being kept.
&nbsp;     */
<b class="nc">&nbsp;    public final class KeepLogBuildBadge implements BuildBadgeAction {</b>
&nbsp;        @Override
<b class="nc">&nbsp;        public @CheckForNull String getIconFileName() { return null; }</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public @CheckForNull String getDisplayName() { return null; }</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        public @CheckForNull String getUrlName() { return null; }</b>
&nbsp;
<b class="nc">&nbsp;        public @CheckForNull String getWhyKeepLog() { return Run.this.getWhyKeepLog(); }</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static final PermissionGroup PERMISSIONS = new PermissionGroup(Run.class, Messages._Run_Permissions_Title());</b>
<b class="fc">&nbsp;    public static final Permission DELETE = new Permission(PERMISSIONS, &quot;Delete&quot;, Messages._Run_DeletePermission_Description(), Permission.DELETE, PermissionScope.RUN);</b>
<b class="fc">&nbsp;    public static final Permission UPDATE = new Permission(PERMISSIONS, &quot;Update&quot;, Messages._Run_UpdatePermission_Description(), Permission.UPDATE, PermissionScope.RUN);</b>
&nbsp;    /** See {@link hudson.Functions#isArtifactsPermissionEnabled} */
<b class="fc">&nbsp;    public static final Permission ARTIFACTS = new Permission(PERMISSIONS, &quot;Artifacts&quot;, Messages._Run_ArtifactsPermission_Description(), null,</b>
<b class="fc">&nbsp;                                                              Functions.isArtifactsPermissionEnabled(), new PermissionScope[]{PermissionScope.RUN});</b>
&nbsp;
<b class="fc">&nbsp;    private static class DefaultFeedAdapter implements FeedAdapter&lt;Run&gt; {</b>
&nbsp;        @Override
&nbsp;        public String getEntryTitle(Run entry) {
<b class="nc">&nbsp;            return entry.getFullDisplayName() + &quot; (&quot; + entry.getBuildStatusSummary().message + &quot;)&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getEntryUrl(Run entry) {
<b class="nc">&nbsp;            return entry.getUrl();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getEntryID(Run entry) {
<b class="nc">&nbsp;            return &quot;tag:&quot; + &quot;hudson.dev.java.net,&quot;</b>
<b class="nc">&nbsp;                + entry.getTimestamp().get(Calendar.YEAR) + &quot;:&quot;</b>
<b class="nc">&nbsp;                + entry.getParent().getFullName() + &#39;:&#39; + entry.getId();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getEntryDescription(Run entry) {
<b class="nc">&nbsp;            return entry.getDescription();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Calendar getEntryTimestamp(Run entry) {
<b class="nc">&nbsp;            return entry.getTimestamp();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getEntryAuthor(Run entry) {
<b class="nc">&nbsp;            return JenkinsLocationConfiguration.get().getAdminAddress();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object getDynamic(String token, StaplerRequest req, StaplerResponse rsp) {
<b class="nc">&nbsp;        Object returnedResult = super.getDynamic(token, req, rsp);</b>
<b class="nc">&nbsp;        if (returnedResult == null) {</b>
&nbsp;            //check transient actions too
<b class="nc">&nbsp;            for (Action action : getTransientActions()) {</b>
<b class="nc">&nbsp;                String urlName = action.getUrlName();</b>
<b class="nc">&nbsp;                if (urlName == null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (urlName.equals(token)) {</b>
<b class="nc">&nbsp;                    return action;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // Next/Previous Build links on an action page (like /job/Abc/123/testReport)
&nbsp;            // will also point to same action (/job/Abc/124/testReport), but other builds
&nbsp;            // may not have the action.. tell browsers to redirect up to the build page.
<b class="nc">&nbsp;            returnedResult = new RedirectUp();</b>
&nbsp;        }
<b class="nc">&nbsp;        return returnedResult;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Object getTarget() {
<b class="nc">&nbsp;        if (!SKIP_PERMISSION_CHECK) {</b>
&nbsp;            // This is a bit weird, but while the Run&#39;s PermissionScope does not have READ, delegate to the parent
<b class="nc">&nbsp;            if (!getParent().hasPermission(Item.DISCOVER)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            getParent().checkPermission(Item.READ);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Escape hatch for StaplerProxy-based access control
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static /* Script Console modifiable */ boolean SKIP_PERMISSION_CHECK = SystemProperties.getBoolean(Run.class.getName() + &quot;.skipPermissionCheck&quot;);</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;    public static class RedirectUp {</b>
&nbsp;        public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException {
&nbsp;            // Compromise to handle both browsers (auto-redirect) and programmatic access
&nbsp;            // (want accurate 404 response).. send 404 with javascript to redirect browsers.
<b class="nc">&nbsp;            rsp.setStatus(HttpServletResponse.SC_NOT_FOUND);</b>
<b class="nc">&nbsp;            rsp.setContentType(&quot;text/html;charset=UTF-8&quot;);</b>
<b class="nc">&nbsp;            PrintWriter out = rsp.getWriter();</b>
<b class="nc">&nbsp;            Util.printRedirect(req.getContextPath(), &quot;..&quot;, &quot;Not found&quot;, out);</b>
<b class="nc">&nbsp;            out.flush();</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
