


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Fingerprint</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: Fingerprint (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Fingerprint</td>
<td class="coverageStat">
  <span class="percent">
    20.5%
  </span>
  <span class="absValue">
    (8/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.8%
  </span>
  <span class="absValue">
    (21/215)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Fingerprint$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$BuildPtr</td>
<td class="coverageStat">
  <span class="percent">
    15.4%
  </span>
  <span class="absValue">
    (2/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    13.8%
  </span>
  <span class="absValue">
    (4/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$ProjectRenameListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$Range</td>
<td class="coverageStat">
  <span class="percent">
    73.7%
  </span>
  <span class="absValue">
    (14/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.9%
  </span>
  <span class="absValue">
    (26/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeSet</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (14/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.4%
  </span>
  <span class="absValue">
    (161/178)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeSet$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeSet$1$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeSet$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeSet$2$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Fingerprint$RangeSet$ConverterImpl</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.2%
  </span>
  <span class="absValue">
    (5/16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    35%
  </span>
  <span class="absValue">
    (42/120)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.7%
  </span>
  <span class="absValue">
    (218/510)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Yahoo! Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
&nbsp;import com.thoughtworks.xstream.converters.Converter;
&nbsp;import com.thoughtworks.xstream.converters.MarshallingContext;
&nbsp;import com.thoughtworks.xstream.converters.UnmarshallingContext;
&nbsp;import com.thoughtworks.xstream.converters.basic.DateConverter;
&nbsp;import com.thoughtworks.xstream.converters.collections.CollectionConverter;
&nbsp;import com.thoughtworks.xstream.io.HierarchicalStreamReader;
&nbsp;import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionList;
&nbsp;import hudson.Util;
&nbsp;import hudson.model.listeners.ItemListener;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.util.HexBinaryConverter;
&nbsp;import hudson.util.Iterators;
&nbsp;import hudson.util.PersistedList;
&nbsp;import hudson.util.RunList;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.util.AbstractCollection;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Date;
&nbsp;import java.util.Hashtable;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import jenkins.fingerprints.FileFingerprintStorage;
&nbsp;import jenkins.fingerprints.FingerprintStorage;
&nbsp;import jenkins.model.FingerprintFacet;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.TransientFingerprintFacetFactory;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.springframework.security.access.AccessDeniedException;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;
&nbsp;/**
&nbsp; * A file being tracked by Jenkins.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Lifecycle is managed by {@link FingerprintMap}.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see FingerprintMap
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public class Fingerprint implements ModelObject, Saveable {
&nbsp;    /**
&nbsp;     * Pointer to a {@link Build}.
&nbsp;     */
&nbsp;    @ExportedBean(defaultVisibility = 2)
&nbsp;    public static class BuildPtr {
&nbsp;        String name;
&nbsp;        final int number;
&nbsp;
<b class="fc">&nbsp;        public BuildPtr(String name, int number) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.number = number;</b>
&nbsp;        }
&nbsp;
&nbsp;        public BuildPtr(Run run) {
<b class="nc">&nbsp;            this(run.getParent().getFullName(), run.getNumber());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets {@link Job#getFullName() the full name of the job}.
&nbsp;         * Such job could be since then removed, so there might not be a corresponding {@link Job}.
&nbsp;         *
&nbsp;         * @return A name of the job
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the current user has permission to see this pointer.
&nbsp;         * @return {@code true} if the job exists and user has {@link Item#READ} permissions
&nbsp;         *      or if the current user has {@link Jenkins#ADMINISTER} permissions.
&nbsp;         *      If the job exists, but the current user has no permission to discover it,
&nbsp;         *      {@code false}  will be returned.
&nbsp;         *      If the job has been deleted and the user has no {@link Jenkins#ADMINISTER} permissions,
&nbsp;         *      it also returns {@code false}   in order to avoid the job existence fact exposure.
&nbsp;         */
&nbsp;        private boolean hasPermissionToDiscoverBuild() {
&nbsp;            // We expose the data to Jenkins administrators in order to
&nbsp;            // let them manage the data for deleted jobs (also works for SYSTEM2)
<b class="nc">&nbsp;            final Jenkins instance = Jenkins.get();</b>
<b class="nc">&nbsp;            if (instance.hasPermission(Jenkins.ADMINISTER)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return canDiscoverItem(name);</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;
&nbsp;        void setName(String newName) {
<b class="nc">&nbsp;            name = newName;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets the {@link Job} that this pointer points to,
&nbsp;         * or null if such a job no longer exists.
&nbsp;         */
&nbsp;        @WithBridgeMethods(value = AbstractProject.class, castRequired = true)
&nbsp;        public Job&lt;?, ?&gt; getJob() {
<b class="nc">&nbsp;            return Jenkins.get().getItemByFullName(name, Job.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets the project build number.
&nbsp;         * &lt;p&gt;
&nbsp;         * Such {@link Run} could be since then discarded.
&nbsp;         * @return A build number
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public int getNumber() {
<b class="nc">&nbsp;            return number;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets the {@link Job} that this pointer points to,
&nbsp;         * or null if such a job no longer exists.
&nbsp;         */
&nbsp;        public Run getRun() {
<b class="nc">&nbsp;            Job j = getJob();</b>
<b class="nc">&nbsp;            if (j == null)     return null;</b>
<b class="nc">&nbsp;            return j.getBuildByNumber(number);</b>
&nbsp;        }
&nbsp;
&nbsp;        private boolean isAlive() {
<b class="nc">&nbsp;            return getRun() != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if {@link BuildPtr} points to the given run.
&nbsp;         */
&nbsp;        public boolean is(Run r) {
<b class="nc">&nbsp;            return r.getNumber() == number &amp;&amp; r.getParent().getFullName().equals(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if {@link BuildPtr} points to the given job.
&nbsp;         */
&nbsp;        public boolean is(Job job) {
<b class="nc">&nbsp;            return job.getFullName().equals(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if {@link BuildPtr} points to the given job
&nbsp;         * or one of its subordinates.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This is useful to check if an artifact in MavenModule
&nbsp;         * belongs to MavenModuleSet.
&nbsp;         */
&nbsp;        public boolean belongsTo(Job job) {
<b class="nc">&nbsp;            Item p = Jenkins.get().getItemByFullName(name);</b>
<b class="nc">&nbsp;            while (p != null) {</b>
<b class="nc">&nbsp;                if (p == job)</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;
&nbsp;                // go up the chain while we
<b class="nc">&nbsp;                ItemGroup&lt;? extends Item&gt; parent = p.getParent();</b>
<b class="nc">&nbsp;                if (!(parent instanceof Item)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                p = (Item) parent;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override public String toString() {
<b class="fc">&nbsp;            return name + &quot; #&quot; + number;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Range of build numbers [start,end). Immutable.
&nbsp;     */
<b class="fc">&nbsp;    @ExportedBean(defaultVisibility = 4)</b>
&nbsp;    public static final class Range {
&nbsp;        final int start;
&nbsp;        final int end;
&nbsp;
<b class="fc">&nbsp;        public Range(int start, int end) {</b>
<b class="fc">&nbsp;            assert start &lt; end;</b>
<b class="fc">&nbsp;            this.start = start;</b>
<b class="fc">&nbsp;            this.end = end;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public int getStart() {
<b class="nc">&nbsp;            return start;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public int getEnd() {
<b class="nc">&nbsp;            return end;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSmallerThan(int i) {
<b class="nc">&nbsp;            return end &lt;= i;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isBiggerThan(int i) {
<b class="fc">&nbsp;            return i &lt; start;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean includes(int i) {
<b class="fc">&nbsp;            return start &lt;= i &amp;&amp; i &lt; end;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Range expandRight() {
<b class="fc">&nbsp;            return new Range(start, end + 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Range expandLeft() {
<b class="fc">&nbsp;            return new Range(start - 1, end);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAdjacentTo(Range that) {
<b class="fc">&nbsp;            return this.end == that.start;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return &quot;[&quot; + start + &quot;,&quot; + end + &quot;)&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if two {@link Range}s can&#39;t be combined into a single range.
&nbsp;         */
&nbsp;        public boolean isIndependent(Range that) {
<b class="fc">&nbsp;            return this.end &lt; that.start || that.end &lt; this.start;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if two {@link Range}s do not share any common integer.
&nbsp;         */
&nbsp;        public boolean isDisjoint(Range that) {
<b class="fc">&nbsp;            return this.end &lt;= that.start || that.end &lt;= this.start;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if this range only represents a single number.
&nbsp;         */
&nbsp;        public boolean isSingle() {
<b class="nc">&nbsp;            return end - 1 == start;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If this range contains every int that&#39;s in the other range, return true
&nbsp;         */
&nbsp;        public boolean contains(Range that) {
<b class="fc">&nbsp;            return this.start &lt;= that.start &amp;&amp; that.end &lt;= this.end;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the {@link Range} that combines two ranges.
&nbsp;         */
&nbsp;        public Range combine(Range that) {
<b class="fc">&nbsp;            assert !isIndependent(that);</b>
<b class="fc">&nbsp;            return new Range(</b>
<b class="fc">&nbsp;                Math.min(this.start, that.start),</b>
<b class="fc">&nbsp;                Math.max(this.end, that.end));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the {@link Range} that represents the intersection of the two.
&nbsp;         */
&nbsp;        public Range intersect(Range that) {
<b class="fc">&nbsp;            assert !isDisjoint(that);</b>
<b class="fc">&nbsp;            return new Range(</b>
<b class="fc">&nbsp;                Math.max(this.start, that.start),</b>
<b class="fc">&nbsp;                Math.min(this.end, that.end));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="fc">&nbsp;            if (this == o) return true;</b>
<b class="fc">&nbsp;            if (o == null || getClass() != o.getClass()) return false;</b>
&nbsp;
<b class="fc">&nbsp;            Range that = (Range) o;</b>
<b class="fc">&nbsp;            return start == that.start &amp;&amp; end == that.end;</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return 31 * start + end;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set of {@link Range}s. Mutable.
&nbsp;     */
<b class="fc">&nbsp;    @ExportedBean(defaultVisibility = 3)</b>
&nbsp;    public static final class RangeSet {
&nbsp;        // sorted
&nbsp;        private final List&lt;Range&gt; ranges;
&nbsp;
&nbsp;        public RangeSet() {
<b class="fc">&nbsp;            this(new ArrayList&lt;&gt;());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        private RangeSet(List&lt;Range&gt; data) {</b>
<b class="fc">&nbsp;            this.ranges = data;</b>
&nbsp;        }
&nbsp;
&nbsp;        private RangeSet(Range initial) {
<b class="nc">&nbsp;            this();</b>
<b class="nc">&nbsp;            ranges.add(initial);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * List all numbers in this range set, in the ascending order.
&nbsp;         */
&nbsp;        public Iterable&lt;Integer&gt; listNumbers() {
<b class="nc">&nbsp;            final List&lt;Range&gt; ranges = getRanges();</b>
<b class="nc">&nbsp;            return new Iterable&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public Iterator&lt;Integer&gt; iterator() {
<b class="nc">&nbsp;                    return new Iterators.FlattenIterator&lt;&gt;(ranges) {</b>
&nbsp;                        @Override
&nbsp;                        protected Iterator&lt;Integer&gt; expand(Range range) {
<b class="nc">&nbsp;                            return Iterators.sequence(range.start, range.end).iterator();</b>
&nbsp;                        }
&nbsp;                    };
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * List all numbers in this range set in the descending order.
&nbsp;         */
&nbsp;        public Iterable&lt;Integer&gt; listNumbersReverse() {
<b class="nc">&nbsp;            final List&lt;Range&gt; ranges = getRanges();</b>
<b class="nc">&nbsp;            return new Iterable&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public Iterator&lt;Integer&gt; iterator() {
<b class="nc">&nbsp;                    return new Iterators.FlattenIterator&lt;&gt;(Iterators.reverse(ranges)) {</b>
&nbsp;                        @Override
&nbsp;                        protected Iterator&lt;Integer&gt; expand(Range range) {
<b class="nc">&nbsp;                            return Iterators.reverseSequence(range.start, range.end).iterator();</b>
&nbsp;                        }
&nbsp;                    };
&nbsp;                }
&nbsp;            };
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets all the ranges.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public synchronized List&lt;Range&gt; getRanges() {
<b class="nc">&nbsp;            return new ArrayList&lt;&gt;(ranges);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Expands the range set to include the given value.
&nbsp;         * If the set already includes this number, this will be a no-op.
&nbsp;         */
&nbsp;        public synchronized void add(int n) {
<b class="fc">&nbsp;            for (int i = 0; i &lt; ranges.size(); i++) {</b>
<b class="fc">&nbsp;                Range r = ranges.get(i);</b>
<b class="fc">&nbsp;                if (r.includes(n))   return; // already included</b>
<b class="fc">&nbsp;                if (r.end == n) {</b>
<b class="fc">&nbsp;                    ranges.set(i, r.expandRight());</b>
<b class="fc">&nbsp;                    checkCollapse(i);</b>
&nbsp;                    return;
&nbsp;                }
<b class="fc">&nbsp;                if (r.start == n + 1) {</b>
<b class="fc">&nbsp;                    ranges.set(i, r.expandLeft());</b>
<b class="fc">&nbsp;                    checkCollapse(i - 1);</b>
&nbsp;                    return;
&nbsp;                }
<b class="fc">&nbsp;                if (r.isBiggerThan(n)) {</b>
&nbsp;                    // needs to insert a single-value Range
<b class="fc">&nbsp;                    ranges.add(i, new Range(n, n + 1));</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            ranges.add(new Range(n, n + 1));</b>
&nbsp;        }
&nbsp;
&nbsp;        public synchronized void addAll(int... n) {
<b class="fc">&nbsp;            for (int i : n)</b>
<b class="fc">&nbsp;                add(i);</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        private void checkCollapse(int i) {
<b class="fc">&nbsp;            if (i &lt; 0 || i == ranges.size() - 1)     return;</b>
<b class="fc">&nbsp;            Range lhs = ranges.get(i);</b>
<b class="fc">&nbsp;            Range rhs = ranges.get(i + 1);</b>
<b class="fc">&nbsp;            if (lhs.isAdjacentTo(rhs)) {</b>
&nbsp;                // collapsed
<b class="fc">&nbsp;                Range r = new Range(lhs.start, rhs.end);</b>
<b class="fc">&nbsp;                ranges.set(i, r);</b>
<b class="fc">&nbsp;                ranges.remove(i + 1);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public synchronized boolean includes(int i) {
<b class="fc">&nbsp;            for (Range r : ranges) {</b>
<b class="fc">&nbsp;                if (r.includes(i))</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public synchronized void add(RangeSet that) {
<b class="fc">&nbsp;            int lhs = 0, rhs = 0;</b>
<b class="fc">&nbsp;            while (lhs &lt; this.ranges.size() &amp;&amp; rhs &lt; that.ranges.size()) {</b>
<b class="fc">&nbsp;                Range lr = this.ranges.get(lhs);</b>
<b class="fc">&nbsp;                Range rr = that.ranges.get(rhs);</b>
&nbsp;
&nbsp;                // no overlap
<b class="fc">&nbsp;                if (lr.end &lt; rr.start) {</b>
<b class="fc">&nbsp;                    lhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (rr.end &lt; lr.start) {</b>
<b class="fc">&nbsp;                    ranges.add(lhs, rr);</b>
<b class="fc">&nbsp;                    lhs++;</b>
<b class="fc">&nbsp;                    rhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // overlap. merge two
<b class="fc">&nbsp;                Range m = lr.combine(rr);</b>
<b class="fc">&nbsp;                rhs++;</b>
&nbsp;
&nbsp;                // since ranges[lhs] is expanded, it might overlap with others in this.ranges
<b class="fc">&nbsp;                while (lhs + 1 &lt; this.ranges.size() &amp;&amp; !m.isIndependent(this.ranges.get(lhs + 1))) {</b>
<b class="fc">&nbsp;                    m = m.combine(this.ranges.get(lhs + 1));</b>
<b class="fc">&nbsp;                    this.ranges.remove(lhs + 1);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                this.ranges.set(lhs, m);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            // if anything is left in that.ranges, add them all
<b class="fc">&nbsp;            this.ranges.addAll(that.ranges.subList(rhs, that.ranges.size()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Updates this range set by the intersection of this range and the given range.
&nbsp;         *
&nbsp;         * @return true if this range set was modified as a result.
&nbsp;         */
&nbsp;        public synchronized boolean retainAll(RangeSet that) {
<b class="fc">&nbsp;            List&lt;Range&gt; intersection = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            int lhs = 0, rhs = 0;</b>
<b class="fc">&nbsp;            while (lhs &lt; this.ranges.size() &amp;&amp; rhs &lt; that.ranges.size()) {</b>
<b class="fc">&nbsp;                Range lr = this.ranges.get(lhs);</b>
<b class="fc">&nbsp;                Range rr = that.ranges.get(rhs);</b>
&nbsp;
<b class="fc">&nbsp;                if (lr.end &lt;= rr.start) { // lr has no overlap with that.ranges</b>
<b class="fc">&nbsp;                    lhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (rr.end &lt;= lr.start) { // rr has no overlap with this.ranges</b>
<b class="fc">&nbsp;                    rhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // overlap. figure out the intersection
<b class="fc">&nbsp;                Range v = lr.intersect(rr);</b>
<b class="fc">&nbsp;                intersection.add(v);</b>
&nbsp;
&nbsp;                // move on to the next pair
<b class="fc">&nbsp;                if (lr.end &lt; rr.end) {</b>
<b class="fc">&nbsp;                    lhs++;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    rhs++;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            boolean same = this.ranges.equals(intersection);</b>
&nbsp;
<b class="fc">&nbsp;            if (!same) {</b>
<b class="fc">&nbsp;                this.ranges.clear();</b>
<b class="fc">&nbsp;                this.ranges.addAll(intersection);</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Updates this range set by removing all the values in the given range set.
&nbsp;         *
&nbsp;         * @return true if this range set was modified as a result.
&nbsp;         */
&nbsp;        public synchronized boolean removeAll(RangeSet that) {
<b class="fc">&nbsp;            boolean modified = false;</b>
<b class="fc">&nbsp;            List&lt;Range&gt; sub = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;            int lhs = 0, rhs = 0;</b>
<b class="fc">&nbsp;            while (lhs &lt; this.ranges.size() &amp;&amp; rhs &lt; that.ranges.size()) {</b>
<b class="fc">&nbsp;                Range lr = this.ranges.get(lhs);</b>
<b class="fc">&nbsp;                Range rr = that.ranges.get(rhs);</b>
&nbsp;
<b class="fc">&nbsp;                if (lr.end &lt;= rr.start) { // lr has no overlap with that.ranges. lr stays</b>
<b class="fc">&nbsp;                    sub.add(lr);</b>
<b class="fc">&nbsp;                    lhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (rr.end &lt;= lr.start) { // rr has no overlap with this.ranges</b>
<b class="fc">&nbsp;                    rhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // some overlap between lr and rr
<b class="fc">&nbsp;                assert !lr.isDisjoint(rr);</b>
<b class="fc">&nbsp;                modified = true;</b>
&nbsp;
<b class="fc">&nbsp;                if (rr.contains(lr)) {</b>
&nbsp;                    // lr completely removed by rr
<b class="fc">&nbsp;                    lhs++;</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
&nbsp;                // we want to look at A and B below, if they are non-null.
&nbsp;                // |------------| lr
&nbsp;                //     |-----|    rr
&nbsp;                //   A         B
&nbsp;                //
&nbsp;                // note that lr and rr could be something like or the other way around
&nbsp;                // |------------| lr
&nbsp;                //         |------------| rr
&nbsp;                //     A             (no B)
&nbsp;
<b class="fc">&nbsp;                if (lr.start &lt; rr.start) { // if A is non-empty, that will stay</b>
<b class="fc">&nbsp;                    Range a = new Range(lr.start, rr.start);</b>
<b class="fc">&nbsp;                    sub.add(a);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                if (rr.end &lt; lr.end) { // if B is non-empty</b>
&nbsp;                    // we still need to check that with that.ranges, so keep it in the place of lr.
&nbsp;                    // how much of them will eventually stay is up to the remainder of that.ranges
<b class="fc">&nbsp;                    this.ranges.set(lhs, new Range(rr.end, lr.end));</b>
<b class="fc">&nbsp;                    rhs++;</b>
&nbsp;                } else {
&nbsp;                    // if B is empty, we are done considering lr
<b class="fc">&nbsp;                    lhs++;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            if (!modified)  return false;   // no changes</b>
&nbsp;
&nbsp;            // whatever that remains in lhs will survive
<b class="fc">&nbsp;            sub.addAll(this.ranges.subList(lhs, this.ranges.size()));</b>
&nbsp;
<b class="fc">&nbsp;            this.ranges.clear();</b>
<b class="fc">&nbsp;            this.ranges.addAll(sub);</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public synchronized String toString() {
<b class="fc">&nbsp;            StringBuilder buf = new StringBuilder();</b>
<b class="fc">&nbsp;            for (Range r : ranges) {</b>
<b class="fc">&nbsp;                if (buf.length() &gt; 0)  buf.append(&#39;,&#39;);</b>
<b class="fc">&nbsp;                buf.append(r);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return buf.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="fc">&nbsp;            if (this == o) return true;</b>
<b class="fc">&nbsp;            if (o == null || getClass() != o.getClass()) return false;</b>
&nbsp;
<b class="fc">&nbsp;            return ranges.equals(((RangeSet) o).ranges);</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return ranges.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        public synchronized boolean isEmpty() {
<b class="fc">&nbsp;            return ranges.isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the smallest value in this range.
&nbsp;         * &lt;p&gt;
&nbsp;         * If this range is empty, this method throws an exception.
&nbsp;         */
&nbsp;        public synchronized int min() {
<b class="nc">&nbsp;            return ranges.get(0).start;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the largest value in this range.
&nbsp;         * &lt;p&gt;
&nbsp;         * If this range is empty, this method throws an exception.
&nbsp;         */
&nbsp;        public synchronized int max() {
<b class="nc">&nbsp;            return ranges.get(ranges.size() - 1).end;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns true if all the integers logically in this {@link RangeSet}
&nbsp;         * is smaller than the given integer. For example, {[1,3)} is smaller than 3,
&nbsp;         * but {[1,3),[100,105)} is not smaller than anything less than 105.
&nbsp;         *
&nbsp;         * Note that {} is smaller than any n.
&nbsp;         */
&nbsp;        public synchronized boolean isSmallerThan(int n) {
<b class="nc">&nbsp;            if (ranges.isEmpty())    return true;</b>
&nbsp;
<b class="nc">&nbsp;            return ranges.get(ranges.size() - 1).isSmallerThan(n);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Parses a {@link RangeSet} from a string like &quot;1-3,5,7-9&quot;
&nbsp;         */
&nbsp;        public static RangeSet fromString(String list, boolean skipError) {
<b class="fc">&nbsp;            RangeSet rs = new RangeSet();</b>
&nbsp;
&nbsp;            // Reject malformed ranges like &quot;1---10&quot;, &quot;1,,,,3&quot; etc.
<b class="fc">&nbsp;            if (list.contains(&quot;--&quot;) || list.contains(&quot;,,&quot;)) {</b>
<b class="fc">&nbsp;                if (!skipError) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(</b>
<b class="fc">&nbsp;                            String.format(&quot;Unable to parse &#39;%s&#39;, expected correct notation M,N or M-N&quot;, list));</b>
&nbsp;                }
&nbsp;                // ignore malformed notation
<b class="fc">&nbsp;                return rs;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            String[] items = Util.tokenize(list, &quot;,&quot;);</b>
<b class="fc">&nbsp;            if (items.length &gt; 1 &amp;&amp; items.length &lt;= StringUtils.countMatches(list, &quot;,&quot;)) {</b>
<b class="fc">&nbsp;                if (!skipError) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(</b>
<b class="fc">&nbsp;                            String.format(&quot;Unable to parse &#39;%s&#39;, expected correct notation M,N or M-N&quot;, list));</b>
&nbsp;                }
&nbsp;                // ignore malformed notation like &quot;,1,2&quot; or &quot;1,2,&quot;
<b class="fc">&nbsp;                return rs;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            for (String s : items) {</b>
<b class="fc">&nbsp;                s = s.trim();</b>
&nbsp;                // s is either single number or range &quot;x-y&quot;.
&nbsp;                // note that the end range is inclusive in this notation, but not in the Range class
&nbsp;                try {
<b class="fc">&nbsp;                    if (s.isEmpty()) {</b>
<b class="fc">&nbsp;                        if (!skipError) {</b>
<b class="fc">&nbsp;                            throw new IllegalArgumentException(</b>
<b class="fc">&nbsp;                                    String.format(&quot;Unable to parse &#39;%s&#39;, expected number&quot;, list));                        }</b>
&nbsp;                        // ignore &quot;&quot; element
<b class="fc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (s.contains(&quot;-&quot;)) {</b>
<b class="fc">&nbsp;                        if (StringUtils.countMatches(s, &quot;-&quot;) &gt; 1) {</b>
<b class="fc">&nbsp;                            if (!skipError) {</b>
<b class="fc">&nbsp;                                throw new IllegalArgumentException(String.format(</b>
&nbsp;                                        &quot;Unable to parse &#39;%s&#39;, expected correct notation M,N or M-N&quot;, list));
&nbsp;                            }
&nbsp;                            // ignore malformed ranges like &quot;-5-2&quot; or &quot;2-5-&quot;
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        String[] tokens = Util.tokenize(s, &quot;-&quot;);</b>
<b class="fc">&nbsp;                        if (tokens.length == 2) {</b>
<b class="fc">&nbsp;                            int left = Integer.parseInt(tokens[0]);</b>
<b class="fc">&nbsp;                            int right = Integer.parseInt(tokens[1]);</b>
<b class="fc">&nbsp;                            if (left &lt; 0 || right &lt; 0) {</b>
<b class="nc">&nbsp;                                if (!skipError) {</b>
<b class="nc">&nbsp;                                    throw new IllegalArgumentException(</b>
<b class="nc">&nbsp;                                            String.format(&quot;Unable to parse &#39;%s&#39;, expected number above zero&quot;, list));</b>
&nbsp;                                }
&nbsp;                                // ignore a range which starts or ends under zero like &quot;-5-3&quot;
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            if (left &gt; right) {</b>
<b class="fc">&nbsp;                                if (!skipError) {</b>
<b class="fc">&nbsp;                                    throw new IllegalArgumentException(String.format(</b>
&nbsp;                                            &quot;Unable to parse &#39;%s&#39;, expected string with a range M-N where M&lt;N&quot;, list));
&nbsp;                                }
&nbsp;                                // ignore inverse range like &quot;10-5&quot;
<b class="fc">&nbsp;                                continue;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            rs.ranges.add(new Range(left, right + 1));</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            if (!skipError) {</b>
<b class="fc">&nbsp;                                throw new IllegalArgumentException(</b>
<b class="fc">&nbsp;                                        String.format(&quot;Unable to parse &#39;%s&#39;, expected string with a range M-N&quot;, list));</b>
&nbsp;                            }
&nbsp;                            // ignore malformed text like &quot;1-10-50&quot;
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        int n = Integer.parseInt(s);</b>
<b class="fc">&nbsp;                        rs.ranges.add(new Range(n, n + 1));</b>
&nbsp;                    }
<b class="fc">&nbsp;                } catch (NumberFormatException e) {</b>
<b class="fc">&nbsp;                    if (!skipError)</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(</b>
<b class="fc">&nbsp;                                String.format(&quot;Unable to parse &#39;%s&#39;, expected number&quot;, list), e);</b>
&nbsp;                    // ignore malformed text
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return rs;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Converter Implementation for RangeSet.
&nbsp;         *
&nbsp;         * @since 2.253
&nbsp;         */
&nbsp;        public static final class ConverterImpl implements Converter {
&nbsp;            private final Converter collectionConv; // used to convert ArrayList in it
&nbsp;
<b class="fc">&nbsp;            public ConverterImpl(Converter collectionConv) {</b>
<b class="fc">&nbsp;                this.collectionConv = collectionConv;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Check if the given class can be converted (i.e. check if it is of type RangeSet).
&nbsp;             */
&nbsp;            @Override
&nbsp;            public boolean canConvert(Class type) {
<b class="fc">&nbsp;                return type == RangeSet.class;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
<b class="nc">&nbsp;                RangeSet src = (RangeSet) source;</b>
<b class="nc">&nbsp;                writer.setValue(serialize(src));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Used to serialize the range sets (builds) of the fingerprint using commas and dashes.
&nbsp;             * For e.g., if used in builds 1,2,3,5, it will be serialized to 1-3,5
&nbsp;             */
&nbsp;            public static String serialize(RangeSet src) {
<b class="nc">&nbsp;                StringBuilder buf = new StringBuilder(src.ranges.size() * 10);</b>
<b class="nc">&nbsp;                for (Range r : src.ranges) {</b>
<b class="nc">&nbsp;                    if (buf.length() &gt; 0)  buf.append(&#39;,&#39;);</b>
<b class="nc">&nbsp;                    if (r.isSingle())</b>
<b class="nc">&nbsp;                        buf.append(r.start);</b>
&nbsp;                    else
<b class="nc">&nbsp;                        buf.append(r.start).append(&#39;-&#39;).append(r.end - 1);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return buf.toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Object unmarshal(HierarchicalStreamReader reader, final UnmarshallingContext context) {
<b class="fc">&nbsp;                if (reader.hasMoreChildren()) {</b>
&nbsp;                    /* old format where &lt;range&gt; elements are nested like
&nbsp;                            &lt;range&gt;
&nbsp;                              &lt;start&gt;1337&lt;/start&gt;
&nbsp;                              &lt;end&gt;1479&lt;/end&gt;
&nbsp;                            &lt;/range&gt;
&nbsp;                     */
<b class="nc">&nbsp;                    return new RangeSet((List&lt;Range&gt;) collectionConv.unmarshal(reader, context));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return RangeSet.fromString(reader.getValue(), true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Extension
<b class="nc">&nbsp;    public static final class ProjectRenameListener extends ItemListener {</b>
&nbsp;        @Override
&nbsp;        public void onLocationChanged(final Item item, final String oldName, final String newName) {
<b class="nc">&nbsp;            try (ACLContext acl = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                locationChanged(item, oldName, newName);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        private void locationChanged(Item item, String oldName, String newName) {
<b class="nc">&nbsp;            if (item instanceof Job) {</b>
<b class="nc">&nbsp;                Job p = Jenkins.get().getItemByFullName(newName, Job.class);</b>
<b class="nc">&nbsp;                if (p != null) {</b>
<b class="nc">&nbsp;                    RunList&lt;? extends Run&gt; builds = p.getBuilds();</b>
<b class="nc">&nbsp;                    for (Run build : builds) {</b>
<b class="nc">&nbsp;                        Collection&lt;Fingerprint&gt; fingerprints = build.getBuildFingerprints();</b>
<b class="nc">&nbsp;                        for (Fingerprint f : fingerprints) {</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                f.rename(oldName, newName);</b>
<b class="nc">&nbsp;                            } catch (IOException e) {</b>
<b class="nc">&nbsp;                                logger.log(Level.WARNING, &quot;Failed to update fingerprint record &quot; + f.getFileName() + &quot; when &quot; + oldName + &quot; was renamed to &quot; + newName, e);</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final DateConverter DATE_CONVERTER = new DateConverter();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Time when the fingerprint has been captured.
&nbsp;     */
&nbsp;    private final @NonNull Date timestamp;
&nbsp;
&nbsp;    /**
&nbsp;     * Null if this fingerprint is for a file that&#39;s
&nbsp;     * apparently produced outside.
&nbsp;     */
&nbsp;    private final @CheckForNull BuildPtr original;
&nbsp;
&nbsp;    private final byte[] md5sum;
&nbsp;
&nbsp;    private final String fileName;
&nbsp;
&nbsp;    /**
&nbsp;     * Range of builds that use this file keyed by a job full name.
&nbsp;     */
<b class="nc">&nbsp;    private Hashtable&lt;String, RangeSet&gt; usages = new Hashtable&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    PersistedList&lt;FingerprintFacet&gt; facets = new PersistedList&lt;&gt;(this);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Lazily computed immutable {@link FingerprintFacet}s created from {@link TransientFingerprintFacetFactory}.
&nbsp;     */
<b class="nc">&nbsp;    private transient volatile List&lt;FingerprintFacet&gt; transientFacets = null;</b>
&nbsp;
&nbsp;    public Fingerprint(@CheckForNull Run build, @NonNull String fileName, @NonNull byte[] md5sum) throws IOException {
<b class="nc">&nbsp;        this(build == null ? null : new BuildPtr(build), fileName, md5sum);</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    Fingerprint(@CheckForNull BuildPtr original, @NonNull String fileName, @NonNull byte[] md5sum) {</b>
<b class="nc">&nbsp;        this.original = original;</b>
<b class="nc">&nbsp;        this.md5sum = md5sum;</b>
<b class="nc">&nbsp;        this.fileName = fileName;</b>
<b class="nc">&nbsp;        this.timestamp = new Date();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The first build in which this file showed up,
&nbsp;     * if the file looked like it&#39;s created there.
&nbsp;     * &lt;p&gt;
&nbsp;     * This is considered as the &quot;source&quot; of this file,
&nbsp;     * or the owner, in the sense that this project &quot;owns&quot;
&nbsp;     * this file.
&nbsp;     *
&nbsp;     * @return null
&nbsp;     *      if the file is apparently created outside Hudson or if the current
&nbsp;     *      user has no permission to discover the job.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @CheckForNull BuildPtr getOriginal() {
<b class="nc">&nbsp;        if (original != null &amp;&amp; original.hasPermissionToDiscoverBuild()) {</b>
<b class="nc">&nbsp;            return original;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public @NonNull String getDisplayName() {
<b class="nc">&nbsp;        return fileName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The file name (like &quot;foo.jar&quot; without path).
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @NonNull String getFileName() {
<b class="fc">&nbsp;        return fileName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the MD5 hash string.
&nbsp;     */
&nbsp;    @Exported(name = &quot;hash&quot;)
&nbsp;    public @NonNull String getHashString() {
<b class="fc">&nbsp;        return Util.toHexString(md5sum);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the timestamp when this record is created.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public @NonNull Date getTimestamp() {
<b class="nc">&nbsp;        return timestamp;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the string that says how long since this build has scheduled.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      string like &quot;3 minutes&quot; &quot;1 day&quot; etc.
&nbsp;     */
&nbsp;    public @NonNull String getTimestampString() {
<b class="nc">&nbsp;        long duration = System.currentTimeMillis() - timestamp.getTime();</b>
<b class="nc">&nbsp;        return Util.getTimeSpanString(duration);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the build range set for the given job name.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * These builds of this job has used this file.
&nbsp;     * @return may be empty but not null.
&nbsp;     */
&nbsp;    public @NonNull RangeSet getRangeSet(String jobFullName) {
<b class="nc">&nbsp;        RangeSet r = usages.get(jobFullName);</b>
<b class="nc">&nbsp;        if (r == null) r = new RangeSet();</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    public RangeSet getRangeSet(Job job) {
<b class="nc">&nbsp;        return getRangeSet(job.getFullName());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the sorted list of job names where this jar is used.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public synchronized List&lt;String&gt; getJobs() {
<b class="nc">&nbsp;        List&lt;String&gt; r = new ArrayList&lt;&gt;(usages.keySet());</b>
<b class="nc">&nbsp;        Collections.sort(r);</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    public @CheckForNull Hashtable&lt;String, RangeSet&gt; getUsages() {
<b class="fc">&nbsp;        return usages;</b>
&nbsp;    }
&nbsp;
&nbsp;    @ExportedBean(defaultVisibility = 2)
&nbsp;    public static final class RangeItem {
&nbsp;        @Exported
&nbsp;        public final String name;
&nbsp;        @Exported
&nbsp;        public final RangeSet ranges;
&nbsp;
<b class="nc">&nbsp;        public RangeItem(String name, RangeSet ranges) {</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.ranges = ranges;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // this is for remote API
&nbsp;    @Exported(name = &quot;usage&quot;)
&nbsp;    public @NonNull List&lt;RangeItem&gt; _getUsages() {
<b class="nc">&nbsp;        List&lt;RangeItem&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        final Jenkins instance = Jenkins.get();</b>
<b class="nc">&nbsp;        for (Map.Entry&lt;String, RangeSet&gt; e : usages.entrySet()) {</b>
<b class="nc">&nbsp;            final String itemName = e.getKey();</b>
<b class="nc">&nbsp;            if (instance.hasPermission(Jenkins.ADMINISTER) || canDiscoverItem(itemName)) {</b>
<b class="nc">&nbsp;                r.add(new RangeItem(itemName, e.getValue()));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated Use {@link #addFor(hudson.model.Run)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void add(@NonNull AbstractBuild b) throws IOException {
<b class="nc">&nbsp;        addFor(b);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a usage reference to the build.
&nbsp;     * @param b {@link Run} to be referenced in {@link #usages}
&nbsp;     * @since 1.577
&nbsp;     */
&nbsp;    public void addFor(@NonNull Run b) throws IOException {
<b class="nc">&nbsp;        add(b.getParent().getFullName(), b.getNumber());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Records that a build of a job has used this file.
&nbsp;     */
&nbsp;    public synchronized void add(@NonNull String jobFullName, int n) throws IOException {
<b class="nc">&nbsp;        addWithoutSaving(jobFullName, n);</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    // JENKINS-49588
&nbsp;    @SuppressFBWarnings(value = &quot;IS2_INCONSISTENT_SYNC&quot;, justification = &quot;nothing should be competing with XStream during deserialization&quot;)
&nbsp;    protected Object readResolve() {
<b class="fc">&nbsp;        if (usages == null) {</b>
<b class="fc">&nbsp;            usages = new Hashtable&lt;&gt;();</b>
&nbsp;        }
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    void addWithoutSaving(@NonNull String jobFullName, int n) {
<b class="nc">&nbsp;        synchronized (usages) { // TODO why not synchronized (this) like some, though not all, other accesses?</b>
<b class="nc">&nbsp;            RangeSet r = usages.get(jobFullName);</b>
<b class="nc">&nbsp;            if (r == null) {</b>
<b class="nc">&nbsp;                r = new RangeSet();</b>
<b class="nc">&nbsp;                usages.put(jobFullName, r);</b>
&nbsp;            }
<b class="nc">&nbsp;            r.add(n);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if any of the builds recorded in this fingerprint
&nbsp;     * is still retained.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is used to find out old fingerprint records that can be removed
&nbsp;     * without losing too much information.
&nbsp;     */
&nbsp;    public synchronized boolean isAlive() {
<b class="nc">&nbsp;        if (original != null &amp;&amp; original.isAlive())</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;String, RangeSet&gt; e : usages.entrySet()) {</b>
<b class="nc">&nbsp;            Job j = Jenkins.get().getItemByFullName(e.getKey(), Job.class);</b>
<b class="nc">&nbsp;            if (j == null)</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;
<b class="nc">&nbsp;            Run firstBuild = j.getFirstBuild();</b>
<b class="nc">&nbsp;            if (firstBuild == null)</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;
<b class="nc">&nbsp;            int oldest = firstBuild.getNumber();</b>
<b class="nc">&nbsp;            if (!e.getValue().isSmallerThan(oldest))</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Trim off references to non-existent builds and jobs, thereby making the fingerprint smaller.
&nbsp;     *
&nbsp;     * @return true
&nbsp;     *      if this record was modified.
&nbsp;     *
&nbsp;     * @throws IOException Save failure
&nbsp;     */
&nbsp;    public synchronized boolean trim() throws IOException {
<b class="nc">&nbsp;        boolean modified = false;</b>
&nbsp;
<b class="nc">&nbsp;        for (Map.Entry&lt;String, RangeSet&gt; e : new Hashtable&lt;&gt;(usages).entrySet()) { // copy because we mutate</b>
<b class="nc">&nbsp;            Job j = Jenkins.get().getItemByFullName(e.getKey(), Job.class);</b>
<b class="nc">&nbsp;            if (j == null) { // no such job any more. recycle the record</b>
<b class="nc">&nbsp;                modified = true;</b>
<b class="nc">&nbsp;                usages.remove(e.getKey());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Run firstBuild = j.getFirstBuild();</b>
<b class="nc">&nbsp;            if (firstBuild == null) { // no builds. recycle the whole record</b>
<b class="nc">&nbsp;                modified = true;</b>
<b class="nc">&nbsp;                usages.remove(e.getKey());</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            RangeSet cur = e.getValue();</b>
&nbsp;
&nbsp;            // builds that are around without the keepLog flag on are normally clustered together (in terms of build #)
&nbsp;            // so our basic strategy is to discard everything up to the first ephemeral build, except those builds
&nbsp;            // that are marked as kept
<b class="nc">&nbsp;            RangeSet kept = new RangeSet();</b>
<b class="nc">&nbsp;            Run r = firstBuild;</b>
<b class="nc">&nbsp;            while (r != null &amp;&amp; r.isKeepLog()) {</b>
<b class="nc">&nbsp;                kept.add(r.getNumber());</b>
<b class="nc">&nbsp;                r = r.getNextBuild();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (r == null) {</b>
&nbsp;                // all the build records are permanently kept ones, so we&#39;ll just have to keep &#39;kept&#39; out of whatever currently in &#39;cur&#39;
<b class="nc">&nbsp;                modified |= cur.retainAll(kept);</b>
&nbsp;            } else {
&nbsp;                // otherwise we are ready to discard [0,r.number) except those marked as &#39;kept&#39;
<b class="nc">&nbsp;                RangeSet discarding =  new RangeSet(new Range(-1, r.getNumber()));</b>
<b class="nc">&nbsp;                discarding.removeAll(kept);</b>
<b class="nc">&nbsp;                modified |= cur.removeAll(discarding);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (cur.isEmpty()) {</b>
<b class="nc">&nbsp;                usages.remove(e.getKey());</b>
<b class="nc">&nbsp;                modified = true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (modified) {</b>
<b class="nc">&nbsp;            if (logger.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                logger.log(Level.FINE, &quot;Saving trimmed Fingerprint &quot;, md5sum);</b>
&nbsp;            }
<b class="nc">&nbsp;            save();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return modified;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the associated {@link FingerprintFacet}s.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method always return a non-empty collection, which is a synthetic collection.
&nbsp;     * It contains persisted {@link FingerprintFacet}s (those that are added explicitly, like
&nbsp;     * {@code fingerprint.getFacets().add(x)}), as well those {@linkplain TransientFingerprintFacetFactory that are transient}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Mutation to this collection will manipulate persisted set of {@link FingerprintFacet}s, and therefore regardless
&nbsp;     * of what you do, this collection will always contain a set of {@link FingerprintFacet}s that are added
&nbsp;     * by {@link TransientFingerprintFacetFactory}s.
&nbsp;     *
&nbsp;     * @since 1.421
&nbsp;     */
&nbsp;    public @NonNull Collection&lt;FingerprintFacet&gt; getFacets() {
<b class="nc">&nbsp;        if (transientFacets == null) {</b>
<b class="nc">&nbsp;            List&lt;FingerprintFacet&gt; transientFacets = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            for (TransientFingerprintFacetFactory fff : TransientFingerprintFacetFactory.all()) {</b>
<b class="nc">&nbsp;                fff.createFor(this, transientFacets);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            this.transientFacets = Collections.unmodifiableList(transientFacets);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new AbstractCollection&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Iterator&lt;FingerprintFacet&gt; iterator() {
<b class="nc">&nbsp;                return Iterators.sequence(facets.iterator(), transientFacets.iterator());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean add(FingerprintFacet e) {
<b class="nc">&nbsp;                facets.add(e);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean remove(Object o) {
<b class="nc">&nbsp;                return facets.remove(o);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean contains(Object o) {
<b class="nc">&nbsp;                return facets.contains(o) || transientFacets.contains(o);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int size() {
<b class="nc">&nbsp;                return facets.size() + transientFacets.size();</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the persisted facets.
&nbsp;     *
&nbsp;     * @since 2.242
&nbsp;     */
&nbsp;    public final @NonNull PersistedList&lt;FingerprintFacet&gt; getPersistedFacets() {
<b class="fc">&nbsp;        return facets;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sorts {@link FingerprintFacet}s by their timestamps.
&nbsp;     * @return Sorted list of {@link FingerprintFacet}s
&nbsp;     */
&nbsp;    public @NonNull Collection&lt;FingerprintFacet&gt; getSortedFacets() {
<b class="nc">&nbsp;        List&lt;FingerprintFacet&gt; r = new ArrayList&lt;&gt;(getFacets());</b>
<b class="nc">&nbsp;        r.sort(new Comparator&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public int compare(FingerprintFacet o1, FingerprintFacet o2) {
<b class="nc">&nbsp;                long a = o1.getTimestamp();</b>
<b class="nc">&nbsp;                long b = o2.getTimestamp();</b>
<b class="nc">&nbsp;                return Long.compare(a, b);</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds a facet of the specific type (including subtypes.)
&nbsp;     * @param &lt;T&gt; Class of the {@link FingerprintFacet}
&nbsp;     * @return First matching facet of the specified class
&nbsp;     * @since 1.556
&nbsp;     */
&nbsp;    public @CheckForNull &lt;T extends FingerprintFacet&gt; T getFacet(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        for (FingerprintFacet f : getFacets()) {</b>
<b class="nc">&nbsp;            if (type.isInstance(f))</b>
<b class="nc">&nbsp;                return type.cast(f);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the actions contributed from {@link #getFacets()}
&nbsp;     */
&nbsp;    public @NonNull List&lt;Action&gt; getActions() {
<b class="nc">&nbsp;        List&lt;Action&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (FingerprintFacet ff : getFacets())</b>
<b class="nc">&nbsp;            ff.createActions(r);</b>
<b class="nc">&nbsp;        return Collections.unmodifiableList(r);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Save the Fingerprint in the Fingerprint Storage
&nbsp;     * @throws IOException Save error
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void save() throws IOException {
<b class="nc">&nbsp;        if (BulkChange.contains(this)) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long start = 0;</b>
<b class="nc">&nbsp;        if (logger.isLoggable(Level.FINE))</b>
<b class="nc">&nbsp;            start = System.currentTimeMillis();</b>
&nbsp;
<b class="nc">&nbsp;        FingerprintStorage configuredFingerprintStorage = FingerprintStorage.get();</b>
<b class="nc">&nbsp;        FingerprintStorage fileFingerprintStorage = ExtensionList.lookupSingleton(FileFingerprintStorage.class);</b>
&nbsp;
&nbsp;        // Implementations are expected to invoke SaveableListener on their own if relevant
&nbsp;        // TODO: Consider improving Saveable Listener API: https://issues.jenkins.io/browse/JENKINS-62543
<b class="nc">&nbsp;        configuredFingerprintStorage.save(this);</b>
&nbsp;
&nbsp;        // In the case that external fingerprint storage is configured, there may be some fingerprints in memory that
&nbsp;        // get saved before a load call (because they are already in memory). This ensures that they get deleted from
&nbsp;        // the file fingerprint storage.
&nbsp;        // TODO: Consider improving KeyedDataStorage so it provides an API for clearing the fingerprints in memory.
<b class="nc">&nbsp;        if (!(configuredFingerprintStorage instanceof FileFingerprintStorage) &amp;&amp; fileFingerprintStorage.isReady()) {</b>
<b class="nc">&nbsp;            fileFingerprintStorage.delete(this.getHashString());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (logger.isLoggable(Level.FINE))</b>
<b class="nc">&nbsp;            logger.fine(&quot;Saving fingerprint &quot; + getHashString() + &quot; took &quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Save the Fingerprint in the given file locally
&nbsp;     * @throws IOException Save error
&nbsp;     * @deprecated as of 2.242. Use {@link #save()} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    void save(File file) throws IOException {
<b class="nc">&nbsp;        FileFingerprintStorage.save(this, file);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a facet that blocks the deletion of the fingerprint.
&nbsp;     * Returns null if no such facet.
&nbsp;     * @since 2.223
&nbsp;     */
&nbsp;    public @CheckForNull FingerprintFacet getFacetBlockingDeletion() {
<b class="nc">&nbsp;        for (FingerprintFacet facet : facets) {</b>
<b class="nc">&nbsp;            if (facet.isFingerprintDeletionBlocked())</b>
<b class="nc">&nbsp;                return facet;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update references to a renamed job in the fingerprint
&nbsp;     */
&nbsp;    public synchronized void rename(String oldName, String newName) throws IOException {
<b class="nc">&nbsp;        boolean touched = false;</b>
<b class="nc">&nbsp;        if (original != null) {</b>
<b class="nc">&nbsp;            if (original.getName().equals(oldName)) {</b>
<b class="nc">&nbsp;                original.setName(newName);</b>
<b class="nc">&nbsp;                touched = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (usages != null) {</b>
<b class="nc">&nbsp;            RangeSet r = usages.get(oldName);</b>
<b class="nc">&nbsp;            if (r != null) {</b>
<b class="nc">&nbsp;                usages.put(newName, r);</b>
<b class="nc">&nbsp;                usages.remove(oldName);</b>
<b class="nc">&nbsp;                touched = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (touched) {</b>
<b class="nc">&nbsp;            save();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a {@link Fingerprint} from the Storage with the given unique id.
&nbsp;     * @return Loaded {@link Fingerprint}. {@code null} if the config file does not exist or
&nbsp;     * malformed.
&nbsp;     *
&nbsp;     * In case an external storage is configured on top of a file system based storage:
&nbsp;     * 1. External storage is polled to retrieve the fingerprint
&nbsp;     * 2. If not found, then the local storage is polled to retrieve the fingerprint
&nbsp;     */
&nbsp;    public static @CheckForNull Fingerprint load(@NonNull String id) throws IOException {
<b class="nc">&nbsp;        long start = 0;</b>
<b class="nc">&nbsp;        if (logger.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;            start = System.currentTimeMillis();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        FingerprintStorage configuredFingerprintStorage = FingerprintStorage.get();</b>
<b class="nc">&nbsp;        FingerprintStorage fileFingerprintStorage = ExtensionList.lookupSingleton(FileFingerprintStorage.class);</b>
&nbsp;
<b class="nc">&nbsp;        Fingerprint loaded = configuredFingerprintStorage.load(id);</b>
&nbsp;
<b class="nc">&nbsp;        if (loaded == null &amp;&amp; !(configuredFingerprintStorage instanceof FileFingerprintStorage) &amp;&amp;</b>
<b class="nc">&nbsp;                fileFingerprintStorage.isReady()) {</b>
<b class="nc">&nbsp;            loaded = fileFingerprintStorage.load(id);</b>
<b class="nc">&nbsp;            if (loaded != null) {</b>
<b class="nc">&nbsp;                initFacets(loaded);</b>
<b class="nc">&nbsp;                configuredFingerprintStorage.save(loaded);</b>
<b class="nc">&nbsp;                fileFingerprintStorage.delete(id);</b>
&nbsp;            }
&nbsp;        } else {
<b class="nc">&nbsp;            initFacets(loaded);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (logger.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;            logger.fine(&quot;Loading fingerprint took &quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return loaded;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the file name from md5sum.
&nbsp;     * @deprecated as of 2.242. Use {@link #load(String)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    /*package*/ static @CheckForNull Fingerprint load(@NonNull byte[] md5sum) throws IOException {
<b class="nc">&nbsp;        return load(Util.toHexString(md5sum));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a {@link Fingerprint} from a file in the image.
&nbsp;     * @return Loaded {@link Fingerprint}. Null if the config file does not exist or
&nbsp;     * malformed.
&nbsp;     * @deprecated as of 2.242. Use {@link #load(String)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    /*package*/ static @CheckForNull Fingerprint load(@NonNull File file) throws IOException {
<b class="nc">&nbsp;        Fingerprint fingerprint = FileFingerprintStorage.load(file);</b>
<b class="nc">&nbsp;        initFacets(fingerprint);</b>
&nbsp;
<b class="nc">&nbsp;        return fingerprint;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes the {@link Fingerprint} in the configured storage with the given unique id.
&nbsp;     *
&nbsp;     * @since 2.242
&nbsp;     */
&nbsp;    public static void delete(@NonNull String id) throws IOException {
<b class="nc">&nbsp;        FingerprintStorage configuredFingerprintStorage = FingerprintStorage.get();</b>
<b class="nc">&nbsp;        FingerprintStorage fileFingerprintStorage = ExtensionList.lookupSingleton(FileFingerprintStorage.class);</b>
&nbsp;
<b class="nc">&nbsp;        configuredFingerprintStorage.delete(id);</b>
&nbsp;
<b class="nc">&nbsp;        if (!(configuredFingerprintStorage instanceof FileFingerprintStorage) &amp;&amp; fileFingerprintStorage.isReady()) {</b>
<b class="nc">&nbsp;            fileFingerprintStorage.delete(id);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs Initialization of facets on a newly loaded Fingerprint.
&nbsp;     */
&nbsp;    private static void initFacets(@CheckForNull Fingerprint fingerprint) {
<b class="nc">&nbsp;        if (fingerprint == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (FingerprintFacet facet : fingerprint.facets) {</b>
<b class="nc">&nbsp;            facet._setOwner(fingerprint);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String toString() {
<b class="fc">&nbsp;        return &quot;Fingerprint[original=&quot;</b>
&nbsp;                + original
&nbsp;                + &quot;,hash=&quot;
<b class="fc">&nbsp;                + getHashString()</b>
&nbsp;                + &quot;,fileName=&quot;
&nbsp;                + fileName
&nbsp;                + &quot;,timestamp=&quot;
<b class="fc">&nbsp;                + DATE_CONVERTER.toString(timestamp)</b>
&nbsp;                + &quot;,usages=&quot;
<b class="fc">&nbsp;                + (usages == null ? &quot;null&quot; : new TreeMap&lt;&gt;(getUsages()))</b>
&nbsp;                + &quot;,facets=&quot;
&nbsp;                + facets
&nbsp;                + &quot;]&quot;;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the current user can Discover the item.
&nbsp;     * If yes, it may be displayed as a text in Fingerprint UIs.
&nbsp;     * @param fullName Full name of the job
&nbsp;     * @return {@code true} if the user can discover the item
&nbsp;     */
&nbsp;    private static boolean canDiscoverItem(@NonNull final String fullName) {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.get();</b>
&nbsp;
&nbsp;        // Fast check to avoid security context switches
<b class="nc">&nbsp;        Item item = null;</b>
&nbsp;        try {
<b class="nc">&nbsp;            item = jenkins.getItemByFullName(fullName);</b>
<b class="nc">&nbsp;        } catch (AccessDeniedException ex) {</b>
&nbsp;            // ignore, we will fall-back later
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (item != null) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Probably it failed due to the missing Item.DISCOVER
&nbsp;        // We try to retrieve the job using SYSTEM2 user and to check permissions manually.
<b class="nc">&nbsp;        final Authentication userAuth = Jenkins.getAuthentication2();</b>
<b class="nc">&nbsp;        try (ACLContext acl = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;            final Item itemBySystemUser = jenkins.getItemByFullName(fullName);</b>
<b class="nc">&nbsp;            if (itemBySystemUser == null) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            // To get the item existence fact, a user needs Item.DISCOVER for the item
&nbsp;            // and Item.READ for all container folders.
<b class="nc">&nbsp;            boolean canDiscoverTheItem = itemBySystemUser.hasPermission2(userAuth, Item.DISCOVER);</b>
<b class="nc">&nbsp;            if (canDiscoverTheItem) {</b>
<b class="nc">&nbsp;                ItemGroup&lt;?&gt; current = itemBySystemUser.getParent();</b>
&nbsp;                do {
<b class="nc">&nbsp;                    if (current instanceof Item) {</b>
<b class="nc">&nbsp;                        final Item i = (Item) current;</b>
<b class="nc">&nbsp;                        current = i.getParent();</b>
<b class="nc">&nbsp;                        if (!i.hasPermission2(userAuth, Item.READ)) {</b>
<b class="nc">&nbsp;                            canDiscoverTheItem = false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        current = null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } while (canDiscoverTheItem &amp;&amp; current != null);</b>
&nbsp;            }
<b class="nc">&nbsp;            return canDiscoverTheItem;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final XStream2 XSTREAM = new XStream2();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Provides the XStream instance this class is using for serialization.
&nbsp;     *
&nbsp;     * @return the XStream instance
&nbsp;     * @since 1.655
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public static XStream2 getXStream() {
<b class="fc">&nbsp;        return XSTREAM;</b>
&nbsp;    }
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        XSTREAM.alias(&quot;fingerprint&quot;, Fingerprint.class);</b>
<b class="fc">&nbsp;        XSTREAM.alias(&quot;range&quot;, Range.class);</b>
<b class="fc">&nbsp;        XSTREAM.alias(&quot;ranges&quot;, RangeSet.class);</b>
<b class="fc">&nbsp;        XSTREAM.registerConverter(new HexBinaryConverter(), 10);</b>
<b class="fc">&nbsp;        XSTREAM.registerConverter(new RangeSet.ConverterImpl(</b>
<b class="fc">&nbsp;            new CollectionConverter(XSTREAM.getMapper()) {</b>
&nbsp;                @Override
&nbsp;                protected Object createCollection(Class type) {
<b class="nc">&nbsp;                    return new ArrayList();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        ), 10);
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final Logger logger = Logger.getLogger(Fingerprint.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
