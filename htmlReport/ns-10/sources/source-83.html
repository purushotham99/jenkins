


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > UpdateCenter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: UpdateCenter (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">UpdateCenter</td>
<td class="coverageStat">
  <span class="percent">
    6.2%
  </span>
  <span class="absValue">
    (4/65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.2%
  </span>
  <span class="absValue">
    (38/462)
  </span>
</td>
</tr>
  <tr>
    <td class="name">UpdateCenter$CompleteBatchJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$CompleteBatchJob$CompleteBatchJobStatus</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$CompleteBatchJob$Failure</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$CompleteBatchJob$Pending</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$CompleteBatchJob$Running</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$CompleteBatchJob$Success</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$ConnectionCheckJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$ConnectionCheckJob$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$ConnectionStatus</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$CoreUpdateMonitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$Failure</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$InstallationStatus</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$Installing</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$Pending</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$Skipped</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$Success</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$DownloadJob$SuccessButRequiresRestart</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$EnableJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$HudsonDowngradeJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$HudsonUpgradeJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$InstallationJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/72)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$NoOpJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$PluginDowngradeJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$PluginEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$RestartJenkinsJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$RestartJenkinsJob$Canceled</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$RestartJenkinsJob$Failure</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$RestartJenkinsJob$Pending</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$RestartJenkinsJob$RestartJenkinsJobStatus</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$RestartJenkinsJob$Running</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$UpdateCenterConfiguration</td>
<td class="coverageStat">
  <span class="percent">
    7.1%
  </span>
  <span class="absValue">
    (1/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.7%
  </span>
  <span class="absValue">
    (4/85)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$UpdateCenterJob</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$VerificationResult</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">UpdateCenter$WithComputedChecksums</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    3.6%
  </span>
  <span class="absValue">
    (7/196)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5%
  </span>
  <span class="absValue">
    (47/936)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, Yahoo! Inc., Seiji Sogabe
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static hudson.init.InitMilestone.PLUGINS_STARTED;
&nbsp;import static java.util.logging.Level.INFO;
&nbsp;import static java.util.logging.Level.WARNING;
&nbsp;
&nbsp;import com.google.common.annotations.VisibleForTesting;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.Functions;
&nbsp;import hudson.PluginManager;
&nbsp;import hudson.PluginWrapper;
&nbsp;import hudson.ProxyConfiguration;
&nbsp;import hudson.Util;
&nbsp;import hudson.XmlFile;
&nbsp;import hudson.init.Initializer;
&nbsp;import hudson.lifecycle.Lifecycle;
&nbsp;import hudson.lifecycle.RestartNotSupportedException;
&nbsp;import hudson.model.UpdateSite.Data;
&nbsp;import hudson.model.UpdateSite.Plugin;
&nbsp;import hudson.model.listeners.SaveableListener;
&nbsp;import hudson.remoting.AtmostOneThreadExecutor;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.security.Permission;
&nbsp;import hudson.util.DaemonThreadFactory;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.HttpResponses;
&nbsp;import hudson.util.NamingThreadFactory;
&nbsp;import hudson.util.PersistedList;
&nbsp;import hudson.util.VersionNumber;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.net.HttpRetryException;
&nbsp;import java.net.HttpURLConnection;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLConnection;
&nbsp;import java.net.UnknownHostException;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.nio.file.AtomicMoveNotSupportedException;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.StandardCopyOption;
&nbsp;import java.security.DigestOutputStream;
&nbsp;import java.security.MessageDigest;
&nbsp;import java.security.NoSuchAlgorithmException;
&nbsp;import java.text.MessageFormat;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Base64;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.UUID;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.jar.Attributes;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import javax.net.ssl.SSLHandshakeException;
&nbsp;import javax.servlet.ServletException;
&nbsp;import jenkins.MissingDependencyException;
&nbsp;import jenkins.RestartRequiredException;
&nbsp;import jenkins.install.InstallUtil;
&nbsp;import jenkins.management.Badge;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.Loadable;
&nbsp;import jenkins.security.stapler.StaplerDispatchable;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.Timer;
&nbsp;import jenkins.util.io.OnMaster;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.io.IOUtils;
&nbsp;import org.apache.commons.io.input.CountingInputStream;
&nbsp;import org.jenkinsci.Symbol;
&nbsp;import org.jvnet.localizer.Localizable;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.StaplerProxy;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;
&nbsp;/**
&nbsp; * Controls update center capability.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * The main job of this class is to keep track of the latest update center metadata file, and perform installations.
&nbsp; * Much of the UI about choosing plugins to install is done in {@link PluginManager}.
&nbsp; * &lt;p&gt;
&nbsp; * The update center can be configured to contact alternate servers for updates
&nbsp; * and plugins, and to use alternate strategies for downloading, installing
&nbsp; * and updating components. See the Javadocs for {@link UpdateCenterConfiguration}
&nbsp; * for more information.
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Extending Update Centers&lt;/b&gt;. The update center in {@code Jenkins} can be replaced by defining a
&nbsp; * System Property ({@code hudson.model.UpdateCenter.className}). See {@link #createUpdateCenter(hudson.model.UpdateCenter.UpdateCenterConfiguration)}.
&nbsp; * This className should be available on early startup, so it cannot come only from a library
&nbsp; * (e.g. Jenkins module or Extra library dependency in the WAR file project).
&nbsp; * Plugins cannot be used for such purpose.
&nbsp; * In order to be correctly instantiated, the class definition must have two constructors:
&nbsp; * {@link #UpdateCenter()} and {@link #UpdateCenter(hudson.model.UpdateCenter.UpdateCenterConfiguration)}.
&nbsp; * If the class does not comply with the requirements, a fallback to the default UpdateCenter will be performed.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @since 1.220
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public class UpdateCenter extends AbstractModelObject implements Loadable, Saveable, OnMaster, StaplerProxy {
&nbsp;
&nbsp;    private static final Logger LOGGER;
&nbsp;    private static final String UPDATE_CENTER_URL;
&nbsp;
&nbsp;    /**
&nbsp;     * Read timeout when downloading plugins, defaults to 1 minute
&nbsp;     */
<b class="fc">&nbsp;    private static final int PLUGIN_DOWNLOAD_READ_TIMEOUT = (int) TimeUnit.SECONDS.toMillis(SystemProperties.getInteger(UpdateCenter.class.getName() + &quot;.pluginDownloadReadTimeoutSeconds&quot;, 60));</b>
&nbsp;
&nbsp;    public static final String PREDEFINED_UPDATE_SITE_ID = &quot;default&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * {@linkplain UpdateSite#getId() ID} of the default update site.
&nbsp;     * @since 1.483; configurable via system property since 2.4
&nbsp;     */
<b class="fc">&nbsp;    public static final String ID_DEFAULT = SystemProperties.getString(UpdateCenter.class.getName() + &quot;.defaultUpdateSiteId&quot;, PREDEFINED_UPDATE_SITE_ID);</b>
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static final String ID_UPLOAD = &quot;_upload&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * {@link ExecutorService} that performs installation.
&nbsp;     * @since 1.501
&nbsp;     */
<b class="nc">&nbsp;    private final ExecutorService installerService = new AtmostOneThreadExecutor(</b>
&nbsp;        new NamingThreadFactory(new DaemonThreadFactory(), &quot;Update center installer thread&quot;));
&nbsp;
&nbsp;    /**
&nbsp;     * An {@link ExecutorService} for updating UpdateSites.
&nbsp;     */
<b class="nc">&nbsp;    protected final ExecutorService updateService = Executors.newCachedThreadPool(</b>
&nbsp;        new NamingThreadFactory(new DaemonThreadFactory(), &quot;Update site data downloader&quot;));
&nbsp;
&nbsp;    /**
&nbsp;     * List of created {@link UpdateCenterJob}s. Access needs to be synchronized.
&nbsp;     */
<b class="nc">&nbsp;    private final Vector&lt;UpdateCenterJob&gt; jobs = new Vector&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link UpdateSite}s from which we&#39;ve already installed a plugin at least once.
&nbsp;     * This is used to skip network tests.
&nbsp;     */
<b class="nc">&nbsp;    private final Set&lt;UpdateSite&gt; sourcesUsed = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * List of {@link UpdateSite}s to be used.
&nbsp;     */
<b class="nc">&nbsp;    private final PersistedList&lt;UpdateSite&gt; sites = new PersistedList&lt;&gt;(this);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Update center configuration data
&nbsp;     */
&nbsp;    private UpdateCenterConfiguration config;
&nbsp;
&nbsp;    private boolean requiresRestart;
&nbsp;
&nbsp;    /** @see #isSiteDataReady */
&nbsp;    private transient volatile boolean siteDataLoading;
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        Logger logger = Logger.getLogger(UpdateCenter.class.getName());</b>
<b class="fc">&nbsp;        LOGGER = logger;</b>
<b class="fc">&nbsp;        String ucOverride = SystemProperties.getString(UpdateCenter.class.getName() + &quot;.updateCenterUrl&quot;);</b>
<b class="fc">&nbsp;        if (ucOverride != null) {</b>
<b class="nc">&nbsp;            logger.log(Level.INFO, &quot;Using a custom update center defined by the system property: {0}&quot;, ucOverride);</b>
<b class="nc">&nbsp;            UPDATE_CENTER_URL = ucOverride;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            UPDATE_CENTER_URL = &quot;https://updates.jenkins.io/&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Simple connection status enum.
&nbsp;     */
<b class="nc">&nbsp;    @Restricted(NoExternalUse.class)</b>
&nbsp;    enum ConnectionStatus {
&nbsp;        /**
&nbsp;         * Connection status has not started yet.
&nbsp;         */
<b class="nc">&nbsp;        PRECHECK,</b>
&nbsp;        /**
&nbsp;         * Connection status check has been skipped.
&nbsp;         * As example, it may happen if there is no connection check URL defined for the site.
&nbsp;         * @since 2.4
&nbsp;         */
<b class="nc">&nbsp;        SKIPPED,</b>
&nbsp;        /**
&nbsp;         * Connection status is being checked at this time.
&nbsp;         */
<b class="nc">&nbsp;        CHECKING,</b>
&nbsp;        /**
&nbsp;         * Connection status was not checked.
&nbsp;         */
<b class="nc">&nbsp;        UNCHECKED,</b>
&nbsp;        /**
&nbsp;         * Connection is ok.
&nbsp;         */
<b class="nc">&nbsp;        OK,</b>
&nbsp;        /**
&nbsp;         * Connection status check failed.
&nbsp;         */
<b class="nc">&nbsp;        FAILED;</b>
&nbsp;
&nbsp;        static final String INTERNET = &quot;internet&quot;;
&nbsp;        static final String UPDATE_SITE = &quot;updatesite&quot;;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public UpdateCenter() {</b>
<b class="nc">&nbsp;        configure(new UpdateCenterConfiguration());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    UpdateCenter(@NonNull UpdateCenterConfiguration configuration) {</b>
<b class="nc">&nbsp;        configure(configuration);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an update center.
&nbsp;     * @param config Requested configuration. May be {@code null} if defaults should be used
&nbsp;     * @return Created Update center. {@link UpdateCenter} by default, but may be overridden
&nbsp;     * @since 2.4
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public static UpdateCenter createUpdateCenter(@CheckForNull UpdateCenterConfiguration config) {
<b class="nc">&nbsp;        String requiredClassName = SystemProperties.getString(UpdateCenter.class.getName() + &quot;.className&quot;, null);</b>
<b class="nc">&nbsp;        if (requiredClassName == null) {</b>
&nbsp;            // Use the default Update Center
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;Using the default Update Center implementation&quot;);</b>
<b class="nc">&nbsp;            return createDefaultUpdateCenter(config);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Using the custom update center: {0}&quot;, requiredClassName);</b>
&nbsp;        try {
<b class="nc">&nbsp;            final Class&lt;?&gt; clazz = Class.forName(requiredClassName).asSubclass(UpdateCenter.class);</b>
<b class="nc">&nbsp;            if (!UpdateCenter.class.isAssignableFrom(clazz)) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;The specified custom Update Center {0} is not an instance of {1}. Falling back to default.&quot;,</b>
<b class="nc">&nbsp;                        new Object[] {requiredClassName, UpdateCenter.class.getName()});</b>
<b class="nc">&nbsp;                return createDefaultUpdateCenter(config);</b>
&nbsp;            }
<b class="nc">&nbsp;            final Class&lt;? extends UpdateCenter&gt; ucClazz = clazz.asSubclass(UpdateCenter.class);</b>
<b class="nc">&nbsp;            final Constructor&lt;? extends UpdateCenter&gt; defaultConstructor = ucClazz.getConstructor();</b>
<b class="nc">&nbsp;            final Constructor&lt;? extends UpdateCenter&gt; configConstructor = ucClazz.getConstructor(UpdateCenterConfiguration.class);</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;Using the constructor {0} Update Center configuration for {1}&quot;,</b>
<b class="nc">&nbsp;                    new Object[] {config != null ? &quot;with&quot; : &quot;without&quot;, requiredClassName});</b>
<b class="nc">&nbsp;            return config != null ? configConstructor.newInstance(config) : defaultConstructor.newInstance();</b>
<b class="nc">&nbsp;        } catch (ClassCastException e) {</b>
&nbsp;            // Should never happen
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;UpdateCenter class {0} does not extend hudson.model.UpdateCenter. Using default.&quot;, requiredClassName);</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, String.format(&quot;UpdateCenter class %s does not define one of the required constructors. Using default&quot;, requiredClassName), e);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, String.format(&quot;Unable to instantiate custom plugin manager [%s]. Using default.&quot;, requiredClassName), e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return createDefaultUpdateCenter(config);</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    private static UpdateCenter createDefaultUpdateCenter(@CheckForNull UpdateCenterConfiguration config) {
<b class="nc">&nbsp;        return config != null ? new UpdateCenter(config) : new UpdateCenter();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures update center to get plugins/updates from alternate servers,
&nbsp;     * and optionally using alternate strategies for downloading, installing
&nbsp;     * and upgrading.
&nbsp;     *
&nbsp;     * @param config Configuration data
&nbsp;     * @see UpdateCenterConfiguration
&nbsp;     */
&nbsp;    public void configure(UpdateCenterConfiguration config) {
<b class="nc">&nbsp;        if (config != null) {</b>
<b class="nc">&nbsp;            this.config = config;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the list of {@link UpdateCenterJob} representing scheduled installation attempts.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      can be empty but never null. Oldest entries first.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @StaplerDispatchable
&nbsp;    public List&lt;UpdateCenterJob&gt; getJobs() {
<b class="nc">&nbsp;        synchronized (jobs) {</b>
<b class="nc">&nbsp;            return new ArrayList&lt;&gt;(jobs);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a job by its ID.
&nbsp;     *
&nbsp;     * Primarily to make {@link UpdateCenterJob} bound to URL.
&nbsp;     */
&nbsp;    public UpdateCenterJob getJob(int id) {
<b class="nc">&nbsp;        synchronized (jobs) {</b>
<b class="nc">&nbsp;            for (UpdateCenterJob job : jobs) {</b>
<b class="nc">&nbsp;                if (job.id == id)</b>
<b class="nc">&nbsp;                    return job;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns latest install/upgrade job for the given plugin.
&nbsp;     * @return InstallationJob or null if not found
&nbsp;     */
&nbsp;    public InstallationJob getJob(Plugin plugin) {
<b class="nc">&nbsp;        List&lt;UpdateCenterJob&gt; jobList = getJobs();</b>
<b class="nc">&nbsp;        Collections.reverse(jobList);</b>
<b class="nc">&nbsp;        for (UpdateCenterJob job : jobList)</b>
<b class="nc">&nbsp;            if (job instanceof InstallationJob) {</b>
<b class="nc">&nbsp;                InstallationJob ij = (InstallationJob) job;</b>
<b class="nc">&nbsp;                if (ij.plugin.name.equals(plugin.name) &amp;&amp; ij.plugin.sourceId.equals(plugin.sourceId))</b>
<b class="nc">&nbsp;                    return ij;</b>
&nbsp;            }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Badge getBadge() {
<b class="nc">&nbsp;        if (!isSiteDataReady()) {</b>
&nbsp;            // Do not display message during this page load, but possibly later.
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;Plugin&gt; plugins = getUpdates();</b>
<b class="nc">&nbsp;        int size = plugins.size();</b>
<b class="nc">&nbsp;        if (size &gt; 0) {</b>
<b class="nc">&nbsp;            StringBuilder tooltip = new StringBuilder();</b>
<b class="nc">&nbsp;            Badge.Severity severity = Badge.Severity.WARNING;</b>
<b class="nc">&nbsp;            int securityFixSize = (int) plugins.stream().filter(plugin -&gt; plugin.fixesSecurityVulnerabilities()).count();</b>
<b class="nc">&nbsp;            int incompatibleSize = (int) plugins.stream().filter(plugin -&gt; !plugin.isCompatibleWithInstalledVersion()).count();</b>
<b class="nc">&nbsp;            if (size &gt; 1) {</b>
<b class="nc">&nbsp;                tooltip.append(jenkins.management.Messages.PluginsLink_updatesAvailable(size));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                tooltip.append(jenkins.management.Messages.PluginsLink_updateAvailable());</b>
&nbsp;            }
<b class="nc">&nbsp;            switch (incompatibleSize) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    tooltip.append(&quot;\n&quot;).append(jenkins.management.Messages.PluginsLink_incompatibleUpdateAvailable());</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    tooltip.append(&quot;\n&quot;).append(jenkins.management.Messages.PluginsLink_incompatibleUpdatesAvailable(incompatibleSize));</b>
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            switch (securityFixSize) {</b>
&nbsp;                case 0:
<b class="nc">&nbsp;                    break;</b>
&nbsp;                case 1:
<b class="nc">&nbsp;                    tooltip.append(&quot;\n&quot;).append(jenkins.management.Messages.PluginsLink_securityUpdateAvailable());</b>
<b class="nc">&nbsp;                    severity = Badge.Severity.DANGER;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    tooltip.append(&quot;\n&quot;).append(jenkins.management.Messages.PluginsLink_securityUpdatesAvailable(securityFixSize));</b>
<b class="nc">&nbsp;                    severity = Badge.Severity.DANGER;</b>
&nbsp;                    break;
&nbsp;            }
<b class="nc">&nbsp;            return new Badge(Integer.toString(size), tooltip.toString(), severity);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the current connection status.
&nbsp;     * &lt;p&gt;
&nbsp;     * Supports a &quot;siteId&quot; request parameter, defaulting to {@link #ID_DEFAULT} for the default
&nbsp;     * update site.
&nbsp;     *
&nbsp;     * @return The current connection status.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public HttpResponse doConnectionStatus(StaplerRequest request) {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);</b>
&nbsp;        try {
<b class="nc">&nbsp;            String siteId = request.getParameter(&quot;siteId&quot;);</b>
<b class="nc">&nbsp;            if (siteId == null) {</b>
<b class="nc">&nbsp;                siteId = ID_DEFAULT;</b>
<b class="nc">&nbsp;            } else if (siteId.equals(&quot;default&quot;)) {</b>
&nbsp;                // If the request explicitly requires the default ID, ship it
<b class="nc">&nbsp;                siteId = ID_DEFAULT;</b>
&nbsp;            }
<b class="nc">&nbsp;            ConnectionCheckJob checkJob = getConnectionCheckJob(siteId);</b>
<b class="nc">&nbsp;            if (checkJob == null) {</b>
<b class="nc">&nbsp;                UpdateSite site = getSite(siteId);</b>
<b class="nc">&nbsp;                if (site != null) {</b>
<b class="nc">&nbsp;                    checkJob = addConnectionCheckJob(site);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (checkJob != null) {</b>
<b class="nc">&nbsp;                boolean isOffline = false;</b>
<b class="nc">&nbsp;                for (ConnectionStatus status : checkJob.connectionStates.values()) {</b>
<b class="nc">&nbsp;                    if (ConnectionStatus.FAILED.equals(status)) {</b>
<b class="nc">&nbsp;                        isOffline = true;</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (isOffline) {</b>
&nbsp;                    // retry connection states if determined to be offline
<b class="nc">&nbsp;                    checkJob.run();</b>
<b class="nc">&nbsp;                    isOffline = false;</b>
<b class="nc">&nbsp;                    for (ConnectionStatus status : checkJob.connectionStates.values()) {</b>
<b class="nc">&nbsp;                        if (ConnectionStatus.FAILED.equals(status)) {</b>
<b class="nc">&nbsp;                            isOffline = true;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (!isOffline) { // also need to download the metadata</b>
<b class="nc">&nbsp;                        updateAllSites();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return HttpResponses.okJSON(checkJob.connectionStates);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return HttpResponses.errorJSON(String.format(&quot;Cannot check connection status of the update site with ID=&#39;%s&#39;&quot;</b>
&nbsp;                        + &quot;. This update center cannot be resolved&quot;, siteId));
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            return HttpResponses.errorJSON(String.format(&quot;ERROR: %s&quot;, e.getMessage()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called to determine if there was an incomplete installation, what the statuses of the plugins are
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class) // WebOnly
&nbsp;    public HttpResponse doIncompleteInstallStatus() {
&nbsp;        try {
<b class="nc">&nbsp;            Map&lt;String, String&gt; jobs = InstallUtil.getPersistedInstallStatus();</b>
<b class="nc">&nbsp;            if (jobs == null) {</b>
<b class="nc">&nbsp;                jobs = Collections.emptyMap();</b>
&nbsp;            }
<b class="nc">&nbsp;            return HttpResponses.okJSON(jobs);</b>
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            return HttpResponses.errorJSON(String.format(&quot;ERROR: %s&quot;, e.getMessage()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called to persist the currently installing plugin states. This allows
&nbsp;     * us to support install resume if Jenkins is restarted while plugins are
&nbsp;     * being installed.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public synchronized void persistInstallStatus() {
<b class="nc">&nbsp;        List&lt;UpdateCenterJob&gt; jobs = getJobs();</b>
&nbsp;
<b class="nc">&nbsp;        boolean activeInstalls = false;</b>
<b class="nc">&nbsp;        for (UpdateCenterJob job : jobs) {</b>
<b class="nc">&nbsp;            if (job instanceof InstallationJob) {</b>
<b class="nc">&nbsp;                InstallationJob installationJob = (InstallationJob) job;</b>
<b class="nc">&nbsp;                if (!installationJob.status.isSuccess()) {</b>
<b class="nc">&nbsp;            activeInstalls = true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (activeInstalls) {</b>
<b class="nc">&nbsp;        InstallUtil.persistInstallStatus(jobs); // save this info</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;        InstallUtil.clearInstallStatus(); // clear this info</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the current installation status of a plugin set.
&nbsp;     * &lt;p&gt;
&nbsp;     * Supports a &quot;correlationId&quot; request parameter if you only want to get the
&nbsp;     * install status of a set of plugins requested for install through
&nbsp;     * {@link PluginManager#doInstallPlugins(org.kohsuke.stapler.StaplerRequest)}.
&nbsp;     *
&nbsp;     * @return The current installation status of a plugin set.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public HttpResponse doInstallStatus(StaplerRequest request) {
&nbsp;        try {
<b class="nc">&nbsp;            String correlationId = request.getParameter(&quot;correlationId&quot;);</b>
<b class="nc">&nbsp;            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            response.put(&quot;state&quot;, Jenkins.get().getInstallState().name());</b>
<b class="nc">&nbsp;            List&lt;Map&lt;String, String&gt;&gt; installStates = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;            response.put(&quot;jobs&quot;, installStates);</b>
<b class="nc">&nbsp;            List&lt;UpdateCenterJob&gt; jobCopy = getJobs();</b>
&nbsp;
<b class="nc">&nbsp;            for (UpdateCenterJob job : jobCopy) {</b>
<b class="nc">&nbsp;                if (job instanceof InstallationJob) {</b>
<b class="nc">&nbsp;                    UUID jobCorrelationId = job.getCorrelationId();</b>
<b class="nc">&nbsp;                    if (correlationId == null || (jobCorrelationId != null &amp;&amp; correlationId.equals(jobCorrelationId.toString()))) {</b>
<b class="nc">&nbsp;                        InstallationJob installationJob = (InstallationJob) job;</b>
<b class="nc">&nbsp;                        Map&lt;String, String&gt; pluginInfo = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;                        pluginInfo.put(&quot;name&quot;, installationJob.plugin.name);</b>
<b class="nc">&nbsp;                        pluginInfo.put(&quot;version&quot;, installationJob.plugin.version);</b>
<b class="nc">&nbsp;                        pluginInfo.put(&quot;title&quot;, installationJob.plugin.title);</b>
<b class="nc">&nbsp;                        pluginInfo.put(&quot;installStatus&quot;, installationJob.status.getType());</b>
<b class="nc">&nbsp;                        pluginInfo.put(&quot;requiresRestart&quot;, Boolean.toString(installationJob.status.requiresRestart()));</b>
<b class="nc">&nbsp;                        if (jobCorrelationId != null) {</b>
<b class="nc">&nbsp;                            pluginInfo.put(&quot;correlationId&quot;, jobCorrelationId.toString());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        installStates.add(pluginInfo);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return HttpResponses.okJSON(JSONObject.fromObject(response));</b>
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            return HttpResponses.errorJSON(String.format(&quot;ERROR: %s&quot;, e.getMessage()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns latest Jenkins upgrade job.
&nbsp;     * @return HudsonUpgradeJob or null if not found
&nbsp;     */
&nbsp;    public HudsonUpgradeJob getHudsonJob() {
<b class="nc">&nbsp;        List&lt;UpdateCenterJob&gt; jobList = getJobs();</b>
<b class="nc">&nbsp;        Collections.reverse(jobList);</b>
<b class="nc">&nbsp;        for (UpdateCenterJob job : jobList)</b>
<b class="nc">&nbsp;            if (job instanceof HudsonUpgradeJob)</b>
<b class="nc">&nbsp;                return (HudsonUpgradeJob) job;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the list of {@link UpdateSite}s to be used.
&nbsp;     * This is a live list, whose change will be persisted automatically.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      can be empty but never null.
&nbsp;     */
&nbsp;    @StaplerDispatchable // referenced by _api.jelly
&nbsp;    public PersistedList&lt;UpdateSite&gt; getSites() {
<b class="nc">&nbsp;        return sites;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Whether it is &lt;em&gt;probably&lt;/em&gt; safe to call all {@link UpdateSite#getData} without blocking.
&nbsp;     * @return true if all data is &lt;em&gt;currently&lt;/em&gt; ready (or absent);
&nbsp;     *         false if some is not ready now (but it will be loaded in the background)
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public boolean isSiteDataReady() {
<b class="nc">&nbsp;        if (sites.stream().anyMatch(UpdateSite::hasUnparsedData)) {</b>
<b class="nc">&nbsp;            if (!siteDataLoading) {</b>
<b class="nc">&nbsp;                siteDataLoading = true;</b>
<b class="nc">&nbsp;                Timer.get().submit(() -&gt; {</b>
<b class="nc">&nbsp;                    sites.forEach(UpdateSite::getData);</b>
<b class="nc">&nbsp;                    siteDataLoading = false;</b>
&nbsp;                });
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The same as {@link #getSites()} but for REST API.
&nbsp;     */
&nbsp;    @Exported(name = &quot;sites&quot;)
&nbsp;    public List&lt;UpdateSite&gt; getSiteList() {
<b class="nc">&nbsp;        return sites.toList();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Alias for {@link #getById}.
&nbsp;     * @param id ID of the update site to be retrieved
&nbsp;     * @return Discovered {@link UpdateSite}. {@code null} if it cannot be found
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public UpdateSite getSite(String id) {
<b class="nc">&nbsp;        return getById(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the string representing how long ago the data was obtained.
&nbsp;     * Will be the newest of all {@link UpdateSite}s.
&nbsp;     */
&nbsp;    public String getLastUpdatedString() {
<b class="nc">&nbsp;        long newestTs = 0;</b>
<b class="nc">&nbsp;        for (UpdateSite s : sites) {</b>
<b class="nc">&nbsp;            if (s.getDataTimestamp() &gt; newestTs) {</b>
<b class="nc">&nbsp;                newestTs = s.getDataTimestamp();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (newestTs == 0) {</b>
<b class="nc">&nbsp;            return Messages.UpdateCenter_n_a();</b>
&nbsp;        }
<b class="nc">&nbsp;        return Util.getTimeSpanString(System.currentTimeMillis() - newestTs);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets {@link UpdateSite} by its ID.
&nbsp;     * Used to bind them to URL.
&nbsp;     * @param id ID of the update site to be retrieved
&nbsp;     * @return Discovered {@link UpdateSite}. {@code null} if it cannot be found
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public UpdateSite getById(String id) {
<b class="nc">&nbsp;        for (UpdateSite s : sites) {</b>
<b class="nc">&nbsp;            if (s.getId().equals(id)) {</b>
<b class="nc">&nbsp;                return s;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link UpdateSite} from which we receive updates for {@code jenkins.war}.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      {@code null} if no such update center is provided.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public UpdateSite getCoreSource() {
<b class="nc">&nbsp;        for (UpdateSite s : sites) {</b>
<b class="nc">&nbsp;            Data data = s.getData();</b>
<b class="nc">&nbsp;            if (data != null &amp;&amp; data.core != null)</b>
<b class="nc">&nbsp;                return s;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the default base URL.
&nbsp;     *
&nbsp;     * @deprecated
&nbsp;     *      TODO: revisit tool update mechanism, as that should be de-centralized, too. In the mean time,
&nbsp;     *      please try not to use this method, and instead ping us to get this part completed.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public String getDefaultBaseUrl() {
<b class="nc">&nbsp;        return config.getUpdateCenterUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the plugin with the given name from the first {@link UpdateSite} to contain it.
&nbsp;     * @return Discovered {@link Plugin}. {@code null} if it cannot be found
&nbsp;     */
&nbsp;    public @CheckForNull Plugin getPlugin(String artifactId) {
<b class="nc">&nbsp;        for (UpdateSite s : sites) {</b>
<b class="nc">&nbsp;            Plugin p = s.getPlugin(artifactId);</b>
<b class="nc">&nbsp;            if (p != null) return p;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the plugin with the given name from the first {@link UpdateSite} to contain it.
&nbsp;     * @return Discovered {@link Plugin}. {@code null} if it cannot be found
&nbsp;     */
&nbsp;    public @CheckForNull Plugin getPlugin(String artifactId, @CheckForNull VersionNumber minVersion) {
<b class="nc">&nbsp;        if (minVersion == null) {</b>
<b class="nc">&nbsp;            return getPlugin(artifactId);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (UpdateSite s : sites) {</b>
<b class="nc">&nbsp;            Plugin p = s.getPlugin(artifactId);</b>
<b class="nc">&nbsp;            if (checkMinVersion(p, minVersion)) {</b>
<b class="nc">&nbsp;                return p;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets plugin info from all available sites
&nbsp;     * @return list of plugins
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public @NonNull List&lt;Plugin&gt; getPluginFromAllSites(String artifactId,
&nbsp;            @CheckForNull VersionNumber minVersion) {
<b class="nc">&nbsp;        ArrayList&lt;Plugin&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (UpdateSite s : sites) {</b>
<b class="nc">&nbsp;            Plugin p = s.getPlugin(artifactId);</b>
<b class="nc">&nbsp;            if (checkMinVersion(p, minVersion)) {</b>
<b class="nc">&nbsp;                result.add(p);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean checkMinVersion(@CheckForNull Plugin p, @CheckForNull VersionNumber minVersion) {
<b class="nc">&nbsp;        return p != null</b>
<b class="nc">&nbsp;                &amp;&amp; (minVersion == null || !minVersion.isNewerThan(new VersionNumber(p.version)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedules a Jenkins upgrade.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication2());</b>
<b class="nc">&nbsp;        if (!Lifecycle.get().canRewriteHudsonWar()) {</b>
<b class="nc">&nbsp;            sendError(&quot;Jenkins upgrade not supported in this running mode&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;Scheduling the core upgrade&quot;);</b>
<b class="nc">&nbsp;        addJob(job);</b>
<b class="nc">&nbsp;        rsp.sendRedirect2(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invalidates the update center JSON data for all the sites and force re-retrieval.
&nbsp;     *
&nbsp;     * @since 1.432
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doInvalidateData() {
<b class="nc">&nbsp;        for (UpdateSite site : sites) {</b>
<b class="nc">&nbsp;            site.doInvalidateData();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return HttpResponses.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Schedules a Jenkins restart.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doSafeRestart(StaplerRequest request, StaplerResponse response) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        synchronized (jobs) {</b>
<b class="nc">&nbsp;            if (!isRestartScheduled()) {</b>
<b class="nc">&nbsp;                addJob(new RestartJenkinsJob(getCoreSource()));</b>
<b class="nc">&nbsp;                LOGGER.info(&quot;Scheduling Jenkins reboot&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        response.sendRedirect2(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Cancel all scheduled jenkins restarts
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doCancelRestart(StaplerResponse response) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        synchronized (jobs) {</b>
<b class="nc">&nbsp;            for (UpdateCenterJob job : jobs) {</b>
<b class="nc">&nbsp;                if (job instanceof RestartJenkinsJob) {</b>
<b class="nc">&nbsp;                    if (((RestartJenkinsJob) job).cancel()) {</b>
<b class="nc">&nbsp;                        LOGGER.info(&quot;Scheduled Jenkins reboot unscheduled&quot;);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        response.sendRedirect2(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If any of the executed {@link UpdateCenterJob}s requires a restart
&nbsp;     * to take effect, this method returns true.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This doesn&#39;t necessarily mean the user has scheduled or initiated
&nbsp;     * the restart operation.
&nbsp;     *
&nbsp;     * @see #isRestartScheduled()
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isRestartRequiredForCompletion() {
<b class="nc">&nbsp;        return requiresRestart;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the restart operation is scheduled
&nbsp;     * (which means in near future Jenkins will restart by itself)
&nbsp;     *
&nbsp;     * @see #isRestartRequiredForCompletion()
&nbsp;     */
&nbsp;    public boolean isRestartScheduled() {
<b class="nc">&nbsp;        for (UpdateCenterJob job : getJobs()) {</b>
<b class="nc">&nbsp;            if (job instanceof RestartJenkinsJob) {</b>
<b class="nc">&nbsp;                RestartJenkinsJob.RestartJenkinsJobStatus status = ((RestartJenkinsJob) job).status;</b>
<b class="nc">&nbsp;                if (status instanceof RestartJenkinsJob.Pending</b>
&nbsp;                        || status instanceof RestartJenkinsJob.Running) {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if backup of jenkins.war exists on the hard drive
&nbsp;     */
&nbsp;    public boolean isDowngradable() {
<b class="nc">&nbsp;        return new File(Lifecycle.get().getHudsonWar() + &quot;.bak&quot;).exists();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs hudson downgrade.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doDowngrade(StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        if (!isDowngradable()) {</b>
<b class="nc">&nbsp;            sendError(&quot;Jenkins downgrade is not possible, probably backup does not exist&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Jenkins.getAuthentication2());</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Scheduling the core downgrade&quot;);</b>
<b class="nc">&nbsp;        addJob(job);</b>
<b class="nc">&nbsp;        rsp.sendRedirect2(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs hudson downgrade.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doRestart(StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Jenkins.getAuthentication2());</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Scheduling the core downgrade&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        addJob(job);</b>
<b class="nc">&nbsp;        rsp.sendRedirect2(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns String with version of backup .war file,
&nbsp;     * if the file does not exists returns null
&nbsp;     */
&nbsp;    public String getBackupVersion() {
&nbsp;        try {
<b class="nc">&nbsp;            try (JarFile backupWar = new JarFile(new File(Lifecycle.get().getHudsonWar() + &quot;.bak&quot;))) {</b>
<b class="nc">&nbsp;                Attributes attrs = backupWar.getManifest().getMainAttributes();</b>
<b class="nc">&nbsp;                String v = attrs.getValue(&quot;Jenkins-Version&quot;);</b>
<b class="nc">&nbsp;                if (v == null)   v = attrs.getValue(&quot;Hudson-Version&quot;);</b>
<b class="nc">&nbsp;                return v;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;Failed to read backup version &quot;, e);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public synchronized Future&lt;UpdateCenterJob&gt; addJob(UpdateCenterJob job) {
<b class="nc">&nbsp;        if (job.site != null) {</b>
<b class="nc">&nbsp;            addConnectionCheckJob(job.site);</b>
&nbsp;        }
<b class="nc">&nbsp;        return job.submit();</b>
&nbsp;    }
&nbsp;
&nbsp;    private @NonNull ConnectionCheckJob addConnectionCheckJob(@NonNull UpdateSite site) {
&nbsp;        // Create a connection check job if the site was not already in the sourcesUsed set i.e. the first
&nbsp;        // job (in the jobs list) relating to a site must be the connection check job.
<b class="nc">&nbsp;        if (sourcesUsed.add(site)) {</b>
<b class="nc">&nbsp;            ConnectionCheckJob connectionCheckJob = newConnectionCheckJob(site);</b>
<b class="nc">&nbsp;            connectionCheckJob.submit();</b>
<b class="nc">&nbsp;            return connectionCheckJob;</b>
&nbsp;        } else {
&nbsp;            // Find the existing connection check job for that site and return it.
<b class="nc">&nbsp;            ConnectionCheckJob connectionCheckJob = getConnectionCheckJob(site);</b>
<b class="nc">&nbsp;            if (connectionCheckJob != null) {</b>
<b class="nc">&nbsp;                return connectionCheckJob;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Illegal addition of an UpdateCenter job without calling UpdateCenter.addJob. &quot; +</b>
&nbsp;                        &quot;No ConnectionCheckJob found for the site.&quot;);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a {@link ConnectionCheckJob} for the specified update site.
&nbsp;     * &lt;p&gt;
&nbsp;     * Does not start/submit the job.
&nbsp;     * @param site The site  for which the Job is to be created.
&nbsp;     * @return A {@link ConnectionCheckJob} for the specified update site.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    ConnectionCheckJob newConnectionCheckJob(UpdateSite site) {
<b class="nc">&nbsp;        return new ConnectionCheckJob(site);</b>
&nbsp;    }
&nbsp;
&nbsp;    private @CheckForNull ConnectionCheckJob getConnectionCheckJob(@NonNull String siteId) {
<b class="nc">&nbsp;        UpdateSite site = getSite(siteId);</b>
<b class="nc">&nbsp;        if (site == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getConnectionCheckJob(site);</b>
&nbsp;    }
&nbsp;
&nbsp;    private @CheckForNull ConnectionCheckJob getConnectionCheckJob(@NonNull UpdateSite site) {
<b class="nc">&nbsp;        synchronized (jobs) {</b>
<b class="nc">&nbsp;            for (UpdateCenterJob job : jobs) {</b>
<b class="nc">&nbsp;                if (job instanceof ConnectionCheckJob &amp;&amp; job.site != null &amp;&amp; job.site.getId().equals(site.getId())) {</b>
<b class="nc">&nbsp;                    return (ConnectionCheckJob) job;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="nc">&nbsp;        return Messages.UpdateCenter_DisplayName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSearchUrl() {
<b class="nc">&nbsp;        return &quot;updateCenter&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Saves the configuration info to the disk.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void save() {
<b class="nc">&nbsp;        if (BulkChange.contains(this))   return;</b>
&nbsp;        try {
<b class="nc">&nbsp;            getConfigFile().write(sites);</b>
<b class="nc">&nbsp;            SaveableListener.fireOnChange(this, getConfigFile());</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;Failed to save &quot; + getConfigFile(), e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the data from the disk into this object.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void load() throws IOException {
<b class="nc">&nbsp;        XmlFile file = getConfigFile();</b>
<b class="nc">&nbsp;        if (file.exists()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                sites.replaceBy(((PersistedList) file.unmarshal(sites)).toList());</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to load &quot; + file, e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            boolean defaultSiteExists = false;</b>
<b class="nc">&nbsp;            for (UpdateSite site : sites) {</b>
&nbsp;                // replace the legacy site with the new site
<b class="nc">&nbsp;                if (site.isLegacyDefault()) {</b>
<b class="nc">&nbsp;                    sites.remove(site);</b>
<b class="nc">&nbsp;                } else if (ID_DEFAULT.equals(site.getId())) {</b>
<b class="nc">&nbsp;                    defaultSiteExists = true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!defaultSiteExists) {</b>
<b class="nc">&nbsp;                sites.add(createDefaultUpdateSite());</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            if (sites.isEmpty()) {</b>
&nbsp;                // If there aren&#39;t already any UpdateSources, add the default one.
&nbsp;                // to maintain compatibility with existing UpdateCenterConfiguration, create the default one as specified by UpdateCenterConfiguration
<b class="nc">&nbsp;                sites.add(createDefaultUpdateSite());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        siteDataLoading = false;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected UpdateSite createDefaultUpdateSite() {
<b class="nc">&nbsp;        return new UpdateSite(PREDEFINED_UPDATE_SITE_ID, config.getUpdateCenterUrl() + &quot;update-center.json&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private XmlFile getConfigFile() {
<b class="nc">&nbsp;        return new XmlFile(XSTREAM, new File(Jenkins.get().root,</b>
<b class="nc">&nbsp;                                    UpdateCenter.class.getName() + &quot;.xml&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    public List&lt;Plugin&gt; getAvailables() {
<b class="nc">&nbsp;        Map&lt;String, Plugin&gt; pluginMap = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (UpdateSite site : sites) {</b>
<b class="nc">&nbsp;            for (Plugin plugin : site.getAvailables()) {</b>
<b class="nc">&nbsp;                final Plugin existing = pluginMap.get(plugin.name);</b>
<b class="nc">&nbsp;                if (existing == null) {</b>
<b class="nc">&nbsp;                    pluginMap.put(plugin.name, plugin);</b>
<b class="nc">&nbsp;                } else if (!existing.version.equals(plugin.version)) {</b>
&nbsp;                    // allow secondary update centers to publish different versions
&nbsp;                    // TODO refactor to consolidate multiple versions of the same plugin within the one row
<b class="nc">&nbsp;                    final String altKey = plugin.name + &quot;:&quot; + plugin.version;</b>
<b class="nc">&nbsp;                    if (!pluginMap.containsKey(altKey)) {</b>
<b class="nc">&nbsp;                        pluginMap.put(altKey, plugin);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(pluginMap.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of plugins that should be shown in the &quot;available&quot; tab, grouped by category.
&nbsp;     * A plugin with multiple categories will appear multiple times in the list.
&nbsp;     * @deprecated use {@link #getAvailables()}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public PluginEntry[] getCategorizedAvailables() {
<b class="nc">&nbsp;        TreeSet&lt;PluginEntry&gt; entries = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Plugin p : getAvailables()) {</b>
<b class="nc">&nbsp;            if (p.categories == null || p.categories.length == 0)</b>
<b class="nc">&nbsp;                entries.add(new PluginEntry(p, getCategoryDisplayName(null)));</b>
&nbsp;            else
<b class="nc">&nbsp;                for (String c : p.categories)</b>
<b class="nc">&nbsp;                    entries.add(new PluginEntry(p, getCategoryDisplayName(c)));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return entries.toArray(new PluginEntry[0]);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class) // Jelly only
&nbsp;    public static String getCategoryDisplayName(String category) {
<b class="nc">&nbsp;        if (category == null)</b>
<b class="nc">&nbsp;            return Messages.UpdateCenter_PluginCategory_misc();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return (String) Messages.class.getMethod(</b>
<b class="nc">&nbsp;                    &quot;UpdateCenter_PluginCategory_&quot; + category.replace(&#39;-&#39;, &#39;_&#39;)).invoke(null);</b>
<b class="nc">&nbsp;        } catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;            throw ex;</b>
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            return category;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Plugin&gt; getUpdates() {
<b class="nc">&nbsp;        Map&lt;String, Plugin&gt; pluginMap = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        final Map&lt;String, Set&lt;Plugin&gt;&gt; incompatiblePluginMap = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        final PluginManager.MetadataCache cache = new PluginManager.MetadataCache();</b>
&nbsp;
<b class="nc">&nbsp;        for (UpdateSite site : sites) {</b>
<b class="nc">&nbsp;            for (Plugin plugin : site.getUpdates()) {</b>
<b class="nc">&nbsp;                final Plugin existing = pluginMap.get(plugin.name);</b>
<b class="nc">&nbsp;                if (existing == null) {</b>
<b class="nc">&nbsp;                    pluginMap.put(plugin.name, plugin);</b>
&nbsp;
<b class="nc">&nbsp;                    if (!plugin.isNeededDependenciesCompatibleWithInstalledVersion()) {</b>
<b class="nc">&nbsp;                       for (Plugin incompatiblePlugin : plugin.getDependenciesIncompatibleWithInstalledVersion(cache)) {</b>
<b class="nc">&nbsp;                           incompatiblePluginMap.computeIfAbsent(incompatiblePlugin.name, _ignored -&gt; new HashSet&lt;&gt;()).add(plugin);</b>
<b class="nc">&nbsp;                       }</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (!existing.version.equals(plugin.version)) {</b>
&nbsp;                    // allow secondary update centers to publish different versions
&nbsp;                    // TODO refactor to consolidate multiple versions of the same plugin within the one row
<b class="nc">&nbsp;                    final String altKey = plugin.name + &quot;:&quot; + plugin.version;</b>
<b class="nc">&nbsp;                    if (!pluginMap.containsKey(altKey)) {</b>
<b class="nc">&nbsp;                        pluginMap.put(altKey, plugin);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        incompatiblePluginMap.forEach((key, incompatiblePlugins) -&gt; pluginMap.computeIfPresent(key, (_ignored, plugin) -&gt; {</b>
<b class="nc">&nbsp;            plugin.setIncompatibleParentPlugins(incompatiblePlugins);</b>
<b class="nc">&nbsp;            return plugin;</b>
&nbsp;        }));
&nbsp;
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(pluginMap.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    // for Jelly
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public boolean hasIncompatibleUpdates(PluginManager.MetadataCache cache) {
<b class="nc">&nbsp;        return getUpdates().stream().anyMatch(plugin -&gt; !plugin.isCompatible(cache));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Ensure that all UpdateSites are up to date, without requiring a user to
&nbsp;     * browse to the instance.
&nbsp;     *
&nbsp;     * @return a list of {@link FormValidation} for each updated Update Site
&nbsp;     * @since 1.501
&nbsp;     */
&nbsp;    public List&lt;FormValidation&gt; updateAllSites() throws InterruptedException, ExecutionException {
<b class="nc">&nbsp;        List&lt;Future&lt;FormValidation&gt;&gt; futures = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (UpdateSite site : getSites()) {</b>
<b class="nc">&nbsp;            Future&lt;FormValidation&gt; future = site.updateDirectly();</b>
<b class="nc">&nbsp;            if (future != null) {</b>
<b class="nc">&nbsp;                futures.add(future);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;FormValidation&gt; results = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Future&lt;FormValidation&gt; f : futures) {</b>
<b class="nc">&nbsp;            results.add(f.get());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return results;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link AdministrativeMonitor} that checks if there&#39;s Jenkins update.
&nbsp;     */
&nbsp;    @Extension @Symbol(&quot;coreUpdate&quot;)
<b class="nc">&nbsp;    public static final class CoreUpdateMonitor extends AdministrativeMonitor {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.UpdateCenter_CoreUpdateMonitor_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isActivated() {
<b class="nc">&nbsp;            if (!Jenkins.get().getUpdateCenter().isSiteDataReady()) {</b>
&nbsp;                // Do not display monitor during this page load, but possibly later.
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            Data data = getData();</b>
<b class="nc">&nbsp;            return data != null &amp;&amp; data.hasCoreUpdates();</b>
&nbsp;        }
&nbsp;
&nbsp;        public Data getData() {
<b class="nc">&nbsp;            UpdateSite cs = Jenkins.get().getUpdateCenter().getCoreSource();</b>
<b class="nc">&nbsp;            if (cs != null)   return cs.getData();</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Permission getRequiredPermission() {
<b class="nc">&nbsp;            return Jenkins.SYSTEM_READ;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Strategy object for controlling the update center&#39;s behaviors.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Until 1.333, this extension point used to control the configuration of
&nbsp;     * where to get updates (hence the name of this class), but with the introduction
&nbsp;     * of multiple update center sites capability, that functionality is achieved by
&nbsp;     * simply installing another {@link UpdateSite}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * See {@link UpdateSite} for how to manipulate them programmatically.
&nbsp;     *
&nbsp;     * @since 1.266
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;UnusedDeclaration&quot;)
&nbsp;    public static class UpdateCenterConfiguration implements ExtensionPoint {
&nbsp;        /**
&nbsp;         * Creates default update center configuration - uses settings for global update center.
&nbsp;         */
<b class="nc">&nbsp;        public UpdateCenterConfiguration() {</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Check network connectivity by trying to establish a connection to
&nbsp;         * the host in connectionCheckUrl.
&nbsp;         *
&nbsp;         * @param job The connection checker that is invoking this strategy.
&nbsp;         * @param connectionCheckUrl A string containing the URL of a domain
&nbsp;         *          that is assumed to be always available.
&nbsp;         * @throws IOException if a connection can&#39;t be established
&nbsp;         */
&nbsp;        public void checkConnection(ConnectionCheckJob job, String connectionCheckUrl) throws IOException {
<b class="nc">&nbsp;            testConnection(new URL(connectionCheckUrl));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Check connection to update center server.
&nbsp;         *
&nbsp;         * @param job The connection checker that is invoking this strategy.
&nbsp;         * @param updateCenterUrl A sting containing the URL of the update center host.
&nbsp;         * @throws IOException if a connection to the update center server can&#39;t be established.
&nbsp;         */
&nbsp;        public void checkUpdateCenter(ConnectionCheckJob job, String updateCenterUrl) throws IOException {
<b class="nc">&nbsp;            testConnection(toUpdateCenterCheckUrl(updateCenterUrl));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Converts an update center URL into the URL to use for checking its connectivity.
&nbsp;         * @param updateCenterUrl the URL to convert.
&nbsp;         * @return the converted URL.
&nbsp;         * @throws MalformedURLException if the supplied URL is malformed.
&nbsp;         */
&nbsp;        static URL toUpdateCenterCheckUrl(String updateCenterUrl) throws MalformedURLException {
&nbsp;            URL url;
<b class="fc">&nbsp;            if (updateCenterUrl.startsWith(&quot;http://&quot;) || updateCenterUrl.startsWith(&quot;https://&quot;)) {</b>
<b class="fc">&nbsp;                url = new URL(updateCenterUrl + (updateCenterUrl.indexOf(&#39;?&#39;) == -1 ? &quot;?uctest&quot; : &quot;&amp;uctest&quot;));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                url = new URL(updateCenterUrl);</b>
&nbsp;            }
<b class="fc">&nbsp;            return url;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Validate the URL of the resource before downloading it.
&nbsp;         *
&nbsp;         * @param job The download job that is invoking this strategy. This job is
&nbsp;         *          responsible for managing the status of the download and installation.
&nbsp;         * @param src The location of the resource on the network
&nbsp;         * @throws IOException if the validation fails
&nbsp;         */
&nbsp;        public void preValidate(DownloadJob job, URL src) throws IOException {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Validate the resource after it has been downloaded, before it is
&nbsp;         * installed. The default implementation does nothing.
&nbsp;         *
&nbsp;         * @param job The download job that is invoking this strategy. This job is
&nbsp;         *          responsible for managing the status of the download and installation.
&nbsp;         * @param src The location of the downloaded resource.
&nbsp;         * @throws IOException if the validation fails.
&nbsp;         */
&nbsp;        public void postValidate(DownloadJob job, File src) throws IOException {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Download a plugin or core upgrade in preparation for installing it
&nbsp;         * into its final location. Implementations will normally download the
&nbsp;         * resource into a temporary location and hand off a reference to this
&nbsp;         * location to the install or upgrade strategy to move into the final location.
&nbsp;         *
&nbsp;         * @param job The download job that is invoking this strategy. This job is
&nbsp;         *          responsible for managing the status of the download and installation.
&nbsp;         * @param src The URL to the resource to be downloaded.
&nbsp;         * @return A File object that describes the downloaded resource.
&nbsp;         * @throws IOException if there were problems downloading the resource.
&nbsp;         * @see DownloadJob
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;WEAK_MESSAGE_DIGEST_SHA1&quot;, justification = &quot;SHA-1 is only used as a fallback if SHA-256/SHA-512 are not available&quot;)
&nbsp;        public File download(DownloadJob job, URL src) throws IOException {
<b class="nc">&nbsp;            MessageDigest sha1 = null;</b>
<b class="nc">&nbsp;            MessageDigest sha256 = null;</b>
<b class="nc">&nbsp;            MessageDigest sha512 = null;</b>
&nbsp;            try {
&nbsp;                // Java spec says SHA-1 and SHA-256 exist, and SHA-512 might not, so one try/catch block should be fine
<b class="nc">&nbsp;                sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);</b>
<b class="nc">&nbsp;                sha256 = MessageDigest.getInstance(&quot;SHA-256&quot;);</b>
<b class="nc">&nbsp;                sha512 = MessageDigest.getInstance(&quot;SHA-512&quot;);</b>
<b class="nc">&nbsp;            } catch (NoSuchAlgorithmException nsa) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to instantiate message digest algorithm, may only have weak or no verification of downloaded file&quot;, nsa);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            URLConnection con = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                con = connect(job, src);</b>
&nbsp;                //JENKINS-34174 - set timeout for downloads, may hang indefinitely
&nbsp;                // particularly noticeable during 2.0 install when downloading
&nbsp;                // many plugins
<b class="nc">&nbsp;                con.setReadTimeout(PLUGIN_DOWNLOAD_READ_TIMEOUT);</b>
&nbsp;
&nbsp;                long total;
<b class="nc">&nbsp;                final long sizeFromMetadata = job.getContentLength();</b>
<b class="nc">&nbsp;                if (sizeFromMetadata == -1) {</b>
&nbsp;                    // Update site does not advertise a file size, so fall back to download file size, if any
<b class="nc">&nbsp;                    total = con.getContentLength();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    total = sizeFromMetadata;</b>
&nbsp;                }
<b class="nc">&nbsp;                byte[] buf = new byte[8192];</b>
&nbsp;                int len;
&nbsp;
<b class="nc">&nbsp;                File dst = job.getDestination();</b>
<b class="nc">&nbsp;                File tmp = new File(dst.getPath() + &quot;.tmp&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                LOGGER.info(&quot;Downloading &quot; + job.getName());</b>
<b class="nc">&nbsp;                Thread t = Thread.currentThread();</b>
<b class="nc">&nbsp;                String oldName = t.getName();</b>
<b class="nc">&nbsp;                t.setName(oldName + &quot;: &quot; + src);</b>
<b class="nc">&nbsp;                try (OutputStream _out = Files.newOutputStream(tmp.toPath());</b>
&nbsp;                     OutputStream out =
<b class="nc">&nbsp;                             sha1 != null ? new DigestOutputStream(</b>
<b class="nc">&nbsp;                                     sha256 != null ? new DigestOutputStream(</b>
<b class="nc">&nbsp;                                             sha512 != null ? new DigestOutputStream(_out, sha512) : _out, sha256) : _out, sha1) : _out;</b>
<b class="nc">&nbsp;                     InputStream in = con.getInputStream();</b>
<b class="nc">&nbsp;                     CountingInputStream cin = new CountingInputStream(in)) {</b>
<b class="nc">&nbsp;                    while ((len = cin.read(buf)) &gt;= 0) {</b>
<b class="nc">&nbsp;                        out.write(buf, 0, len);</b>
<b class="nc">&nbsp;                        final int count = cin.getCount();</b>
<b class="nc">&nbsp;                        job.status = job.new Installing(total == -1 ? -1 : ((int) (count * 100 / total)));</b>
<b class="nc">&nbsp;                        if (total != -1 &amp;&amp; total &lt; count) {</b>
<b class="nc">&nbsp;                            throw new IOException(&quot;Received more data than expected. Expected &quot; + total + &quot; bytes but got &quot; + count + &quot; bytes (so far), aborting download.&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (IOException | InvalidPathException e) {</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to load &quot; + src + &quot; to &quot; + tmp, e);</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    t.setName(oldName);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (total != -1 &amp;&amp; total != tmp.length()) {</b>
&nbsp;                    // don&#39;t know exactly how this happens, but report like
&nbsp;                    // http://www.ashlux.com/wordpress/2009/08/14/hudson-and-the-sonar-plugin-fail-maveninstallation-nosuchmethoderror/
&nbsp;                    // indicates that this kind of inconsistency can happen. So let&#39;s be defensive
<b class="nc">&nbsp;                    throw new IOException(&quot;Inconsistent file length: expected &quot; + total + &quot; but only got &quot; + tmp.length());</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (sha1 != null) {</b>
<b class="nc">&nbsp;                    byte[] digest = sha1.digest();</b>
<b class="nc">&nbsp;                    job.computedSHA1 = Base64.getEncoder().encodeToString(digest);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (sha256 != null) {</b>
<b class="nc">&nbsp;                    byte[] digest = sha256.digest();</b>
<b class="nc">&nbsp;                    job.computedSHA256 = Base64.getEncoder().encodeToString(digest);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (sha512 != null) {</b>
<b class="nc">&nbsp;                    byte[] digest = sha512.digest();</b>
<b class="nc">&nbsp;                    job.computedSHA512 = Base64.getEncoder().encodeToString(digest);</b>
&nbsp;                }
<b class="nc">&nbsp;                return tmp;</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
&nbsp;                // assist troubleshooting in case of e.g. &quot;too many redirects&quot; by printing actual URL
<b class="nc">&nbsp;                String extraMessage = &quot;&quot;;</b>
<b class="nc">&nbsp;                if (con != null &amp;&amp; con.getURL() != null &amp;&amp; !src.toString().equals(con.getURL().toString())) {</b>
&nbsp;                    // Two URLs are considered equal if different hosts resolve to same IP. Prefer to log in case of string inequality,
&nbsp;                    // because who knows how the server responds to different host name in the request header?
&nbsp;                    // Also, since it involved name resolution, it&#39;d be an expensive operation.
<b class="nc">&nbsp;                    extraMessage = &quot; (redirected to: &quot; + con.getURL() + &quot;)&quot;;</b>
&nbsp;                }
<b class="nc">&nbsp;                throw new IOException(&quot;Failed to download from &quot; + src + extraMessage, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Connects to the given URL for downloading the binary. Useful for tweaking
&nbsp;         * how the connection gets established.
&nbsp;         */
&nbsp;        protected URLConnection connect(DownloadJob job, URL src) throws IOException {
<b class="nc">&nbsp;            return ProxyConfiguration.open(src);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called after a plugin has been downloaded to move it into its final
&nbsp;         * location. The default implementation is a file rename.
&nbsp;         *
&nbsp;         * @param job The install job that is invoking this strategy.
&nbsp;         * @param src The temporary location of the plugin.
&nbsp;         * @param dst The final destination to install the plugin to.
&nbsp;         * @throws IOException if there are problems installing the resource.
&nbsp;         */
&nbsp;        public void install(DownloadJob job, File src, File dst) throws IOException {
<b class="nc">&nbsp;            job.replace(dst, src);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called after an upgrade has been downloaded to move it into its final
&nbsp;         * location. The default implementation is a file rename.
&nbsp;         *
&nbsp;         * @param job The upgrade job that is invoking this strategy.
&nbsp;         * @param src The temporary location of the upgrade.
&nbsp;         * @param dst The final destination to install the upgrade to.
&nbsp;         * @throws IOException if there are problems installing the resource.
&nbsp;         */
&nbsp;        public void upgrade(DownloadJob job, File src, File dst) throws IOException {
<b class="nc">&nbsp;            job.replace(dst, src);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an &quot;always up&quot; server for Internet connectivity testing.
&nbsp;         *
&nbsp;         * @deprecated as of 1.333
&nbsp;         *      With the introduction of multiple update center capability, this information
&nbsp;         *      is now a part of the {@code update-center.json} file. See
&nbsp;         *      {@code http://jenkins-ci.org/update-center.json} as an example.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public String getConnectionCheckUrl() {
<b class="nc">&nbsp;            return &quot;http://www.google.com&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the URL of the server that hosts the update-center.json
&nbsp;         * file.
&nbsp;         *
&nbsp;         * @return
&nbsp;         *      Absolute URL that ends with &#39;/&#39;.
&nbsp;         * @deprecated as of 1.333
&nbsp;         *      With the introduction of multiple update center capability, this information
&nbsp;         *      is now moved to {@link UpdateSite}.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public String getUpdateCenterUrl() {
<b class="nc">&nbsp;            return UPDATE_CENTER_URL;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the URL of the server that hosts plugins and core updates.
&nbsp;         *
&nbsp;         * @deprecated as of 1.333
&nbsp;         *      {@code update-center.json} is now signed, so we don&#39;t have to further make sure that
&nbsp;         *      we aren&#39;t downloading from anywhere unsecure.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public String getPluginRepositoryBaseUrl() {
<b class="nc">&nbsp;            return &quot;http://jenkins-ci.org/&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        private void testConnection(URL url) throws IOException {
&nbsp;            try {
<b class="nc">&nbsp;                URLConnection connection = ProxyConfiguration.open(url);</b>
&nbsp;
<b class="nc">&nbsp;                if (connection instanceof HttpURLConnection) {</b>
<b class="nc">&nbsp;                    int responseCode = ((HttpURLConnection) connection).getResponseCode();</b>
<b class="nc">&nbsp;                    if (HttpURLConnection.HTTP_OK != responseCode) {</b>
<b class="nc">&nbsp;                        throw new HttpRetryException(&quot;Invalid response code (&quot; + responseCode + &quot;) from URL: &quot; + url, responseCode);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    try (InputStream is = connection.getInputStream(); OutputStream os = OutputStream.nullOutputStream()) {</b>
<b class="nc">&nbsp;                        IOUtils.copy(is, os);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (SSLHandshakeException e) {</b>
<b class="nc">&nbsp;                if (e.getMessage().contains(&quot;PKIX path building failed&quot;))</b>
&nbsp;                   // fix up this crappy error message from JDK
<b class="nc">&nbsp;                    throw new IOException(&quot;Failed to validate the SSL certificate of &quot; + url, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Things that {@link UpdateCenter#installerService} executes.
&nbsp;     *
&nbsp;     * This object will have the {@code row.jelly} which renders the job on UI.
&nbsp;     */
&nbsp;    @ExportedBean
&nbsp;    public abstract class UpdateCenterJob implements Runnable {
&nbsp;        /**
&nbsp;         * Unique ID that identifies this job.
&nbsp;         *
&nbsp;         * @see UpdateCenter#getJob(int)
&nbsp;         */
<b class="nc">&nbsp;        @Exported</b>
<b class="nc">&nbsp;        public final int id = iota.incrementAndGet();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Which {@link UpdateSite} does this belong to?
&nbsp;         */
&nbsp;        public final @CheckForNull UpdateSite site;
&nbsp;
&nbsp;        /**
&nbsp;         * Simple correlation ID that can be used to associated a batch of jobs e.g. the
&nbsp;         * installation of a set of plugins.
&nbsp;         */
<b class="nc">&nbsp;        private UUID correlationId = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * If this job fails, set to the error.
&nbsp;         */
&nbsp;        protected Throwable error;
&nbsp;
<b class="nc">&nbsp;        protected UpdateCenterJob(@CheckForNull UpdateSite site) {</b>
<b class="nc">&nbsp;            this.site = site;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Api getApi() {
<b class="nc">&nbsp;            return new Api(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        public UUID getCorrelationId() {
<b class="nc">&nbsp;            return correlationId;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void setCorrelationId(UUID correlationId) {
<b class="nc">&nbsp;            if (this.correlationId != null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Illegal call to set the &#39;correlationId&#39;. Already set.&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            this.correlationId = correlationId;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated as of 1.326
&nbsp;         *      Use {@link #submit()} instead.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public void schedule() {
<b class="nc">&nbsp;            submit();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public String getType() {
<b class="nc">&nbsp;            return getClass().getSimpleName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Schedules this job for an execution
&nbsp;         * @return
&nbsp;         *      {@link Future} to keeps track of the status of the execution.
&nbsp;         */
&nbsp;        public Future&lt;UpdateCenterJob&gt; submit() {
<b class="nc">&nbsp;            LOGGER.fine(&quot;Scheduling &quot; + this + &quot; to installerService&quot;);</b>
&nbsp;            // TODO: seems like this access to jobs should be synchronized, no?
&nbsp;            // It might get synch&#39;d accidentally via the addJob method, but that wouldn&#39;t be good.
<b class="nc">&nbsp;            jobs.add(this);</b>
<b class="nc">&nbsp;            return installerService.submit(this, this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public String getErrorMessage() {
<b class="nc">&nbsp;            return error != null ? error.getMessage() : null;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Throwable getError() {
<b class="nc">&nbsp;            return error;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Restarts jenkins.
&nbsp;     */
&nbsp;    public class RestartJenkinsJob extends UpdateCenterJob {
&nbsp;         /**
&nbsp;         * Immutable state of this job.
&nbsp;         */
<b class="nc">&nbsp;         @Exported(inline = true)</b>
&nbsp;        public volatile RestartJenkinsJobStatus status = new RestartJenkinsJob.Pending();
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the user that started this job
&nbsp;         */
&nbsp;        private String authentication;
&nbsp;
&nbsp;        /**
&nbsp;         * Cancel job
&nbsp;         */
&nbsp;        public synchronized boolean cancel() {
<b class="nc">&nbsp;            if (status instanceof RestartJenkinsJob.Pending) {</b>
<b class="nc">&nbsp;                status = new RestartJenkinsJob.Canceled();</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public RestartJenkinsJob(UpdateSite site) {</b>
<b class="nc">&nbsp;            super(site);</b>
<b class="nc">&nbsp;            this.authentication = Jenkins.getAuthentication2().getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public synchronized void run() {
<b class="nc">&nbsp;            if (!(status instanceof RestartJenkinsJob.Pending)) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            status = new RestartJenkinsJob.Running();</b>
&nbsp;            try {
&nbsp;                // safeRestart records the current authentication for the log, so set it to the managing user
<b class="nc">&nbsp;                try (ACLContext acl = ACL.as(User.get(authentication, false, Collections.emptyMap()))) {</b>
<b class="nc">&nbsp;                    Jenkins.get().safeRestart();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (RestartNotSupportedException exception) {</b>
&nbsp;                // ignore if restart is not allowed
<b class="nc">&nbsp;                status = new RestartJenkinsJob.Failure();</b>
<b class="nc">&nbsp;                error = exception;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @ExportedBean
<b class="nc">&nbsp;        public abstract class RestartJenkinsJobStatus {</b>
<b class="nc">&nbsp;            @Exported</b>
<b class="nc">&nbsp;            public final int id = iota.incrementAndGet();</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public class Pending extends RestartJenkinsJobStatus {</b>
&nbsp;            @Exported
&nbsp;            public String getType() {
<b class="nc">&nbsp;                return getClass().getSimpleName();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public class Running extends RestartJenkinsJobStatus {</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public class Failure extends RestartJenkinsJobStatus {</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public class Canceled extends RestartJenkinsJobStatus {</b>
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tests the internet connectivity.
&nbsp;     */
&nbsp;    public final class ConnectionCheckJob extends UpdateCenterJob {
<b class="nc">&nbsp;        private final Vector&lt;String&gt; statuses = new Vector&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        final Map&lt;String, ConnectionStatus&gt; connectionStates = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        public ConnectionCheckJob(UpdateSite site) {</b>
<b class="nc">&nbsp;            super(site);</b>
<b class="nc">&nbsp;            connectionStates.put(ConnectionStatus.INTERNET, ConnectionStatus.PRECHECK);</b>
<b class="nc">&nbsp;            connectionStates.put(ConnectionStatus.UPDATE_SITE, ConnectionStatus.PRECHECK);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
<b class="nc">&nbsp;            connectionStates.put(ConnectionStatus.INTERNET, ConnectionStatus.UNCHECKED);</b>
<b class="nc">&nbsp;            connectionStates.put(ConnectionStatus.UPDATE_SITE, ConnectionStatus.UNCHECKED);</b>
<b class="nc">&nbsp;            if (site == null || ID_UPLOAD.equals(site.getId())) {</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            LOGGER.fine(&quot;Doing a connectivity check&quot;);</b>
<b class="nc">&nbsp;            Future&lt;?&gt; internetCheck = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                final String connectionCheckUrl = site.getConnectionCheckUrl();</b>
<b class="nc">&nbsp;                if (connectionCheckUrl != null) {</b>
<b class="nc">&nbsp;                    connectionStates.put(ConnectionStatus.INTERNET, ConnectionStatus.CHECKING);</b>
<b class="nc">&nbsp;                    statuses.add(Messages.UpdateCenter_Status_CheckingInternet());</b>
&nbsp;                    // Run the internet check in parallel
<b class="nc">&nbsp;                    internetCheck = updateService.submit(new Runnable() {</b>
&nbsp;                        @Override
&nbsp;                        public void run() {
&nbsp;                            try {
<b class="nc">&nbsp;                                config.checkConnection(ConnectionCheckJob.this, connectionCheckUrl);</b>
<b class="nc">&nbsp;                            } catch (Exception e) {</b>
<b class="nc">&nbsp;                                if (e.getMessage().contains(&quot;Connection timed out&quot;)) {</b>
&nbsp;                                    // Google can&#39;t be down, so this is probably a proxy issue
<b class="nc">&nbsp;                                    connectionStates.put(ConnectionStatus.INTERNET, ConnectionStatus.FAILED);</b>
<b class="nc">&nbsp;                                    statuses.add(Messages.UpdateCenter_Status_ConnectionFailed(Functions.xmlEscape(connectionCheckUrl), Jenkins.get().getRootUrl()));</b>
&nbsp;                                    return;
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                            connectionStates.put(ConnectionStatus.INTERNET, ConnectionStatus.OK);</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;                } else {
<b class="nc">&nbsp;                    LOGGER.log(WARNING, &quot;Update site &#39;&#39;{0}&#39;&#39; does not declare the connection check URL. &quot;</b>
<b class="nc">&nbsp;                            + &quot;Skipping the network availability check.&quot;, site.getId());</b>
<b class="nc">&nbsp;                    connectionStates.put(ConnectionStatus.INTERNET, ConnectionStatus.SKIPPED);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                connectionStates.put(ConnectionStatus.UPDATE_SITE, ConnectionStatus.CHECKING);</b>
<b class="nc">&nbsp;                statuses.add(Messages.UpdateCenter_Status_CheckingJavaNet());</b>
&nbsp;
<b class="nc">&nbsp;                config.checkUpdateCenter(this, site.getUrl());</b>
&nbsp;
<b class="nc">&nbsp;                connectionStates.put(ConnectionStatus.UPDATE_SITE, ConnectionStatus.OK);</b>
<b class="nc">&nbsp;                statuses.add(Messages.UpdateCenter_Status_Success());</b>
<b class="nc">&nbsp;            } catch (UnknownHostException e) {</b>
<b class="nc">&nbsp;                connectionStates.put(ConnectionStatus.UPDATE_SITE, ConnectionStatus.FAILED);</b>
<b class="nc">&nbsp;                statuses.add(Messages.UpdateCenter_Status_UnknownHostException(Functions.xmlEscape(e.getMessage()), Jenkins.get().getRootUrl()));</b>
<b class="nc">&nbsp;                addStatus(e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                connectionStates.put(ConnectionStatus.UPDATE_SITE, ConnectionStatus.FAILED);</b>
<b class="nc">&nbsp;                addStatus(e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (internetCheck != null) {</b>
&nbsp;                try {
&nbsp;                    // Wait for internet check to complete
<b class="nc">&nbsp;                    internetCheck.get();</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Error completing internet connectivity check: &quot; + e.getMessage(), e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void addStatus(Throwable e) {
<b class="nc">&nbsp;            statuses.add(&quot;&lt;pre&gt;&quot; + Functions.xmlEscape(Functions.printThrowable(e)) + &quot;&lt;/pre&gt;&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        public String[] getStatuses() {
<b class="nc">&nbsp;            synchronized (statuses) {</b>
<b class="nc">&nbsp;                return statuses.toArray(new String[0]);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Enables a required plugin, provides feedback in the update center
&nbsp;     */
&nbsp;    public class EnableJob extends InstallationJob {
<b class="nc">&nbsp;        public EnableJob(UpdateSite site, Authentication auth, @NonNull Plugin plugin, boolean dynamicLoad) {</b>
<b class="nc">&nbsp;            super(plugin, site, auth, dynamicLoad);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Plugin getPlugin() {
<b class="nc">&nbsp;            return plugin;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                PluginWrapper installed = plugin.getInstalled();</b>
<b class="nc">&nbsp;                synchronized (installed) {</b>
<b class="nc">&nbsp;                    if (!installed.isEnabled()) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            installed.enable();</b>
<b class="nc">&nbsp;                        } catch (IOException e) {</b>
<b class="nc">&nbsp;                            LOGGER.log(Level.SEVERE, &quot;Failed to enable &quot; + plugin.getDisplayName(), e);</b>
<b class="nc">&nbsp;                            error = e;</b>
<b class="nc">&nbsp;                            status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
<b class="nc">&nbsp;                        if (dynamicLoad) {</b>
&nbsp;                            try {
&nbsp;                                // remove the existing, disabled inactive plugin to force a new one to load
<b class="nc">&nbsp;                                pm.dynamicLoad(getDestination(), true, null);</b>
<b class="nc">&nbsp;                            } catch (Exception e) {</b>
<b class="nc">&nbsp;                                LOGGER.log(Level.SEVERE, &quot;Failed to dynamically load &quot; + plugin.getDisplayName(), e);</b>
<b class="nc">&nbsp;                                error = e;</b>
<b class="nc">&nbsp;                                requiresRestart = true;</b>
<b class="nc">&nbsp;                                status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            requiresRestart = true;</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;An unexpected error occurred while attempting to enable &quot; + plugin.getDisplayName(), e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;                requiresRestart = true;</b>
<b class="nc">&nbsp;                status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (status instanceof DownloadJob.Pending) {</b>
<b class="nc">&nbsp;                status = new DownloadJob.Success();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A no-op, e.g. this plugin is already installed
&nbsp;     */
&nbsp;    public class NoOpJob extends EnableJob {
<b class="nc">&nbsp;        public NoOpJob(UpdateSite site, Authentication auth, @NonNull Plugin plugin) {</b>
<b class="nc">&nbsp;            super(site, auth, plugin, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            // do nothing
<b class="nc">&nbsp;            status = new DownloadJob.Success();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    /*package*/ interface WithComputedChecksums {
&nbsp;        String getComputedSHA1();
&nbsp;
&nbsp;        String getComputedSHA256();
&nbsp;
&nbsp;        String getComputedSHA512();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Base class for a job that downloads a file from the Jenkins project.
&nbsp;     */
&nbsp;    public abstract class DownloadJob extends UpdateCenterJob implements WithComputedChecksums {
&nbsp;        /**
&nbsp;         * Immutable object representing the current state of this job.
&nbsp;         */
<b class="nc">&nbsp;        @Exported(inline = true)</b>
&nbsp;        public volatile InstallationStatus status = new DownloadJob.Pending();
&nbsp;
&nbsp;        /**
&nbsp;         * Where to download the file from.
&nbsp;         */
&nbsp;        protected abstract URL getURL() throws MalformedURLException;
&nbsp;
&nbsp;        /**
&nbsp;         * Where to download the file to.
&nbsp;         */
&nbsp;        protected abstract File getDestination();
&nbsp;
&nbsp;        /**
&nbsp;         * Code name used for logging.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public abstract String getName();
&nbsp;
&nbsp;        /**
&nbsp;         * Display name used for the GUI.
&nbsp;         * @since 2.189
&nbsp;         */
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called when the whole thing went successfully.
&nbsp;         */
&nbsp;        protected abstract void onSuccess();
&nbsp;
&nbsp;        /**
&nbsp;         * During download, an attempt is made to compute the SHA-1 checksum of the file.
&nbsp;         * This is the base64 encoded SHA-1 checksum.
&nbsp;         *
&nbsp;         * @since 1.641
&nbsp;         */
&nbsp;        @Override
&nbsp;        @CheckForNull
&nbsp;        public String getComputedSHA1() {
<b class="nc">&nbsp;            return computedSHA1;</b>
&nbsp;        }
&nbsp;
&nbsp;        private String computedSHA1;
&nbsp;
&nbsp;        /**
&nbsp;         * Base64 encoded SHA-256 checksum of the downloaded file, if it could be computed.
&nbsp;         *
&nbsp;         * @since 2.130
&nbsp;         */
&nbsp;        @Override
&nbsp;        @CheckForNull
&nbsp;        public String getComputedSHA256() {
<b class="nc">&nbsp;            return computedSHA256;</b>
&nbsp;        }
&nbsp;
&nbsp;        private String computedSHA256;
&nbsp;
&nbsp;        /**
&nbsp;         * Base64 encoded SHA-512 checksum of the downloaded file, if it could be computed.
&nbsp;         *
&nbsp;         * @since 2.130
&nbsp;         */
&nbsp;        @Override
&nbsp;        @CheckForNull
&nbsp;        public String getComputedSHA512() {
<b class="nc">&nbsp;            return computedSHA512;</b>
&nbsp;        }
&nbsp;
&nbsp;        private String computedSHA512;
&nbsp;
&nbsp;        private Authentication authentication;
&nbsp;
&nbsp;        /**
&nbsp;         * Get the user that initiated this job
&nbsp;         */
&nbsp;        public Authentication getUser() {
<b class="nc">&nbsp;            return this.authentication;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        protected DownloadJob(UpdateSite site, Authentication authentication) {</b>
<b class="nc">&nbsp;            super(site);</b>
<b class="nc">&nbsp;            this.authentication = authentication;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                LOGGER.info(&quot;Starting the installation of &quot; + getName() + &quot; on behalf of &quot; + getUser().getName());</b>
&nbsp;
<b class="nc">&nbsp;                _run();</b>
&nbsp;
<b class="nc">&nbsp;                LOGGER.info(&quot;Installation successful: &quot; + getName());</b>
<b class="nc">&nbsp;                status = new DownloadJob.Success();</b>
<b class="nc">&nbsp;                onSuccess();</b>
<b class="nc">&nbsp;            } catch (InstallationStatus e) {</b>
<b class="nc">&nbsp;                status = e;</b>
<b class="nc">&nbsp;                if (status.isSuccess()) onSuccess();</b>
<b class="nc">&nbsp;                requiresRestart |= status.requiresRestart();</b>
<b class="nc">&nbsp;            } catch (MissingDependencyException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to install {0}: {1}&quot;, new Object[] { getName(), e.getMessage() });</b>
<b class="nc">&nbsp;                status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to install &quot; + getName(), e);</b>
<b class="nc">&nbsp;                status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        protected void _run() throws IOException, InstallationStatus {
<b class="nc">&nbsp;            URL src = getURL();</b>
&nbsp;
<b class="nc">&nbsp;            config.preValidate(this, src);</b>
&nbsp;
<b class="nc">&nbsp;            File dst = getDestination();</b>
<b class="nc">&nbsp;            File tmp = config.download(this, src);</b>
&nbsp;
<b class="nc">&nbsp;            config.postValidate(this, tmp);</b>
<b class="nc">&nbsp;            config.install(this, tmp, dst);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called when the download is completed to overwrite
&nbsp;         * the old file with the new file.
&nbsp;         */
&nbsp;        protected synchronized void replace(File dst, File src) throws IOException {
<b class="nc">&nbsp;            File bak = Util.changeExtension(dst, &quot;.bak&quot;);</b>
<b class="nc">&nbsp;            moveAtomically(dst, bak);</b>
<b class="nc">&nbsp;            moveAtomically(src, dst);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicate the expected size of the download as provided in update site
&nbsp;         * metadata.
&nbsp;         *
&nbsp;         * @return the expected size, or -1 if unknown.
&nbsp;         * @since 2.325
&nbsp;         */
&nbsp;        public long getContentLength() {
<b class="nc">&nbsp;            return -1;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates the status or the result of a plugin installation.
&nbsp;         * &lt;p&gt;
&nbsp;         * Instances of this class is immutable.
&nbsp;         */
&nbsp;        @ExportedBean
<b class="nc">&nbsp;        public abstract class InstallationStatus extends Throwable {</b>
<b class="nc">&nbsp;            public final int id = iota.incrementAndGet();</b>
&nbsp;
&nbsp;            @Exported
&nbsp;            public boolean isSuccess() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Exported
&nbsp;            public final String getType() {
<b class="nc">&nbsp;                return getClass().getSimpleName();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a restart is needed to complete the tasks.
&nbsp;             */
&nbsp;            public boolean requiresRestart() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the installation of a plugin failed.
&nbsp;         */
&nbsp;        public class Failure extends InstallationStatus {
&nbsp;            public final Throwable problem;
&nbsp;
<b class="nc">&nbsp;            public Failure(Throwable problem) {</b>
<b class="nc">&nbsp;                this.problem = problem;</b>
&nbsp;            }
&nbsp;
&nbsp;            public String getProblemStackTrace() {
<b class="nc">&nbsp;                return Functions.printThrowable(problem);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the installation was successful but a restart is needed.
&nbsp;         */
&nbsp;        public class SuccessButRequiresRestart extends Success {
&nbsp;            private final Localizable message;
&nbsp;
<b class="nc">&nbsp;            public SuccessButRequiresRestart(Localizable message) {</b>
<b class="nc">&nbsp;                this.message = message;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String getMessage() {
<b class="nc">&nbsp;                return message.toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean requiresRestart() {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the plugin was successfully installed.
&nbsp;         */
<b class="nc">&nbsp;        public class Success extends InstallationStatus {</b>
&nbsp;            @Override public boolean isSuccess() {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the plugin was successfully installed.
&nbsp;         */
<b class="nc">&nbsp;        public class Skipped extends InstallationStatus {</b>
&nbsp;            @Override public boolean isSuccess() {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the plugin is waiting for its turn for installation.
&nbsp;         */
<b class="nc">&nbsp;        public class Pending extends InstallationStatus {</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Installation of a plugin is in progress.
&nbsp;         */
&nbsp;        public class Installing extends InstallationStatus {
&nbsp;            /**
&nbsp;             * % completed download, or -1 if the percentage is not known.
&nbsp;             */
&nbsp;            public final int percentage;
&nbsp;
<b class="nc">&nbsp;            public Installing(int percentage) {</b>
<b class="nc">&nbsp;                this.percentage = percentage;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compare the provided values and return the appropriate {@link VerificationResult}.
&nbsp;     *
&nbsp;     */
&nbsp;    private static VerificationResult verifyChecksums(String expectedDigest, String actualDigest, boolean caseSensitive) {
<b class="fc">&nbsp;        if (expectedDigest == null) {</b>
<b class="fc">&nbsp;            return VerificationResult.NOT_PROVIDED;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (actualDigest == null) {</b>
<b class="fc">&nbsp;            return VerificationResult.NOT_COMPUTED;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (caseSensitive) {</b>
<b class="fc">&nbsp;            if (MessageDigest.isEqual(expectedDigest.getBytes(StandardCharsets.US_ASCII), actualDigest.getBytes(StandardCharsets.US_ASCII))) {</b>
<b class="fc">&nbsp;                return VerificationResult.PASS;</b>
&nbsp;            }
&nbsp;        } else {
<b class="fc">&nbsp;            if (MessageDigest.isEqual(expectedDigest.toLowerCase().getBytes(StandardCharsets.US_ASCII), actualDigest.toLowerCase().getBytes(StandardCharsets.US_ASCII))) {</b>
<b class="fc">&nbsp;                return VerificationResult.PASS;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return VerificationResult.FAIL;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private enum VerificationResult {</b>
<b class="fc">&nbsp;        PASS,</b>
<b class="fc">&nbsp;        NOT_PROVIDED,</b>
<b class="fc">&nbsp;        NOT_COMPUTED,</b>
<b class="fc">&nbsp;        FAIL</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Throws an {@code IOException} with a message about {@code actual} not matching {@code expected} for {@code file} when using {@code algorithm}.
&nbsp;     */
&nbsp;    private static void throwVerificationFailure(String expected, String actual, File file, String algorithm) throws IOException {
<b class="fc">&nbsp;        throw new IOException(&quot;Downloaded file &quot; + file.getAbsolutePath() + &quot; does not match expected &quot; + algorithm + &quot;, expected &#39;&quot; + expected + &quot;&#39;, actual &#39;&quot; + actual + &quot;&#39;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the checksum verification logic with fallback to weaker algorithm for {@link DownloadJob}.
&nbsp;     * @param job The job downloading the file to check
&nbsp;     * @param entry The metadata entry for the file to check
&nbsp;     * @param file The downloaded file
&nbsp;     * @throws IOException thrown when one of the checks failed, or no checksum could be computed.
&nbsp;     */
&nbsp;    @VisibleForTesting
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    /* package */ static void verifyChecksums(WithComputedChecksums job, UpdateSite.Entry entry, File file) throws IOException {
<b class="fc">&nbsp;        VerificationResult result512 = verifyChecksums(entry.getSha512(), job.getComputedSHA512(), false);</b>
<b class="fc">&nbsp;        switch (result512) {</b>
&nbsp;            case PASS:
&nbsp;                // this has passed so no reason to check the weaker checksums
&nbsp;                return;
&nbsp;            case FAIL:
<b class="nc">&nbsp;                throwVerificationFailure(entry.getSha512(), job.getComputedSHA512(), file, &quot;SHA-512&quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case NOT_COMPUTED:
<b class="fc">&nbsp;                LOGGER.log(WARNING, &quot;Attempt to verify a downloaded file (&quot; + file.getName() + &quot;) using SHA-512 failed since it could not be computed. Falling back to weaker algorithms. Update your JRE.&quot;);</b>
<b class="fc">&nbsp;                break;</b>
&nbsp;            case NOT_PROVIDED:
<b class="fc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected value: &quot; + result512);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        VerificationResult result256 = verifyChecksums(entry.getSha256(), job.getComputedSHA256(), false);</b>
<b class="fc">&nbsp;        switch (result256) {</b>
&nbsp;            case PASS:
&nbsp;                return;
&nbsp;            case FAIL:
<b class="nc">&nbsp;                throwVerificationFailure(entry.getSha256(), job.getComputedSHA256(), file, &quot;SHA-256&quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case NOT_COMPUTED:
&nbsp;            case NOT_PROVIDED:
<b class="fc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected value: &quot; + result256);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (result512 == VerificationResult.NOT_PROVIDED &amp;&amp; result256 == VerificationResult.NOT_PROVIDED) {</b>
<b class="fc">&nbsp;            LOGGER.log(INFO, &quot;Attempt to verify a downloaded file (&quot; + file.getName() + &quot;) using SHA-512 or SHA-256 failed since your configured update site does not provide either of those checksums. Falling back to SHA-1.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        VerificationResult result1 = verifyChecksums(entry.getSha1(), job.getComputedSHA1(), true);</b>
<b class="fc">&nbsp;        switch (result1) {</b>
&nbsp;            case PASS:
&nbsp;                return;
&nbsp;            case FAIL:
<b class="fc">&nbsp;                throwVerificationFailure(entry.getSha1(), job.getComputedSHA1(), file, &quot;SHA-1&quot;);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case NOT_COMPUTED:
<b class="nc">&nbsp;                throw new IOException(&quot;Failed to compute SHA-1 of downloaded file, refusing installation&quot;);</b>
&nbsp;            case NOT_PROVIDED:
<b class="fc">&nbsp;                throw new IOException(&quot;Unable to confirm integrity of downloaded file, refusing installation&quot;);</b>
&nbsp;            default:
<b class="nc">&nbsp;                throw new AssertionError(&quot;Unknown verification result: &quot; + result1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the state of the installation activity of one plugin.
&nbsp;     */
&nbsp;    public class InstallationJob extends DownloadJob {
&nbsp;        /**
&nbsp;         * What plugin are we trying to install?
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final Plugin plugin;
&nbsp;
<b class="nc">&nbsp;        protected final PluginManager pm = Jenkins.get().getPluginManager();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * True to load the plugin into this Jenkins, false to wait until restart.
&nbsp;         */
&nbsp;        protected final boolean dynamicLoad;
&nbsp;
&nbsp;        @CheckForNull List&lt;PluginWrapper&gt; batch;
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated as of 1.442
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public InstallationJob(Plugin plugin, UpdateSite site, Authentication auth) {
<b class="nc">&nbsp;            this(plugin, site, auth, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #InstallationJob(UpdateSite.Plugin, UpdateSite, Authentication, boolean)}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public InstallationJob(Plugin plugin, UpdateSite site, org.acegisecurity.Authentication auth, boolean dynamicLoad) {
<b class="nc">&nbsp;            this(plugin, site, auth.toSpring(), dynamicLoad);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public InstallationJob(Plugin plugin, UpdateSite site, Authentication auth, boolean dynamicLoad) {</b>
<b class="nc">&nbsp;            super(site, auth);</b>
<b class="nc">&nbsp;            this.plugin = plugin;</b>
<b class="nc">&nbsp;            this.dynamicLoad = dynamicLoad;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected URL getURL() throws MalformedURLException {
<b class="nc">&nbsp;            return new URL(plugin.url);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected File getDestination() {
<b class="nc">&nbsp;            File baseDir = pm.rootDir;</b>
<b class="nc">&nbsp;            return new File(baseDir, plugin.name + &quot;.jpi&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        private File getLegacyDestination() {
<b class="nc">&nbsp;            File baseDir = pm.rootDir;</b>
<b class="nc">&nbsp;            return new File(baseDir, plugin.name + &quot;.hpi&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return plugin.name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return plugin.getDisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public long getContentLength() {
<b class="nc">&nbsp;            final Long size = plugin.getFileSize();</b>
<b class="nc">&nbsp;            return size == null ? -1 : size;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void _run() throws IOException, InstallationStatus {
<b class="nc">&nbsp;            if (wasInstalled()) {</b>
&nbsp;                // Do this first so we can avoid duplicate downloads, too
&nbsp;                // check to see if the plugin is already installed at the same version and skip it
<b class="nc">&nbsp;                LOGGER.info(&quot;Skipping duplicate install of: &quot; + plugin.getDisplayName() + &quot;@&quot; + plugin.version);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                super._run();</b>
&nbsp;
&nbsp;                // if this is a bundled plugin, make sure it won&#39;t get overwritten
<b class="nc">&nbsp;                PluginWrapper pw = plugin.getInstalled();</b>
<b class="nc">&nbsp;                if (pw != null &amp;&amp; pw.isBundled()) {</b>
<b class="nc">&nbsp;                    try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                        pw.doPin();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (dynamicLoad) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        pm.dynamicLoad(getDestination(), false, batch);</b>
<b class="nc">&nbsp;                    } catch (RestartRequiredException e) {</b>
<b class="nc">&nbsp;                        throw new DownloadJob.SuccessButRequiresRestart(e.message);</b>
<b class="nc">&nbsp;                    } catch (Exception e) {</b>
<b class="nc">&nbsp;                        throw new IOException(&quot;Failed to dynamically deploy this plugin&quot;, e);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new DownloadJob.SuccessButRequiresRestart(Messages._UpdateCenter_DownloadButNotActivated());</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                synchronized (this) {</b>
&nbsp;                    // There may be other threads waiting on completion
<b class="nc">&nbsp;                    LOGGER.fine(&quot;Install complete for: &quot; + plugin.getDisplayName() + &quot;@&quot; + plugin.version);</b>
&nbsp;                    // some status other than Installing or Downloading needs to be set here
&nbsp;                    // {@link #isAlreadyInstalling()}, it will be overwritten by {@link DownloadJob#run()}
<b class="nc">&nbsp;                    status = new DownloadJob.Skipped();</b>
<b class="nc">&nbsp;                    notifyAll();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates there is another installation job for this plugin
&nbsp;         * @since 2.1
&nbsp;         */
&nbsp;        protected boolean wasInstalled() {
<b class="nc">&nbsp;            synchronized (UpdateCenter.this) {</b>
<b class="nc">&nbsp;                for (UpdateCenterJob job : getJobs()) {</b>
<b class="nc">&nbsp;                    if (job == this) {</b>
&nbsp;                        // oldest entries first, if we reach this instance,
&nbsp;                        // we need it to continue installing
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (job instanceof InstallationJob) {</b>
<b class="nc">&nbsp;                        InstallationJob ij = (InstallationJob) job;</b>
<b class="nc">&nbsp;                        if (ij.plugin.equals(plugin) &amp;&amp; ij.plugin.version.equals(plugin.version)) {</b>
&nbsp;                            // wait until other install is completed
<b class="nc">&nbsp;                            synchronized (ij) {</b>
<b class="nc">&nbsp;                                if (ij.status instanceof DownloadJob.Installing || ij.status instanceof DownloadJob.Pending) {</b>
&nbsp;                                    try {
<b class="nc">&nbsp;                                        LOGGER.fine(&quot;Waiting for other plugin install of: &quot; + plugin.getDisplayName() + &quot;@&quot; + plugin.version);</b>
<b class="nc">&nbsp;                                        ij.wait();</b>
<b class="nc">&nbsp;                                    } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                                        throw new RuntimeException(e);</b>
<b class="nc">&nbsp;                                    }</b>
&nbsp;                                }
&nbsp;                                // Must check for success, otherwise may have failed installation
<b class="nc">&nbsp;                                if (ij.status instanceof DownloadJob.Success) {</b>
<b class="nc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onSuccess() {
<b class="nc">&nbsp;            pm.pluginUploaded = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return super.toString() + &quot;[plugin=&quot; + plugin.title + &quot;]&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called when the download is completed to overwrite
&nbsp;         * the old file with the new file.
&nbsp;         */
&nbsp;        @Override
&nbsp;        protected void replace(File dst, File src) throws IOException {
<b class="nc">&nbsp;            if (site == null || !site.getId().equals(ID_UPLOAD)) {</b>
<b class="nc">&nbsp;                verifyChecksums(this, plugin, src);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            synchronized (this) {</b>
<b class="nc">&nbsp;                File bak = Util.changeExtension(dst, &quot;.bak&quot;);</b>
&nbsp;
<b class="nc">&nbsp;                final File legacy = getLegacyDestination();</b>
<b class="nc">&nbsp;                if (Files.exists(Util.fileToPath(legacy))) {</b>
<b class="nc">&nbsp;                    moveAtomically(legacy, bak);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (Files.exists(Util.fileToPath(dst))) {</b>
<b class="nc">&nbsp;                    moveAtomically(dst, bak);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                moveAtomically(src, dst);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        void setBatch(List&lt;PluginWrapper&gt; batch) {
<b class="nc">&nbsp;            this.batch = batch;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public final class CompleteBatchJob extends UpdateCenterJob {
&nbsp;
&nbsp;        private final List&lt;PluginWrapper&gt; batch;
&nbsp;        private final long start;
<b class="nc">&nbsp;        @Exported(inline = true)</b>
&nbsp;        @SuppressFBWarnings(value = &quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, justification = &quot;read by Stapler&quot;)
&nbsp;        public volatile CompleteBatchJobStatus status = new CompleteBatchJob.Pending();
&nbsp;
<b class="nc">&nbsp;        public CompleteBatchJob(List&lt;PluginWrapper&gt; batch, long start, UUID correlationId) {</b>
<b class="nc">&nbsp;            super(getCoreSource());</b>
<b class="nc">&nbsp;            this.batch = batch;</b>
<b class="nc">&nbsp;            this.start = start;</b>
<b class="nc">&nbsp;            setCorrelationId(correlationId);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
<b class="nc">&nbsp;            LOGGER.info(&quot;Completing installing of plugin batch&quot;);</b>
<b class="nc">&nbsp;            status = new CompleteBatchJob.Running();</b>
&nbsp;            try {
<b class="nc">&nbsp;                Jenkins.get().getPluginManager().start(batch);</b>
<b class="nc">&nbsp;                status = new CompleteBatchJob.Success();</b>
<b class="nc">&nbsp;            } catch (Exception x) {</b>
<b class="nc">&nbsp;                status = new CompleteBatchJob.Failure(x);</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to start some plugins&quot;, x);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            LOGGER.log(INFO, &quot;Completed installation of {0} plugins in {1}&quot;, new Object[] {batch.size(), Util.getTimeSpanString((System.nanoTime() - start) / 1_000_000)});</b>
&nbsp;        }
&nbsp;
&nbsp;        @ExportedBean
<b class="nc">&nbsp;        public abstract class CompleteBatchJobStatus {</b>
<b class="nc">&nbsp;            @Exported</b>
<b class="nc">&nbsp;            public final int id = iota.incrementAndGet();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public class Pending extends CompleteBatchJobStatus {}</b>
&nbsp;
<b class="nc">&nbsp;        public class Running extends CompleteBatchJobStatus {}</b>
&nbsp;
<b class="nc">&nbsp;        public class Success extends CompleteBatchJobStatus {}</b>
&nbsp;
&nbsp;        public class Failure extends CompleteBatchJobStatus {
<b class="nc">&nbsp;            Failure(Throwable problemStackTrace) {</b>
<b class="nc">&nbsp;                this.problemStackTrace = problemStackTrace;</b>
&nbsp;            }
&nbsp;
&nbsp;            public final Throwable problemStackTrace;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the state of the downgrading activity of plugin.
&nbsp;     */
&nbsp;    public final class PluginDowngradeJob extends DownloadJob {
&nbsp;        /**
&nbsp;         * What plugin are we trying to install?
&nbsp;         */
&nbsp;        public final Plugin plugin;
&nbsp;
<b class="nc">&nbsp;        private final PluginManager pm = Jenkins.get().getPluginManager();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #PluginDowngradeJob(UpdateSite.Plugin, UpdateSite, Authentication)}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public PluginDowngradeJob(Plugin plugin, UpdateSite site, org.acegisecurity.Authentication auth) {
<b class="nc">&nbsp;            this(plugin, site, auth.toSpring());</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        public PluginDowngradeJob(Plugin plugin, UpdateSite site, Authentication auth) {</b>
<b class="nc">&nbsp;            super(site, auth);</b>
<b class="nc">&nbsp;            this.plugin = plugin;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected URL getURL() throws MalformedURLException {
<b class="nc">&nbsp;            return new URL(plugin.url);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected File getDestination() {
<b class="nc">&nbsp;            File baseDir = pm.rootDir;</b>
<b class="nc">&nbsp;            final File legacy = new File(baseDir, plugin.name + &quot;.hpi&quot;);</b>
<b class="nc">&nbsp;            if (legacy.exists()) {</b>
<b class="nc">&nbsp;                return legacy;</b>
&nbsp;            }
<b class="nc">&nbsp;            return new File(baseDir, plugin.name + &quot;.jpi&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        protected File getBackup() {
<b class="nc">&nbsp;            File baseDir = pm.rootDir;</b>
<b class="nc">&nbsp;            return new File(baseDir, plugin.name + &quot;.bak&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return plugin.name;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return plugin.getDisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                LOGGER.info(&quot;Starting the downgrade of &quot; + getName() + &quot; on behalf of &quot; + getUser().getName());</b>
&nbsp;
<b class="nc">&nbsp;                _run();</b>
&nbsp;
<b class="nc">&nbsp;                LOGGER.info(&quot;Downgrade successful: &quot; + getName());</b>
<b class="nc">&nbsp;                status = new Success();</b>
<b class="nc">&nbsp;                onSuccess();</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to downgrade &quot; + getName(), e);</b>
<b class="nc">&nbsp;                status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void _run() throws IOException {
<b class="nc">&nbsp;            File dst = getDestination();</b>
<b class="nc">&nbsp;            File backup = getBackup();</b>
&nbsp;
<b class="nc">&nbsp;            config.install(this, backup, dst);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called to overwrite
&nbsp;         * current version with backup file
&nbsp;         */
&nbsp;        @Override
&nbsp;        protected synchronized void replace(File dst, File backup) throws IOException {
<b class="nc">&nbsp;            moveAtomically(backup, dst);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onSuccess() {
<b class="nc">&nbsp;            pm.pluginUploaded = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return super.toString() + &quot;[plugin=&quot; + plugin.title + &quot;]&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the state of the upgrade activity of Jenkins core.
&nbsp;     */
&nbsp;    public final class HudsonUpgradeJob extends DownloadJob {
&nbsp;
&nbsp;        /**
&nbsp;          * @deprecated use {@link #HudsonUpgradeJob(UpdateSite, Authentication)}
&nbsp;         */
&nbsp;        @Deprecated
<b class="nc">&nbsp;        public HudsonUpgradeJob(UpdateSite site, org.acegisecurity.Authentication auth) {</b>
<b class="nc">&nbsp;            super(site, auth.toSpring());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public HudsonUpgradeJob(UpdateSite site, Authentication auth) {</b>
<b class="nc">&nbsp;            super(site, auth);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected URL getURL() throws MalformedURLException {
<b class="nc">&nbsp;            if (site == null) {</b>
<b class="nc">&nbsp;                throw new MalformedURLException(&quot;no update site defined&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new URL(site.getData().core.url);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected File getDestination() {
<b class="nc">&nbsp;            return Lifecycle.get().getHudsonWar();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return &quot;jenkins.war&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onSuccess() {
<b class="nc">&nbsp;            status = new DownloadJob.Success();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void replace(File dst, File src) throws IOException {
<b class="nc">&nbsp;            if (site == null) {</b>
<b class="nc">&nbsp;                throw new IOException(&quot;no update site defined&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            verifyChecksums(this, site.getData().core, src);</b>
<b class="nc">&nbsp;            Lifecycle.get().rewriteHudsonWar(src);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public final class HudsonDowngradeJob extends DownloadJob {
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #HudsonDowngradeJob(UpdateSite, Authentication)}
&nbsp;         */
&nbsp;        @Deprecated
<b class="nc">&nbsp;        public HudsonDowngradeJob(UpdateSite site, org.acegisecurity.Authentication auth) {</b>
<b class="nc">&nbsp;            super(site, auth.toSpring());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public HudsonDowngradeJob(UpdateSite site, Authentication auth) {</b>
<b class="nc">&nbsp;            super(site, auth);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected URL getURL() throws MalformedURLException {
<b class="nc">&nbsp;            if (site == null) {</b>
<b class="nc">&nbsp;                throw new MalformedURLException(&quot;no update site defined&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new URL(site.getData().core.url);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected File getDestination() {
<b class="nc">&nbsp;            return Lifecycle.get().getHudsonWar();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return &quot;jenkins.war&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onSuccess() {
<b class="nc">&nbsp;            status = new DownloadJob.Success();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                LOGGER.info(&quot;Starting the downgrade of &quot; + getName() + &quot; on behalf of &quot; + getUser().getName());</b>
&nbsp;
<b class="nc">&nbsp;                _run();</b>
&nbsp;
<b class="nc">&nbsp;                LOGGER.info(&quot;Downgrading successful: &quot; + getName());</b>
<b class="nc">&nbsp;                status = new DownloadJob.Success();</b>
<b class="nc">&nbsp;                onSuccess();</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Failed to downgrade &quot; + getName(), e);</b>
<b class="nc">&nbsp;                status = new DownloadJob.Failure(e);</b>
<b class="nc">&nbsp;                error = e;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void _run() throws IOException {
&nbsp;
<b class="nc">&nbsp;            File backup = new File(Lifecycle.get().getHudsonWar() + &quot;.bak&quot;);</b>
<b class="nc">&nbsp;            File dst = getDestination();</b>
&nbsp;
<b class="nc">&nbsp;            config.install(this, backup, dst);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void replace(File dst, File src) throws IOException {
<b class="nc">&nbsp;            Lifecycle.get().rewriteHudsonWar(src);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated
&nbsp;    public static final class PluginEntry implements Comparable&lt;PluginEntry&gt; {
&nbsp;        public Plugin plugin;
&nbsp;        public String category;
&nbsp;
<b class="nc">&nbsp;        private PluginEntry(Plugin p, String c) {</b>
<b class="nc">&nbsp;            plugin = p;</b>
<b class="nc">&nbsp;            category = c;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int compareTo(PluginEntry o) {
<b class="nc">&nbsp;            int r = category.compareTo(o.category);</b>
<b class="nc">&nbsp;            if (r == 0) r = plugin.name.compareToIgnoreCase(o.plugin.name);</b>
<b class="nc">&nbsp;            if (r == 0) r = new VersionNumber(plugin.version).compareTo(new VersionNumber(o.plugin.version));</b>
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object o) {
<b class="nc">&nbsp;            if (this == o) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (o == null || getClass() != o.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            PluginEntry that = (PluginEntry) o;</b>
&nbsp;
<b class="nc">&nbsp;            if (!category.equals(that.category)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!plugin.name.equals(that.plugin.name)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            return plugin.version.equals(that.plugin.version);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = category.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + plugin.name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + plugin.version.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initializes the update center.
&nbsp;     *
&nbsp;     * This has to wait until after all plugins load, to let custom UpdateCenterConfiguration take effect first.
&nbsp;     */
&nbsp;    @Initializer(after = PLUGINS_STARTED, fatal = false)
&nbsp;    public static void init(Jenkins h) throws IOException {
<b class="nc">&nbsp;        h.getUpdateCenter().load();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static void updateAllSitesNow() {
<b class="nc">&nbsp;        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSites()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                site.updateDirectlyNow();</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, MessageFormat.format(&quot;Failed to update the update site &#39;&#39;{0}&#39;&#39;. &quot; +</b>
<b class="nc">&nbsp;                        &quot;Plugin upgrades may fail.&quot;, site.getId()), e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static void updateDefaultSite() {
<b class="nc">&nbsp;        final UpdateSite site = Jenkins.get().getUpdateCenter().getSite(UpdateCenter.ID_DEFAULT);</b>
<b class="nc">&nbsp;        if (site == null) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.SEVERE, &quot;Upgrading Jenkins. Cannot retrieve the default Update Site &#39;&#39;{0}&#39;&#39;. &quot;</b>
&nbsp;                    + &quot;Plugin installation may fail.&quot;, UpdateCenter.ID_DEFAULT);
&nbsp;            return;
&nbsp;        }
&nbsp;        try {
&nbsp;            // Need to do the following because the plugin manager will attempt to access
&nbsp;            // $JENKINS_HOME/updates/$ID_DEFAULT.json. Needs to be up to date.
<b class="nc">&nbsp;            site.updateDirectlyNow();</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;Upgrading Jenkins. Failed to update the default Update Site &#39;&quot; + UpdateCenter.ID_DEFAULT +</b>
&nbsp;                    &quot;&#39;. Plugin upgrades may fail.&quot;, e);
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Object getTarget() {
<b class="nc">&nbsp;        if (!SKIP_PERMISSION_CHECK) {</b>
<b class="nc">&nbsp;            Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Escape hatch for StaplerProxy-based access control
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static /* Script Console modifiable */ boolean SKIP_PERMISSION_CHECK = SystemProperties.getBoolean(UpdateCenter.class.getName() + &quot;.skipPermissionCheck&quot;);</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Sequence number generator.
&nbsp;     */
<b class="fc">&nbsp;    private static final AtomicInteger iota = new AtomicInteger();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.333
&nbsp;     *      Use {@link UpdateSite#neverUpdate}
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static boolean neverUpdate = SystemProperties.getBoolean(UpdateCenter.class.getName() + &quot;.never&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    public static final XStream2 XSTREAM = new XStream2();</b>
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        XSTREAM.alias(&quot;site&quot;, UpdateSite.class);</b>
<b class="fc">&nbsp;        XSTREAM.alias(&quot;sites&quot;, PersistedList.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void moveAtomically(File src, File target) throws IOException {
&nbsp;        try {
<b class="nc">&nbsp;            Files.move(Util.fileToPath(src), Util.fileToPath(target), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);</b>
<b class="nc">&nbsp;        } catch (AtomicMoveNotSupportedException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;Atomic move not supported. Falling back to non-atomic move.&quot;, e);</b>
&nbsp;            try {
<b class="nc">&nbsp;                Files.move(Util.fileToPath(src), Util.fileToPath(target), StandardCopyOption.REPLACE_EXISTING);</b>
<b class="nc">&nbsp;            } catch (IOException e2) {</b>
<b class="nc">&nbsp;                e2.addSuppressed(e);</b>
<b class="nc">&nbsp;                throw e2;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
