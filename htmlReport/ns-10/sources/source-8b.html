


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > View</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: View (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">View</td>
<td class="coverageStat">
  <span class="percent">
    6.6%
  </span>
  <span class="absValue">
    (5/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.6%
  </span>
  <span class="absValue">
    (24/317)
  </span>
</td>
</tr>
  <tr>
    <td class="name">View$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">View$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">View$AsynchPeople</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/80)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">View$AsynchPeople$People</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">View$MockitoMock$HWwofGC5</td>
  </tr>
  <tr>
    <td class="name">View$MockitoMock$HWwofGC5$auxiliary$7FYIZODP</td>
  </tr>
  <tr>
    <td class="name">View$MockitoMock$HWwofGC5$auxiliary$G1JLiuXw</td>
  </tr>
  <tr>
    <td class="name">View$People</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/56)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">View$PropertyList</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">View$UserInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    5.6%
  </span>
  <span class="absValue">
    (6/108)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.1%
  </span>
  <span class="absValue">
    (25/487)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi, Tom Huybrechts,
&nbsp; * Yahoo!, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
&nbsp;
&nbsp;import com.thoughtworks.xstream.converters.ConversionException;
&nbsp;import com.thoughtworks.xstream.io.StreamException;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.DescriptorExtensionList;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Indenter;
&nbsp;import hudson.Util;
&nbsp;import hudson.init.InitMilestone;
&nbsp;import hudson.init.Initializer;
&nbsp;import hudson.model.Descriptor.FormException;
&nbsp;import hudson.model.listeners.ItemListener;
&nbsp;import hudson.scm.ChangeLogSet;
&nbsp;import hudson.search.CollectionSearchIndex;
&nbsp;import hudson.search.SearchIndexBuilder;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.security.Permission;
&nbsp;import hudson.security.PermissionGroup;
&nbsp;import hudson.security.PermissionScope;
&nbsp;import hudson.tasks.UserAvatarResolver;
&nbsp;import hudson.util.AlternativeUiTextProvider;
&nbsp;import hudson.util.AlternativeUiTextProvider.Message;
&nbsp;import hudson.util.DescribableList;
&nbsp;import hudson.util.DescriptorList;
&nbsp;import hudson.util.FormApply;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.RunList;
&nbsp;import hudson.util.XStream2;
&nbsp;import hudson.views.ListViewColumn;
&nbsp;import java.io.BufferedInputStream;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.io.StringWriter;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.servlet.http.HttpServletResponse;
&nbsp;import javax.xml.transform.Source;
&nbsp;import javax.xml.transform.TransformerException;
&nbsp;import javax.xml.transform.sax.SAXSource;
&nbsp;import javax.xml.transform.stream.StreamResult;
&nbsp;import javax.xml.transform.stream.StreamSource;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.ModelObjectWithChildren;
&nbsp;import jenkins.model.ModelObjectWithContextMenu;
&nbsp;import jenkins.model.item_category.Categories;
&nbsp;import jenkins.model.item_category.Category;
&nbsp;import jenkins.model.item_category.ItemCategory;
&nbsp;import jenkins.scm.RunWithSCM;
&nbsp;import jenkins.security.stapler.StaplerAccessibleType;
&nbsp;import jenkins.util.ProgressiveRendering;
&nbsp;import jenkins.util.xml.XMLUtils;
&nbsp;import jenkins.widgets.HasWidgets;
&nbsp;import net.sf.json.JSON;
&nbsp;import net.sf.json.JSONArray;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.lang.StringUtils;
&nbsp;import org.jenkins.ui.icon.Icon;
&nbsp;import org.jenkins.ui.icon.IconSet;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.DataBoundSetter;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.WebMethod;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.kohsuke.stapler.verb.POST;
&nbsp;import org.xml.sax.SAXException;
&nbsp;
&nbsp;/**
&nbsp; * Encapsulates the rendering of the list of {@link TopLevelItem}s
&nbsp; * that {@link Jenkins} owns.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This is an extension point in Hudson, allowing different kind of
&nbsp; * rendering to be added as plugins.
&nbsp; *
&nbsp; * &lt;h2&gt;Note for implementers&lt;/h2&gt;
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;
&nbsp; * {@link View} subtypes need the {@code newViewDetail.jelly} page,
&nbsp; * which is included in the &quot;new view&quot; page. This page should have some
&nbsp; * description of what the view is about.
&nbsp; * &lt;/ul&gt;
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see ViewDescriptor
&nbsp; * @see ViewGroup
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public abstract class View extends AbstractModelObject implements AccessControlled, Describable&lt;View&gt;, ExtensionPoint, Saveable, ModelObjectWithChildren, DescriptorByNameOwner, HasWidgets {
&nbsp;
&nbsp;    /**
&nbsp;     * Container of this view. Set right after the construction
&nbsp;     * and never change thereafter.
&nbsp;     */
&nbsp;    protected /*final*/ ViewGroup owner;
&nbsp;
&nbsp;    /**
&nbsp;     * Name of this view.
&nbsp;     */
&nbsp;    protected String name;
&nbsp;
&nbsp;    /**
&nbsp;     * Message displayed in the view page.
&nbsp;     */
&nbsp;    protected String description;
&nbsp;
&nbsp;    /**
&nbsp;     * If true, only show relevant executors
&nbsp;     */
&nbsp;    protected boolean filterExecutors;
&nbsp;
&nbsp;    /**
&nbsp;     * If true, only show relevant queue items
&nbsp;     */
&nbsp;    protected boolean filterQueue;
&nbsp;
&nbsp;    /**
&nbsp;     * List of {@link ViewProperty}s configured for this view.
&nbsp;     * @since 1.406
&nbsp;     */
<b class="fc">&nbsp;    private volatile DescribableList&lt;ViewProperty, ViewPropertyDescriptor&gt; properties = new PropertyList(this);</b>
&nbsp;
<b class="fc">&nbsp;    protected View(String name) {</b>
<b class="fc">&nbsp;        this.name = name;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected View(String name, ViewGroup owner) {</b>
<b class="nc">&nbsp;        this.name = name;</b>
<b class="nc">&nbsp;        this.owner = owner;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the items in this collection in a read-only view.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    @Exported(name = &quot;jobs&quot;)
&nbsp;    public abstract Collection&lt;TopLevelItem&gt; getItems();
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the items recursively contained in this collection in a read-only view.
&nbsp;     * &lt;p&gt;
&nbsp;     * The default implementation recursively adds the items of all contained Views
&nbsp;     * in case this view implements {@link ViewGroup}, which should be enough for most cases.
&nbsp;     *
&nbsp;     * @since 1.520
&nbsp;     */
&nbsp;    public Collection&lt;TopLevelItem&gt; getAllItems() {
&nbsp;
<b class="fc">&nbsp;        if (this instanceof ViewGroup) {</b>
<b class="fc">&nbsp;            final Collection&lt;TopLevelItem&gt; items = new LinkedHashSet&lt;&gt;(getItems());</b>
&nbsp;
<b class="fc">&nbsp;            for (View view : ((ViewGroup) this).getViews()) {</b>
<b class="fc">&nbsp;                items.addAll(view.getAllItems());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return Collections.unmodifiableCollection(items);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return getItems();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link TopLevelItem} of the given name.
&nbsp;     */
&nbsp;    public TopLevelItem getItem(String name) {
<b class="nc">&nbsp;        return getOwner().getItemGroup().getItem(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Alias for {@link #getItem(String)}. This is the one used in the URL binding.
&nbsp;     */
&nbsp;    public final TopLevelItem getJob(String name) {
<b class="nc">&nbsp;        return getItem(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the job is in this collection.
&nbsp;     */
&nbsp;    public abstract boolean contains(TopLevelItem item);
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the name of all this collection.
&nbsp;     *
&nbsp;     * @see #rename(String)
&nbsp;     */
&nbsp;    @Exported(visibility = 2, name = &quot;name&quot;)
&nbsp;    @NonNull
&nbsp;    public String getViewName() {
<b class="nc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Renames this view.
&nbsp;     */
&nbsp;    public void rename(String newName) throws Failure, FormException {
<b class="nc">&nbsp;        if (name.equals(newName))    return; // noop</b>
<b class="nc">&nbsp;        Jenkins.checkGoodName(newName);</b>
<b class="nc">&nbsp;        if (owner.getView(newName) != null)</b>
<b class="nc">&nbsp;            throw new FormException(Messages.Hudson_ViewAlreadyExists(newName), &quot;name&quot;);</b>
<b class="nc">&nbsp;        String oldName = name;</b>
<b class="nc">&nbsp;        name = newName;</b>
<b class="nc">&nbsp;        owner.onViewRenamed(this, oldName, newName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link ViewGroup} that this view belongs to.
&nbsp;     */
&nbsp;    public ViewGroup getOwner() {
<b class="nc">&nbsp;        return owner;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated call {@link ViewGroup#getItemGroup} directly */
&nbsp;    @Deprecated
&nbsp;    public ItemGroup&lt;? extends TopLevelItem&gt; getOwnerItemGroup() {
<b class="nc">&nbsp;        return owner.getItemGroup();</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated call {@link ViewGroup#getPrimaryView} directly */
&nbsp;    @Deprecated
&nbsp;    public View getOwnerPrimaryView() {
<b class="nc">&nbsp;        return owner.getPrimaryView();</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated call {@link ViewGroup#getViewActions} directly */
&nbsp;    @Deprecated
&nbsp;    public List&lt;Action&gt; getOwnerViewActions() {
<b class="nc">&nbsp;        return owner.getViewActions();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Message displayed in the top page. Can be null. Includes HTML.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public synchronized String getDescription() {
<b class="nc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;    @DataBoundSetter
&nbsp;    public synchronized void setDescription(String description) {
<b class="nc">&nbsp;        this.description = Util.nullify(description);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the view properties configured for this view.
&nbsp;     * @since 1.406
&nbsp;     */
&nbsp;    public DescribableList&lt;ViewProperty, ViewPropertyDescriptor&gt; getProperties() {
&nbsp;        // readResolve was the best place to do this, but for compatibility reasons,
&nbsp;        // this class can no longer have readResolve() (the mechanism itself isn&#39;t suitable for class hierarchy)
&nbsp;        // see JENKINS-9431
&nbsp;        //
&nbsp;        // until we have that, putting this logic here.
<b class="nc">&nbsp;        synchronized (PropertyList.class) {</b>
<b class="nc">&nbsp;            if (properties == null) {</b>
<b class="nc">&nbsp;                properties = new PropertyList(this);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                properties.setOwner(this);</b>
&nbsp;            }
<b class="nc">&nbsp;            return properties;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all the {@link ViewPropertyDescriptor}s that can be potentially configured
&nbsp;     * on this view. Returns both {@link ViewPropertyDescriptor}s visible and invisible for user, see
&nbsp;     * {@link View#getVisiblePropertyDescriptors} to filter invisible one.
&nbsp;     */
&nbsp;    public List&lt;ViewPropertyDescriptor&gt; getApplicablePropertyDescriptors() {
<b class="nc">&nbsp;        List&lt;ViewPropertyDescriptor&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (ViewPropertyDescriptor pd : ViewProperty.all()) {</b>
<b class="nc">&nbsp;            if (pd.isEnabledFor(this))</b>
<b class="nc">&nbsp;                r.add(pd);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return all the {@link ViewPropertyDescriptor}s that can be potentially configured on this View and are visible
&nbsp;     * for the user. Use {@link DescriptorVisibilityFilter} to make a View property invisible for users.
&nbsp;     * @since 2.214
&nbsp;     */
&nbsp;    public List&lt;ViewPropertyDescriptor&gt; getVisiblePropertyDescriptors() {
<b class="nc">&nbsp;        return DescriptorVisibilityFilter.apply(this, getApplicablePropertyDescriptors());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void save() throws IOException {
&nbsp;        // persistence is a part of the owner
&nbsp;        // due to initialization timing issue, it can be null when this method is called
<b class="nc">&nbsp;        if (owner != null) {</b>
<b class="nc">&nbsp;            owner.save();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * List of all {@link ViewProperty}s exposed primarily for the remoting API.
&nbsp;     * @since 1.406
&nbsp;     */
&nbsp;    @Exported(name = &quot;property&quot;, inline = true)
&nbsp;    public List&lt;ViewProperty&gt; getAllProperties() {
<b class="nc">&nbsp;        return getProperties().toList();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ViewDescriptor getDescriptor() {
<b class="nc">&nbsp;        return (ViewDescriptor) Jenkins.get().getDescriptorOrDie(getClass());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="fc">&nbsp;        return getViewName();</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getNewPronoun() {
<b class="nc">&nbsp;        return AlternativeUiTextProvider.get(NEW_PRONOUN, this, Messages.AbstractItem_Pronoun());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * By default, return true to render the &quot;Edit view&quot; link on the page.
&nbsp;     * This method is really just for the default &quot;All&quot; view to hide the edit link
&nbsp;     * so that the default Hudson top page remains the same as before 1.316.
&nbsp;     *
&nbsp;     * @since 1.316
&nbsp;     */
&nbsp;    public boolean isEditable() {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to enable or disable automatic refreshes of the view.
&nbsp;     *
&nbsp;     * @since 1.557
&nbsp;     *
&nbsp;     * @deprecated Auto-refresh has been removed
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean isAutomaticRefreshEnabled() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If true, only show relevant executors
&nbsp;     */
&nbsp;    public boolean isFilterExecutors() {
<b class="nc">&nbsp;        return filterExecutors;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.426
&nbsp;     */
&nbsp;    @DataBoundSetter
&nbsp;    public void setFilterExecutors(boolean filterExecutors) {
<b class="nc">&nbsp;        this.filterExecutors = filterExecutors;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If true, only show relevant queue items
&nbsp;     */
&nbsp;    public boolean isFilterQueue() {
<b class="nc">&nbsp;        return filterQueue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.426
&nbsp;     */
&nbsp;    @DataBoundSetter
&nbsp;    public void setFilterQueue(boolean filterQueue) {
<b class="nc">&nbsp;        this.filterQueue = filterQueue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this view uses {@code &lt;t:projectView&gt;} for rendering, this method returns columns to be displayed.
&nbsp;     */
&nbsp;    public Iterable&lt;? extends ListViewColumn&gt; getColumns() {
<b class="nc">&nbsp;        return ListViewColumn.createDefaultInitialColumnList(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this view uses {@code t:projectView} for rendering, this method returns the indenter used
&nbsp;     * to indent each row.
&nbsp;     */
&nbsp;    public Indenter getIndenter() {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If true, this is a view that renders the top page of Hudson.
&nbsp;     */
&nbsp;    public boolean isDefault() {
<b class="nc">&nbsp;        return getOwner().getPrimaryView() == this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Computer&gt; getComputers() {
<b class="nc">&nbsp;        Computer[] computers = Jenkins.get().getComputers();</b>
&nbsp;
<b class="nc">&nbsp;        if (!isFilterExecutors()) {</b>
<b class="nc">&nbsp;            return Arrays.asList(computers);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;Computer&gt; result = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        HashSet&lt;Label&gt; labels = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Item item : getItems()) {</b>
<b class="nc">&nbsp;            if (item instanceof AbstractProject&lt;?, ?&gt;) {</b>
<b class="nc">&nbsp;                labels.addAll(((AbstractProject&lt;?, ?&gt;) item).getRelevantLabels());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (Computer c : computers) {</b>
<b class="nc">&nbsp;            if (isRelevant(labels, c)) result.add(c);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isRelevant(Collection&lt;Label&gt; labels, Computer computer) {
<b class="nc">&nbsp;        Node node = computer.getNode();</b>
<b class="nc">&nbsp;        if (node == null) return false;</b>
<b class="nc">&nbsp;        if (labels.contains(null) &amp;&amp; node.getMode() == Node.Mode.NORMAL) return true;</b>
&nbsp;
<b class="nc">&nbsp;        for (Label l : labels)</b>
<b class="nc">&nbsp;            if (l != null &amp;&amp; l.contains(node))</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static final int FILTER_LOOP_MAX_COUNT = 10;
&nbsp;
&nbsp;    private List&lt;Queue.Item&gt; filterQueue(List&lt;Queue.Item&gt; base) {
<b class="nc">&nbsp;        if (!isFilterQueue()) {</b>
<b class="nc">&nbsp;            return base;</b>
&nbsp;        }
<b class="nc">&nbsp;        Collection&lt;TopLevelItem&gt; items = getItems();</b>
<b class="nc">&nbsp;        return base.stream().filter(qi -&gt; filterQueueItemTest(qi, items))</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean filterQueueItemTest(Queue.Item item, Collection&lt;TopLevelItem&gt; viewItems) {
&nbsp;        // Check if the task of parent tasks are in the list of viewItems.
&nbsp;        // Pipeline jobs and other jobs which allow parts require us to
&nbsp;        // check owner tasks as well.
<b class="nc">&nbsp;        Queue.Task currentTask = item.task;</b>
<b class="nc">&nbsp;        for (int count = 1;; count++) {</b>
<b class="nc">&nbsp;            if (viewItems.contains(currentTask)) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            Queue.Task next = currentTask.getOwnerTask();</b>
<b class="nc">&nbsp;            if (next == currentTask) {</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                currentTask = next;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (count == FILTER_LOOP_MAX_COUNT) {</b>
<b class="nc">&nbsp;                LOGGER.warning(String.format(</b>
&nbsp;                        &quot;Failed to find root task for queue item &#39;%s&#39; for &quot; +
&nbsp;                        &quot;view &#39;%s&#39; in under %d iterations, aborting!&quot;,
<b class="nc">&nbsp;                        item.getDisplayName(), getDisplayName(),</b>
<b class="nc">&nbsp;                        FILTER_LOOP_MAX_COUNT));</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
&nbsp;        }
&nbsp;        // Check root project for sub-job projects (e.g. matrix jobs).
<b class="nc">&nbsp;        if (item.task instanceof AbstractProject&lt;?, ?&gt;) {</b>
<b class="nc">&nbsp;            AbstractProject&lt;?, ?&gt; project = (AbstractProject&lt;?, ?&gt;) item.task;</b>
<b class="nc">&nbsp;            return viewItems.contains(project.getRootProject());</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;Queue.Item&gt; getQueueItems() {
<b class="nc">&nbsp;        return filterQueue(Arrays.asList(Jenkins.get().getQueue().getItems()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The items in the queue.
&nbsp;     * @deprecated Use {@link #getQueueItems()}. As of 1.607 the approximation is no longer needed.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public List&lt;Queue.Item&gt; getApproximateQueueItemsQuickly() {
<b class="nc">&nbsp;        return filterQueue(Jenkins.get().getQueue().getApproximateItemsQuickly());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the path relative to the context root.
&nbsp;     *
&nbsp;     * Doesn&#39;t start with &#39;/&#39; but ends with &#39;/&#39; (except returns
&nbsp;     * empty string when this is the default view).
&nbsp;     */
&nbsp;    public String getUrl() {
<b class="nc">&nbsp;        return isDefault() ? (owner != null ? owner.getUrl() : &quot;&quot;) : getViewUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #getUrl()} except this returns a view/{name} path
&nbsp;     * even for the default view.
&nbsp;     */
&nbsp;    public String getViewUrl() {
<b class="nc">&nbsp;        return (owner != null ? owner.getUrl() : &quot;&quot;) + &quot;view/&quot; + Util.rawEncode(getViewName()) + &#39;/&#39;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String toString() {
<b class="nc">&nbsp;        return super.toString() + &quot;[&quot; + getViewUrl() + &quot;]&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSearchUrl() {
<b class="nc">&nbsp;        return getUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the transient {@link Action}s associated with the top page.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * If views don&#39;t want to show top-level actions, this method
&nbsp;     * can be overridden to return different objects.
&nbsp;     *
&nbsp;     * @see Jenkins#getActions()
&nbsp;     */
&nbsp;    public List&lt;Action&gt; getActions() {
<b class="nc">&nbsp;        List&lt;Action&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        result.addAll(getOwner().getViewActions());</b>
<b class="nc">&nbsp;        result.addAll(TransientViewActionFactory.createAllFor(this));</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * No-op. Included to maintain backwards compatibility.
&nbsp;     * @deprecated This method does nothing and should not be used
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    @Deprecated
<b class="nc">&nbsp;    public void updateTransientActions() {}</b>
&nbsp;
&nbsp;    public Object getDynamic(String token) {
<b class="nc">&nbsp;        for (Action a : getActions()) {</b>
<b class="nc">&nbsp;            String url = a.getUrlName();</b>
<b class="nc">&nbsp;            if (url == null)  continue;</b>
<b class="nc">&nbsp;            if (url.equals(token))</b>
<b class="nc">&nbsp;                return a;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the absolute URL of this view.
&nbsp;     */
&nbsp;    @Exported(visibility = 2, name = &quot;url&quot;)
&nbsp;    public String getAbsoluteUrl() {
<b class="nc">&nbsp;        return Jenkins.get().getRootUrl() + getUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the page to redirect the user to, after the view is created.
&nbsp;     *
&nbsp;     * The returned string is appended to &quot;/view/foobar/&quot;, so for example
&nbsp;     * to direct the user to the top page of the view, return &quot;&quot;, etc.
&nbsp;     */
&nbsp;    public String getPostConstructLandingPage() {
<b class="nc">&nbsp;        return &quot;configure&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link ACL} for this object.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public ACL getACL() {
<b class="nc">&nbsp;        return Jenkins.get().getAuthorizationStrategy().getACL(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated Does not work properly with moved jobs. Use {@link ItemListener#onLocationChanged} instead. */
&nbsp;    @Deprecated
<b class="nc">&nbsp;    public void onJobRenamed(Item item, String oldName, String newName) {}</b>
&nbsp;
&nbsp;    @ExportedBean(defaultVisibility = 2)
&nbsp;    public static final class UserInfo implements Comparable&lt;UserInfo&gt; {
&nbsp;        private final User user;
&nbsp;        /**
&nbsp;         * When did this user made a last commit on any of our projects? Can be null.
&nbsp;         */
&nbsp;        private Calendar lastChange;
&nbsp;        /**
&nbsp;         * Which project did this user commit? Can be null.
&nbsp;         */
&nbsp;        private Job&lt;?, ?&gt; project;
&nbsp;
&nbsp;        /** @see UserAvatarResolver */
&nbsp;        String avatar;
&nbsp;
<b class="nc">&nbsp;        UserInfo(User user, Job&lt;?, ?&gt; p, Calendar lastChange) {</b>
<b class="nc">&nbsp;            this.user = user;</b>
<b class="nc">&nbsp;            this.project = p;</b>
<b class="nc">&nbsp;            this.lastChange = lastChange;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public User getUser() {
<b class="nc">&nbsp;            return user;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public Calendar getLastChange() {
<b class="nc">&nbsp;            return lastChange;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Deprecated
&nbsp;        public AbstractProject getProject() {
<b class="nc">&nbsp;            return project instanceof AbstractProject ? (AbstractProject) project : null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported(name = &quot;project&quot;)
&nbsp;        public Job&lt;?, ?&gt; getJob() {
<b class="nc">&nbsp;            return project;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a human-readable string representation of when this user was last active.
&nbsp;         */
&nbsp;        public String getLastChangeTimeString() {
<b class="nc">&nbsp;            if (lastChange == null)    return &quot;N/A&quot;;</b>
<b class="nc">&nbsp;            long duration = new GregorianCalendar().getTimeInMillis() - ordinal();</b>
<b class="nc">&nbsp;            return Util.getTimeSpanString(duration);</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getTimeSortKey() {
<b class="nc">&nbsp;            if (lastChange == null)    return &quot;-&quot;;</b>
<b class="nc">&nbsp;            return Util.XS_DATETIME_FORMATTER.format(lastChange.getTime());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int compareTo(UserInfo that) {
<b class="nc">&nbsp;            long rhs = that.ordinal();</b>
<b class="nc">&nbsp;            long lhs = this.ordinal();</b>
<b class="nc">&nbsp;            return Long.compare(rhs, lhs);</b>
&nbsp;        }
&nbsp;
&nbsp;        private long ordinal() {
<b class="nc">&nbsp;            if (lastChange == null)    return 0;</b>
<b class="nc">&nbsp;            return lastChange.getTimeInMillis();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does this {@link View} has any associated user information recorded?
&nbsp;     * @deprecated Potentially very expensive call; do not use from Jelly views.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean hasPeople() {
<b class="nc">&nbsp;        return People.isApplicable(getItems());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the users that show up in the changelog of this job collection.
&nbsp;     */
&nbsp;    public People getPeople() {
<b class="nc">&nbsp;        return new People(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.484
&nbsp;     */
&nbsp;    public AsynchPeople getAsynchPeople() {
<b class="nc">&nbsp;        return new AsynchPeople(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @ExportedBean
&nbsp;    @StaplerAccessibleType
&nbsp;    public static final class People  {
&nbsp;        @Exported
&nbsp;        public final List&lt;UserInfo&gt; users;
&nbsp;
&nbsp;        public final ModelObject parent;
&nbsp;
<b class="nc">&nbsp;        public People(Jenkins parent) {</b>
<b class="nc">&nbsp;            this.parent = parent;</b>
&nbsp;            // for Hudson, really load all users
<b class="nc">&nbsp;            Map&lt;User, UserInfo&gt; users = getUserInfo(parent.getItems());</b>
<b class="nc">&nbsp;            User unknown = User.getUnknown();</b>
<b class="nc">&nbsp;            for (User u : User.getAll()) {</b>
<b class="nc">&nbsp;                if (u == unknown)  continue;   // skip the special &#39;unknown&#39; user</b>
<b class="nc">&nbsp;                if (!users.containsKey(u))</b>
<b class="nc">&nbsp;                    users.put(u, new UserInfo(u, null, null));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            this.users = toList(users);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public People(View parent) {</b>
<b class="nc">&nbsp;            this.parent = parent;</b>
<b class="nc">&nbsp;            this.users = toList(getUserInfo(parent.getItems()));</b>
&nbsp;        }
&nbsp;
&nbsp;        private Map&lt;User, UserInfo&gt; getUserInfo(Collection&lt;? extends Item&gt; items) {
<b class="nc">&nbsp;            Map&lt;User, UserInfo&gt; users = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Item item : items) {</b>
<b class="nc">&nbsp;                for (Job&lt;?, ?&gt; job : item.getAllJobs()) {</b>
<b class="nc">&nbsp;                    RunList&lt;? extends Run&lt;?, ?&gt;&gt; runs = job.getBuilds();</b>
<b class="nc">&nbsp;                    for (Run&lt;?, ?&gt; r : runs) {</b>
<b class="nc">&nbsp;                        if (r instanceof RunWithSCM) {</b>
<b class="nc">&nbsp;                            RunWithSCM&lt;?, ?&gt; runWithSCM = (RunWithSCM&lt;?, ?&gt;) r;</b>
&nbsp;
<b class="nc">&nbsp;                            for (ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt; c : runWithSCM.getChangeSets()) {</b>
<b class="nc">&nbsp;                                for (ChangeLogSet.Entry entry : c) {</b>
<b class="nc">&nbsp;                                    User user = entry.getAuthor();</b>
&nbsp;
<b class="nc">&nbsp;                                    UserInfo info = users.get(user);</b>
<b class="nc">&nbsp;                                    if (info == null)</b>
<b class="nc">&nbsp;                                        users.put(user, new UserInfo(user, job, r.getTimestamp()));</b>
<b class="nc">&nbsp;                                    else if (info.getLastChange().before(r.getTimestamp())) {</b>
<b class="nc">&nbsp;                                        info.project = job;</b>
<b class="nc">&nbsp;                                        info.lastChange = r.getTimestamp();</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return users;</b>
&nbsp;        }
&nbsp;
&nbsp;        private List&lt;UserInfo&gt; toList(Map&lt;User, UserInfo&gt; users) {
<b class="nc">&nbsp;            ArrayList&lt;UserInfo&gt; list = new ArrayList&lt;&gt;(users.values());</b>
<b class="nc">&nbsp;            Collections.sort(list);</b>
<b class="nc">&nbsp;            return Collections.unmodifiableList(list);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Api getApi() {
<b class="nc">&nbsp;            return new Api(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated Potentially very expensive call; do not use from Jelly views.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public static boolean isApplicable(Collection&lt;? extends Item&gt; items) {
<b class="nc">&nbsp;            for (Item item : items) {</b>
<b class="nc">&nbsp;                for (Job job : item.getAllJobs()) {</b>
<b class="nc">&nbsp;                    RunList&lt;? extends Run&lt;?, ?&gt;&gt; runs = job.getBuilds();</b>
&nbsp;
<b class="nc">&nbsp;                    for (Run&lt;?, ?&gt; r : runs) {</b>
<b class="nc">&nbsp;                        if (r instanceof RunWithSCM) {</b>
<b class="nc">&nbsp;                            RunWithSCM&lt;?, ?&gt; runWithSCM = (RunWithSCM&lt;?, ?&gt;) r;</b>
<b class="nc">&nbsp;                            for (ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt; c : runWithSCM.getChangeSets()) {</b>
<b class="nc">&nbsp;                                for (ChangeLogSet.Entry entry : c) {</b>
<b class="nc">&nbsp;                                    User user = entry.getAuthor();</b>
<b class="nc">&nbsp;                                    if (user != null)</b>
<b class="nc">&nbsp;                                        return true;</b>
<b class="nc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Variant of {@link People} which can be displayed progressively, since it may be slow.
&nbsp;     * @since 1.484
&nbsp;     */
&nbsp;    public static final class AsynchPeople extends ProgressiveRendering { // JENKINS-15206
&nbsp;
&nbsp;        private final Collection&lt;TopLevelItem&gt; items;
&nbsp;        private final User unknown;
<b class="nc">&nbsp;        private final Map&lt;User, UserInfo&gt; users = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        private final Set&lt;User&gt; modified = new HashSet&lt;&gt;();</b>
&nbsp;        private final String iconSize;
&nbsp;        public final ModelObject parent;
&nbsp;
&nbsp;        /** @see Jenkins#getAsynchPeople */
<b class="nc">&nbsp;        public AsynchPeople(Jenkins parent) {</b>
<b class="nc">&nbsp;            this.parent = parent;</b>
<b class="nc">&nbsp;            items = parent.getItems();</b>
<b class="nc">&nbsp;            unknown = User.getUnknown();</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @see View#getAsynchPeople */
<b class="nc">&nbsp;        public AsynchPeople(View parent) {</b>
<b class="nc">&nbsp;            this.parent = parent;</b>
<b class="nc">&nbsp;            items = parent.getItems();</b>
<b class="nc">&nbsp;            unknown = null;</b>
&nbsp;        }
&nbsp;
&nbsp;        {
<b class="nc">&nbsp;            StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="nc">&nbsp;            iconSize = req != null ? Functions.validateIconSize(Functions.getCookie(req, &quot;iconSize&quot;, &quot;32x32&quot;)) : &quot;32x32&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override protected void compute() throws Exception {
<b class="nc">&nbsp;            int itemCount = 0;</b>
<b class="nc">&nbsp;            for (Item item : items) {</b>
<b class="nc">&nbsp;                for (Job&lt;?, ?&gt; job : item.getAllJobs()) {</b>
<b class="nc">&nbsp;                    RunList&lt;? extends Run&lt;?, ?&gt;&gt; builds = job.getBuilds();</b>
<b class="nc">&nbsp;                    int buildCount = 0;</b>
<b class="nc">&nbsp;                    for (Run&lt;?, ?&gt; r : builds) {</b>
<b class="nc">&nbsp;                        if (canceled()) {</b>
&nbsp;                            return;
&nbsp;                        }
<b class="nc">&nbsp;                        if (!(r instanceof RunWithSCM)) {</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        RunWithSCM&lt;?, ?&gt; runWithSCM = (RunWithSCM&lt;?, ?&gt;) r;</b>
<b class="nc">&nbsp;                        for (ChangeLogSet&lt;? extends ChangeLogSet.Entry&gt; c : runWithSCM.getChangeSets()) {</b>
<b class="nc">&nbsp;                            for (ChangeLogSet.Entry entry : c) {</b>
<b class="nc">&nbsp;                                User user = entry.getAuthor();</b>
<b class="nc">&nbsp;                                UserInfo info = users.get(user);</b>
<b class="nc">&nbsp;                                if (info == null) {</b>
<b class="nc">&nbsp;                                    UserInfo userInfo = new UserInfo(user, job, r.getTimestamp());</b>
<b class="nc">&nbsp;                                    userInfo.avatar = UserAvatarResolver.resolveOrNull(user, iconSize);</b>
<b class="nc">&nbsp;                                    synchronized (this) {</b>
<b class="nc">&nbsp;                                        users.put(user, userInfo);</b>
<b class="nc">&nbsp;                                        modified.add(user);</b>
<b class="nc">&nbsp;                                    }</b>
<b class="nc">&nbsp;                                } else if (info.getLastChange().before(r.getTimestamp())) {</b>
<b class="nc">&nbsp;                                    synchronized (this) {</b>
<b class="nc">&nbsp;                                        info.project = job;</b>
<b class="nc">&nbsp;                                        info.lastChange = r.getTimestamp();</b>
<b class="nc">&nbsp;                                        modified.add(user);</b>
<b class="nc">&nbsp;                                    }</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                        // TODO consider also adding the user of the UserCause when applicable
<b class="nc">&nbsp;                        buildCount++;</b>
&nbsp;                        // TODO this defeats lazy-loading. Should rather do a breadth-first search, as in hudson.plugins.view.dashboard.builds.LatestBuilds
&nbsp;                        // (though currently there is no quick implementation of RunMap.size() ~ idOnDisk.size(), which would be needed for proper progress)
<b class="nc">&nbsp;                        progress((itemCount + 1.0 * buildCount / builds.size()) / (items.size() + 1));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                itemCount++;</b>
<b class="nc">&nbsp;                progress(1.0 * itemCount / (items.size() + /* handling User.getAll */1));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (unknown != null) {</b>
<b class="nc">&nbsp;                if (canceled()) {</b>
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                for (User u : User.getAll()) { // TODO nice to have a method to iterate these lazily</b>
<b class="nc">&nbsp;                    if (canceled()) {</b>
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    if (u == unknown) {</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (!users.containsKey(u)) {</b>
<b class="nc">&nbsp;                        UserInfo userInfo = new UserInfo(u, null, null);</b>
<b class="nc">&nbsp;                        userInfo.avatar = UserAvatarResolver.resolveOrNull(u, iconSize);</b>
<b class="nc">&nbsp;                        synchronized (this) {</b>
<b class="nc">&nbsp;                            users.put(u, userInfo);</b>
<b class="nc">&nbsp;                            modified.add(u);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override protected synchronized JSON data() {
<b class="nc">&nbsp;            JSONArray r = new JSONArray();</b>
<b class="nc">&nbsp;            for (User u : modified) {</b>
<b class="nc">&nbsp;                UserInfo i = users.get(u);</b>
<b class="nc">&nbsp;                JSONObject entry = new JSONObject().</b>
<b class="nc">&nbsp;                        accumulate(&quot;id&quot;, u.getId()).</b>
<b class="nc">&nbsp;                        accumulate(&quot;fullName&quot;, u.getFullName()).</b>
<b class="nc">&nbsp;                        accumulate(&quot;url&quot;, u.getUrl() + &quot;/&quot;).</b>
<b class="nc">&nbsp;                        accumulate(&quot;avatar&quot;, i.avatar != null ? i.avatar : Stapler.getCurrentRequest().getContextPath() + Functions.getResourcePath() + &quot;/images/svgs/person.svg&quot;).</b>
<b class="nc">&nbsp;                        accumulate(&quot;timeSortKey&quot;, i.getTimeSortKey()).</b>
<b class="nc">&nbsp;                        accumulate(&quot;lastChangeTimeString&quot;, i.getLastChangeTimeString());</b>
<b class="nc">&nbsp;                Job&lt;?, ?&gt; p = i.getJob();</b>
<b class="nc">&nbsp;                if (p != null) {</b>
<b class="nc">&nbsp;                    entry.accumulate(&quot;projectUrl&quot;, p.getUrl()).accumulate(&quot;projectFullDisplayName&quot;, p.getFullDisplayName());</b>
&nbsp;                }
<b class="nc">&nbsp;                r.add(entry);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            modified.clear();</b>
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;
&nbsp;        public Api getApi() {
<b class="nc">&nbsp;            return new Api(new People());</b>
&nbsp;        }
&nbsp;
&nbsp;        /** JENKINS-16397 workaround */
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        @ExportedBean
<b class="nc">&nbsp;        public final class People {</b>
&nbsp;
&nbsp;            private View.People people;
&nbsp;
&nbsp;            @Exported public synchronized List&lt;UserInfo&gt; getUsers() {
<b class="nc">&nbsp;                if (people == null) {</b>
<b class="nc">&nbsp;                    people = parent instanceof Jenkins ? new View.People((Jenkins) parent) : new View.People((View) parent);</b>
&nbsp;                }
<b class="nc">&nbsp;                return people.users;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    void addDisplayNamesToSearchIndex(SearchIndexBuilder sib, Collection&lt;TopLevelItem&gt; items) {
<b class="fc">&nbsp;        for (TopLevelItem item : items) {</b>
&nbsp;
<b class="fc">&nbsp;            if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                LOGGER.fine(String.format(&quot;Adding url=%s,displayName=%s&quot;,</b>
<b class="nc">&nbsp;                            item.getSearchUrl(), item.getDisplayName()));</b>
&nbsp;            }
<b class="fc">&nbsp;            sib.add(item.getSearchUrl(), item.getDisplayName());</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a simple CollectionSearchIndex object to sib
&nbsp;     *
&nbsp;     * @param sib the SearchIndexBuilder
&nbsp;     * @since 2.200
&nbsp;     */
&nbsp;    protected void makeSearchIndex(SearchIndexBuilder sib) {
<b class="nc">&nbsp;        sib.add(new CollectionSearchIndex&lt;TopLevelItem&gt;() { // for jobs in the view</b>
&nbsp;            @Override
<b class="nc">&nbsp;            protected TopLevelItem get(String key) { return getItem(key); }</b>
&nbsp;
&nbsp;            @Override
<b class="nc">&nbsp;            protected Collection&lt;TopLevelItem&gt; all() { return getItems(); }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected String getName(TopLevelItem o) {
&nbsp;                // return the name instead of the display for suggestion searching
<b class="nc">&nbsp;                return o.getName();</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SearchIndexBuilder makeSearchIndex() {
<b class="nc">&nbsp;        SearchIndexBuilder sib = super.makeSearchIndex();</b>
<b class="nc">&nbsp;        makeSearchIndex(sib);</b>
&nbsp;
&nbsp;        // add the display name for each item in the search index
<b class="nc">&nbsp;        addDisplayNamesToSearchIndex(sib, getItems());</b>
&nbsp;
<b class="nc">&nbsp;        return sib;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts the new description.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized void doSubmitDescription(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
&nbsp;
<b class="nc">&nbsp;        description = req.getParameter(&quot;description&quot;);</b>
<b class="nc">&nbsp;        save();</b>
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;.&quot;);  // go to the top page</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts submission from the configuration page.
&nbsp;     *
&nbsp;     * Subtypes should override the {@link #submit(StaplerRequest)} method.
&nbsp;     */
&nbsp;    @POST
&nbsp;    public final synchronized void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
&nbsp;
<b class="nc">&nbsp;        submit(req);</b>
&nbsp;
<b class="nc">&nbsp;        var json = req.getSubmittedForm();</b>
<b class="nc">&nbsp;        setDescription(json.optString(&quot;description&quot;));</b>
<b class="nc">&nbsp;        setFilterExecutors(json.optBoolean(&quot;filterExecutors&quot;));</b>
<b class="nc">&nbsp;        setFilterQueue(json.optBoolean(&quot;filterQueue&quot;));</b>
<b class="nc">&nbsp;        rename(req.getParameter(&quot;name&quot;));</b>
&nbsp;
<b class="nc">&nbsp;        getProperties().rebuild(req, json, getApplicablePropertyDescriptors());</b>
&nbsp;
<b class="nc">&nbsp;        save();</b>
&nbsp;
<b class="nc">&nbsp;        FormApply.success(&quot;../&quot; + Util.rawEncode(name)).generateResponse(req, rsp, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Handles the configuration submission.
&nbsp;     *
&nbsp;     * Load view-specific properties here.
&nbsp;     */
&nbsp;    protected abstract void submit(StaplerRequest req) throws IOException, ServletException, FormException;
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this view.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        checkPermission(DELETE);</b>
&nbsp;
<b class="nc">&nbsp;        owner.deleteView(this);</b>
&nbsp;
<b class="nc">&nbsp;        rsp.sendRedirect2(req.getContextPath() + &quot;/&quot; + owner.getUrl());</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@link Item} in this collection.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method should call {@link ModifiableItemGroup#doCreateItem(StaplerRequest, StaplerResponse)}
&nbsp;     * and then add the newly created item to this view.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      null if fails.
&nbsp;     */
&nbsp;    public abstract Item doCreateItem(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException;
&nbsp;
&nbsp;    /**
&nbsp;     * Makes sure that the given name is good as a job name.
&nbsp;     * For use from {@code newJob}.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class) // called from newJob view
&nbsp;    public FormValidation doCheckJobName(@QueryParameter String value) {
&nbsp;        // this method can be used to check if a file exists anywhere in the file system,
&nbsp;        // so it should be protected.
<b class="nc">&nbsp;        getOwner().checkPermission(Item.CREATE);</b>
&nbsp;
<b class="nc">&nbsp;        if (Util.fixEmpty(value) == null) {</b>
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            Jenkins.checkGoodName(value);</b>
<b class="nc">&nbsp;            value = value.trim(); // why trim *after* checkGoodName? not sure, but ItemGroupMixIn.createTopLevelItem does the same</b>
<b class="nc">&nbsp;            ItemGroup&lt;?&gt; parent = getOwner().getItemGroup();</b>
<b class="nc">&nbsp;            Jenkins.get().getProjectNamingStrategy().checkName(parent.getFullName(), value);</b>
<b class="nc">&nbsp;        } catch (Failure e) {</b>
<b class="nc">&nbsp;            return FormValidation.error(e.getMessage());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (getOwner().getItemGroup().getItem(value) != null) {</b>
<b class="nc">&nbsp;            return FormValidation.error(Messages.Hudson_JobAlreadyExists(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        // looks good
<b class="nc">&nbsp;        return FormValidation.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An API REST method to get the allowed {$link TopLevelItem}s and its categories.
&nbsp;     *
&nbsp;     * @return A {@link Categories} entity that is shown as JSON file.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public Categories doItemCategories(StaplerRequest req, StaplerResponse rsp, @QueryParameter String iconStyle) throws IOException, ServletException {
<b class="nc">&nbsp;        getOwner().checkPermission(Item.CREATE);</b>
&nbsp;
<b class="nc">&nbsp;        rsp.addHeader(&quot;Cache-Control&quot;, &quot;no-cache, no-store, must-revalidate&quot;);</b>
<b class="nc">&nbsp;        rsp.addHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</b>
<b class="nc">&nbsp;        rsp.addHeader(&quot;Expires&quot;, &quot;0&quot;);</b>
<b class="nc">&nbsp;        Categories categories = new Categories();</b>
<b class="nc">&nbsp;        int order = 0;</b>
&nbsp;        String resUrl;
&nbsp;
<b class="nc">&nbsp;        if (StringUtils.isNotBlank(iconStyle)) {</b>
<b class="nc">&nbsp;            resUrl = req.getContextPath() + Jenkins.RESOURCE_PATH;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            resUrl = null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (TopLevelItemDescriptor descriptor : DescriptorVisibilityFilter.apply(getOwner().getItemGroup(), Items.all2(Jenkins.getAuthentication2(), getOwner().getItemGroup()))) {</b>
<b class="nc">&nbsp;            ItemCategory ic = ItemCategory.getCategory(descriptor);</b>
<b class="nc">&nbsp;            Map&lt;String, Serializable&gt; metadata = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;            // Information about Item.
<b class="nc">&nbsp;            metadata.put(&quot;class&quot;, descriptor.getId());</b>
<b class="nc">&nbsp;            metadata.put(&quot;order&quot;, ++order);</b>
<b class="nc">&nbsp;            metadata.put(&quot;displayName&quot;, descriptor.getDisplayName());</b>
<b class="nc">&nbsp;            metadata.put(&quot;description&quot;, descriptor.getDescription());</b>
<b class="nc">&nbsp;            metadata.put(&quot;iconFilePathPattern&quot;, descriptor.getIconFilePathPattern());</b>
<b class="nc">&nbsp;            String iconClassName = descriptor.getIconClassName();</b>
<b class="nc">&nbsp;            if (StringUtils.isNotBlank(iconClassName)) {</b>
<b class="nc">&nbsp;                metadata.put(&quot;iconClassName&quot;, iconClassName);</b>
<b class="nc">&nbsp;                if (resUrl != null) {</b>
<b class="nc">&nbsp;                    Icon icon = IconSet.icons</b>
<b class="nc">&nbsp;                            .getIconByClassSpec(String.join(&quot; &quot;, iconClassName, iconStyle));</b>
<b class="nc">&nbsp;                    if (icon != null) {</b>
<b class="nc">&nbsp;                        metadata.put(&quot;iconQualifiedUrl&quot;, icon.getQualifiedUrl(resUrl));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Category category = categories.getItem(ic.getId());</b>
<b class="nc">&nbsp;            if (category != null) {</b>
<b class="nc">&nbsp;                category.getItems().add(metadata);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                List&lt;Map&lt;String, Serializable&gt;&gt; temp = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;                temp.add(metadata);</b>
<b class="nc">&nbsp;                category = new Category(ic.getId(), ic.getDisplayName(), ic.getDescription(), ic.getOrder(), ic.getMinToShow(), temp);</b>
<b class="nc">&nbsp;                categories.getItems().add(category);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return categories;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doRssAll(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        RSS.rss(req, rsp, &quot;Jenkins:&quot; + getDisplayName() + &quot; (all builds)&quot;, getUrl(), getBuilds().newBuilds());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doRssFailed(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        RSS.rss(req, rsp, &quot;Jenkins:&quot; + getDisplayName() + &quot; (failed builds)&quot;, getUrl(), getBuilds().failureOnly().newBuilds());</b>
&nbsp;    }
&nbsp;
&nbsp;    public RunList getBuilds() {
<b class="nc">&nbsp;        return new RunList(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Deprecated
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public BuildTimelineWidget getTimeline() {
<b class="nc">&nbsp;        return new BuildTimelineWidget(getBuilds());</b>
&nbsp;    }
&nbsp;
&nbsp;    public void doRssLatest(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        List&lt;Run&gt; lastBuilds = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (TopLevelItem item : getItems()) {</b>
<b class="nc">&nbsp;            if (item instanceof Job) {</b>
<b class="nc">&nbsp;                Job job = (Job) item;</b>
<b class="nc">&nbsp;                Run lb = job.getLastBuild();</b>
<b class="nc">&nbsp;                if (lb != null)    lastBuilds.add(lb);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        RSS.rss(req, rsp, &quot;Jenkins:&quot; + getDisplayName() + &quot; (latest builds)&quot;, getUrl(), RunList.fromRuns(lastBuilds), Run.FEED_ADAPTER_LATEST);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts {@code config.xml} submission, as well as serve it.
&nbsp;     */
&nbsp;    @WebMethod(name = &quot;config.xml&quot;)
&nbsp;    public HttpResponse doConfigDotXml(StaplerRequest req) throws IOException {
<b class="nc">&nbsp;        if (req.getMethod().equals(&quot;GET&quot;)) {</b>
&nbsp;            // read
<b class="nc">&nbsp;            checkPermission(READ);</b>
<b class="nc">&nbsp;            return new HttpResponse() {</b>
&nbsp;                @Override
&nbsp;                public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {
<b class="nc">&nbsp;                    rsp.setContentType(&quot;application/xml&quot;);</b>
<b class="nc">&nbsp;                    View.this.writeXml(rsp.getOutputStream());</b>
&nbsp;                }
&nbsp;            };
&nbsp;        }
<b class="nc">&nbsp;        if (req.getMethod().equals(&quot;POST&quot;)) {</b>
&nbsp;            // submission
<b class="nc">&nbsp;            updateByXml(new StreamSource(req.getReader()));</b>
<b class="nc">&nbsp;            return HttpResponses.ok();</b>
&nbsp;        }
&nbsp;
&nbsp;        // huh?
<b class="nc">&nbsp;        return HttpResponses.error(SC_BAD_REQUEST, &quot;Unexpected request method &quot; + req.getMethod());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.538
&nbsp;     */
&nbsp;    public void writeXml(OutputStream out) throws IOException {
&nbsp;        // pity we don&#39;t have a handy way to clone Jenkins.XSTREAM to temp add the omit Field
<b class="nc">&nbsp;        XStream2 xStream2 = new XStream2();</b>
<b class="nc">&nbsp;        xStream2.omitField(View.class, &quot;owner&quot;);</b>
<b class="nc">&nbsp;        xStream2.toXMLUTF8(View.this,  out);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the View with the new XML definition.
&nbsp;     * @param source source of the Item&#39;s new definition.
&nbsp;     *               The source should be either a {@link StreamSource} or {@link SAXSource}, other sources
&nbsp;     *               may not be handled.
&nbsp;     */
&nbsp;    public void updateByXml(Source source) throws IOException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
<b class="nc">&nbsp;        StringWriter out = new StringWriter();</b>
&nbsp;        try {
&nbsp;            // this allows us to use UTF-8 for storing data,
&nbsp;            // plus it checks any well-formedness issue in the submitted
&nbsp;            // data
<b class="nc">&nbsp;            XMLUtils.safeTransform(source, new StreamResult(out));</b>
<b class="nc">&nbsp;            out.close();</b>
<b class="nc">&nbsp;        } catch (TransformerException | SAXException e) {</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Failed to persist configuration.xml&quot;, e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // try to reflect the changes by reloading
<b class="nc">&nbsp;        try (InputStream in = new BufferedInputStream(new ByteArrayInputStream(out.toString().getBytes(StandardCharsets.UTF_8)))) {</b>
&nbsp;            // Do not allow overwriting view name as it might collide with another
&nbsp;            // view in same ViewGroup and might not satisfy Jenkins.checkGoodName.
<b class="nc">&nbsp;            String oldname = name;</b>
<b class="nc">&nbsp;            ViewGroup oldOwner = owner; // oddly, this field is not transient</b>
<b class="nc">&nbsp;            Object o = Jenkins.XSTREAM2.unmarshal(XStream2.getDefaultDriver().createReader(in), this, null, true);</b>
<b class="nc">&nbsp;            if (!o.getClass().equals(getClass())) {</b>
&nbsp;                // ensure that we&#39;ve got the same view type. extending this code to support updating
&nbsp;                // to different view type requires destroying &amp; creating a new view type
<b class="nc">&nbsp;                throw new IOException(&quot;Expecting view type: &quot; + this.getClass() + &quot; but got: &quot; + o.getClass() + &quot; instead.&quot; +</b>
&nbsp;                    &quot;\nShould you needed to change to a new view type, you must first delete and then re-create &quot; +
&nbsp;                    &quot;the view with the new view type.&quot;);
&nbsp;            }
<b class="nc">&nbsp;            name = oldname;</b>
<b class="nc">&nbsp;            owner = oldOwner;</b>
<b class="nc">&nbsp;        } catch (StreamException | ConversionException | Error e) { // mostly reflection errors</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Unable to read&quot;, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ModelObjectWithContextMenu.ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {
<b class="nc">&nbsp;        ModelObjectWithContextMenu.ContextMenu m = new ModelObjectWithContextMenu.ContextMenu();</b>
<b class="nc">&nbsp;        for (TopLevelItem i : getItems())</b>
<b class="nc">&nbsp;            m.add(Functions.getRelativeLinkTo(i), Functions.getRelativeDisplayNameFrom(i, getOwner().getItemGroup()));</b>
<b class="nc">&nbsp;        return m;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of available view types.
&nbsp;     * @deprecated as of 1.286
&nbsp;     *      Use {@link #all()} for read access, and use {@link Extension} for registration.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static final DescriptorList&lt;View&gt; LIST = new DescriptorList&lt;&gt;(View.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all the registered {@link ViewDescriptor}s.
&nbsp;     */
&nbsp;    public static DescriptorExtensionList&lt;View, ViewDescriptor&gt; all() {
<b class="nc">&nbsp;        return Jenkins.get().getDescriptorList(View.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link ViewDescriptor} instances that can be instantiated for the {@link ViewGroup} in the current
&nbsp;     * {@link StaplerRequest}.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;strong&gt;NOTE: Historically this method is only ever called from a {@link StaplerRequest}&lt;/strong&gt;
&nbsp;     * @return the list of instantiable {@link ViewDescriptor} instances for the current {@link StaplerRequest}
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public static List&lt;ViewDescriptor&gt; allInstantiable() {
<b class="nc">&nbsp;        List&lt;ViewDescriptor&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        StaplerRequest request = Stapler.getCurrentRequest();</b>
<b class="nc">&nbsp;        if (request == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;This method can only be invoked from a stapler request&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        ViewGroup owner = request.findAncestorObject(ViewGroup.class);</b>
<b class="nc">&nbsp;        if (owner == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;This method can only be invoked from a request with a ViewGroup ancestor&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (ViewDescriptor d : DescriptorVisibilityFilter.apply(owner, all())) {</b>
<b class="nc">&nbsp;            if (d.isApplicableIn(owner) &amp;&amp; d.isInstantiable()</b>
<b class="nc">&nbsp;                    &amp;&amp; owner.getACL().hasCreatePermission2(Jenkins.getAuthentication2(), owner, d)) {</b>
<b class="nc">&nbsp;                r.add(d);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static final Comparator&lt;View&gt; SORTER = Comparator.comparing(View::getViewName);</b>
&nbsp;
<b class="fc">&nbsp;    public static final PermissionGroup PERMISSIONS = new PermissionGroup(View.class, Messages._View_Permissions_Title());</b>
&nbsp;    /**
&nbsp;     * Permission to create new views.
&nbsp;     */
<b class="fc">&nbsp;    public static final Permission CREATE = new Permission(PERMISSIONS, &quot;Create&quot;, Messages._View_CreatePermission_Description(), Permission.CREATE, PermissionScope.ITEM_GROUP);</b>
<b class="fc">&nbsp;    public static final Permission DELETE = new Permission(PERMISSIONS, &quot;Delete&quot;, Messages._View_DeletePermission_Description(), Permission.DELETE, PermissionScope.ITEM_GROUP);</b>
<b class="fc">&nbsp;    public static final Permission CONFIGURE = new Permission(PERMISSIONS, &quot;Configure&quot;, Messages._View_ConfigurePermission_Description(), Permission.CONFIGURE, PermissionScope.ITEM_GROUP);</b>
<b class="fc">&nbsp;    public static final Permission READ = new Permission(PERMISSIONS, &quot;Read&quot;, Messages._View_ReadPermission_Description(), Permission.READ, PermissionScope.ITEM_GROUP);</b>
&nbsp;
&nbsp;    @SuppressFBWarnings(value = &quot;RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT&quot;, justification = &quot;to guard against potential future compiler optimizations&quot;)
&nbsp;    @Initializer(before = InitMilestone.SYSTEM_CONFIG_LOADED)
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public static void registerPermissions() {
&nbsp;        // Pending JENKINS-17200, ensure that the above permissions have been registered prior to
&nbsp;        // allowing plugins to adapt the system configuration, which may depend on these permissions
&nbsp;        // having been registered. Since this method is static and since it follows the above
&nbsp;        // construction of static permission objects (and therefore their calls to
&nbsp;        // PermissionGroup#register), there is nothing further to do in this method. We call
&nbsp;        // Objects.hash() to guard against potential future compiler optimizations.
<b class="nc">&nbsp;        Objects.hash(PERMISSIONS, CREATE, DELETE, CONFIGURE, READ);</b>
&nbsp;    }
&nbsp;
&nbsp;    // to simplify access from Jelly
&nbsp;    public static Permission getItemCreatePermission() {
<b class="nc">&nbsp;        return Item.CREATE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static View create(StaplerRequest req, StaplerResponse rsp, ViewGroup owner)
&nbsp;            throws FormException, IOException, ServletException {
<b class="nc">&nbsp;        String mode = req.getParameter(&quot;mode&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        String requestContentType = req.getContentType();</b>
<b class="nc">&nbsp;        if (requestContentType == null</b>
<b class="nc">&nbsp;                &amp;&amp; !(mode != null &amp;&amp; mode.equals(&quot;copy&quot;)))</b>
<b class="nc">&nbsp;            throw new Failure(&quot;No Content-Type header set&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        boolean isXmlSubmission = requestContentType != null</b>
<b class="nc">&nbsp;                &amp;&amp; (requestContentType.startsWith(&quot;application/xml&quot;)</b>
<b class="nc">&nbsp;                        || requestContentType.startsWith(&quot;text/xml&quot;));</b>
&nbsp;
<b class="nc">&nbsp;        String name = req.getParameter(&quot;name&quot;);</b>
<b class="nc">&nbsp;        Jenkins.checkGoodName(name);</b>
<b class="nc">&nbsp;        if (owner.getView(name) != null)</b>
<b class="nc">&nbsp;            throw new Failure(Messages.Hudson_ViewAlreadyExists(name));</b>
&nbsp;
<b class="nc">&nbsp;        if (mode == null || mode.isEmpty()) {</b>
<b class="nc">&nbsp;            if (isXmlSubmission) {</b>
<b class="nc">&nbsp;                View v = createViewFromXML(name, req.getInputStream());</b>
<b class="nc">&nbsp;                owner.getACL().checkCreatePermission(owner, v.getDescriptor());</b>
<b class="nc">&nbsp;                v.owner = owner;</b>
<b class="nc">&nbsp;                rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;                return v;</b>
&nbsp;            } else
<b class="nc">&nbsp;                throw new Failure(Messages.View_MissingMode());</b>
&nbsp;        }
&nbsp;
&nbsp;        View v;
<b class="nc">&nbsp;        if (&quot;copy&quot;.equals(mode)) {</b>
<b class="nc">&nbsp;            v = copy(req, owner, name);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            ViewDescriptor descriptor = all().findByName(mode);</b>
<b class="nc">&nbsp;            if (descriptor == null) {</b>
<b class="nc">&nbsp;                throw new Failure(&quot;No view type &quot; + mode + &quot; is known&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            // create a view
<b class="nc">&nbsp;            JSONObject submittedForm = req.getSubmittedForm();</b>
<b class="nc">&nbsp;            submittedForm.put(&quot;name&quot;, name);</b>
<b class="nc">&nbsp;            v = descriptor.newInstance(req, submittedForm);</b>
&nbsp;        }
<b class="nc">&nbsp;        owner.getACL().checkCreatePermission(owner, v.getDescriptor());</b>
<b class="nc">&nbsp;        v.owner = owner;</b>
&nbsp;
&nbsp;        // redirect to the config screen
<b class="nc">&nbsp;        rsp.sendRedirect2(req.getContextPath() + &#39;/&#39; + v.getUrl() + v.getPostConstructLandingPage());</b>
&nbsp;
<b class="nc">&nbsp;        return v;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static View copy(StaplerRequest req, ViewGroup owner, String name) throws IOException {
&nbsp;        View v;
<b class="nc">&nbsp;        String from = req.getParameter(&quot;from&quot;);</b>
<b class="nc">&nbsp;        View src = owner.getView(from);</b>
&nbsp;
<b class="nc">&nbsp;        if (src == null) {</b>
<b class="nc">&nbsp;            if (Util.fixEmpty(from) == null)</b>
<b class="nc">&nbsp;                throw new Failure(&quot;Specify which view to copy&quot;);</b>
&nbsp;            else
<b class="nc">&nbsp;                throw new Failure(&quot;No such view: &quot; + from);</b>
&nbsp;        }
<b class="nc">&nbsp;        String xml = Jenkins.XSTREAM.toXML(src);</b>
<b class="nc">&nbsp;        v = createViewFromXML(name, new ByteArrayInputStream(xml.getBytes(Charset.defaultCharset())));</b>
<b class="nc">&nbsp;        return v;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instantiate View subtype from XML stream.
&nbsp;     *
&nbsp;     * @param name Alternative name to use or {@code null} to keep the one in xml.
&nbsp;     */
&nbsp;    public static View createViewFromXML(String name, InputStream xml) throws IOException {
&nbsp;
<b class="nc">&nbsp;        try (InputStream in = new BufferedInputStream(xml)) {</b>
<b class="nc">&nbsp;            View v = (View) Jenkins.XSTREAM.fromXML(in);</b>
<b class="nc">&nbsp;            if (name != null) v.name = name;</b>
<b class="nc">&nbsp;            Jenkins.checkGoodName(v.name);</b>
<b class="nc">&nbsp;            return v;</b>
<b class="nc">&nbsp;        } catch (StreamException | ConversionException | Error e) { // mostly reflection errors</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Unable to read&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class PropertyList extends DescribableList&lt;ViewProperty, ViewPropertyDescriptor&gt; {
&nbsp;        private PropertyList(View owner) {
<b class="fc">&nbsp;            super(owner);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public PropertyList() {// needed for XStream deserialization</b>
&nbsp;        }
&nbsp;
&nbsp;        public View getOwner() {
<b class="nc">&nbsp;            return (View) owner;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onModified() throws IOException {
<b class="nc">&nbsp;            for (ViewProperty p : this)</b>
<b class="nc">&nbsp;                p.setView(getOwner());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &quot;Job&quot; in &quot;New Job&quot;. When a view is used in a context that restricts the child type,
&nbsp;     * It might be useful to override this.
&nbsp;     */
<b class="fc">&nbsp;    public static final Message&lt;View&gt; NEW_PRONOUN = new Message&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(View.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
