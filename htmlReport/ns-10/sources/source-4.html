


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AbstractItem</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: AbstractItem (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractItem</td>
<td class="coverageStat">
  <span class="percent">
    25.5%
  </span>
  <span class="absValue">
    (13/51)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.6%
  </span>
  <span class="absValue">
    (28/327)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractItem$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractItem$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractItem$Replacer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    22.8%
  </span>
  <span class="absValue">
    (13/57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (28/339)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Daniel Dyer, Tom Huybrechts, Yahoo!, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static hudson.model.queue.Executables.getParentOf;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
&nbsp;
&nbsp;import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.AbortException;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Util;
&nbsp;import hudson.XmlFile;
&nbsp;import hudson.cli.declarative.CLIResolver;
&nbsp;import hudson.model.listeners.ItemListener;
&nbsp;import hudson.model.listeners.SaveableListener;
&nbsp;import hudson.model.queue.SubTask;
&nbsp;import hudson.model.queue.Tasks;
&nbsp;import hudson.model.queue.WorkUnit;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.util.AlternativeUiTextProvider;
&nbsp;import hudson.util.AlternativeUiTextProvider.Message;
&nbsp;import hudson.util.AtomicFileWriter;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.IOUtils;
&nbsp;import hudson.util.Secret;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Files;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.ListIterator;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.xml.transform.Source;
&nbsp;import javax.xml.transform.TransformerException;
&nbsp;import javax.xml.transform.sax.SAXSource;
&nbsp;import javax.xml.transform.stream.StreamResult;
&nbsp;import javax.xml.transform.stream.StreamSource;
&nbsp;import jenkins.model.DirectlyModifiableTopLevelItemGroup;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.Loadable;
&nbsp;import jenkins.model.queue.ItemDeletion;
&nbsp;import jenkins.security.NotReallyRoleSensitiveCallable;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.xml.XMLUtils;
&nbsp;import org.apache.tools.ant.Project;
&nbsp;import org.apache.tools.ant.taskdefs.Copy;
&nbsp;import org.apache.tools.ant.types.FileSet;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.args4j.Argument;
&nbsp;import org.kohsuke.args4j.CmdLineException;
&nbsp;import org.kohsuke.stapler.Ancestor;
&nbsp;import org.kohsuke.stapler.HttpDeletable;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;import org.kohsuke.stapler.StaplerProxy;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.WebMethod;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.springframework.security.access.AccessDeniedException;
&nbsp;import org.xml.sax.SAXException;
&nbsp;
&nbsp;/**
&nbsp; * Partial default implementation of {@link Item}.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;// Item doesn&#39;t necessarily have to be Actionable, but
&nbsp;// Java doesn&#39;t let multiple inheritance.
<b class="fc">&nbsp;@ExportedBean</b>
&nbsp;public abstract class AbstractItem extends Actionable implements Loadable, Item, HttpDeletable, AccessControlled, DescriptorByNameOwner, StaplerProxy {
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(AbstractItem.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Project name.
&nbsp;     */
&nbsp;    protected /*final*/ transient String name;
&nbsp;
&nbsp;    /**
&nbsp;     * Project description. Can be HTML.
&nbsp;     */
&nbsp;    protected volatile String description;
&nbsp;
&nbsp;    private transient ItemGroup parent;
&nbsp;
&nbsp;    protected String displayName;
&nbsp;
<b class="fc">&nbsp;    protected AbstractItem(ItemGroup parent, String name) {</b>
<b class="fc">&nbsp;        this.parent = parent;</b>
<b class="fc">&nbsp;        doSetName(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Exported(visibility = 999)
&nbsp;    public String getName() {
<b class="fc">&nbsp;        return name;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the term used in the UI to represent this kind of
&nbsp;     * {@link Item}. Must start with a capital letter.
&nbsp;     */
&nbsp;    public String getPronoun() {
<b class="nc">&nbsp;        return AlternativeUiTextProvider.get(PRONOUN, this, Messages.AbstractItem_Pronoun());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the term used in the UI to represent the kind of {@link Queue.Task} associated with this kind of
&nbsp;     * {@link Item}. Must start with a capital letter. Defaults to &quot;Build&quot;.
&nbsp;     * @since 2.50
&nbsp;     */
&nbsp;    public String getTaskNoun() {
<b class="nc">&nbsp;        return AlternativeUiTextProvider.get(TASK_NOUN, this, Messages.AbstractItem_TaskNoun());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return The display name of this object, or if it is not set, the name
&nbsp;     * of the object.
&nbsp;     */
&nbsp;    @Override
&nbsp;    @Exported
&nbsp;    public String getDisplayName() {
<b class="fc">&nbsp;        if (null != displayName) {</b>
<b class="fc">&nbsp;            return displayName;</b>
&nbsp;        }
&nbsp;        // if the displayName is not set, then return the name as we use to do
<b class="fc">&nbsp;        return getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This is intended to be used by the Job configuration pages where
&nbsp;     * we want to return null if the display name is not set.
&nbsp;     * @return The display name of this object or null if the display name is not
&nbsp;     * set
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public String getDisplayNameOrNull() {
<b class="fc">&nbsp;        return displayName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method exists so that the Job configuration pages can use
&nbsp;     * getDisplayNameOrNull so that nothing is shown in the display name text
&nbsp;     * box if the display name is not set.
&nbsp;     */
&nbsp;    public void setDisplayNameOrNull(String displayName) throws IOException {
<b class="fc">&nbsp;        setDisplayName(displayName);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDisplayName(String displayName) throws IOException {
<b class="fc">&nbsp;        this.displayName = Util.fixEmptyAndTrim(displayName);</b>
<b class="fc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public File getRootDir() {
<b class="nc">&nbsp;        return getParent().getRootDirFor(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This bridge method is to maintain binary compatibility with {@link TopLevelItem#getParent()}.
&nbsp;     */
&nbsp;    @WithBridgeMethods(value = Jenkins.class, castRequired = true)
&nbsp;    @Override public @NonNull ItemGroup getParent() {
<b class="nc">&nbsp;        if (parent == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;no parent set on &quot; + getClass().getName() + &quot;[&quot; + name + &quot;]&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return parent;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the project description HTML.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;        return description;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the project description HTML.
&nbsp;     */
&nbsp;    public void setDescription(String description) throws IOException {
<b class="nc">&nbsp;        this.description = description;</b>
<b class="nc">&nbsp;        save();</b>
<b class="nc">&nbsp;        ItemListener.fireOnUpdated(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Just update {@link #name} without performing the rename operation,
&nbsp;     * which would involve copying files and etc.
&nbsp;     */
&nbsp;    protected void doSetName(String name) {
<b class="fc">&nbsp;        this.name = name;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Controls whether the default rename action is available for this item.
&nbsp;     *
&nbsp;     * @return whether {@link #name} can be modified by a user
&nbsp;     * @see #checkRename
&nbsp;     * @see #renameTo
&nbsp;     * @since 2.110
&nbsp;     */
&nbsp;    public boolean isNameEditable() {
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Renames this item
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public HttpResponse doConfirmRename(@QueryParameter String newName) throws IOException {
<b class="fc">&nbsp;        newName = newName == null ? null : newName.trim();</b>
<b class="fc">&nbsp;        FormValidation validationError = doCheckNewName(newName);</b>
<b class="fc">&nbsp;        if (validationError.kind != FormValidation.Kind.OK) {</b>
<b class="fc">&nbsp;            throw new Failure(validationError.getMessage());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        renameTo(newName);</b>
&nbsp;        // send to the new job page
&nbsp;        // note we can&#39;t use getUrl() because that would pick up old name in the
&nbsp;        // Ancestor.getUrl()
<b class="nc">&nbsp;        return HttpResponses.redirectTo(&quot;../&quot; + Functions.encode(newName));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called by {@link #doConfirmRename} and {@code rename.jelly} to validate renames.
&nbsp;     * @return {@link FormValidation#ok} if this item can be renamed as specified, otherwise
&nbsp;     * {@link FormValidation#error} with a message explaining the problem.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public @NonNull FormValidation doCheckNewName(@QueryParameter String newName) {
&nbsp;
<b class="fc">&nbsp;        if (!isNameEditable()) {</b>
<b class="fc">&nbsp;            return FormValidation.error(&quot;Trying to rename an item that does not support this operation.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // TODO: Create an Item.RENAME permission to use here, see JENKINS-18649.
<b class="nc">&nbsp;        if (!hasPermission(Item.CONFIGURE)) {</b>
<b class="nc">&nbsp;            if (parent instanceof AccessControlled) {</b>
<b class="nc">&nbsp;                ((AccessControlled) parent).checkPermission(Item.CREATE);</b>
&nbsp;            }
<b class="nc">&nbsp;            checkPermission(Item.DELETE);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        newName = newName == null ? null : newName.trim();</b>
&nbsp;        try {
<b class="nc">&nbsp;            Jenkins.checkGoodName(newName);</b>
<b class="nc">&nbsp;            assert newName != null; // Would have thrown Failure</b>
<b class="nc">&nbsp;            if (newName.equals(name)) {</b>
<b class="nc">&nbsp;                return FormValidation.warning(Messages.AbstractItem_NewNameUnchanged());</b>
&nbsp;            }
<b class="nc">&nbsp;            Jenkins.get().getProjectNamingStrategy().checkName(getParent().getFullName(), newName);</b>
<b class="nc">&nbsp;            checkIfNameIsUsed(newName);</b>
<b class="nc">&nbsp;            checkRename(newName);</b>
<b class="nc">&nbsp;        } catch (Failure e) {</b>
<b class="nc">&nbsp;            return FormValidation.error(e.getMessage());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return FormValidation.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check new name for job
&nbsp;     * @param newName - New name for job.
&nbsp;     */
&nbsp;    private void checkIfNameIsUsed(@NonNull String newName) throws Failure {
&nbsp;        try {
<b class="nc">&nbsp;            Item item = getParent().getItem(newName);</b>
<b class="nc">&nbsp;            if (item != null) {</b>
<b class="nc">&nbsp;                throw new Failure(Messages.AbstractItem_NewNameInUse(newName));</b>
&nbsp;            }
<b class="nc">&nbsp;            try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                item = getParent().getItem(newName);</b>
<b class="nc">&nbsp;                if (item != null) {</b>
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINE, &quot;Unable to rename the job {0}: name {1} is already in use. &quot; +</b>
&nbsp;                                &quot;User {2} has no {3} permission for existing job with the same name&quot;,
<b class="nc">&nbsp;                                new Object[] {this.getFullName(), newName, ctx.getPreviousContext2().getAuthentication().getName(), Item.DISCOVER.name});</b>
&nbsp;                    }
&nbsp;                    // Don&#39;t explicitly mention that there is another item with the same name.
<b class="nc">&nbsp;                    throw new Failure(Messages.Jenkins_NotAllowedName(newName));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } catch (AccessDeniedException ex) {</b>
<b class="nc">&nbsp;            if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;Unable to rename the job {0}: name {1} is already in use. &quot; +</b>
&nbsp;                        &quot;User {2} has {3} permission, but no {4} for existing job with the same name&quot;,
<b class="nc">&nbsp;                        new Object[] {this.getFullName(), newName, User.current(), Item.DISCOVER.name, Item.READ.name});</b>
&nbsp;            }
<b class="nc">&nbsp;            throw new Failure(Messages.AbstractItem_NewNameInUse(newName));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows subclasses to block renames for domain-specific reasons. Generic validation of the new name
&nbsp;     * (e.g., null checking, checking for illegal characters, and checking that the name is not in use)
&nbsp;     * always happens prior to calling this method.
&nbsp;     *
&nbsp;     * @param newName the new name for the item
&nbsp;     * @throws Failure if the rename should be blocked
&nbsp;     * @since 2.110
&nbsp;     * @see Job#checkRename
&nbsp;     */
&nbsp;    protected void checkRename(@NonNull String newName) throws Failure {
&nbsp;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Renames this item.
&nbsp;     * Not all the Items need to support this operation, but if you decide to do so,
&nbsp;     * you can use this method.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;SWL_SLEEP_WITH_LOCK_HELD&quot;, justification = &quot;no big deal&quot;)
&nbsp;    protected void renameTo(final String newName) throws IOException {
&nbsp;
<b class="fc">&nbsp;        if (!isNameEditable()) {</b>
<b class="fc">&nbsp;            throw new IOException(&quot;Trying to rename an item that does not support this operation.&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // always synchronize from bigger objects first
<b class="nc">&nbsp;        final ItemGroup parent = getParent();</b>
<b class="nc">&nbsp;        String oldName = this.name;</b>
<b class="nc">&nbsp;        String oldFullName = getFullName();</b>
<b class="nc">&nbsp;        synchronized (parent) {</b>
<b class="nc">&nbsp;            synchronized (this) {</b>
&nbsp;                // sanity check
<b class="nc">&nbsp;                if (newName == null)</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;New name is not given&quot;);</b>
&nbsp;
&nbsp;                // noop?
<b class="nc">&nbsp;                if (this.name.equals(newName))</b>
<b class="nc">&nbsp;                    return;</b>
&nbsp;
&nbsp;                // the lookup is case insensitive, so we should not fail if this item was the “existing” one
&nbsp;                // to allow people to rename &quot;Foo&quot; to &quot;foo&quot;, for example.
&nbsp;                // see http://www.nabble.com/error-on-renaming-project-tt18061629.html
<b class="nc">&nbsp;                Items.verifyItemDoesNotAlreadyExist(parent, newName, this);</b>
&nbsp;
<b class="nc">&nbsp;                File oldRoot = this.getRootDir();</b>
&nbsp;
<b class="nc">&nbsp;                doSetName(newName);</b>
<b class="nc">&nbsp;                File newRoot = this.getRootDir();</b>
&nbsp;
<b class="nc">&nbsp;                boolean success = false;</b>
&nbsp;
&nbsp;                try { // rename data files
<b class="nc">&nbsp;                    boolean interrupted = false;</b>
<b class="nc">&nbsp;                    boolean renamed = false;</b>
&nbsp;
&nbsp;                    // try to rename the job directory.
&nbsp;                    // this may fail on Windows due to some other processes
&nbsp;                    // accessing a file.
&nbsp;                    // so retry few times before we fall back to copy.
<b class="nc">&nbsp;                    for (int retry = 0; retry &lt; 5; retry++) {</b>
<b class="nc">&nbsp;                        if (oldRoot.renameTo(newRoot)) {</b>
<b class="nc">&nbsp;                            renamed = true;</b>
<b class="nc">&nbsp;                            break; // succeeded</b>
&nbsp;                        }
&nbsp;                        try {
<b class="nc">&nbsp;                            Thread.sleep(500);</b>
<b class="nc">&nbsp;                        } catch (InterruptedException e) {</b>
&nbsp;                            // process the interruption later
<b class="nc">&nbsp;                            interrupted = true;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    if (interrupted)</b>
<b class="nc">&nbsp;                        Thread.currentThread().interrupt();</b>
&nbsp;
<b class="nc">&nbsp;                    if (!renamed) {</b>
&nbsp;                        // failed to rename. it must be that some lengthy
&nbsp;                        // process is going on
&nbsp;                        // to prevent a rename operation. So do a copy. Ideally
&nbsp;                        // we&#39;d like to
&nbsp;                        // later delete the old copy, but we can&#39;t reliably do
&nbsp;                        // so, as before the VM
&nbsp;                        // shuts down there might be a new job created under the
&nbsp;                        // old name.
<b class="nc">&nbsp;                        Copy cp = new Copy();</b>
<b class="nc">&nbsp;                        cp.setProject(new Project());</b>
<b class="nc">&nbsp;                        cp.setTodir(newRoot);</b>
<b class="nc">&nbsp;                        FileSet src = new FileSet();</b>
<b class="nc">&nbsp;                        src.setDir(oldRoot);</b>
<b class="nc">&nbsp;                        cp.addFileset(src);</b>
<b class="nc">&nbsp;                        cp.setOverwrite(true);</b>
<b class="nc">&nbsp;                        cp.setPreserveLastModified(true);</b>
<b class="nc">&nbsp;                        cp.setFailOnError(false); // keep going even if</b>
&nbsp;                                                    // there&#39;s an error
<b class="nc">&nbsp;                        cp.execute();</b>
&nbsp;
&nbsp;                        // try to delete as much as possible
&nbsp;                        try {
<b class="nc">&nbsp;                            Util.deleteRecursive(oldRoot);</b>
<b class="nc">&nbsp;                        } catch (IOException e) {</b>
&nbsp;                            // but ignore the error, since we expect that
<b class="nc">&nbsp;                            e.printStackTrace();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    success = true;</b>
&nbsp;                } finally {
&nbsp;                    // if failed, back out the rename.
<b class="nc">&nbsp;                    if (!success)</b>
<b class="nc">&nbsp;                        doSetName(oldName);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                parent.onRenamed(this, oldName, newName);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        ItemListener.fireLocationChange(this, oldFullName);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Notify this item it&#39;s been moved to another location, replaced by newItem (might be the same object, but not guaranteed).
&nbsp;     * This method is executed &lt;em&gt;after&lt;/em&gt; the item root directory has been moved to it&#39;s new location.
&nbsp;     * &lt;p&gt;
&nbsp;     * Derived classes can override this method to add some specific behavior on move, but have to call parent method
&nbsp;     * so the item is actually setup within it&#39;s new parent.
&nbsp;     *
&nbsp;     * @see hudson.model.Items#move(AbstractItem, jenkins.model.DirectlyModifiableTopLevelItemGroup)
&nbsp;     */
&nbsp;    public void movedTo(DirectlyModifiableTopLevelItemGroup destination, AbstractItem newItem, File destDir) throws IOException {
<b class="nc">&nbsp;        newItem.onLoad(destination, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the jobs that this {@link Item} contains as descendants.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public abstract Collection&lt;? extends Job&gt; getAllJobs();
&nbsp;
&nbsp;    @Override
&nbsp;    @Exported
&nbsp;    public final String getFullName() {
<b class="fc">&nbsp;        String n = getParent().getFullName();</b>
<b class="nc">&nbsp;        if (n.isEmpty())   return getName();</b>
<b class="nc">&nbsp;        else                return n + &#39;/&#39; + getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Exported
&nbsp;    public final String getFullDisplayName() {
<b class="nc">&nbsp;        String n = getParent().getFullDisplayName();</b>
<b class="nc">&nbsp;        if (n.isEmpty())   return getDisplayName();</b>
<b class="nc">&nbsp;        else                return n + &quot; » &quot; + getDisplayName();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the display name of the current item relative to the given group.
&nbsp;     *
&nbsp;     * @since 1.515
&nbsp;     * @param p the ItemGroup used as point of reference for the item
&nbsp;     * @return
&nbsp;     *      String like &quot;foo » bar&quot;
&nbsp;     */
&nbsp;    public String getRelativeDisplayNameFrom(ItemGroup p) {
<b class="nc">&nbsp;        return Functions.getRelativeDisplayNameFrom(this, p);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method only exists to disambiguate {@link #getRelativeNameFrom(ItemGroup)} and {@link #getRelativeNameFrom(Item)}
&nbsp;     * @since 1.512
&nbsp;     * @see #getRelativeNameFrom(ItemGroup)
&nbsp;     */
&nbsp;    public String getRelativeNameFromGroup(ItemGroup p) {
<b class="nc">&nbsp;        return getRelativeNameFrom(p);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called right after when a {@link Item} is loaded from disk.
&nbsp;     * This is an opportunity to do a post load processing.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void onLoad(ItemGroup&lt;? extends Item&gt; parent, String name) throws IOException {
<b class="nc">&nbsp;        this.parent = parent;</b>
<b class="nc">&nbsp;        doSetName(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * When a {@link Item} is copied from existing one,
&nbsp;     * the files are first copied on the file system,
&nbsp;     * then it will be loaded, then this method will be invoked
&nbsp;     * to perform any implementation-specific work.
&nbsp;     *
&nbsp;     * @param src
&nbsp;     *      Item from which it&#39;s copied from. The same type as {@code this}. Never null.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void onCopiedFrom(Item src) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public final String getUrl() {
&nbsp;        // try to stick to the current view if possible
<b class="nc">&nbsp;        StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="nc">&nbsp;        String shortUrl = getShortUrl();</b>
<b class="nc">&nbsp;        String uri = req == null ? null : req.getRequestURI();</b>
<b class="nc">&nbsp;        if (req != null) {</b>
<b class="nc">&nbsp;            String seed = Functions.getNearestAncestorUrl(req, this);</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINER, &quot;seed={0} for {1} from {2}&quot;, new Object[] {seed, this, uri});</b>
<b class="nc">&nbsp;            if (seed != null) {</b>
&nbsp;                // trim off the context path portion and leading &#39;/&#39;, but add trailing &#39;/&#39;
<b class="nc">&nbsp;                return seed.substring(req.getContextPath().length() + 1) + &#39;/&#39;;</b>
&nbsp;            }
<b class="nc">&nbsp;            List&lt;Ancestor&gt; ancestors = req.getAncestors();</b>
<b class="nc">&nbsp;            if (!ancestors.isEmpty()) {</b>
<b class="nc">&nbsp;                Ancestor last = ancestors.get(ancestors.size() - 1);</b>
<b class="nc">&nbsp;                if (last.getObject() instanceof View) {</b>
<b class="nc">&nbsp;                    View view = (View) last.getObject();</b>
<b class="nc">&nbsp;                    if (view.getOwner().getItemGroup() == getParent() &amp;&amp; !view.isDefault()) {</b>
&nbsp;                        // Showing something inside a view, so should use that as the base URL.
<b class="nc">&nbsp;                        String prefix = req.getContextPath() + &quot;/&quot;;</b>
<b class="nc">&nbsp;                        String url = last.getUrl();</b>
<b class="nc">&nbsp;                        if (url.startsWith(prefix)) {</b>
<b class="nc">&nbsp;                            String base = url.substring(prefix.length()) + &#39;/&#39;;</b>
<b class="nc">&nbsp;                            LOGGER.log(Level.FINER, &quot;using {0}{1} for {2} from {3} given {4}&quot;, new Object[] {base, shortUrl, this, uri, prefix});</b>
<b class="nc">&nbsp;                            return base + shortUrl;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            LOGGER.finer(() -&gt; url + &quot; does not start with &quot; + prefix + &quot; as expected&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINER, &quot;irrelevant {0} for {1} from {2}&quot;, new Object[] {view.getViewName(), this, uri});</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINER, &quot;inapplicable {0} for {1} from {2}&quot;, new Object[] {last.getObject(), this, uri});</b>
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINER, &quot;no ancestors for {0} from {1}&quot;, new Object[] {this, uri});</b>
&nbsp;            }
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINER, &quot;no current request for {0}&quot;, this);</b>
&nbsp;        }
&nbsp;        // otherwise compute the path normally
<b class="nc">&nbsp;        String base = getParent().getUrl();</b>
<b class="nc">&nbsp;        LOGGER.log(Level.FINER, &quot;falling back to {0}{1} for {2} from {3}&quot;, new Object[] {base, shortUrl, this, uri});</b>
<b class="nc">&nbsp;        return base + shortUrl;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getShortUrl() {
<b class="nc">&nbsp;        String prefix = getParent().getUrlChildPrefix();</b>
<b class="nc">&nbsp;        String subdir = Util.rawEncode(getName());</b>
<b class="nc">&nbsp;        return prefix.equals(&quot;.&quot;) ? subdir + &#39;/&#39; : prefix + &#39;/&#39; + subdir + &#39;/&#39;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSearchUrl() {
<b class="nc">&nbsp;        return getShortUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Exported(visibility = 999, name = &quot;url&quot;)
&nbsp;    public final String getAbsoluteUrl() {
<b class="nc">&nbsp;        return Item.super.getAbsoluteUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remote API access.
&nbsp;     */
&nbsp;    public final Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link ACL} for this object.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public ACL getACL() {
<b class="nc">&nbsp;        return Jenkins.get().getAuthorizationStrategy().getACL(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Save the settings to a file.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void save() throws IOException {
<b class="nc">&nbsp;        if (BulkChange.contains(this))   return;</b>
<b class="nc">&nbsp;        getConfigFile().write(this);</b>
<b class="nc">&nbsp;        SaveableListener.fireOnChange(this, getConfigFile());</b>
&nbsp;    }
&nbsp;
&nbsp;    public final XmlFile getConfigFile() {
<b class="nc">&nbsp;        return Items.getConfigFile(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected Object writeReplace() {
<b class="nc">&nbsp;        return XmlFile.replaceIfNotAtTopLevel(this, () -&gt; new Replacer(this));</b>
&nbsp;    }
&nbsp;
&nbsp;    private static class Replacer {
&nbsp;        private final String fullName;
&nbsp;
<b class="nc">&nbsp;        Replacer(AbstractItem i) {</b>
<b class="nc">&nbsp;            fullName = i.getFullName();</b>
&nbsp;        }
&nbsp;
&nbsp;        private Object readResolve() {
<b class="nc">&nbsp;            Jenkins j = Jenkins.getInstanceOrNull();</b>
<b class="nc">&nbsp;            if (j == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;            // Will generally only work if called after job loading:
<b class="nc">&nbsp;            return j.getItemByFullName(fullName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts the new description.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized void doSubmitDescription(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
&nbsp;
<b class="nc">&nbsp;        setDescription(req.getParameter(&quot;description&quot;));</b>
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;.&quot;);  // go to the top page</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this item.
&nbsp;     * Note on the funny name: for reasons of historical compatibility, this URL is {@code /doDelete}
&nbsp;     * since it predates {@code &lt;l:confirmationLink&gt;}. {@code /delete} goes to a Jelly page
&nbsp;     * which should now be unused by core but is left in case plugins are still using it.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {
<b class="nc">&nbsp;        delete();</b>
<b class="nc">&nbsp;        if (req == null || rsp == null) { // CLI</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        List&lt;Ancestor&gt; ancestors = req.getAncestors();</b>
<b class="nc">&nbsp;        ListIterator&lt;Ancestor&gt; it = ancestors.listIterator(ancestors.size());</b>
<b class="nc">&nbsp;        String url = getParent().getUrl(); // fallback but we ought to get to Jenkins.instance at the root</b>
<b class="nc">&nbsp;        while (it.hasPrevious()) {</b>
<b class="nc">&nbsp;            Object a = it.previous().getObject();</b>
<b class="nc">&nbsp;            if (a instanceof View) {</b>
<b class="nc">&nbsp;                url = ((View) a).getUrl();</b>
<b class="nc">&nbsp;                break;</b>
<b class="nc">&nbsp;            } else if (a instanceof ViewGroup &amp;&amp; a != this) {</b>
<b class="nc">&nbsp;                url = ((ViewGroup) a).getUrl();</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        rsp.sendRedirect2(req.getContextPath() + &#39;/&#39; + url);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void delete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
&nbsp;        try {
<b class="nc">&nbsp;            delete();</b>
<b class="nc">&nbsp;            rsp.setStatus(204);</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
&nbsp;            // TODO: allow this in Stapler
<b class="nc">&nbsp;            throw new ServletException(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes this item.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Any exception indicates the deletion has failed, but {@link AbortException} would prevent the caller
&nbsp;     * from showing the stack trace. This
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void delete() throws IOException, InterruptedException {
<b class="nc">&nbsp;        checkPermission(DELETE);</b>
<b class="nc">&nbsp;        boolean responsibleForAbortingBuilds = !ItemDeletion.contains(this);</b>
<b class="nc">&nbsp;        boolean ownsRegistration = ItemDeletion.register(this);</b>
<b class="nc">&nbsp;        if (!ownsRegistration &amp;&amp; ItemDeletion.isRegistered(this)) {</b>
&nbsp;            // we are not the owning thread and somebody else is concurrently deleting this exact item
<b class="nc">&nbsp;            throw new Failure(Messages.AbstractItem_BeingDeleted(getPronoun()));</b>
&nbsp;        }
&nbsp;        try {
&nbsp;            // if a build is in progress. Cancel it.
<b class="nc">&nbsp;            if (responsibleForAbortingBuilds || ownsRegistration) {</b>
<b class="nc">&nbsp;                Queue queue = Queue.getInstance();</b>
<b class="nc">&nbsp;                if (this instanceof Queue.Task) {</b>
&nbsp;                    // clear any items in the queue so they do not get picked up
<b class="nc">&nbsp;                    queue.cancel((Queue.Task) this);</b>
&nbsp;                }
&nbsp;                // now cancel any child items - this happens after ItemDeletion registration, so we can use a snapshot
<b class="nc">&nbsp;                for (Queue.Item i : queue.getItems()) {</b>
<b class="nc">&nbsp;                    Item item = Tasks.getItemOf(i.task);</b>
<b class="nc">&nbsp;                    while (item != null) {</b>
<b class="nc">&nbsp;                        if (item == this) {</b>
<b class="nc">&nbsp;                            if (!queue.cancel(i)) {</b>
<b class="nc">&nbsp;                                LOGGER.warning(() -&gt; &quot;failed to cancel &quot; + i);</b>
&nbsp;                            }
&nbsp;                            break;
&nbsp;                        }
<b class="nc">&nbsp;                        if (item.getParent() instanceof Item) {</b>
<b class="nc">&nbsp;                            item = (Item) item.getParent();</b>
&nbsp;                        } else {
&nbsp;                            break;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;                // interrupt any builds in progress (and this should be a recursive test so that folders do not pay
&nbsp;                // the 15 second delay for every child item). This happens after queue cancellation, so will be
&nbsp;                // a complete set of builds in flight
<b class="nc">&nbsp;                Map&lt;Executor, Queue.Executable&gt; buildsInProgress = new LinkedHashMap&lt;&gt;();</b>
<b class="nc">&nbsp;                for (Computer c : Jenkins.get().getComputers()) {</b>
<b class="nc">&nbsp;                    for (Executor e : c.getAllExecutors()) {</b>
<b class="nc">&nbsp;                        final WorkUnit workUnit = e.getCurrentWorkUnit();</b>
<b class="nc">&nbsp;                        final Queue.Executable executable = workUnit != null ? workUnit.getExecutable() : null;</b>
<b class="nc">&nbsp;                        final SubTask subtask = executable != null ? getParentOf(executable) : null;</b>
&nbsp;
<b class="nc">&nbsp;                        if (subtask != null) {</b>
<b class="nc">&nbsp;                            Item item = Tasks.getItemOf(subtask);</b>
<b class="nc">&nbsp;                            while (item != null) {</b>
<b class="nc">&nbsp;                                if (item == this) {</b>
<b class="nc">&nbsp;                                    buildsInProgress.put(e, e.getCurrentExecutable());</b>
<b class="nc">&nbsp;                                    e.interrupt(Result.ABORTED);</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                if (item.getParent() instanceof Item) {</b>
<b class="nc">&nbsp;                                    item = (Item) item.getParent();</b>
&nbsp;                                } else {
&nbsp;                                    break;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;                if (!buildsInProgress.isEmpty()) {</b>
&nbsp;                    // give them 15 seconds or so to respond to the interrupt
<b class="nc">&nbsp;                    long expiration = System.nanoTime() + TimeUnit.SECONDS.toNanos(15);</b>
&nbsp;                    // comparison with executor.getCurrentExecutable() == computation currently should always be true
&nbsp;                    // as we no longer recycle Executors, but safer to future-proof in case we ever revisit recycling
<b class="nc">&nbsp;                    while (!buildsInProgress.isEmpty() &amp;&amp; expiration - System.nanoTime() &gt; 0L) {</b>
&nbsp;                        // we know that ItemDeletion will prevent any new builds in the queue
&nbsp;                        // ItemDeletion happens-before Queue.cancel so we know that the Queue will stay clear
&nbsp;                        // Queue.cancel happens-before collecting the buildsInProgress list
&nbsp;                        // thus buildsInProgress contains the complete set we need to interrupt and wait for
<b class="nc">&nbsp;                        for (Iterator&lt;Map.Entry&lt;Executor, Queue.Executable&gt;&gt; iterator =</b>
<b class="nc">&nbsp;                             buildsInProgress.entrySet().iterator();</b>
<b class="nc">&nbsp;                             iterator.hasNext(); ) {</b>
<b class="nc">&nbsp;                            Map.Entry&lt;Executor, Queue.Executable&gt; entry = iterator.next();</b>
&nbsp;                            // comparison with executor.getCurrentExecutable() == executable currently should always be
&nbsp;                            // true as we no longer recycle Executors, but safer to future-proof in case we ever
&nbsp;                            // revisit recycling.
<b class="nc">&nbsp;                            if (!entry.getKey().isAlive()</b>
<b class="nc">&nbsp;                                    || entry.getValue() != entry.getKey().getCurrentExecutable()) {</b>
<b class="nc">&nbsp;                                iterator.remove();</b>
&nbsp;                            }
&nbsp;                            // I don&#39;t know why, but we have to keep interrupting
<b class="nc">&nbsp;                            entry.getKey().interrupt(Result.ABORTED);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        Thread.sleep(50L);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (!buildsInProgress.isEmpty()) {</b>
<b class="nc">&nbsp;                        throw new Failure(Messages.AbstractItem_FailureToStopBuilds(</b>
<b class="nc">&nbsp;                                buildsInProgress.size(), getFullDisplayName()</b>
&nbsp;                        ));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            if (this instanceof ItemGroup) {</b>
&nbsp;                // delete individual items first
&nbsp;                // (disregard whether they would be deletable in isolation)
&nbsp;                // JENKINS-34939: do not hold the monitor on this folder while deleting them
&nbsp;                // (thus we cannot do this inside performDelete)
<b class="nc">&nbsp;                try (ACLContext oldContext = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                    for (Item i : ((ItemGroup&lt;?&gt;) this).getItems(TopLevelItem.class::isInstance)) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            i.delete();</b>
<b class="nc">&nbsp;                        } catch (AbortException e) {</b>
<b class="nc">&nbsp;                            throw (AbortException) new AbortException(</b>
<b class="nc">&nbsp;                                    &quot;Failed to delete &quot; + i.getFullDisplayName() + &quot; : &quot; + e.getMessage()).initCause(e);</b>
<b class="nc">&nbsp;                        } catch (IOException e) {</b>
<b class="nc">&nbsp;                            throw new IOException(&quot;Failed to delete &quot; + i.getFullDisplayName(), e);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            synchronized (this) { // could just make performDelete synchronized but overriders might not honor that</b>
<b class="nc">&nbsp;                performDelete();</b>
<b class="nc">&nbsp;            } // JENKINS-19446: leave synch block, but JENKINS-22001: still notify synchronously</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            if (ownsRegistration) {</b>
<b class="nc">&nbsp;                ItemDeletion.deregister(this);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        getParent().onDeleted(AbstractItem.this);</b>
<b class="nc">&nbsp;        Jenkins.get().rebuildDependencyGraphAsync();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does the real job of deleting the item.
&nbsp;     */
&nbsp;    protected void performDelete() throws IOException, InterruptedException {
<b class="nc">&nbsp;        getConfigFile().delete();</b>
<b class="nc">&nbsp;        Util.deleteRecursive(getRootDir());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts {@code config.xml} submission, as well as serve it.
&nbsp;     */
&nbsp;    @WebMethod(name = &quot;config.xml&quot;)
&nbsp;    public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp)
&nbsp;            throws IOException {
<b class="nc">&nbsp;        if (req.getMethod().equals(&quot;GET&quot;)) {</b>
&nbsp;            // read
<b class="nc">&nbsp;            rsp.setContentType(&quot;application/xml&quot;);</b>
<b class="nc">&nbsp;            writeConfigDotXml(rsp.getOutputStream());</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (req.getMethod().equals(&quot;POST&quot;)) {</b>
&nbsp;            // submission
<b class="nc">&nbsp;            updateByXml((Source) new StreamSource(req.getReader()));</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // huh?
<b class="nc">&nbsp;        rsp.sendError(SC_BAD_REQUEST);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static final Pattern SECRET_PATTERN = Pattern.compile(&quot;&gt;(&quot; + Secret.ENCRYPTED_VALUE_PATTERN + &quot;)&lt;&quot;);</b>
&nbsp;    /**
&nbsp;     * Writes {@code config.xml} to the specified output stream.
&nbsp;     * The user must have at least {@link #EXTENDED_READ}.
&nbsp;     * If he lacks {@link #CONFIGURE}, then any {@link Secret}s detected will be masked out.
&nbsp;     */
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void writeConfigDotXml(OutputStream os) throws IOException {
<b class="nc">&nbsp;        checkPermission(EXTENDED_READ);</b>
<b class="nc">&nbsp;        XmlFile configFile = getConfigFile();</b>
<b class="nc">&nbsp;        if (hasPermission(CONFIGURE)) {</b>
<b class="nc">&nbsp;            IOUtils.copy(configFile.getFile(), os);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            String encoding = configFile.sniffEncoding();</b>
<b class="nc">&nbsp;            String xml = Files.readString(Util.fileToPath(configFile.getFile()), Charset.forName(encoding));</b>
<b class="nc">&nbsp;            Matcher matcher = SECRET_PATTERN.matcher(xml);</b>
<b class="nc">&nbsp;            StringBuilder cleanXml = new StringBuilder();</b>
<b class="nc">&nbsp;            while (matcher.find()) {</b>
<b class="nc">&nbsp;                if (Secret.decrypt(matcher.group(1)) != null) {</b>
<b class="nc">&nbsp;                    matcher.appendReplacement(cleanXml, &quot;&gt;********&lt;&quot;);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            matcher.appendTail(cleanXml);</b>
<b class="nc">&nbsp;            org.apache.commons.io.IOUtils.write(cleanXml.toString(), os, encoding);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.473
&nbsp;     *      Use {@link #updateByXml(Source)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void updateByXml(StreamSource source) throws IOException {
<b class="nc">&nbsp;        updateByXml((Source) source);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates an Item by its XML definition.
&nbsp;     * @param source source of the Item&#39;s new definition.
&nbsp;     *               The source should be either a {@link StreamSource} or a {@link SAXSource}, other
&nbsp;     *               sources may not be handled.
&nbsp;     * @since 1.473
&nbsp;     */
&nbsp;    public void updateByXml(Source source) throws IOException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
<b class="nc">&nbsp;        XmlFile configXmlFile = getConfigFile();</b>
<b class="nc">&nbsp;        final AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());</b>
&nbsp;        try {
&nbsp;            try {
<b class="nc">&nbsp;                XMLUtils.safeTransform(source, new StreamResult(out));</b>
<b class="nc">&nbsp;                out.close();</b>
<b class="nc">&nbsp;            } catch (TransformerException | SAXException e) {</b>
<b class="nc">&nbsp;                throw new IOException(&quot;Failed to persist config.xml&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // try to reflect the changes by reloading
<b class="nc">&nbsp;            Object o = new XmlFile(Items.XSTREAM, out.getTemporaryPath().toFile()).unmarshalNullingOut(this);</b>
<b class="nc">&nbsp;            if (o != this) {</b>
&nbsp;                // ensure that we&#39;ve got the same job type. extending this code to support updating
&nbsp;                // to different job type requires destroying &amp; creating a new job type
<b class="nc">&nbsp;                throw new IOException(&quot;Expecting &quot; + this.getClass() + &quot; but got &quot; + o.getClass() + &quot; instead&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable&lt;Void, IOException&gt;() {</b>
&nbsp;                @Override public Void call() throws IOException {
<b class="nc">&nbsp;                    onLoad(getParent(), getRootDir().getName());</b>
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;            Jenkins.get().rebuildDependencyGraphAsync();</b>
&nbsp;
&nbsp;            // if everything went well, commit this new version
<b class="nc">&nbsp;            out.commit();</b>
<b class="nc">&nbsp;            SaveableListener.fireOnChange(this, getConfigFile());</b>
&nbsp;
&nbsp;        } finally {
<b class="nc">&nbsp;            out.abort(); // don&#39;t leave anything behind</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reloads this job from the disk.
&nbsp;     *
&nbsp;     * Exposed through CLI as well.
&nbsp;     *
&nbsp;     * TODO: think about exposing this to UI
&nbsp;     *
&nbsp;     * @since 1.556
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doReload() throws IOException {
<b class="nc">&nbsp;        load();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void load() throws IOException {
<b class="nc">&nbsp;        checkPermission(CONFIGURE);</b>
&nbsp;
&nbsp;        // try to reflect the changes by reloading
<b class="nc">&nbsp;        getConfigFile().unmarshal(this);</b>
<b class="nc">&nbsp;        Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable&lt;Void, IOException&gt;() {</b>
&nbsp;            @Override
&nbsp;            public Void call() throws IOException {
<b class="nc">&nbsp;                onLoad(getParent(), getParent().getItemName(getRootDir(), AbstractItem.this));</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        Jenkins.get().rebuildDependencyGraphAsync();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSearchName() {
&nbsp;        // the search name of abstract items should be the name and not display name.
&nbsp;        // this will make suggestions use the names and not the display name
&nbsp;        // so that the links will 302 directly to the thing the user was finding
<b class="fc">&nbsp;        return getName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public String toString() {
<b class="nc">&nbsp;        return super.toString() + &#39;[&#39; + (parent != null ? getFullName() : &quot;?/&quot; + name) + &#39;]&#39;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Object getTarget() {
<b class="nc">&nbsp;        if (!SKIP_PERMISSION_CHECK) {</b>
<b class="nc">&nbsp;            if (!hasPermission(Item.DISCOVER)) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            checkPermission(Item.READ);</b>
&nbsp;        }
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Escape hatch for StaplerProxy-based access control
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static /* Script Console modifiable */ boolean SKIP_PERMISSION_CHECK = SystemProperties.getBoolean(AbstractItem.class.getName() + &quot;.skipPermissionCheck&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used for CLI binding.
&nbsp;     */
&nbsp;    @CLIResolver
&nbsp;    public static AbstractItem resolveForCLI(
&nbsp;            @Argument(required = true, metaVar = &quot;NAME&quot;, usage = &quot;Item name&quot;) String name) throws CmdLineException {
&nbsp;        // TODO can this (and its pseudo-override in AbstractProject) share code with GenericItemOptionHandler, used for explicit CLICommand’s rather than CLIMethod’s?
<b class="nc">&nbsp;        AbstractItem item = Jenkins.get().getItemByFullName(name, AbstractItem.class);</b>
<b class="nc">&nbsp;        if (item == null) {</b>
<b class="nc">&nbsp;            AbstractItem project = Items.findNearest(AbstractItem.class, name, Jenkins.get());</b>
<b class="nc">&nbsp;            throw new CmdLineException(null, project == null ? Messages.AbstractItem_NoSuchJobExistsWithoutSuggestion(name)</b>
<b class="nc">&nbsp;                    : Messages.AbstractItem_NoSuchJobExists(name, project.getFullName()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return item;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Replaceable pronoun of that points to a job. Defaults to &quot;Job&quot;/&quot;Project&quot; depending on the context.
&nbsp;     */
<b class="fc">&nbsp;    public static final Message&lt;AbstractItem&gt; PRONOUN = new Message&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Replaceable noun for describing the kind of task that this item represents. Defaults to &quot;Build&quot;.
&nbsp;     */
<b class="fc">&nbsp;    public static final Message&lt;AbstractItem&gt; TASK_NOUN = new Message&lt;&gt;();</b>
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
