


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Queue</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: Queue (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Queue</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (16/80)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.6%
  </span>
  <span class="absValue">
    (80/635)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Queue$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$2</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$3</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (1/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$4</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$BlockedItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$BuildableItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$BuildableRunnable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$Executable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$FlyweightTask</td>
  </tr>
  <tr>
    <td class="name">Queue$Item</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (6/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20.5%
  </span>
  <span class="absValue">
    (16/78)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$ItemList</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    13.3%
  </span>
  <span class="absValue">
    (4/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$JobOffer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$LeftItem</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$LockedHRCallable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$LockedJUCCallable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$LockedRunnable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$MaintainTask</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$NonBlockingTask</td>
  </tr>
  <tr>
    <td class="name">Queue$NotWaitingItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$QueueAction</td>
  </tr>
  <tr>
    <td class="name">Queue$QueueDecisionHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$Saver</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$Snapshot</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$State</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$StubItem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$StubTask</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$Task</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (1/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5%
  </span>
  <span class="absValue">
    (1/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Queue$Task$MockitoMock$AsctleXQ</td>
  </tr>
  <tr>
    <td class="name">Queue$Task$MockitoMock$AsctleXQ$auxiliary$dwXeRE1A</td>
  </tr>
  <tr>
    <td class="name">Queue$Task$MockitoMock$AsctleXQ$auxiliary$royNXKSg</td>
  </tr>
  <tr>
    <td class="name">Queue$TransientTask</td>
  </tr>
  <tr>
    <td class="name">Queue$WaitingItem</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.5%
  </span>
  <span class="absValue">
    (13/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    20.6%
  </span>
  <span class="absValue">
    (44/214)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.2%
  </span>
  <span class="absValue">
    (139/977)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Stephen Connolly, Tom Huybrechts, InfraDNA, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static hudson.init.InitMilestone.JOB_CONFIG_ADAPTED;
&nbsp;import static hudson.model.Item.CANCEL;
&nbsp;import static hudson.util.Iterators.reverse;
&nbsp;
&nbsp;import com.google.common.annotations.VisibleForTesting;
&nbsp;import com.google.common.cache.Cache;
&nbsp;import com.google.common.cache.CacheBuilder;
&nbsp;import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
&nbsp;import com.thoughtworks.xstream.XStream;
&nbsp;import com.thoughtworks.xstream.converters.basic.AbstractSingleValueConverter;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionList;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.Util;
&nbsp;import hudson.XmlFile;
&nbsp;import hudson.cli.declarative.CLIResolver;
&nbsp;import hudson.init.Initializer;
&nbsp;import hudson.model.Node.Mode;
&nbsp;import hudson.model.labels.LabelAssignmentAction;
&nbsp;import hudson.model.listeners.SaveableListener;
&nbsp;import hudson.model.queue.CauseOfBlockage;
&nbsp;import hudson.model.queue.CauseOfBlockage.BecauseLabelIsBusy;
&nbsp;import hudson.model.queue.CauseOfBlockage.BecauseLabelIsOffline;
&nbsp;import hudson.model.queue.CauseOfBlockage.BecauseNodeIsBusy;
&nbsp;import hudson.model.queue.CauseOfBlockage.BecauseNodeIsOffline;
&nbsp;import hudson.model.queue.Executables;
&nbsp;import hudson.model.queue.FoldableAction;
&nbsp;import hudson.model.queue.FutureImpl;
&nbsp;import hudson.model.queue.MappingWorksheet;
&nbsp;import hudson.model.queue.MappingWorksheet.Mapping;
&nbsp;import hudson.model.queue.QueueListener;
&nbsp;import hudson.model.queue.QueueSorter;
&nbsp;import hudson.model.queue.QueueTaskDispatcher;
&nbsp;import hudson.model.queue.QueueTaskFuture;
&nbsp;import hudson.model.queue.ScheduleResult;
&nbsp;import hudson.model.queue.ScheduleResult.Created;
&nbsp;import hudson.model.queue.SubTask;
&nbsp;import hudson.model.queue.Tasks;
&nbsp;import hudson.model.queue.WorkUnit;
&nbsp;import hudson.model.queue.WorkUnitContext;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.security.Permission;
&nbsp;import hudson.triggers.SafeTimerTask;
&nbsp;import hudson.util.ConsistentHash;
&nbsp;import hudson.util.Futures;
&nbsp;import hudson.util.XStream2;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.ref.WeakReference;
&nbsp;import java.nio.channels.ClosedByInterruptException;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.StandardCopyOption;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicLong;
&nbsp;import java.util.concurrent.locks.Condition;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.servlet.http.HttpServletResponse;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.queue.AsynchronousExecution;
&nbsp;import jenkins.model.queue.CompositeCauseOfBlockage;
&nbsp;import jenkins.model.queue.QueueItem;
&nbsp;import jenkins.security.QueueItemAuthenticator;
&nbsp;import jenkins.security.QueueItemAuthenticatorProvider;
&nbsp;import jenkins.security.stapler.StaplerAccessibleType;
&nbsp;import jenkins.util.AtmostOneTaskExecutor;
&nbsp;import jenkins.util.Listeners;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.Timer;
&nbsp;import net.jcip.annotations.GuardedBy;
&nbsp;import org.jenkinsci.remoting.RoleChecker;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.springframework.security.access.AccessDeniedException;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;
&nbsp;/**
&nbsp; * Build queue.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * This class implements the core scheduling logic. {@link Task} represents the executable
&nbsp; * task that are placed in the queue. While in the queue, it&#39;s wrapped into {@link Item}
&nbsp; * so that we can keep track of additional data used for deciding what to execute when.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Items in queue goes through several stages, as depicted below:
&nbsp; * &lt;pre&gt;{@code
&nbsp; * (enter) --&gt; waitingList --+--&gt; blockedProjects
&nbsp; *                           |        ^
&nbsp; *                           |        |
&nbsp; *                           |        v
&nbsp; *                           +--&gt; buildables ---&gt; pending ---&gt; left
&nbsp; *                                    ^              |
&nbsp; *                                    |              |
&nbsp; *                                    +---(rarely)---+
&nbsp; * }&lt;/pre&gt;
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * Note: In the normal case of events pending items only move to left. However they can move back
&nbsp; * if the node they are assigned to execute on disappears before their {@link Executor} thread
&nbsp; * starts, where the node is removed before the {@link Executable} has been instantiated it
&nbsp; * is safe to move the pending item back to buildable. Once the {@link Executable} has been
&nbsp; * instantiated the only option is to let the {@link Executable} bomb out as soon as it starts
&nbsp; * to try an execute on the node that no longer exists.
&nbsp; *
&nbsp; * &lt;p&gt;
&nbsp; * In addition, at any stage, an item can be removed from the queue (for example, when the user
&nbsp; * cancels a job in the queue.) See the corresponding field for their exact meanings.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; * @see QueueListener
&nbsp; * @see QueueTaskDispatcher
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public class Queue extends ResourceController implements Saveable {
&nbsp;
&nbsp;    /**
&nbsp;
&nbsp;     * Items that are waiting for its quiet period to pass.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This consists of {@link Item}s that cannot be run yet
&nbsp;     * because its time has not yet come.
&nbsp;     */
<b class="fc">&nbsp;    private final Set&lt;WaitingItem&gt; waitingList = new TreeSet&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Task}s that can be built immediately
&nbsp;     * but blocked because another build is in progress,
&nbsp;     * required {@link Resource}s are not available,
&nbsp;     * blocked via {@link QueueTaskDispatcher#canRun(Item)},
&nbsp;     * or otherwise blocked by {@link Task#isBuildBlocked()}.
&nbsp;     */
<b class="fc">&nbsp;    private final ItemList&lt;BlockedItem&gt; blockedProjects = new ItemList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Task}s that can be built immediately
&nbsp;     * that are waiting for available {@link Executor}.
&nbsp;     * This list is sorted in such a way that earlier items are built earlier.
&nbsp;     */
<b class="fc">&nbsp;    private final ItemList&lt;BuildableItem&gt; buildables = new ItemList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Task}s that are being handed over to the executor, but execution
&nbsp;     * has not started yet.
&nbsp;     */
<b class="fc">&nbsp;    private final ItemList&lt;BuildableItem&gt; pendings = new ItemList&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private transient volatile Snapshot snapshot = new Snapshot(waitingList, blockedProjects, buildables, pendings);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Items that left queue would stay here for a while to enable tracking via {@link Item#getId()}.
&nbsp;     *
&nbsp;     * This map is forgetful, since we can&#39;t remember everything that executed in the past.
&nbsp;     */
<b class="fc">&nbsp;    private final Cache&lt;Long, LeftItem&gt; leftItems = CacheBuilder.newBuilder().expireAfterWrite(5 * 60, TimeUnit.SECONDS).build();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Data structure created for each idle {@link Executor}.
&nbsp;     * This is a job offer from the queue to an executor.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * For each idle executor, this gets created to allow the scheduling logic
&nbsp;     * to assign a work. Once a work is assigned, the executor actually gets
&nbsp;     * started to carry out the task in question.
&nbsp;     */
<b class="nc">&nbsp;    public static class JobOffer extends MappingWorksheet.ExecutorSlot {</b>
&nbsp;        public final Executor executor;
&nbsp;
&nbsp;        /**
&nbsp;         * The work unit that this {@link Executor} is going to handle.
&nbsp;         */
&nbsp;        private WorkUnit workUnit;
&nbsp;
<b class="nc">&nbsp;        private JobOffer(Executor executor) {</b>
<b class="nc">&nbsp;            this.executor = executor;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void set(WorkUnit p) {
<b class="nc">&nbsp;            assert this.workUnit == null;</b>
<b class="nc">&nbsp;            this.workUnit = p;</b>
<b class="nc">&nbsp;            assert executor.isParking();</b>
<b class="nc">&nbsp;            executor.start(workUnit);</b>
&nbsp;            // LOGGER.info(&quot;Starting &quot;+executor.getName());
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Executor getExecutor() {
<b class="nc">&nbsp;            return executor;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated discards information; prefer {@link #getCauseOfBlockage}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public boolean canTake(BuildableItem item) {
<b class="nc">&nbsp;            return getCauseOfBlockage(item) == null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks whether the {@link Executor} represented by this object is capable of executing the given task.
&nbsp;         * @return a reason why it cannot, or null if it could
&nbsp;         * @since 2.37
&nbsp;         */
&nbsp;        public @CheckForNull CauseOfBlockage getCauseOfBlockage(BuildableItem item) {
<b class="nc">&nbsp;            Node node = getNode();</b>
<b class="nc">&nbsp;            if (node == null) {</b>
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_node_has_been_removed_from_configuration(executor.getOwner().getDisplayName()));</b>
&nbsp;            }
<b class="nc">&nbsp;            CauseOfBlockage reason = node.canTake(item);</b>
<b class="nc">&nbsp;            if (reason != null) {</b>
<b class="nc">&nbsp;                return reason;</b>
&nbsp;            }
<b class="nc">&nbsp;            for (QueueTaskDispatcher d : QueueTaskDispatcher.all()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    reason = d.canTake(node, item);</b>
<b class="nc">&nbsp;                } catch (Throwable t) {</b>
&nbsp;                    // We cannot guarantee the task can be taken by the node because something wrong happened
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, t, () -&gt; String.format(&quot;Exception evaluating if the node &#39;%s&#39; can take the task &#39;%s&#39;&quot;, node.getNodeName(), item.task.getName()));</b>
<b class="nc">&nbsp;                    reason = CauseOfBlockage.fromMessage(Messages._Queue_ExceptionCanTake());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (reason != null) {</b>
<b class="nc">&nbsp;                    return reason;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // inlining isAvailable:
<b class="nc">&nbsp;            if (workUnit != null) { // unlikely in practice (should not have even found this executor if so)</b>
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_executor_slot_already_in_use());</b>
&nbsp;            }
<b class="nc">&nbsp;            if (executor.getOwner().isOffline()) {</b>
<b class="nc">&nbsp;                return new CauseOfBlockage.BecauseNodeIsOffline(node);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!executor.getOwner().isAcceptingTasks()) { // Node.canTake (above) does not consider RetentionStrategy.isAcceptingTasks</b>
<b class="nc">&nbsp;                return new CauseOfBlockage.BecauseNodeIsNotAcceptingTasks(node);</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Is this executor ready to accept some tasks?
&nbsp;         */
&nbsp;        @Override
&nbsp;        public boolean isAvailable() {
<b class="nc">&nbsp;            return workUnit == null &amp;&amp; !executor.getOwner().isOffline() &amp;&amp; executor.getOwner().isAcceptingTasks();</b>
&nbsp;        }
&nbsp;
&nbsp;        @CheckForNull
&nbsp;        public Node getNode() {
<b class="nc">&nbsp;            return executor.getOwner().getNode();</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNotExclusive() {
<b class="nc">&nbsp;            return getNode().getMode() == Mode.NORMAL;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return String.format(&quot;JobOffer[%s #%d]&quot;, executor.getOwner().getName(), executor.getNumber());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private transient volatile LoadBalancer loadBalancer;
&nbsp;
&nbsp;    private transient volatile QueueSorter sorter;
&nbsp;
<b class="fc">&nbsp;    private final transient AtmostOneTaskExecutor&lt;Void&gt; maintainerThread = new AtmostOneTaskExecutor&lt;&gt;(new Callable&lt;&gt;() {</b>
&nbsp;        @Override
&nbsp;        public Void call() throws Exception {
<b class="fc">&nbsp;            maintain();</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return &quot;Periodic Jenkins queue maintenance&quot;;</b>
&nbsp;        }
&nbsp;    });
&nbsp;
<b class="fc">&nbsp;    private final transient ReentrantLock lock = new ReentrantLock();</b>
&nbsp;
<b class="fc">&nbsp;    private final transient Condition condition = lock.newCondition();</b>
&nbsp;
<b class="fc">&nbsp;    public Queue(@NonNull LoadBalancer loadBalancer) {</b>
<b class="fc">&nbsp;        this.loadBalancer =  loadBalancer.sanitize();</b>
&nbsp;        // if all the executors are busy doing something, then the queue won&#39;t be maintained in
&nbsp;        // timely fashion, so use another thread to make sure it happens.
<b class="fc">&nbsp;        new MaintainTask(this).periodic();</b>
&nbsp;    }
&nbsp;
&nbsp;    public LoadBalancer getLoadBalancer() {
<b class="nc">&nbsp;        return loadBalancer;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setLoadBalancer(@NonNull LoadBalancer loadBalancer) {
<b class="nc">&nbsp;        this.loadBalancer = loadBalancer.sanitize();</b>
&nbsp;    }
&nbsp;
&nbsp;    public QueueSorter getSorter() {
<b class="nc">&nbsp;        return sorter;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setSorter(QueueSorter sorter) {
<b class="nc">&nbsp;        this.sorter = sorter;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Simple queue state persistence object.
&nbsp;     */
<b class="nc">&nbsp;    static class State {</b>
&nbsp;        public long counter;
<b class="nc">&nbsp;        public List&lt;Item&gt; items = new ArrayList&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the queue contents that was {@link #save() saved}.
&nbsp;     */
&nbsp;    public void load() {
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
&nbsp;            // Clear items, for the benefit of reloading.
<b class="nc">&nbsp;            waitingList.clear();</b>
<b class="nc">&nbsp;            blockedProjects.clear();</b>
<b class="nc">&nbsp;            buildables.clear();</b>
<b class="nc">&nbsp;            pendings.clear();</b>
&nbsp;
<b class="nc">&nbsp;            File queueFile = getXMLQueueFile();</b>
<b class="nc">&nbsp;            if (Files.exists(queueFile.toPath())) {</b>
<b class="nc">&nbsp;                Object unmarshaledObj = new XmlFile(XSTREAM, queueFile).read();</b>
&nbsp;                List items;
&nbsp;
<b class="nc">&nbsp;                if (unmarshaledObj instanceof State) {</b>
<b class="nc">&nbsp;                    State state = (State) unmarshaledObj;</b>
<b class="nc">&nbsp;                    items = state.items;</b>
<b class="nc">&nbsp;                    WaitingItem.COUNTER.set(state.counter);</b>
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // backward compatibility - it&#39;s an old List queue.xml
<b class="nc">&nbsp;                    items = (List) unmarshaledObj;</b>
<b class="nc">&nbsp;                    long maxId = 0;</b>
<b class="nc">&nbsp;                    for (Object o : items) {</b>
<b class="nc">&nbsp;                        if (o instanceof Item) {</b>
<b class="nc">&nbsp;                            maxId = Math.max(maxId, ((Item) o).id);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    WaitingItem.COUNTER.set(maxId);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                for (Object o : items) {</b>
<b class="nc">&nbsp;                    if (o instanceof Task) {</b>
&nbsp;                        // backward compatibility
<b class="nc">&nbsp;                        schedule((Task) o, 0);</b>
<b class="nc">&nbsp;                    } else if (o instanceof Item) {</b>
<b class="nc">&nbsp;                        Item item = (Item) o;</b>
&nbsp;
<b class="nc">&nbsp;                        if (item.task == null) {</b>
<b class="nc">&nbsp;                            continue;   // botched persistence. throw this one away</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (item instanceof WaitingItem) {</b>
<b class="nc">&nbsp;                            item.enter(this);</b>
<b class="nc">&nbsp;                        } else if (item instanceof BlockedItem) {</b>
<b class="nc">&nbsp;                            item.enter(this);</b>
<b class="nc">&nbsp;                        } else if (item instanceof BuildableItem) {</b>
<b class="nc">&nbsp;                            item.enter(this);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Unknown item type! &quot; + item);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                // I just had an incident where all the executors are dead at AbstractProject._getRuns()
&nbsp;                // because runs is null. Debugger revealed that this is caused by a MatrixConfiguration
&nbsp;                // object that doesn&#39;t appear to be de-serialized properly.
&nbsp;                // I don&#39;t know how this problem happened, but to diagnose this problem better
&nbsp;                // when it happens again, save the old queue file for introspection.
<b class="nc">&nbsp;                File bk = new File(queueFile.getPath() + &quot;.bak&quot;);</b>
<b class="nc">&nbsp;                Files.move(queueFile.toPath(), bk.toPath(), StandardCopyOption.REPLACE_EXISTING);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException | InvalidPathException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;Failed to load the queue file &quot; + getXMLQueueFile(), e);</b>
<b class="nc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Persists the queue contents to the disk.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void save() {
<b class="nc">&nbsp;        if (BulkChange.contains(this))  return;</b>
<b class="nc">&nbsp;        if (Jenkins.getInstanceOrNull() == null) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        XmlFile queueFile = new XmlFile(XSTREAM, getXMLQueueFile());</b>
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try {
&nbsp;            // write out the queue state we want to save
<b class="nc">&nbsp;            State state = new State();</b>
<b class="nc">&nbsp;            state.counter = WaitingItem.COUNTER.longValue();</b>
&nbsp;
&nbsp;            // write out the tasks on the queue
<b class="nc">&nbsp;            for (Item item : getItems()) {</b>
<b class="nc">&nbsp;                if (item.task instanceof TransientTask)  continue;</b>
<b class="nc">&nbsp;                state.items.add(item);</b>
&nbsp;            }
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                queueFile.write(state);</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(e instanceof ClosedByInterruptException ? Level.FINE : Level.WARNING, &quot;Failed to write out the queue file &quot; + getXMLQueueFile(), e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        SaveableListener.fireOnChange(this, queueFile);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wipes out all the items currently in the queue, as if all of them are cancelled at once.
&nbsp;     */
&nbsp;    public void clear() {
<b class="nc">&nbsp;        Jenkins.get().checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
<b class="nc">&nbsp;            for (WaitingItem i : new ArrayList&lt;&gt;(</b>
&nbsp;                    waitingList))   // copy the list as we&#39;ll modify it in the loop
<b class="nc">&nbsp;                i.cancel(this);</b>
<b class="nc">&nbsp;            blockedProjects.cancelAll();</b>
<b class="nc">&nbsp;            pendings.cancelAll();</b>
<b class="nc">&nbsp;            buildables.cancelAll();</b>
<b class="nc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        scheduleMaintenance();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*package*/ File getXMLQueueFile() {
<b class="nc">&nbsp;        String id = SystemProperties.getString(Queue.class.getName() + &quot;.id&quot;);</b>
<b class="nc">&nbsp;        if (id != null) {</b>
<b class="nc">&nbsp;            return new File(Jenkins.get().getRootDir(), &quot;queue/&quot; + id + &quot;.xml&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new File(Jenkins.get().getRootDir(), &quot;queue.xml&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #schedule(AbstractProject)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean add(AbstractProject p) {
<b class="nc">&nbsp;        return schedule(p) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedule a new build for this project.
&nbsp;     * @see #schedule(Task, int)
&nbsp;     */
&nbsp;    public @CheckForNull WaitingItem schedule(AbstractProject p) {
<b class="nc">&nbsp;        return schedule(p, p.getQuietPeriod());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedules a new build with a custom quiet period.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Left for backward compatibility with &amp;lt;1.114.
&nbsp;     *
&nbsp;     * @since 1.105
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #schedule(Task, int)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean add(AbstractProject p, int quietPeriod) {
<b class="nc">&nbsp;        return schedule(p, quietPeriod) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.521
&nbsp;     *  Use {@link #schedule2(Task, int, List)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public WaitingItem schedule(Task p, int quietPeriod, List&lt;Action&gt; actions) {
<b class="nc">&nbsp;        return schedule2(p, quietPeriod, actions).getCreateItem();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedules an execution of a task.
&nbsp;     *
&nbsp;     * @param actions
&nbsp;     *      These actions can be used for associating information scoped to a particular build, to
&nbsp;     *      the task being queued. Upon the start of the build, these {@link Action}s will be automatically
&nbsp;     *      added to the {@link Run} object, and hence available to everyone.
&nbsp;     *      For the convenience of the caller, this list can contain null, and those will be silently ignored.
&nbsp;     * @since 1.311
&nbsp;     * @return
&nbsp;     *      {@link hudson.model.queue.ScheduleResult.Refused} if Jenkins refused to add this task into the queue (for example because the system
&nbsp;     *      is about to shutdown.) Otherwise the task is either merged into existing items in the queue
&nbsp;     *      (in which case you get {@link hudson.model.queue.ScheduleResult.Existing} instance back), or a new item
&nbsp;     *      gets created in the queue (in which case you get {@link Created}.
&nbsp;     *
&nbsp;     *      Note the nature of the queue
&nbsp;     *      is that such {@link Item} only captures the state of the item at a particular moment,
&nbsp;     *      and by the time you inspect the object, some of its information can be already stale.
&nbsp;     *
&nbsp;     *      That said, one can still look at {@link Queue.Item#future}, {@link Queue.Item#getId()}, etc.
&nbsp;     */
&nbsp;    public @NonNull ScheduleResult schedule2(Task p, int quietPeriod, List&lt;Action&gt; actions) {
&nbsp;        // remove nulls
<b class="fc">&nbsp;        actions = new ArrayList&lt;&gt;(actions);</b>
<b class="fc">&nbsp;        actions.removeIf(Objects::isNull);</b>
&nbsp;
<b class="fc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
<b class="fc">&nbsp;            for (QueueDecisionHandler h : QueueDecisionHandler.all())</b>
<b class="nc">&nbsp;                if (!h.shouldSchedule(p, actions))</b>
<b class="nc">&nbsp;                    return ScheduleResult.refused();    // veto</b>
&nbsp;
<b class="fc">&nbsp;            return scheduleInternal(p, quietPeriod, actions);</b>
<b class="fc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="fc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedules an execution of a task.
&nbsp;     *
&nbsp;     * @since 1.311
&nbsp;     * @return
&nbsp;     *      {@link hudson.model.queue.ScheduleResult.Existing} if this task is already in the queue and
&nbsp;     *      therefore the add operation was no-op. Otherwise {@link hudson.model.queue.ScheduleResult.Created}
&nbsp;     *      indicates the {@link WaitingItem} object added, although the nature of the queue
&nbsp;     *      is that such {@link Item} only captures the state of the item at a particular moment,
&nbsp;     *      and by the time you inspect the object, some of its information can be already stale.
&nbsp;     *
&nbsp;     *      That said, one can still look at {@link WaitingItem#future}, {@link WaitingItem#getId()}, etc.
&nbsp;     */
&nbsp;    private @NonNull ScheduleResult scheduleInternal(Task p, int quietPeriod, List&lt;Action&gt; actions) {
<b class="fc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
<b class="fc">&nbsp;            Calendar due = new GregorianCalendar();</b>
<b class="fc">&nbsp;            due.add(Calendar.SECOND, quietPeriod);</b>
&nbsp;
&nbsp;            // Do we already have this task in the queue? Because if so, we won&#39;t schedule a new one.
<b class="fc">&nbsp;            List&lt;Item&gt; duplicatesInQueue = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (Item item : liveGetItems(p)) {</b>
<b class="nc">&nbsp;                boolean shouldScheduleItem = false;</b>
<b class="nc">&nbsp;                for (QueueAction action : item.getActions(QueueAction.class)) {</b>
<b class="nc">&nbsp;                    shouldScheduleItem |= action.shouldSchedule(actions);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                for (QueueAction action : Util.filter(actions, QueueAction.class)) {</b>
<b class="nc">&nbsp;                    shouldScheduleItem |= action.shouldSchedule(new ArrayList&lt;&gt;(item.getAllActions()));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (!shouldScheduleItem) {</b>
<b class="nc">&nbsp;                    duplicatesInQueue.add(item);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (duplicatesInQueue.isEmpty()) {</b>
<b class="fc">&nbsp;                LOGGER.log(Level.FINE, &quot;{0} added to queue&quot;, p);</b>
&nbsp;
&nbsp;                // put the item in the queue
<b class="fc">&nbsp;                WaitingItem added = new WaitingItem(due, p, actions);</b>
<b class="fc">&nbsp;                added.enter(this);</b>
<b class="fc">&nbsp;                scheduleMaintenance();   // let an executor know that a new item is in the queue.</b>
<b class="fc">&nbsp;                return ScheduleResult.created(added);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;{0} is already in the queue&quot;, p);</b>
&nbsp;
&nbsp;            // but let the actions affect the existing stuff.
<b class="nc">&nbsp;            for (Item item : duplicatesInQueue) {</b>
<b class="nc">&nbsp;                for (FoldableAction a : Util.filter(actions, FoldableAction.class)) {</b>
<b class="nc">&nbsp;                    a.foldIntoExisting(item, p, actions);</b>
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINE, &quot;after folding {0}, {1} includes {2}&quot;, new Object[] {a, item, item.getAllActions()});</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            boolean queueUpdated = false;</b>
<b class="nc">&nbsp;            for (WaitingItem wi : Util.filter(duplicatesInQueue, WaitingItem.class)) {</b>
&nbsp;                // make sure to always use the shorter of the available due times
<b class="nc">&nbsp;                if (wi.timestamp.before(due))</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;
&nbsp;                // waitingList is sorted, so when we change a timestamp we need to maintain order
<b class="nc">&nbsp;                wi.leave(this);</b>
<b class="nc">&nbsp;                wi.timestamp = due;</b>
<b class="nc">&nbsp;                wi.enter(this);</b>
<b class="nc">&nbsp;                queueUpdated = true;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (queueUpdated) scheduleMaintenance();</b>
&nbsp;
&nbsp;            // REVISIT: when there are multiple existing items in the queue that matches the incoming one,
&nbsp;            // whether the new one should affect all existing ones or not is debatable. I for myself
&nbsp;            // thought this would only affect one, so the code was bit of surprise, but I&#39;m keeping the current
&nbsp;            // behaviour.
<b class="nc">&nbsp;            return ScheduleResult.existing(duplicatesInQueue.get(0));</b>
<b class="fc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="fc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #schedule(Task, int)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean add(Task p, int quietPeriod) {
<b class="nc">&nbsp;        return schedule(p, quietPeriod) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public @CheckForNull WaitingItem schedule(Task p, int quietPeriod) {
<b class="fc">&nbsp;        return schedule(p, quietPeriod, new Action[0]);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.311
&nbsp;     *      Use {@link #schedule(Task, int, Action...)}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean add(Task p, int quietPeriod, Action... actions) {
<b class="nc">&nbsp;        return schedule(p, quietPeriod, actions) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience wrapper method around {@link #schedule(Task, int, List)}
&nbsp;     */
&nbsp;    public @CheckForNull WaitingItem schedule(Task p, int quietPeriod, Action... actions) {
<b class="fc">&nbsp;        return schedule2(p, quietPeriod, actions).getCreateItem();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience wrapper method around {@link #schedule2(Task, int, List)}
&nbsp;     */
&nbsp;    public @NonNull ScheduleResult schedule2(Task p, int quietPeriod, Action... actions) {
<b class="fc">&nbsp;        return schedule2(p, quietPeriod, Arrays.asList(actions));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Cancels the item in the queue. If the item is scheduled more than once, cancels the first occurrence.
&nbsp;     *
&nbsp;     * @return true if the project was indeed in the queue and was removed.
&nbsp;     *         false if this was no-op.
&nbsp;     */
&nbsp;    public boolean cancel(Task p) {
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;Cancelling {0}&quot;, p);</b>
<b class="nc">&nbsp;            for (WaitingItem item : waitingList) {</b>
<b class="nc">&nbsp;                if (item.task.equals(p)) {</b>
<b class="nc">&nbsp;                    return item.cancel(this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            // use bitwise-OR to make sure that both branches get evaluated all the time
<b class="nc">&nbsp;            return blockedProjects.cancel(p) != null | buildables.cancel(p) != null;</b>
<b class="nc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateSnapshot() {
<b class="fc">&nbsp;        Snapshot revised = new Snapshot(waitingList, blockedProjects, buildables, pendings);</b>
<b class="fc">&nbsp;        if (LOGGER.isLoggable(Level.FINEST)) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINEST, &quot;{0} ? {1}; leftItems={2}&quot;, new Object[] {snapshot, revised, leftItems.asMap()});</b>
&nbsp;        }
<b class="fc">&nbsp;        snapshot = revised;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean cancel(Item item) {
<b class="fc">&nbsp;        LOGGER.log(Level.FINE, &quot;Cancelling {0} item#{1}&quot;, new Object[] {item.task, item.id});</b>
<b class="fc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
<b class="fc">&nbsp;            return item.cancel(this);</b>
<b class="fc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="fc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called from {@code queue.jelly} and {@code queue-items.jelly}.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doCancelItem(@QueryParameter long id) throws IOException, ServletException {
<b class="fc">&nbsp;        Item item = getItem(id);</b>
<b class="fc">&nbsp;        if (item != null &amp;&amp; !hasReadPermission(item, true)) {</b>
<b class="nc">&nbsp;            item = null;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (item != null) {</b>
<b class="fc">&nbsp;            if (item.hasCancelPermission()) {</b>
<b class="fc">&nbsp;                if (cancel(item)) {</b>
<b class="fc">&nbsp;                    return HttpResponses.status(HttpServletResponse.SC_NO_CONTENT);</b>
&nbsp;                }
<b class="nc">&nbsp;                return HttpResponses.error(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, &quot;Could not cancel run for id &quot; + id);</b>
&nbsp;            }
<b class="fc">&nbsp;            return HttpResponses.error(422, &quot;Item for id (&quot; + id + &quot;) is not cancellable&quot;);</b>
&nbsp;        } // else too late, ignore (JENKINS-14813)
<b class="fc">&nbsp;        return HttpResponses.error(HttpServletResponse.SC_NOT_FOUND, &quot;Provided id (&quot; + id + &quot;) not found&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        return snapshot.waitingList.isEmpty() &amp;&amp; snapshot.blockedProjects.isEmpty() &amp;&amp; snapshot.buildables.isEmpty()</b>
<b class="nc">&nbsp;                &amp;&amp; snapshot.pendings.isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    private WaitingItem peek() {
<b class="nc">&nbsp;        return waitingList.iterator().next();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a snapshot of items in the queue.
&nbsp;     *
&nbsp;     * Generally speaking the array is sorted such that the items that are most likely built sooner are
&nbsp;     * at the end.
&nbsp;     */
&nbsp;    @Exported(inline = true)
&nbsp;    public Item[] getItems() {
<b class="nc">&nbsp;        Snapshot s = this.snapshot;</b>
<b class="nc">&nbsp;        List&lt;Item&gt; r = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (WaitingItem p : s.waitingList) {</b>
<b class="nc">&nbsp;            r = checkPermissionsAndAddToList(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (BlockedItem p : s.blockedProjects) {</b>
<b class="nc">&nbsp;            r = checkPermissionsAndAddToList(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (BuildableItem p : reverse(s.buildables)) {</b>
<b class="nc">&nbsp;            r = checkPermissionsAndAddToList(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (BuildableItem p : reverse(s.pendings)) {</b>
<b class="nc">&nbsp;            r = checkPermissionsAndAddToList(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Item[] items = new Item[r.size()];</b>
<b class="nc">&nbsp;        r.toArray(items);</b>
<b class="nc">&nbsp;        return items;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;Item&gt; checkPermissionsAndAddToList(List&lt;Item&gt; r, Item t) {
&nbsp;        // TODO Changing the second arg to &#39;true&#39; should reveal some tasks currently hidden for no obvious reason
<b class="nc">&nbsp;        if (hasReadPermission(t.task, false)) {</b>
<b class="nc">&nbsp;            r.add(t);</b>
&nbsp;        }
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean hasReadPermission(Item t, boolean valueIfNotAccessControlled) {
<b class="fc">&nbsp;        return hasReadPermission(t.task, valueIfNotAccessControlled);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean hasReadPermission(Queue.Task t, boolean valueIfNotAccessControlled) {
<b class="fc">&nbsp;        if (t instanceof AccessControlled) {</b>
<b class="nc">&nbsp;            AccessControlled taskAC = (AccessControlled) t;</b>
<b class="nc">&nbsp;            if (taskAC.hasPermission(hudson.model.Item.READ)</b>
<b class="nc">&nbsp;                    || taskAC.hasPermission(Permission.READ)) { // TODO should be unnecessary given the &#39;implies&#39; relationship</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        return valueIfNotAccessControlled;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an array of Item for which it is only visible the name of the task.
&nbsp;     *
&nbsp;     * Generally speaking the array is sorted such that the items that are most likely built sooner are
&nbsp;     * at the end.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @Exported(inline = true)
&nbsp;    public StubItem[] getDiscoverableItems() {
<b class="nc">&nbsp;        Snapshot s = this.snapshot;</b>
<b class="nc">&nbsp;        List&lt;StubItem&gt; r = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (WaitingItem p : s.waitingList) {</b>
<b class="nc">&nbsp;            r = filterDiscoverableItemListBasedOnPermissions(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (BlockedItem p : s.blockedProjects) {</b>
<b class="nc">&nbsp;            r = filterDiscoverableItemListBasedOnPermissions(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (BuildableItem p : reverse(s.buildables)) {</b>
<b class="nc">&nbsp;            r = filterDiscoverableItemListBasedOnPermissions(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (BuildableItem p : reverse(s.pendings)) {</b>
<b class="nc">&nbsp;            r = filterDiscoverableItemListBasedOnPermissions(r, p);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        StubItem[] items = new StubItem[r.size()];</b>
<b class="nc">&nbsp;        r.toArray(items);</b>
<b class="nc">&nbsp;        return items;</b>
&nbsp;    }
&nbsp;
&nbsp;    private List&lt;StubItem&gt; filterDiscoverableItemListBasedOnPermissions(List&lt;StubItem&gt; r, Item t) {
<b class="nc">&nbsp;        if (t.task instanceof hudson.model.Item) {</b>
<b class="nc">&nbsp;            hudson.model.Item taskAsItem = (hudson.model.Item) t.task;</b>
<b class="nc">&nbsp;            if (!taskAsItem.hasPermission(hudson.model.Item.READ)</b>
<b class="nc">&nbsp;                    &amp;&amp; taskAsItem.hasPermission(hudson.model.Item.DISCOVER)) {</b>
<b class="nc">&nbsp;                r.add(new StubItem(new StubTask(t.task)));</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Like {@link #getItems()}, but returns an approximation that might not be completely up-to-date.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * At the expense of accuracy, this method does not usually lock {@link Queue} and therefore is faster
&nbsp;     * in a highly concurrent situation.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The list obtained is an accurate snapshot of the queue at some point in the past. The snapshot
&nbsp;     * is updated and normally no more than one second old, but this is a soft commitment that might
&nbsp;     * get violated when the lock on {@link Queue} is highly contended.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is primarily added to make UI threads run faster.
&nbsp;     *
&nbsp;     * @since 1.483
&nbsp;     * @deprecated Use {@link #getItems()} directly. As of 1.607 the approximation is no longer needed.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public List&lt;Item&gt; getApproximateItemsQuickly() {
<b class="nc">&nbsp;        return Arrays.asList(getItems());</b>
&nbsp;    }
&nbsp;
&nbsp;    public Item getItem(long id) {
<b class="fc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="fc">&nbsp;        for (Item item : snapshot.blockedProjects) {</b>
<b class="nc">&nbsp;            if (item.id == id)</b>
<b class="nc">&nbsp;                return item;</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (Item item : snapshot.buildables) {</b>
<b class="nc">&nbsp;            if (item.id == id)</b>
<b class="nc">&nbsp;                return item;</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (Item item : snapshot.pendings) {</b>
<b class="nc">&nbsp;            if (item.id == id)</b>
<b class="nc">&nbsp;                return item;</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;        for (Item item : snapshot.waitingList) {</b>
<b class="fc">&nbsp;            if (item.id == id) {</b>
<b class="fc">&nbsp;                return item;</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return leftItems.getIfPresent(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the {@link BuildableItem}s that are waiting for an executor in the given {@link Computer}.
&nbsp;     */
&nbsp;    public List&lt;BuildableItem&gt; getBuildableItems(Computer c) {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        List&lt;BuildableItem&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        _getBuildableItems(c, snapshot.buildables, result);</b>
<b class="nc">&nbsp;        _getBuildableItems(c, snapshot.pendings, result);</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _getBuildableItems(Computer c, List&lt;BuildableItem&gt; col, List&lt;BuildableItem&gt; result) {
<b class="nc">&nbsp;        Node node = c.getNode();</b>
<b class="nc">&nbsp;        if (node == null)   // Deleted computers cannot take build items...</b>
&nbsp;            return;
<b class="nc">&nbsp;        for (BuildableItem p : col) {</b>
<b class="nc">&nbsp;            if (node.canTake(p) == null)</b>
<b class="nc">&nbsp;                result.add(p);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the snapshot of all {@link BuildableItem}s.
&nbsp;     */
&nbsp;    public List&lt;BuildableItem&gt; getBuildableItems() {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        ArrayList&lt;BuildableItem&gt; r = new ArrayList&lt;&gt;(snapshot.buildables);</b>
<b class="nc">&nbsp;        r.addAll(snapshot.pendings);</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the snapshot of all {@link BuildableItem}s.
&nbsp;     */
&nbsp;    public List&lt;BuildableItem&gt; getPendingItems() {
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(snapshot.pendings);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the snapshot of all {@link BlockedItem}s.
&nbsp;     */
&nbsp;    protected List&lt;BlockedItem&gt; getBlockedItems() {
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;(snapshot.blockedProjects);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the snapshot of all {@link LeftItem}s.
&nbsp;     *
&nbsp;     * @since 1.519
&nbsp;     */
&nbsp;    public Collection&lt;LeftItem&gt; getLeftItems() {
<b class="nc">&nbsp;        return Collections.unmodifiableCollection(leftItems.asMap().values());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Immediately clear the {@link #getLeftItems} cache.
&nbsp;     * Useful for tests which need to verify that no links to a build remain.
&nbsp;     * @since 1.519
&nbsp;     */
&nbsp;    public void clearLeftItems() {
<b class="nc">&nbsp;        leftItems.invalidateAll();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all items that are in the queue but not blocked
&nbsp;     *
&nbsp;     * @since 1.402
&nbsp;     */
&nbsp;    public List&lt;Item&gt; getUnblockedItems() {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        List&lt;Item&gt; queuedNotBlocked = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        queuedNotBlocked.addAll(snapshot.waitingList);</b>
<b class="nc">&nbsp;        queuedNotBlocked.addAll(snapshot.buildables);</b>
<b class="nc">&nbsp;        queuedNotBlocked.addAll(snapshot.pendings);</b>
&nbsp;        // but not &#39;blockedProjects&#39;
<b class="nc">&nbsp;        return queuedNotBlocked;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Works just like {@link #getUnblockedItems()} but return tasks.
&nbsp;     *
&nbsp;     * @since 1.402
&nbsp;     */
&nbsp;    public Set&lt;Task&gt; getUnblockedTasks() {
<b class="nc">&nbsp;        List&lt;Item&gt; items = getUnblockedItems();</b>
<b class="nc">&nbsp;        Set&lt;Task&gt; unblockedTasks = new HashSet&lt;&gt;(items.size());</b>
<b class="nc">&nbsp;        for (Queue.Item t : items)</b>
<b class="nc">&nbsp;            unblockedTasks.add(t.task);</b>
<b class="nc">&nbsp;        return unblockedTasks;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is the given task currently pending execution?
&nbsp;     */
&nbsp;    public boolean isPending(Task t) {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        for (BuildableItem i : snapshot.pendings)</b>
<b class="nc">&nbsp;            if (i.task.equals(t))</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * How many {@link BuildableItem}s are assigned for the given label?
&nbsp;     * @param l Label to be checked. If null, any label will be accepted.
&nbsp;     *    If you want to count {@link BuildableItem}s without assigned labels,
&nbsp;     *    use {@link #strictCountBuildableItemsFor(hudson.model.Label)}.
&nbsp;     * @return Number of {@link BuildableItem}s for the specified label.
&nbsp;     */
&nbsp;    public /* @java.annotation.Nonnegative */ int countBuildableItemsFor(@CheckForNull Label l) {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        int r = 0;</b>
<b class="nc">&nbsp;        for (BuildableItem bi : snapshot.buildables)</b>
<b class="nc">&nbsp;            for (SubTask st : bi.task.getSubTasks())</b>
<b class="nc">&nbsp;                if (null == l || bi.getAssignedLabelFor(st) == l)</b>
<b class="nc">&nbsp;                    r++;</b>
<b class="nc">&nbsp;        for (BuildableItem bi : snapshot.pendings)</b>
<b class="nc">&nbsp;            for (SubTask st : bi.task.getSubTasks())</b>
<b class="nc">&nbsp;                if (null == l || bi.getAssignedLabelFor(st) == l)</b>
<b class="nc">&nbsp;                    r++;</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * How many {@link BuildableItem}s are assigned for the given label?
&nbsp;     * &lt;p&gt;
&nbsp;     * The implementation is quite similar to {@link #countBuildableItemsFor(hudson.model.Label)},
&nbsp;     * but it has another behavior for null parameters.
&nbsp;     * @param l Label to be checked. If null, only jobs without assigned labels
&nbsp;     *      will be taken into the account.
&nbsp;     * @return Number of {@link BuildableItem}s for the specified label.
&nbsp;     * @since 1.615
&nbsp;     */
&nbsp;    public /* @java.annotation.Nonnegative */ int strictCountBuildableItemsFor(@CheckForNull Label l) {
<b class="nc">&nbsp;        Snapshot _snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        int r = 0;</b>
<b class="nc">&nbsp;        for (BuildableItem bi : _snapshot.buildables)</b>
<b class="nc">&nbsp;            for (SubTask st : bi.task.getSubTasks())</b>
<b class="nc">&nbsp;                if (bi.getAssignedLabelFor(st) == l)</b>
<b class="nc">&nbsp;                    r++;</b>
<b class="nc">&nbsp;        for (BuildableItem bi : _snapshot.pendings)</b>
<b class="nc">&nbsp;            for (SubTask st : bi.task.getSubTasks())</b>
<b class="nc">&nbsp;                if (bi.getAssignedLabelFor(st) == l)</b>
<b class="nc">&nbsp;                    r++;</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Counts all the {@link BuildableItem}s currently in the queue.
&nbsp;     */
&nbsp;    public int countBuildableItems() {
<b class="nc">&nbsp;        return countBuildableItemsFor(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the information about the queue item for the given project.
&nbsp;     *
&nbsp;     * @return null if the project is not in the queue.
&nbsp;     */
&nbsp;    public Item getItem(Task t) {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        for (Item item : snapshot.blockedProjects) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t))</b>
<b class="nc">&nbsp;                return item;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Item item : snapshot.buildables) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t))</b>
<b class="nc">&nbsp;                return item;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Item item : snapshot.pendings) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t))</b>
<b class="nc">&nbsp;                return item;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Item item : snapshot.waitingList) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t)) {</b>
<b class="nc">&nbsp;                return item;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the information about the queue item for the given project.
&nbsp;     *
&nbsp;     * @return null if the project is not in the queue.
&nbsp;     * @since 1.607
&nbsp;     */
&nbsp;    private List&lt;Item&gt; liveGetItems(Task t) {
<b class="fc">&nbsp;        lock.lock();</b>
&nbsp;        try {
<b class="fc">&nbsp;            List&lt;Item&gt; result = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            result.addAll(blockedProjects.getAll(t));</b>
<b class="fc">&nbsp;            result.addAll(buildables.getAll(t));</b>
&nbsp;            // Do not include pendingswe have already finalized WorkUnitContext.actions.
<b class="fc">&nbsp;            if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                List&lt;BuildableItem&gt; thePendings = pendings.getAll(t);</b>
<b class="nc">&nbsp;                if (!thePendings.isEmpty()) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;ignoring {0} during scheduleInternal&quot;, thePendings);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            for (Item item : waitingList) {</b>
<b class="nc">&nbsp;                if (item.task.equals(t)) {</b>
<b class="nc">&nbsp;                    result.add(item);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the information about the queue item for the given project.
&nbsp;     *
&nbsp;     * @return empty if the project is not in the queue.
&nbsp;     */
&nbsp;    public List&lt;Item&gt; getItems(Task t) {
<b class="nc">&nbsp;        Snapshot snapshot = this.snapshot;</b>
<b class="nc">&nbsp;        List&lt;Item&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Item item : snapshot.blockedProjects) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t)) {</b>
<b class="nc">&nbsp;                result.add(item);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Item item : snapshot.buildables) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t)) {</b>
<b class="nc">&nbsp;                result.add(item);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Item item : snapshot.pendings) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t)) {</b>
<b class="nc">&nbsp;                result.add(item);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Item item : snapshot.waitingList) {</b>
<b class="nc">&nbsp;            if (item.task.equals(t)) {</b>
<b class="nc">&nbsp;                result.add(item);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this queue contains the said project.
&nbsp;     */
&nbsp;    public boolean contains(Task t) {
<b class="nc">&nbsp;        return getItem(t) != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called when the executor actually starts executing the assigned work unit.
&nbsp;     *
&nbsp;     * This moves the task from the pending state to the &quot;left the queue&quot; state.
&nbsp;     */
&nbsp;    /*package*/ void onStartExecuting(Executor exec) throws InterruptedException {
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
<b class="nc">&nbsp;            final WorkUnit wu = exec.getCurrentWorkUnit();</b>
<b class="nc">&nbsp;            pendings.remove(wu.context.item);</b>
&nbsp;
<b class="nc">&nbsp;            LeftItem li = new LeftItem(wu.context);</b>
<b class="nc">&nbsp;            li.enter(this);</b>
<b class="nc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the queue and runs anything that can be run.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * When conditions are changed, this method should be invoked.
&nbsp;     * &lt;p&gt;
&nbsp;     * This wakes up one {@link Executor} so that it will maintain a queue.
&nbsp;     */
&nbsp;    @WithBridgeMethods(void.class)
&nbsp;    public Future&lt;?&gt; scheduleMaintenance() {
&nbsp;        // LOGGER.info(&quot;Scheduling maintenance&quot;);
<b class="fc">&nbsp;        return maintainerThread.submit();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the given item should be prevented from entering into the {@link #buildables} state
&nbsp;     * and instead stay in the {@link #blockedProjects} state.
&nbsp;     *
&nbsp;     * @return the reason of blockage if it exists null otherwise.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    private CauseOfBlockage getCauseOfBlockageForItem(Item i) {
<b class="nc">&nbsp;        CauseOfBlockage causeOfBlockage = getCauseOfBlockageForTask(i.task);</b>
<b class="nc">&nbsp;        if (causeOfBlockage != null) {</b>
<b class="nc">&nbsp;            return causeOfBlockage;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (QueueTaskDispatcher d : QueueTaskDispatcher.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                causeOfBlockage = d.canRun(i);</b>
<b class="nc">&nbsp;            } catch (Throwable t) {</b>
&nbsp;                // We cannot guarantee the task can be run because something wrong happened
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, t, () -&gt; String.format(&quot;Exception evaluating if the queue can run the task &#39;%s&#39;&quot;, i.task.getName()));</b>
<b class="nc">&nbsp;                causeOfBlockage = CauseOfBlockage.fromMessage(Messages._Queue_ExceptionCanRun());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (causeOfBlockage != null)</b>
<b class="nc">&nbsp;                return causeOfBlockage;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (!(i instanceof BuildableItem)) {</b>
&nbsp;            // Make sure we don&#39;t queue two tasks of the same project to be built
&nbsp;            // unless that project allows concurrent builds. Once item is buildable it&#39;s ok.
&nbsp;            //
&nbsp;            // This check should never pass. And must be remove once we can completely rely on `getCauseOfBlockage`.
&nbsp;            // If `task.isConcurrentBuild` returns `false`,
&nbsp;            // it should also return non-null value for `task.getCauseOfBlockage` in case of on-going execution.
&nbsp;            // But both are public non-final methods, so, we need to keep backward compatibility here.
&nbsp;            // And check one more time across all `buildables` and `pendings` for O(N) each.
<b class="nc">&nbsp;            if (!i.task.isConcurrentBuild() &amp;&amp; (buildables.containsKey(i.task) || pendings.containsKey(i.task))) {</b>
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_InProgress());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *
&nbsp;     * Checks if the given task knows the reasons to be blocked or it needs some unavailable resources
&nbsp;     *
&nbsp;     * @param task the task.
&nbsp;     * @return the reason of blockage if it exists null otherwise.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    private CauseOfBlockage getCauseOfBlockageForTask(Task task) {
<b class="nc">&nbsp;        CauseOfBlockage causeOfBlockage = task.getCauseOfBlockage();</b>
<b class="nc">&nbsp;        if (causeOfBlockage != null) {</b>
<b class="nc">&nbsp;            return causeOfBlockage;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!canRun(task.getResourceList())) {</b>
<b class="nc">&nbsp;            ResourceActivity r = getBlockingActivity(task);</b>
<b class="nc">&nbsp;            if (r != null) {</b>
<b class="nc">&nbsp;                if (r == task) // blocked by itself, meaning another build is in progress</b>
<b class="nc">&nbsp;                    return CauseOfBlockage.fromMessage(Messages._Queue_InProgress());</b>
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_BlockedBy(r.getDisplayName()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some operations require to be performed with the {@link Queue} lock held. Use one of these methods rather
&nbsp;     * than locking directly on Queue in order to allow for future refactoring.
&nbsp;     * @param runnable the operation to perform.
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    public static void withLock(Runnable runnable) {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        if (queue == null) {</b>
<b class="nc">&nbsp;            runnable.run();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            queue._withLock(runnable);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some operations require the {@link Queue} lock held. Use one of these methods rather
&nbsp;     * than locking directly on Queue in order to allow for future refactoring.
&nbsp;     *
&nbsp;     * @param callable the operation to perform.
&nbsp;     * @param &lt;V&gt;      the type of return value
&nbsp;     * @param &lt;T&gt;      the type of exception.
&nbsp;     * @return the result of the callable.
&nbsp;     * @throws T the exception of the callable
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    public static &lt;V, T extends Throwable&gt; V withLock(hudson.remoting.Callable&lt;V, T&gt; callable) throws T {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        if (queue == null) {</b>
<b class="nc">&nbsp;            return callable.call();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return queue._withLock(callable);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some operations require to be performed with the {@link Queue} lock held. Use one of these methods rather
&nbsp;     * than locking directly on Queue in order to allow for future refactoring.
&nbsp;     *
&nbsp;     * @param callable the operation to perform.
&nbsp;     * @param &lt;V&gt;      the type of return value
&nbsp;     * @return the result of the callable.
&nbsp;     * @throws Exception if the callable throws an exception.
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    public static &lt;V&gt; V withLock(java.util.concurrent.Callable&lt;V&gt; callable) throws Exception {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        if (queue == null) {</b>
<b class="nc">&nbsp;            return callable.call();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return queue._withLock(callable);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the supplied {@link Runnable} if the {@link Queue} lock was obtained without blocking.
&nbsp;     *
&nbsp;     * @param runnable the operation to perform.
&nbsp;     * @return {@code true} if the lock was available and the operation was performed.
&nbsp;     * @since 1.618
&nbsp;     */
&nbsp;    public static boolean tryWithLock(Runnable runnable) {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        if (queue == null) {</b>
<b class="nc">&nbsp;            runnable.run();</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return queue._tryWithLock(runnable);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * Wraps a {@link Runnable} with the  {@link Queue} lock held.
&nbsp;     *
&nbsp;     * @param runnable the operation to wrap.
&nbsp;     * @since 1.618
&nbsp;     */
&nbsp;
&nbsp;    public static Runnable wrapWithLock(Runnable runnable) {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        return queue == null ? runnable : new LockedRunnable(runnable);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps a {@link hudson.remoting.Callable} with the  {@link Queue} lock held.
&nbsp;     *
&nbsp;     * @param callable the operation to wrap.
&nbsp;     * @since 1.618
&nbsp;     */
&nbsp;    public static &lt;V, T extends Throwable&gt; hudson.remoting.Callable&lt;V, T&gt; wrapWithLock(hudson.remoting.Callable&lt;V, T&gt; callable) {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        return queue == null ? callable : new LockedHRCallable&lt;&gt;(callable);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps a {@link java.util.concurrent.Callable} with the {@link Queue} lock held.
&nbsp;     *
&nbsp;     * @param callable the operation to wrap.
&nbsp;     * @since 1.618
&nbsp;     */
&nbsp;    public static &lt;V&gt; java.util.concurrent.Callable&lt;V&gt; wrapWithLock(java.util.concurrent.Callable&lt;V&gt; callable) {
<b class="nc">&nbsp;        final Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
&nbsp;        // TODO confirm safe to assume non-null and use getInstance()
<b class="nc">&nbsp;        final Queue queue = jenkins == null ? null : jenkins.getQueue();</b>
<b class="nc">&nbsp;        return queue == null ? callable : new LockedJUCCallable&lt;&gt;(callable);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @SuppressFBWarnings(value = &quot;WA_AWAIT_NOT_IN_LOOP&quot;, justification = &quot;the caller does indeed call this method in a loop&quot;)
&nbsp;    protected void _await() throws InterruptedException {
<b class="nc">&nbsp;        condition.await();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void _signalAll() {
<b class="nc">&nbsp;        condition.signalAll();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some operations require to be performed with the {@link Queue} lock held. Use one of these methods rather
&nbsp;     * than locking directly on Queue in order to allow for future refactoring.
&nbsp;     * @param runnable the operation to perform.
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected void _withLock(Runnable runnable) {
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            runnable.run();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the supplied {@link Runnable} if the {@link Queue} lock was obtained without blocking.
&nbsp;     *
&nbsp;     * @param runnable the operation to perform.
&nbsp;     * @return {@code true} if the lock was available and the operation was performed.
&nbsp;     * @since 1.618
&nbsp;     */
&nbsp;    protected boolean _tryWithLock(Runnable runnable) {
<b class="nc">&nbsp;        if (lock.tryLock()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                runnable.run();</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                lock.unlock();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some operations require to be performed with the {@link Queue} lock held. Use one of these methods rather
&nbsp;     * than locking directly on Queue in order to allow for future refactoring.
&nbsp;     *
&nbsp;     * @param callable the operation to perform.
&nbsp;     * @param &lt;V&gt;      the type of return value
&nbsp;     * @param &lt;T&gt;      the type of exception.
&nbsp;     * @return the result of the callable.
&nbsp;     * @throws T the exception of the callable
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected &lt;V, T extends Throwable&gt; V _withLock(hudson.remoting.Callable&lt;V, T&gt; callable) throws T {
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return callable.call();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Some operations require to be performed with the {@link Queue} lock held. Use one of these methods rather
&nbsp;     * than locking directly on Queue in order to allow for future refactoring.
&nbsp;     *
&nbsp;     * @param callable the operation to perform.
&nbsp;     * @param &lt;V&gt;      the type of return value
&nbsp;     * @return the result of the callable.
&nbsp;     * @throws Exception if the callable throws an exception.
&nbsp;     * @since 1.592
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected &lt;V&gt; V _withLock(java.util.concurrent.Callable&lt;V&gt; callable) throws Exception {
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return callable.call();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Queue maintenance.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Move projects between {@link #waitingList}, {@link #blockedProjects}, {@link #buildables}, and {@link #pendings}
&nbsp;     * appropriately.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Jenkins internally invokes this method by itself whenever there&#39;s a change that can affect
&nbsp;     * the scheduling (such as new node becoming online, # of executors change, a task completes execution, etc.),
&nbsp;     * and it also gets invoked periodically (see {@link Queue.MaintainTask}.)
&nbsp;     */
&nbsp;    public void maintain() {
<b class="fc">&nbsp;        Jenkins jenkins = Jenkins.getInstanceOrNull();</b>
<b class="fc">&nbsp;        if (jenkins == null) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        lock.lock();</b>
&nbsp;        try { try {
&nbsp;
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;Queue maintenance started on {0} with {1}&quot;, new Object[] {this, snapshot});</b>
&nbsp;
&nbsp;            // The executors that are currently waiting for a job to run.
<b class="nc">&nbsp;            Map&lt;Executor, JobOffer&gt; parked = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;            { // update parked (and identify any pending items whose executor has disappeared)
<b class="nc">&nbsp;                List&lt;BuildableItem&gt; lostPendings = new ArrayList&lt;&gt;(pendings);</b>
<b class="nc">&nbsp;                for (Computer c : jenkins.getComputers()) {</b>
<b class="nc">&nbsp;                    for (Executor e : c.getAllExecutors()) {</b>
<b class="nc">&nbsp;                        if (e.isInterrupted()) {</b>
&nbsp;                            // JENKINS-28840 we will deadlock if we try to touch this executor while interrupt flag set
&nbsp;                            // we need to clear lost pendings as we cannot know what work unit was on this executor
&nbsp;                            // while it is interrupted. (All this dancing is a result of Executor extending Thread)
<b class="nc">&nbsp;                            lostPendings.clear(); // we&#39;ll get them next time around when the flag is cleared.</b>
<b class="nc">&nbsp;                            LOGGER.log(Level.FINEST,</b>
&nbsp;                                    &quot;Interrupt thread for executor {0} is set and we do not know what work unit was on the executor.&quot;,
<b class="nc">&nbsp;                                    e.getDisplayName());</b>
<b class="nc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (e.isParking()) {</b>
<b class="nc">&nbsp;                            LOGGER.log(Level.FINEST, &quot;{0} is parking and is waiting for a job to execute.&quot;, e.getDisplayName());</b>
<b class="nc">&nbsp;                            parked.put(e, new JobOffer(e));</b>
&nbsp;                        }
<b class="nc">&nbsp;                        final WorkUnit workUnit = e.getCurrentWorkUnit();</b>
<b class="nc">&nbsp;                        if (workUnit != null) {</b>
<b class="nc">&nbsp;                            lostPendings.remove(workUnit.context.item);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // pending -&gt; buildable
<b class="nc">&nbsp;                for (BuildableItem p : lostPendings) {</b>
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(Level.FINE)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINE,</b>
&nbsp;                            &quot;BuildableItem {0}: pending -&gt; buildable as the assigned executor disappeared&quot;,
<b class="nc">&nbsp;                            p.task.getFullDisplayName());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    p.isPending = false;</b>
<b class="nc">&nbsp;                    pendings.remove(p);</b>
<b class="nc">&nbsp;                    makeBuildable(p); // TODO whatever this is for, the return value is being ignored, so this does nothing at all</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            final QueueSorter s = sorter;</b>
&nbsp;
&nbsp;            { // blocked -&gt; buildable
&nbsp;                // copy as we&#39;ll mutate the list and we want to process in a potentially different order
<b class="nc">&nbsp;                List&lt;BlockedItem&gt; blockedItems = new ArrayList&lt;&gt;(blockedProjects.values());</b>
&nbsp;                // if facing a cycle of blocked tasks, ensure we process in the desired sort order
<b class="nc">&nbsp;                if (s != null) {</b>
<b class="nc">&nbsp;                    s.sortBlockedItems(blockedItems);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    blockedItems.sort(QueueSorter.DEFAULT_BLOCKED_ITEM_COMPARATOR);</b>
&nbsp;                }
<b class="nc">&nbsp;                for (BlockedItem p : blockedItems) {</b>
<b class="nc">&nbsp;                    String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINEST, &quot;Current blocked item: {0}&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;                    CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);</b>
<b class="nc">&nbsp;                    if (causeOfBlockage == null) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINEST,</b>
&nbsp;                                &quot;BlockedItem {0}: blocked -&gt; buildable as the build is not blocked and new tasks are allowed&quot;,
&nbsp;                                taskDisplayName);
&nbsp;
&nbsp;                        // ready to be executed
<b class="nc">&nbsp;                        Runnable r = makeBuildable(new BuildableItem(p));</b>
<b class="nc">&nbsp;                        if (r != null) {</b>
<b class="nc">&nbsp;                            p.leave(this);</b>
<b class="nc">&nbsp;                            r.run();</b>
&nbsp;                            // JENKINS-28926 we have removed a task from the blocked projects and added to building
&nbsp;                            // thus we should update the snapshot so that subsequent blocked projects can correctly
&nbsp;                            // determine if they are blocked by the lucky winner
<b class="nc">&nbsp;                            updateSnapshot();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        p.setCauseOfBlockage(causeOfBlockage);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // waitingList -&gt; buildable/blocked
<b class="nc">&nbsp;            while (!waitingList.isEmpty()) {</b>
<b class="nc">&nbsp;                WaitingItem top = peek();</b>
&nbsp;
<b class="nc">&nbsp;                if (top.timestamp.compareTo(new GregorianCalendar()) &gt; 0) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINEST, &quot;Finished moving all ready items from queue.&quot;);</b>
<b class="nc">&nbsp;                    break; // finished moving all ready items from queue</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                top.leave(this);</b>
<b class="nc">&nbsp;                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(top);</b>
<b class="nc">&nbsp;                if (causeOfBlockage == null) {</b>
&nbsp;                    // ready to be executed immediately
<b class="nc">&nbsp;                    Runnable r = makeBuildable(new BuildableItem(top));</b>
<b class="nc">&nbsp;                    String topTaskDisplayName = LOGGER.isLoggable(Level.FINEST) ? top.task.getFullDisplayName() : null;</b>
<b class="nc">&nbsp;                    if (r != null) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINEST, &quot;Executing runnable {0}&quot;, topTaskDisplayName);</b>
<b class="nc">&nbsp;                        r.run();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        LOGGER.log(Level.FINEST, &quot;Item {0} was unable to be made a buildable and is now a blocked item.&quot;, topTaskDisplayName);</b>
<b class="nc">&nbsp;                        new BlockedItem(top, CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown())).enter(this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    // this can&#39;t be built now because another build is in progress
&nbsp;                    // set this project aside.
<b class="nc">&nbsp;                    new BlockedItem(top, causeOfBlockage).enter(this);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (s != null) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    s.sortBuildableItems(buildables);</b>
<b class="nc">&nbsp;                } catch (Throwable e) {</b>
&nbsp;                    // We don&#39;t really care if the sort doesn&#39;t sort anything, we still should
&nbsp;                    // continue to do our job. We&#39;ll complain about it and continue.
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;s.sortBuildableItems() threw Throwable: {0}&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            // Ensure that identification of blocked tasks is using the live state: JENKINS-27708 &amp; JENKINS-27871
<b class="nc">&nbsp;            updateSnapshot();</b>
&nbsp;
&nbsp;            // allocate buildable jobs to executors
<b class="nc">&nbsp;            for (BuildableItem p : new ArrayList&lt;&gt;(</b>
&nbsp;                    buildables)) { // copy as we&#39;ll mutate the list in the loop
&nbsp;                // one last check to make sure this build is not blocked.
<b class="nc">&nbsp;                CauseOfBlockage causeOfBlockage = getCauseOfBlockageForItem(p);</b>
<b class="nc">&nbsp;                if (causeOfBlockage != null) {</b>
<b class="nc">&nbsp;                    p.leave(this);</b>
<b class="nc">&nbsp;                    new BlockedItem(p, causeOfBlockage).enter(this);</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Catching that {0} is blocked in the last minute&quot;, p);</b>
&nbsp;                    // JENKINS-28926 we have moved an unblocked task into the blocked state, update snapshot
&nbsp;                    // so that other buildables which might have been blocked by this can see the state change
<b class="nc">&nbsp;                    updateSnapshot();</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;</b>
&nbsp;
<b class="nc">&nbsp;                if (p.task instanceof FlyweightTask) {</b>
<b class="nc">&nbsp;                    Runnable r = makeFlyWeightTaskBuildable(new BuildableItem(p));</b>
<b class="nc">&nbsp;                    if (r != null) {</b>
<b class="nc">&nbsp;                        p.leave(this);</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINEST, &quot;Executing flyweight task {0}&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;                        r.run();</b>
<b class="nc">&nbsp;                        updateSnapshot();</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
&nbsp;
<b class="nc">&nbsp;                    List&lt;JobOffer&gt; candidates = new ArrayList&lt;&gt;(parked.size());</b>
<b class="nc">&nbsp;                    Map&lt;Node, CauseOfBlockage&gt; reasonMap = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;                    for (JobOffer j : parked.values()) {</b>
<b class="nc">&nbsp;                        Node offerNode = j.getNode();</b>
&nbsp;                        CauseOfBlockage reason;
<b class="nc">&nbsp;                        if (reasonMap.containsKey(offerNode)) {</b>
<b class="nc">&nbsp;                            reason = reasonMap.get(offerNode);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            reason = j.getCauseOfBlockage(p);</b>
<b class="nc">&nbsp;                            reasonMap.put(offerNode, reason);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (reason == null) {</b>
<b class="nc">&nbsp;                            LOGGER.log(Level.FINEST,</b>
&nbsp;                                    &quot;{0} is a potential candidate for task {1}&quot;,
&nbsp;                                    new Object[]{j, taskDisplayName});
<b class="nc">&nbsp;                            candidates.add(j);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            LOGGER.log(Level.FINEST, &quot;{0} rejected {1}: {2}&quot;, new Object[] {j, taskDisplayName, reason});</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
<b class="nc">&nbsp;                    MappingWorksheet ws = new MappingWorksheet(p, candidates);</b>
<b class="nc">&nbsp;                    Mapping m = loadBalancer.map(p.task, ws);</b>
<b class="nc">&nbsp;                    if (m == null) {</b>
&nbsp;                        // if we couldn&#39;t find the executor that fits,
&nbsp;                        // just leave it in the buildables list and
&nbsp;                        // check if we can execute other projects
<b class="nc">&nbsp;                        LOGGER.log(Level.FINER, &quot;Failed to map {0} to executors. candidates={1} parked={2}&quot;,</b>
<b class="nc">&nbsp;                                new Object[]{p, candidates, parked.values()});</b>
<b class="nc">&nbsp;                        List&lt;CauseOfBlockage&gt; reasons = reasonMap.values().stream().filter(Objects::nonNull).collect(Collectors.toList());</b>
<b class="nc">&nbsp;                        p.transientCausesOfBlockage = reasons.isEmpty() ? null : reasons;</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    // found a matching executor. use it.
<b class="nc">&nbsp;                    WorkUnitContext wuc = new WorkUnitContext(p);</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINEST, &quot;Found a matching executor for {0}. Using it.&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;                    m.execute(wuc);</b>
&nbsp;
<b class="nc">&nbsp;                    p.leave(this);</b>
<b class="nc">&nbsp;                    if (!wuc.getWorkUnits().isEmpty()) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.FINEST, &quot;BuildableItem {0} marked as pending.&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;                        makePending(p);</b>
&nbsp;                    }
&nbsp;                    else
<b class="nc">&nbsp;                        LOGGER.log(Level.FINEST, &quot;BuildableItem {0} with empty work units!?&quot;, p);</b>
&nbsp;
&nbsp;                    // Ensure that identification of blocked tasks is using the live state: JENKINS-27708 &amp; JENKINS-27871
&nbsp;                    // The creation of a snapshot itself should be relatively cheap given the expected rate of
&nbsp;                    // job execution. You probably would need 100&#39;s of jobs starting execution every iteration
&nbsp;                    // of maintain() before this could even start to become an issue and likely the calculation
&nbsp;                    // of getCauseOfBlockageForItem(p) will become a bottleneck before updateSnapshot() will. Additionally
&nbsp;                    // since the snapshot itself only ever has at most one reference originating outside of the stack
&nbsp;                    // it should remain in the eden space and thus be cheap to GC.
&nbsp;                    // See https://issues.jenkins.io/browse/JENKINS-27708?focusedCommentId=225819&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-225819
&nbsp;                    // or https://issues.jenkins.io/browse/JENKINS-27708?focusedCommentId=225906&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-225906
&nbsp;                    // for alternative fixes of this issue.
<b class="nc">&nbsp;                    updateSnapshot();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } finally { updateSnapshot(); } } finally {</b>
<b class="nc">&nbsp;            lock.unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to make an item ready to build.
&nbsp;     * @param p a proposed buildable item
&nbsp;     * @return a thunk to actually prepare it (after leaving an earlier list), or null if it cannot be run now
&nbsp;     */
&nbsp;    private @CheckForNull Runnable makeBuildable(final BuildableItem p) {
<b class="nc">&nbsp;        if (p.task instanceof FlyweightTask) {</b>
<b class="nc">&nbsp;            String taskDisplayName = LOGGER.isLoggable(Level.FINEST) ? p.task.getFullDisplayName() : null;</b>
<b class="nc">&nbsp;            if (!isBlockedByShutdown(p.task)) {</b>
&nbsp;
<b class="nc">&nbsp;                Runnable runnable = makeFlyWeightTaskBuildable(p);</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINEST, &quot;Converting flyweight task: {0} into a BuildableRunnable&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;                if (runnable != null) {</b>
<b class="nc">&nbsp;                    return runnable;</b>
&nbsp;                }
&nbsp;
&nbsp;                //this is to solve JENKINS-30084: the task has to be buildable to force the provisioning of nodes.
&nbsp;                //if the execution gets here, it means the task could not be scheduled since the node
&nbsp;                //the task is supposed to run on is offline or not available.
&nbsp;                //Thus, the flyweighttask enters the buildables queue and will ask Jenkins to provision a node
<b class="nc">&nbsp;                LOGGER.log(Level.FINEST, &quot;Flyweight task {0} is entering as buildable to provision a node.&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;                return new BuildableRunnable(p);</b>
&nbsp;            }
&nbsp;            // if the execution gets here, it means the task is blocked by shutdown and null is returned.
<b class="nc">&nbsp;            LOGGER.log(Level.FINEST, &quot;Task {0} is blocked by shutdown.&quot;, taskDisplayName);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } else {
&nbsp;            // regular heavyweight task
<b class="nc">&nbsp;            return new BuildableRunnable(p);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks if the flyweight task can be run on any of the available executors
&nbsp;     * @param p - the flyweight task to be scheduled
&nbsp;     * @return a Runnable if there is an executor that can take the task, null otherwise
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    private Runnable makeFlyWeightTaskBuildable(final BuildableItem p) {
&nbsp;        //we double check if this is a flyweight task
<b class="nc">&nbsp;        if (p.task instanceof FlyweightTask) {</b>
<b class="nc">&nbsp;            Jenkins h = Jenkins.get();</b>
&nbsp;
<b class="nc">&nbsp;            Label lbl = p.getAssignedLabel();</b>
&nbsp;
<b class="nc">&nbsp;            Computer masterComputer = h.toComputer();</b>
<b class="nc">&nbsp;            if (lbl != null &amp;&amp; lbl.equals(h.getSelfLabel())) {</b>
&nbsp;                // the flyweight task is bound to the master
<b class="nc">&nbsp;                if (h.canTake(p) == null) {</b>
<b class="nc">&nbsp;                    return createFlyWeightTaskRunnable(p, masterComputer);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (lbl == null &amp;&amp; h.canTake(p) == null &amp;&amp; masterComputer.isOnline() &amp;&amp; masterComputer.isAcceptingTasks()) {</b>
&nbsp;                // The flyweight task is not tied to a specific label, so execute on master if possible.
&nbsp;                // This will ensure that actual agent disconnects do not impact flyweight tasks randomly assigned to them.
<b class="nc">&nbsp;                return createFlyWeightTaskRunnable(p, masterComputer);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Map&lt;Node, Integer&gt; hashSource = new HashMap&lt;&gt;(h.getNodes().size());</b>
&nbsp;
<b class="nc">&nbsp;            for (Node n : h.getNodes()) {</b>
<b class="nc">&nbsp;                hashSource.put(n, n.getNumExecutors() * 100);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            ConsistentHash&lt;Node&gt; hash = new ConsistentHash&lt;&gt;(NODE_HASH);</b>
<b class="nc">&nbsp;            hash.addAll(hashSource);</b>
&nbsp;
<b class="nc">&nbsp;            String fullDisplayName = p.task.getFullDisplayName();</b>
<b class="nc">&nbsp;            for (Node n : hash.list(fullDisplayName)) {</b>
<b class="nc">&nbsp;                final Computer c = n.toComputer();</b>
<b class="nc">&nbsp;                if (c == null || c.isOffline()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (lbl != null &amp;&amp; !lbl.contains(n)) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if (n.canTake(p) != null) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return createFlyWeightTaskRunnable(p, c);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Runnable createFlyWeightTaskRunnable(final BuildableItem p, final Computer c) {
<b class="nc">&nbsp;        if (LOGGER.isLoggable(Level.FINEST)) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINEST, &quot;Creating flyweight task {0} for computer {1}&quot;,</b>
<b class="nc">&nbsp;                    new Object[]{p.task.getFullDisplayName(), c.getName()});</b>
&nbsp;        }
<b class="nc">&nbsp;        return () -&gt; {</b>
<b class="nc">&nbsp;            c.startFlyWeightTask(new WorkUnitContext(p).createWorkUnit(p.task));</b>
<b class="nc">&nbsp;            makePending(p);</b>
&nbsp;        };
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final ConsistentHash.Hash&lt;Node&gt; NODE_HASH = Node::getNodeName;</b>
&nbsp;
&nbsp;    private boolean makePending(BuildableItem p) {
&nbsp;        // LOGGER.info(&quot;Making &quot;+p.task+&quot; pending&quot;); // REMOVE
<b class="nc">&nbsp;        p.isPending = true;</b>
<b class="nc">&nbsp;        return pendings.add(p);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated Use {@link #isBlockedByShutdown} instead. */
&nbsp;    @Deprecated
&nbsp;    public static boolean ifBlockedByHudsonShutdown(Task task) {
<b class="nc">&nbsp;        return isBlockedByShutdown(task);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a task should not be scheduled because {@link Jenkins#isQuietingDown()}.
&nbsp;     * @param task some queue task
&nbsp;     * @return true if {@link Jenkins#isQuietingDown()} unless this is a {@link NonBlockingTask}
&nbsp;     * @since 1.598
&nbsp;     */
&nbsp;    public static boolean isBlockedByShutdown(Task task) {
<b class="nc">&nbsp;        return Jenkins.get().isQuietingDown() &amp;&amp; !(task instanceof NonBlockingTask);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks {@link Task}s that are not persisted.
&nbsp;     * @since 1.311
&nbsp;     */
&nbsp;    public interface TransientTask extends Task {}
&nbsp;
&nbsp;    /**
&nbsp;     * Marks {@link Task}s that do not consume {@link Executor}.
&nbsp;     * @see OneOffExecutor
&nbsp;     * @since 1.318
&nbsp;     */
&nbsp;    public interface FlyweightTask extends Task {}
&nbsp;
&nbsp;    /**
&nbsp;     * Marks {@link Task}s that are not affected by the {@linkplain Jenkins#isQuietingDown()}  quieting down},
&nbsp;     * because these tasks keep other tasks executing.
&nbsp;     * @see #isBlockedByShutdown
&nbsp;     * @since 1.336
&nbsp;     */
&nbsp;    public interface NonBlockingTask extends Task {}
&nbsp;
&nbsp;    /**
&nbsp;     * Task whose execution is controlled by the queue.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link #equals(Object) Value equality} of {@link Task}s is used
&nbsp;     * to collapse two tasks into one. This is used to avoid infinite
&nbsp;     * queue backlog.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Pending {@link Task}s are persisted when Hudson shuts down, so
&nbsp;     * it needs to be persistable via XStream. To create a non-persisted
&nbsp;     * transient Task, extend {@link TransientTask} marker interface.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Plugins are encouraged to implement {@link AccessControlled} otherwise
&nbsp;     * the tasks will be hidden from display in the queue.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * For historical reasons, {@link Task} object by itself
&nbsp;     * also represents the &quot;primary&quot; sub-task (and as implied by this
&nbsp;     * design, a {@link Task} must have at least one sub-task.)
&nbsp;     * Most of the time, the primary subtask is the only sub task.
&nbsp;     */
&nbsp;    public interface Task extends ModelObject, SubTask {
&nbsp;        /**
&nbsp;         * Returns true if the execution should be blocked
&nbsp;         * for temporary reasons.
&nbsp;         * @deprecated Use {@link #getCauseOfBlockage} != null
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        default boolean isBuildBlocked() {
<b class="nc">&nbsp;            return getCauseOfBlockage() != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated as of 1.330
&nbsp;         *      Use {@link CauseOfBlockage#getShortDescription()} instead.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        default String getWhyBlocked() {
<b class="nc">&nbsp;            CauseOfBlockage cause = getCauseOfBlockage();</b>
<b class="nc">&nbsp;            return cause != null ? cause.getShortDescription() : null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If the execution of this task should be blocked for temporary reasons,
&nbsp;         * this method returns a non-null object explaining why.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * Otherwise this method returns null, indicating that the build can proceed right away.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This can be used to define mutual exclusion that goes beyond
&nbsp;         * {@link #getResourceList()}.
&nbsp;         * @return by default, null
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        default CauseOfBlockage getCauseOfBlockage() {
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Unique name of this task.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This method is no longer used, left here for compatibility. Just return {@link #getDisplayName()}.
&nbsp;         */
&nbsp;        String getName();
&nbsp;
&nbsp;        /**
&nbsp;         * @see hudson.model.Item#getFullDisplayName()
&nbsp;         */
&nbsp;        String getFullDisplayName();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns task-specific key which is used by the {@link LoadBalancer} to choose one particular executor
&nbsp;         * amongst all the free executors on all possibly suitable nodes.
&nbsp;         * NOTE: To be able to re-use the same node during the next run this key should not change from one run to
&nbsp;         * another. You probably want to compute that key based on the job&#39;s name.
&nbsp;         *
&nbsp;         * @return by default: {@link #getFullDisplayName()}
&nbsp;         * @see hudson.model.LoadBalancer
&nbsp;         */
<b class="nc">&nbsp;        default String getAffinityKey() { return getFullDisplayName(); }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Checks the permission to see if the current user can abort this executable.
&nbsp;         * Returns normally from this method if it&#39;s OK.
&nbsp;         * &lt;p&gt;
&nbsp;         * NOTE: If you have implemented {@link AccessControlled} this defaults to
&nbsp;         * {@code checkPermission(hudson.model.Item.CANCEL);}
&nbsp;         *
&nbsp;         * @throws AccessDeniedException if the permission is not granted.
&nbsp;         */
&nbsp;        default void checkAbortPermission() {
<b class="nc">&nbsp;            if (this instanceof AccessControlled) {</b>
<b class="nc">&nbsp;                ((AccessControlled) this).checkPermission(CANCEL);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Works just like {@link #checkAbortPermission()} except it indicates the status by a return value,
&nbsp;         * instead of exception.
&nbsp;         * Also used by default for {@link hudson.model.Queue.Item#hasCancelPermission}.
&nbsp;         * &lt;p&gt;
&nbsp;         * NOTE: If you have implemented {@link AccessControlled} this returns by default
&nbsp;         * {@code return hasPermission(hudson.model.Item.CANCEL);}
&nbsp;         *
&nbsp;         * @return false
&nbsp;         *      if the user doesn&#39;t have the permission.
&nbsp;         */
&nbsp;        default boolean hasAbortPermission() {
<b class="nc">&nbsp;            if (this instanceof AccessControlled) {</b>
<b class="nc">&nbsp;                return ((AccessControlled) this).hasPermission(CANCEL);</b>
&nbsp;            }
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the URL of this task relative to the context root of the application.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * When the user clicks an item in the queue, this is the page where the user is taken to.
&nbsp;         * Hudson expects the current instance to be bound to the URL returned by this method.
&nbsp;         *
&nbsp;         * @return
&nbsp;         *      URL that ends with &#39;/&#39;.
&nbsp;         */
&nbsp;        String getUrl();
&nbsp;
&nbsp;        /**
&nbsp;         * True if the task allows concurrent builds, where the same {@link Task} is executed
&nbsp;         * by multiple executors concurrently on the same or different nodes.
&nbsp;         * @return by default, false
&nbsp;         * @since 1.338
&nbsp;         */
&nbsp;        default boolean isConcurrentBuild() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Obtains the {@link SubTask}s that constitute this task.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * The collection returned by this method must also contain the primary {@link SubTask}
&nbsp;         * represented by this {@link Task} object itself as the first element.
&nbsp;         * The returned value is read-only.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * At least size 1.
&nbsp;         *
&nbsp;         * @return by default, {@code this}
&nbsp;         * @since 1.377
&nbsp;         */
&nbsp;        default Collection&lt;? extends SubTask&gt; getSubTasks() {
<b class="nc">&nbsp;            return Set.of(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * This method allows the task to provide the default fallback authentication object to be used
&nbsp;         * when {@link QueueItemAuthenticator} fails to authenticate the build.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * When the task execution touches other objects inside Jenkins, the access control is performed
&nbsp;         * based on whether this {@link Authentication} is allowed to use them.
&nbsp;         *
&nbsp;         * @return by default, {@link ACL#SYSTEM2}
&nbsp;         * @since 2.266
&nbsp;         * @see QueueItemAuthenticator
&nbsp;         * @see Tasks#getDefaultAuthenticationOf(Queue.Task)
&nbsp;         */
&nbsp;        default @NonNull Authentication getDefaultAuthentication2() {
<b class="nc">&nbsp;            if (Util.isOverridden(Queue.Task.class, getClass(), &quot;getDefaultAuthentication&quot;)) {</b>
<b class="nc">&nbsp;                return getDefaultAuthentication().toSpring();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return ACL.SYSTEM2;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #getDefaultAuthentication2()}
&nbsp;         * @since 1.520
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        default @NonNull org.acegisecurity.Authentication getDefaultAuthentication() {
<b class="nc">&nbsp;            return org.acegisecurity.Authentication.fromSpring(getDefaultAuthentication2());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * This method allows the task to provide the default fallback authentication object to be used
&nbsp;         * when {@link QueueItemAuthenticator} fails to authenticate the build.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * When the task execution touches other objects inside Jenkins, the access control is performed
&nbsp;         * based on whether this {@link Authentication} is allowed to use them.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This method was added to an interface after it was created, so plugins built against
&nbsp;         * older versions of Jenkins may not have this method implemented. Called private method _getDefaultAuthenticationOf(Task) on {@link Tasks}
&nbsp;         * to avoid {@link AbstractMethodError}.
&nbsp;         *
&nbsp;         * @since 2.266
&nbsp;         * @see QueueItemAuthenticator
&nbsp;         * @see Tasks#getDefaultAuthenticationOf(Queue.Task, Queue.Item)
&nbsp;         */
&nbsp;        default @NonNull Authentication getDefaultAuthentication2(Queue.Item item) {
<b class="nc">&nbsp;            if (Util.isOverridden(Queue.Task.class, getClass(), &quot;getDefaultAuthentication&quot;, Queue.Item.class)) {</b>
<b class="nc">&nbsp;                return getDefaultAuthentication(item).toSpring();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return getDefaultAuthentication2();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #getDefaultAuthentication2(Queue.Item)}
&nbsp;         * @since 1.592
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        default @NonNull org.acegisecurity.Authentication getDefaultAuthentication(Queue.Item item) {
<b class="nc">&nbsp;            return org.acegisecurity.Authentication.fromSpring(getDefaultAuthentication2(item));</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the real meat of the computation run by {@link Executor}.
&nbsp;     *
&nbsp;     * &lt;h2&gt;Views&lt;/h2&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Implementation must have {@code executorCell.jelly}, which is
&nbsp;     * used to render the HTML that indicates this executable is executing.
&nbsp;     */
&nbsp;    @StaplerAccessibleType
&nbsp;    public interface Executable extends Runnable {
&nbsp;        /**
&nbsp;         * Task from which this executable was created.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * Since this method went through a signature change in 1.377, the invocation may results in
&nbsp;         * {@link AbstractMethodError}.
&nbsp;         * Use {@link Executables#getParentOf(Queue.Executable)} that avoids this.
&nbsp;         */
&nbsp;        @NonNull SubTask getParent();
&nbsp;
&nbsp;        /**
&nbsp;         * An umbrella executable (such as a {@link Run}) of which this is one part.
&nbsp;         * Some invariants:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;{@code getParent().getOwnerTask() == getParent() || getParentExecutable().getParent() == getParent().getOwnerTask()}
&nbsp;         * &lt;li&gt;{@code getParent().getOwnerExecutable() == null || getParentExecutable() == getParent().getOwnerExecutable()}
&nbsp;         * &lt;/ul&gt;
&nbsp;         * @return a &lt;em&gt;distinct&lt;/em&gt; executable (never {@code this}, unlike the default of {@link SubTask#getOwnerTask}!); or null if this executable was already at top level
&nbsp;         * @since 2.313, but implementations can already implement this with a lower core dependency.
&nbsp;         * @see SubTask#getOwnerExecutable
&nbsp;         */
&nbsp;        default @CheckForNull Executable getParentExecutable() {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Called by {@link Executor} to perform the task.
&nbsp;         * @throws AsynchronousExecution if you would like to continue without consuming a thread
&nbsp;         */
&nbsp;        @Override void run() throws AsynchronousExecution;
&nbsp;
&nbsp;        /**
&nbsp;         * Estimate of how long will it take to execute this executable.
&nbsp;         * Measured in milliseconds.
&nbsp;         *
&nbsp;         * @return -1 if it&#39;s impossible to estimate; default, {@link SubTask#getEstimatedDuration}
&nbsp;         * @since 1.383
&nbsp;         */
&nbsp;        default long getEstimatedDuration() {
<b class="nc">&nbsp;            return Executables.getParentOf(this).getEstimatedDuration();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Used to render the HTML. Should be a human readable text of what this executable is.
&nbsp;         */
&nbsp;        @Override String toString();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Item in a queue.
&nbsp;     */
&nbsp;    @ExportedBean(defaultVisibility = 999)
&nbsp;    public abstract static class Item extends Actionable implements QueueItem {
&nbsp;
&nbsp;        private final long id;
&nbsp;
&nbsp;        /**
&nbsp;         * Unique ID (per master) that tracks the {@link Task} as it moves through different stages
&nbsp;         * in the queue (each represented by different subtypes of {@link Item} and into any subsequent
&nbsp;         * {@link Run} instance (see {@link Run#getQueueId()}).
&nbsp;         * @since 1.601
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @Override
&nbsp;        public long getId() {
<b class="fc">&nbsp;            return id;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Deprecated
&nbsp;        public int getIdLegacy() {
<b class="nc">&nbsp;            if (id &gt; Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Sorry, you need to update any Plugins attempting to &quot; +</b>
&nbsp;                        &quot;assign &#39;Queue.Item.id&#39; to an int value. &#39;Queue.Item.id&#39; is now a long value and &quot; +
&nbsp;                        &quot;has incremented to a value greater than Integer.MAX_VALUE (2^31 - 1).&quot;);
&nbsp;            }
<b class="nc">&nbsp;            return (int) id;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * Project to be built.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @NonNull
&nbsp;        public final Task task;
&nbsp;
&nbsp;        private /*almost final*/ transient FutureImpl future;
&nbsp;
&nbsp;        private final long inQueueSince;
&nbsp;
&nbsp;        @Override
&nbsp;        @NonNull
&nbsp;        public Task getTask() {
<b class="fc">&nbsp;            return task;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Build is blocked because another build is in progress,
&nbsp;         * required {@link Resource}s are not available, or otherwise blocked
&nbsp;         * by {@link Task#isBuildBlocked()}.
&nbsp;         */
&nbsp;        @Exported
<b class="nc">&nbsp;        public boolean isBlocked() { return this instanceof BlockedItem; }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Build is waiting the executor to become available.
&nbsp;         * This flag is only used in {@link Queue#getItems()} for
&nbsp;         * &#39;pseudo&#39; items that are actually not really in the queue.
&nbsp;         */
&nbsp;        @Exported
<b class="nc">&nbsp;        public boolean isBuildable() { return this instanceof BuildableItem; }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * True if the item is starving for an executor for too long.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @Override
<b class="nc">&nbsp;        public boolean isStuck() { return false; }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Since when is this item in the queue.
&nbsp;         * @return Unix timestamp
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public long getInQueueSince() {
<b class="nc">&nbsp;            return this.inQueueSince;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a human readable presentation of how long this item is already in the queue.
&nbsp;         * E.g. something like &#39;3 minutes 40 seconds&#39;
&nbsp;         */
&nbsp;        @Override
&nbsp;        public String getInQueueForString() {
<b class="nc">&nbsp;            long duration = System.currentTimeMillis() - this.inQueueSince;</b>
<b class="nc">&nbsp;            return Util.getTimeSpanString(duration);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Can be used to wait for the completion (either normal, abnormal, or cancellation) of the {@link Task}.
&nbsp;         * &lt;p&gt;
&nbsp;         * Just like {@link #getId()}, the same object tracks various stages of the queue.
&nbsp;         */
&nbsp;        @WithBridgeMethods(Future.class)
<b class="nc">&nbsp;        public QueueTaskFuture&lt;Executable&gt; getFuture() { return future; }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * If this task needs to be run on a node with a particular label,
&nbsp;         * return that {@link Label}. Otherwise null, indicating
&nbsp;         * it can run on anywhere.
&nbsp;         *
&nbsp;         * &lt;p&gt;
&nbsp;         * This code takes {@link LabelAssignmentAction} into account, then fall back to {@link SubTask#getAssignedLabel()}
&nbsp;         */
&nbsp;        @CheckForNull
&nbsp;        public Label getAssignedLabel() {
<b class="nc">&nbsp;            for (LabelAssignmentAction laa : getActions(LabelAssignmentAction.class)) {</b>
<b class="nc">&nbsp;                Label l = laa.getAssignedLabel(task);</b>
<b class="nc">&nbsp;                if (l != null)    return l;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return task.getAssignedLabel();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Test if the specified {@link SubTask} needs to be run on a node with a particular label.
&nbsp;         * &lt;p&gt;
&nbsp;         * This method takes {@link LabelAssignmentAction} into account, the first
&nbsp;         * non-null assignment will be returned.
&nbsp;         * Otherwise falls back to {@link SubTask#getAssignedLabel()}
&nbsp;         * @param st {@link SubTask} to be checked.
&nbsp;         * @return Required {@link Label}. Otherwise null, indicating it can run on anywhere.
&nbsp;
&nbsp;         */
&nbsp;        public @CheckForNull Label getAssignedLabelFor(@NonNull SubTask st) {
<b class="nc">&nbsp;            for (LabelAssignmentAction laa : getActions(LabelAssignmentAction.class)) {</b>
<b class="nc">&nbsp;                Label l = laa.getAssignedLabel(st);</b>
<b class="nc">&nbsp;                if (l != null)    return l;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return st.getAssignedLabel();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Convenience method that returns a read only view of the {@link Cause}s associated with this item in the queue.
&nbsp;         *
&nbsp;         * @return can be empty but never null
&nbsp;         * @since 1.343
&nbsp;         */
&nbsp;        public final List&lt;Cause&gt; getCauses() {
<b class="nc">&nbsp;            CauseAction ca = getAction(CauseAction.class);</b>
<b class="nc">&nbsp;            if (ca != null)</b>
<b class="nc">&nbsp;                return Collections.unmodifiableList(ca.getCauses());</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(DoNotUse.class) // used from Jelly
&nbsp;        @Override
&nbsp;        public String getCausesDescription() {
<b class="nc">&nbsp;            List&lt;Cause&gt; causes = getCauses();</b>
<b class="nc">&nbsp;            StringBuilder s = new StringBuilder();</b>
<b class="nc">&nbsp;            for (Cause c : causes) {</b>
<b class="nc">&nbsp;                s.append(c.getShortDescription()).append(&#39;\n&#39;);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return s.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        protected Item(@NonNull Task task, @NonNull List&lt;Action&gt; actions, long id, FutureImpl future) {
<b class="fc">&nbsp;            this(task, actions, id, future, System.currentTimeMillis());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        protected Item(@NonNull Task task, @NonNull List&lt;Action&gt; actions, long id, FutureImpl future, long inQueueSince) {</b>
<b class="fc">&nbsp;            this.task = task;</b>
<b class="fc">&nbsp;            this.id = id;</b>
<b class="fc">&nbsp;            this.future = future;</b>
<b class="fc">&nbsp;            this.inQueueSince = inQueueSince;</b>
<b class="fc">&nbsp;            for (Action action : actions) addAction(action);</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressWarnings(&quot;deprecation&quot;) // JENKINS-51584
&nbsp;        protected Item(Item item) {
&nbsp;            // do not use item.getAllActions() here as this will persist actions from a TransientActionFactory
<b class="fc">&nbsp;            this(item.task, new ArrayList&lt;&gt;(item.getActions()), item.id, item.future, item.inQueueSince);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the URL of this {@link Item} relative to the context path of Jenkins
&nbsp;         *
&nbsp;         * @return
&nbsp;         *      URL that ends with &#39;/&#39;.
&nbsp;         * @since 1.519
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public String getUrl() {
<b class="nc">&nbsp;            return &quot;queue/item/&quot; + id + &#39;/&#39;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets a human-readable status message describing why it&#39;s in the queue.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @Override
&nbsp;        public final String getWhy() {
<b class="nc">&nbsp;            CauseOfBlockage cob = getCauseOfBlockage();</b>
<b class="nc">&nbsp;            return cob != null ? cob.getShortDescription() : null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Gets an object that describes why this item is in the queue.
&nbsp;         */
&nbsp;        public abstract CauseOfBlockage getCauseOfBlockage();
&nbsp;
&nbsp;        /**
&nbsp;         * Gets a human-readable message about the parameters of this item
&nbsp;         * @return String
&nbsp;         */
&nbsp;        @Exported
&nbsp;        @Override
&nbsp;        public String getParams() {
<b class="nc">&nbsp;            StringBuilder s = new StringBuilder();</b>
<b class="nc">&nbsp;            for (ParametersAction pa : getActions(ParametersAction.class)) {</b>
<b class="nc">&nbsp;                for (ParameterValue p : pa.getParameters()) {</b>
<b class="nc">&nbsp;                    s.append(&#39;\n&#39;).append(p.getShortDescription());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return s.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getSearchUrl() {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** @deprecated Use {@link #doCancelItem} instead. */
&nbsp;        @Deprecated
&nbsp;        @RequirePOST
&nbsp;        public HttpResponse doCancelQueue() {
<b class="nc">&nbsp;            if (hasCancelPermission()) {</b>
<b class="nc">&nbsp;                Jenkins.get().getQueue().cancel(this);</b>
&nbsp;            }
<b class="nc">&nbsp;            return HttpResponses.status(HttpServletResponse.SC_NO_CONTENT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the identity that this task carries when it runs, for the purpose of access control.
&nbsp;         *
&nbsp;         * When the task execution touches other objects inside Jenkins, the access control is performed
&nbsp;         * based on whether this {@link Authentication} is allowed to use them. Implementers, if you are unsure,
&nbsp;         * return the identity of the user who queued the task, or {@link ACL#SYSTEM2} to bypass the access control
&nbsp;         * and run as the super user.
&nbsp;         *
&nbsp;         * @since 2.266
&nbsp;         */
&nbsp;        @NonNull
&nbsp;        public Authentication authenticate2() {
<b class="nc">&nbsp;            for (QueueItemAuthenticator auth : QueueItemAuthenticatorProvider.authenticators()) {</b>
<b class="nc">&nbsp;                Authentication a = auth.authenticate2(this);</b>
<b class="nc">&nbsp;                if (a != null)</b>
<b class="nc">&nbsp;                    return a;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return task.getDefaultAuthentication2(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @deprecated use {@link #authenticate2}
&nbsp;         * @since 1.520
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public org.acegisecurity.Authentication authenticate() {
<b class="nc">&nbsp;            return org.acegisecurity.Authentication.fromSpring(authenticate2());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(DoNotUse.class) // only for Stapler export
&nbsp;        public Api getApi() throws AccessDeniedException {
<b class="nc">&nbsp;            if (task instanceof AccessControlled) {</b>
<b class="nc">&nbsp;                AccessControlled ac = (AccessControlled) task;</b>
<b class="nc">&nbsp;                if (!ac.hasPermission(hudson.model.Item.DISCOVER)) {</b>
<b class="nc">&nbsp;                    return null; // same as getItem(long) returning null (details are printed only in case of -Dstapler.trace=true)</b>
<b class="nc">&nbsp;                } else if (!ac.hasPermission(hudson.model.Item.READ)) {</b>
<b class="nc">&nbsp;                    throw new AccessDeniedException(&quot;Please log in to access &quot; + task.getUrl()); // like Jenkins.getItem</b>
&nbsp;                } else { // have READ
<b class="nc">&nbsp;                    return new Api(this);</b>
&nbsp;                }
&nbsp;            } else { // err on the safe side
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected Object readResolve() {
<b class="nc">&nbsp;            this.future = new FutureImpl(task);</b>
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return getClass().getName() + &#39;:&#39; + task + &#39;:&#39; + id;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Enters the appropriate queue for this type of item.
&nbsp;         */
&nbsp;        /*package*/ abstract void enter(Queue q);
&nbsp;
&nbsp;        /**
&nbsp;         * Leaves the appropriate queue for this type of item.
&nbsp;         */
&nbsp;        /*package*/ abstract boolean leave(Queue q);
&nbsp;
&nbsp;        /**
&nbsp;         * Cancels this item, which updates {@link #future} to notify the listener, and
&nbsp;         * also leaves the queue.
&nbsp;         *
&nbsp;         * @return true
&nbsp;         *      if the item was successfully cancelled.
&nbsp;         */
&nbsp;        /*package*/ boolean cancel(Queue q) {
<b class="fc">&nbsp;            boolean r = leave(q);</b>
<b class="fc">&nbsp;            if (r) {</b>
<b class="fc">&nbsp;                future.setAsCancelled();</b>
<b class="fc">&nbsp;                LeftItem li = new LeftItem(this);</b>
<b class="fc">&nbsp;                li.enter(q);</b>
&nbsp;            }
<b class="fc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A Stub class for {@link Task} which exposes only the name of the Task to be displayed when the user
&nbsp;     * has DISCOVERY permissions only.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @ExportedBean(defaultVisibility = 999)
&nbsp;    public static class StubTask {
&nbsp;
&nbsp;        private final String name;
&nbsp;
<b class="nc">&nbsp;        public StubTask(@NonNull Queue.Task base) {</b>
<b class="nc">&nbsp;            this.name = base.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A Stub class for {@link Item} which exposes only the name of the Task to be displayed when the user
&nbsp;     * has DISCOVERY permissions only.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @ExportedBean(defaultVisibility = 999)
&nbsp;    @SuppressFBWarnings(value = &quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, justification = &quot;read by Stapler&quot;)
&nbsp;    public static class StubItem {
&nbsp;
&nbsp;        @Exported public StubTask task;
&nbsp;
<b class="nc">&nbsp;        public StubItem(StubTask task) {</b>
<b class="nc">&nbsp;            this.task = task;</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An optional interface for actions on Queue.Item.
&nbsp;     * Lets the action cooperate in queue management.
&nbsp;     *
&nbsp;     * @since 1.300-ish.
&nbsp;     */
&nbsp;    public interface QueueAction extends Action {
&nbsp;        /**
&nbsp;         * Returns whether the new item should be scheduled.
&nbsp;         * An action should return true if the associated task is &#39;different enough&#39; to warrant a separate execution.
&nbsp;         */
&nbsp;        boolean shouldSchedule(List&lt;Action&gt; actions);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extension point for deciding if particular job should be scheduled or not.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This handler is consulted every time someone tries to submit a task to the queue.
&nbsp;     * If any of the registered handlers returns false, the task will not be added
&nbsp;     * to the queue, and the task will never get executed.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The other use case is to add additional {@link Action}s to the task
&nbsp;     * (for example {@link LabelAssignmentAction}) to tasks that are submitted to the queue.
&nbsp;     *
&nbsp;     * @since 1.316
&nbsp;     */
<b class="nc">&nbsp;    public abstract static class QueueDecisionHandler implements ExtensionPoint {</b>
&nbsp;        /**
&nbsp;         * Returns whether the new item should be scheduled.
&nbsp;         *
&nbsp;         * @param actions
&nbsp;         *      List of actions that are to be made available as {@link AbstractBuild#getActions()}
&nbsp;         *      upon the start of the build. This list is live, and can be mutated.
&nbsp;         */
&nbsp;        public abstract boolean shouldSchedule(Task p, List&lt;Action&gt; actions);
&nbsp;
&nbsp;        /**
&nbsp;         * All registered {@link QueueDecisionHandler}s
&nbsp;         */
&nbsp;        public static ExtensionList&lt;QueueDecisionHandler&gt; all() {
<b class="fc">&nbsp;            return ExtensionList.lookup(QueueDecisionHandler.class);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Item} in the {@link Queue#waitingList} stage.
&nbsp;     */
&nbsp;    public static final class WaitingItem extends Item implements Comparable&lt;WaitingItem&gt; {
<b class="fc">&nbsp;        private static final AtomicLong COUNTER = new AtomicLong(0);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * This item can be run after this time.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public Calendar timestamp;
&nbsp;
&nbsp;        public WaitingItem(Calendar timestamp, Task project, List&lt;Action&gt; actions) {
<b class="fc">&nbsp;            super(project, actions, COUNTER.incrementAndGet(), new FutureImpl(project));</b>
<b class="fc">&nbsp;            this.timestamp = timestamp;</b>
&nbsp;        }
&nbsp;
&nbsp;        static int getCurrentCounterValue() {
<b class="fc">&nbsp;            return COUNTER.intValue();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int compareTo(WaitingItem that) {
<b class="fc">&nbsp;            int r = this.timestamp.getTime().compareTo(that.timestamp.getTime());</b>
<b class="fc">&nbsp;            if (r != 0) return r;</b>
&nbsp;
<b class="fc">&nbsp;            return Long.compare(this.getId(), that.getId());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public CauseOfBlockage getCauseOfBlockage() {
<b class="nc">&nbsp;            long diff = timestamp.getTimeInMillis() - System.currentTimeMillis();</b>
<b class="nc">&nbsp;            if (diff &gt;= 0)</b>
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_InQuietPeriod(Util.getTimeSpanString(diff)));</b>
&nbsp;            else
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_FinishedWaiting());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        /*package*/ void enter(Queue q) {
<b class="fc">&nbsp;            if (q.waitingList.add(this)) {</b>
<b class="fc">&nbsp;                Listeners.notify(QueueListener.class, true, l -&gt; l.onEnterWaiting(this));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        /*package*/ boolean leave(Queue q) {
<b class="fc">&nbsp;            boolean r = q.waitingList.remove(this);</b>
<b class="fc">&nbsp;            if (r) {</b>
<b class="fc">&nbsp;                Listeners.notify(QueueListener.class, true, l -&gt; l.onLeaveWaiting(this));</b>
&nbsp;            }
<b class="fc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Common part between {@link BlockedItem} and {@link BuildableItem}.
&nbsp;     */
&nbsp;    public abstract static class NotWaitingItem extends Item {
&nbsp;        /**
&nbsp;         * When did this job exit the {@link Queue#waitingList} phase?
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public final long buildableStartMilliseconds;
&nbsp;
&nbsp;        protected NotWaitingItem(WaitingItem wi) {
<b class="nc">&nbsp;            super(wi);</b>
<b class="nc">&nbsp;            buildableStartMilliseconds = System.currentTimeMillis();</b>
&nbsp;        }
&nbsp;
&nbsp;        protected NotWaitingItem(NotWaitingItem ni) {
<b class="nc">&nbsp;            super(ni);</b>
<b class="nc">&nbsp;            buildableStartMilliseconds = ni.buildableStartMilliseconds;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Item} in the {@link Queue#blockedProjects} stage.
&nbsp;     */
&nbsp;    public final class BlockedItem extends NotWaitingItem {
<b class="nc">&nbsp;        private transient CauseOfBlockage causeOfBlockage = null;</b>
&nbsp;
&nbsp;        public BlockedItem(WaitingItem wi) {
<b class="nc">&nbsp;            this(wi, null);</b>
&nbsp;        }
&nbsp;
&nbsp;        public BlockedItem(NotWaitingItem ni) {
<b class="nc">&nbsp;            this(ni, null);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        BlockedItem(WaitingItem wi, CauseOfBlockage causeOfBlockage) {</b>
<b class="nc">&nbsp;            super(wi);</b>
<b class="nc">&nbsp;            this.causeOfBlockage = causeOfBlockage;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        BlockedItem(NotWaitingItem ni, CauseOfBlockage causeOfBlockage) {</b>
<b class="nc">&nbsp;            super(ni);</b>
<b class="nc">&nbsp;            this.causeOfBlockage = causeOfBlockage;</b>
&nbsp;        }
&nbsp;
&nbsp;        void setCauseOfBlockage(CauseOfBlockage causeOfBlockage) {
<b class="nc">&nbsp;            this.causeOfBlockage = causeOfBlockage;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Restricted(NoExternalUse.class)
&nbsp;        public boolean isCauseOfBlockageNull() {
<b class="nc">&nbsp;            if (causeOfBlockage == null) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public CauseOfBlockage getCauseOfBlockage() {
<b class="nc">&nbsp;            if (causeOfBlockage != null) {</b>
<b class="nc">&nbsp;                return causeOfBlockage;</b>
&nbsp;            }
&nbsp;
&nbsp;            // fallback for backward compatibility
<b class="nc">&nbsp;            return getCauseOfBlockageForItem(this);</b>
&nbsp;        }
&nbsp;
&nbsp;                    @Override
&nbsp;        /*package*/ void enter(Queue q) {
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;{0} is blocked&quot;, this);</b>
<b class="nc">&nbsp;            blockedProjects.add(this);</b>
<b class="nc">&nbsp;            Listeners.notify(QueueListener.class, true, l -&gt; l.onEnterBlocked(this));</b>
&nbsp;        }
&nbsp;
&nbsp;                    @Override
&nbsp;        /*package*/ boolean leave(Queue q) {
<b class="nc">&nbsp;            boolean r = blockedProjects.remove(this);</b>
<b class="nc">&nbsp;            if (r) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;{0} no longer blocked&quot;, this);</b>
<b class="nc">&nbsp;                Listeners.notify(QueueListener.class, true, l -&gt; l.onLeaveBlocked(this));</b>
&nbsp;            }
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Item} in the {@link Queue#buildables} stage.
&nbsp;     */
&nbsp;    public static final class BuildableItem extends NotWaitingItem {
&nbsp;        /**
&nbsp;         * Set to true when this is added to the {@link Queue#pendings} list.
&nbsp;         */
&nbsp;        private boolean isPending;
&nbsp;
&nbsp;        /**
&nbsp;         * Reasons why the last call to {@link #maintain} left this buildable (but not blocked or executing).
&nbsp;         * May be null but not empty.
&nbsp;         */
&nbsp;        private transient volatile @CheckForNull List&lt;CauseOfBlockage&gt; transientCausesOfBlockage;
&nbsp;
&nbsp;        public BuildableItem(WaitingItem wi) {
<b class="nc">&nbsp;            super(wi);</b>
&nbsp;        }
&nbsp;
&nbsp;        public BuildableItem(NotWaitingItem ni) {
<b class="nc">&nbsp;            super(ni);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public CauseOfBlockage getCauseOfBlockage() {
<b class="nc">&nbsp;            Jenkins jenkins = Jenkins.get();</b>
<b class="nc">&nbsp;            if (isBlockedByShutdown(task))</b>
<b class="nc">&nbsp;                return CauseOfBlockage.fromMessage(Messages._Queue_HudsonIsAboutToShutDown());</b>
&nbsp;
<b class="nc">&nbsp;            List&lt;CauseOfBlockage&gt; causesOfBlockage = transientCausesOfBlockage;</b>
&nbsp;
<b class="nc">&nbsp;            Label label = getAssignedLabel();</b>
<b class="nc">&nbsp;            List&lt;Node&gt; allNodes = jenkins.getNodes();</b>
<b class="nc">&nbsp;            if (allNodes.isEmpty())</b>
<b class="nc">&nbsp;                label = null;    // no master/agent. pointless to talk about nodes</b>
&nbsp;
<b class="nc">&nbsp;            if (label != null) {</b>
<b class="nc">&nbsp;                Set&lt;Node&gt; nodes = label.getNodes();</b>
<b class="nc">&nbsp;                if (label.isOffline()) {</b>
<b class="nc">&nbsp;                    if (nodes.size() != 1)      return new BecauseLabelIsOffline(label);</b>
<b class="nc">&nbsp;                    else                        return new BecauseNodeIsOffline(nodes.iterator().next());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    if (causesOfBlockage != null &amp;&amp; label.getIdleExecutors() &gt; 0) {</b>
<b class="nc">&nbsp;                        return new CompositeCauseOfBlockage(causesOfBlockage);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (nodes.size() != 1)      return new BecauseLabelIsBusy(label);</b>
<b class="nc">&nbsp;                    else                        return new BecauseNodeIsBusy(nodes.iterator().next());</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (causesOfBlockage != null &amp;&amp; new ComputerSet().getIdleExecutors() &gt; 0) {</b>
<b class="nc">&nbsp;                return new CompositeCauseOfBlockage(causesOfBlockage);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return CauseOfBlockage.createNeedsMoreExecutor(Messages._Queue_WaitingForNextAvailableExecutor());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isStuck() {
<b class="nc">&nbsp;            Label label = getAssignedLabel();</b>
<b class="nc">&nbsp;            if (label != null &amp;&amp; label.isOffline())</b>
&nbsp;                // no executor online to process this job. definitely stuck.
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="nc">&nbsp;            long d = task.getEstimatedDuration();</b>
<b class="nc">&nbsp;            long elapsed = System.currentTimeMillis() - buildableStartMilliseconds;</b>
<b class="nc">&nbsp;            if (d &gt;= 0) {</b>
&nbsp;                // if we were running elsewhere, we would have done this build ten times.
<b class="nc">&nbsp;                return elapsed &gt; Math.max(d, 60000L) * 10;</b>
&nbsp;            } else {
&nbsp;                // more than a day in the queue
<b class="nc">&nbsp;                return TimeUnit.MILLISECONDS.toHours(elapsed) &gt; 24;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Exported
&nbsp;        public boolean isPending() {
<b class="nc">&nbsp;            return isPending;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        /*package*/ void enter(Queue q) {
<b class="nc">&nbsp;            q.buildables.add(this);</b>
<b class="nc">&nbsp;            Listeners.notify(QueueListener.class, true, l -&gt; l.onEnterBuildable(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        /*package*/ boolean leave(Queue q) {
<b class="nc">&nbsp;            boolean r = q.buildables.remove(this);</b>
<b class="nc">&nbsp;            if (r) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.FINE, &quot;{0} no longer blocked&quot;, this);</b>
<b class="nc">&nbsp;                Listeners.notify(QueueListener.class, true, l -&gt; l.onLeaveBuildable(this));</b>
&nbsp;            }
<b class="nc">&nbsp;            return r;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Item} in the {@link Queue#leftItems} stage. These are items that had left the queue
&nbsp;     * by either began executing or by getting cancelled.
&nbsp;     *
&nbsp;     * @since 1.519
&nbsp;     */
&nbsp;    public static final class LeftItem extends Item {
&nbsp;        public final WorkUnitContext outcome;
&nbsp;
&nbsp;        /**
&nbsp;         * When item has left the queue and begin executing.
&nbsp;         */
&nbsp;        public LeftItem(WorkUnitContext wuc) {
<b class="nc">&nbsp;            super(wuc.item);</b>
<b class="nc">&nbsp;            this.outcome = wuc;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * When item is cancelled.
&nbsp;         */
&nbsp;        public LeftItem(Item cancelled) {
<b class="fc">&nbsp;            super(cancelled);</b>
<b class="fc">&nbsp;            this.outcome = null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public CauseOfBlockage getCauseOfBlockage() {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * If this is representing an item that started executing, this property returns
&nbsp;         * the primary executable (such as {@link AbstractBuild}) that created out of it.
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public @CheckForNull Executable getExecutable() {
<b class="nc">&nbsp;            return outcome != null ? outcome.getPrimaryWorkUnit().getExecutable() : null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Is this representing a cancelled item?
&nbsp;         */
&nbsp;        @Exported
&nbsp;        public boolean isCancelled() {
<b class="nc">&nbsp;            return outcome == null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        void enter(Queue q) {
<b class="fc">&nbsp;            q.leftItems.put(getId(), this);</b>
<b class="fc">&nbsp;            Listeners.notify(QueueListener.class, true, l -&gt; l.onLeft(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        boolean leave(Queue q) {
&nbsp;            // there&#39;s no leave operation
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Queue.class.getName());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This {@link XStream} instance is used to persist {@link Task}s.
&nbsp;     */
<b class="fc">&nbsp;    public static final XStream XSTREAM = new XStream2();</b>
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        XSTREAM.registerConverter(new AbstractSingleValueConverter() {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean canConvert(Class klazz) {
<b class="nc">&nbsp;                return hudson.model.Item.class.isAssignableFrom(klazz);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Object fromString(String string) {
<b class="nc">&nbsp;                Object item = Jenkins.get().getItemByFullName(string);</b>
<b class="nc">&nbsp;                if (item == null)  throw new NoSuchElementException(&quot;No such job exists: &quot; + string);</b>
<b class="nc">&nbsp;                return item;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString(Object item) {
<b class="nc">&nbsp;                return ((hudson.model.Item) item).getFullName();</b>
&nbsp;            }
&nbsp;        });
<b class="fc">&nbsp;        XSTREAM.registerConverter(new AbstractSingleValueConverter() {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean canConvert(Class klazz) {
<b class="nc">&nbsp;                return Run.class.isAssignableFrom(klazz);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Object fromString(String string) {
<b class="nc">&nbsp;                String[] split = string.split(&quot;#&quot;);</b>
<b class="nc">&nbsp;                String projectName = split[0];</b>
<b class="nc">&nbsp;                int buildNumber = Integer.parseInt(split[1]);</b>
<b class="nc">&nbsp;                Job&lt;?, ?&gt; job = (Job&lt;?, ?&gt;) Jenkins.get().getItemByFullName(projectName);</b>
<b class="nc">&nbsp;                if (job == null)  throw new NoSuchElementException(&quot;No such job exists: &quot; + projectName);</b>
<b class="nc">&nbsp;                Run&lt;?, ?&gt; run = job.getBuildByNumber(buildNumber);</b>
<b class="nc">&nbsp;                if (run == null)  throw new NoSuchElementException(&quot;No such build: &quot; + string);</b>
<b class="nc">&nbsp;                return run;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString(Object object) {
<b class="nc">&nbsp;                Run&lt;?, ?&gt; run = (Run&lt;?, ?&gt;) object;</b>
<b class="nc">&nbsp;                return run.getParent().getFullName() + &quot;#&quot; + run.getNumber();</b>
&nbsp;            }
&nbsp;        });
&nbsp;
&nbsp;        /*
&nbsp;         * Reconnect every reference to Queue by the singleton.
&nbsp;         */
<b class="fc">&nbsp;        XSTREAM.registerConverter(new AbstractSingleValueConverter() {</b>
&nbsp;            @Override
&nbsp;            public boolean canConvert(Class klazz) {
<b class="nc">&nbsp;                return Queue.class.isAssignableFrom(klazz);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public Object fromString(String string) {
<b class="nc">&nbsp;                return Jenkins.get().getQueue();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString(Object item) {
<b class="nc">&nbsp;                return &quot;queue&quot;;</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Regularly invokes {@link Queue#maintain()} and clean itself up when
&nbsp;     * {@link Queue} gets GC-ed.
&nbsp;     */
&nbsp;    private static class MaintainTask extends SafeTimerTask {
&nbsp;        private final WeakReference&lt;Queue&gt; queue;
&nbsp;
<b class="fc">&nbsp;        MaintainTask(Queue queue) {</b>
<b class="fc">&nbsp;            this.queue = new WeakReference&lt;&gt;(queue);</b>
&nbsp;        }
&nbsp;
&nbsp;        private void periodic() {
<b class="fc">&nbsp;            long interval = 5000;</b>
<b class="fc">&nbsp;            Timer.get().scheduleWithFixedDelay(this, interval, interval, TimeUnit.MILLISECONDS);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void doRun() {
<b class="fc">&nbsp;            Queue q = queue.get();</b>
<b class="fc">&nbsp;            if (q != null)</b>
<b class="fc">&nbsp;                q.maintain();</b>
&nbsp;            else
<b class="fc">&nbsp;                cancel();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link ArrayList} of {@link Item} with more convenience methods.
&nbsp;     */
<b class="fc">&nbsp;    private class ItemList&lt;T extends Item&gt; extends ArrayList&lt;T&gt; {</b>
&nbsp;        public T get(Task task) {
<b class="nc">&nbsp;            for (T item : this) {</b>
<b class="nc">&nbsp;                if (item.task.equals(task)) {</b>
<b class="nc">&nbsp;                    return item;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;T&gt; getAll(Task task) {
<b class="fc">&nbsp;            List&lt;T&gt; result = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;            for (T item : this) {</b>
<b class="nc">&nbsp;                if (item.task.equals(task)) {</b>
<b class="nc">&nbsp;                    result.add(item);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean containsKey(Task task) {
<b class="nc">&nbsp;            return get(task) != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        public T remove(Task task) {
<b class="nc">&nbsp;            Iterator&lt;T&gt; it = iterator();</b>
<b class="nc">&nbsp;            while (it.hasNext()) {</b>
<b class="nc">&nbsp;                T t = it.next();</b>
<b class="nc">&nbsp;                if (t.task.equals(task)) {</b>
<b class="nc">&nbsp;                    it.remove();</b>
<b class="nc">&nbsp;                    return t;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void put(Task task, T item) {
<b class="nc">&nbsp;            assert item.task.equals(task);</b>
<b class="nc">&nbsp;            add(item);</b>
&nbsp;        }
&nbsp;
&nbsp;        public ItemList&lt;T&gt; values() {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Works like {@link #remove(Task)} but also marks the {@link Item} as cancelled.
&nbsp;         */
&nbsp;        public T cancel(Task p) {
<b class="nc">&nbsp;            T x = get(p);</b>
<b class="nc">&nbsp;            if (x != null) x.cancel(Queue.this);</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(value = &quot;IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD&quot;,
&nbsp;                justification = &quot;It will invoke the inherited clear() method according to Java semantics. &quot;
&nbsp;                              + &quot;FindBugs recommends suppressing warnings in such case&quot;)
&nbsp;        public void cancelAll() {
<b class="nc">&nbsp;            for (T t : new ArrayList&lt;&gt;(this))</b>
<b class="nc">&nbsp;                t.cancel(Queue.this);</b>
<b class="nc">&nbsp;            clear();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class Snapshot {
&nbsp;        private final Set&lt;WaitingItem&gt; waitingList;
&nbsp;        private final List&lt;BlockedItem&gt; blockedProjects;
&nbsp;        private final List&lt;BuildableItem&gt; buildables;
&nbsp;        private final List&lt;BuildableItem&gt; pendings;
&nbsp;
&nbsp;        Snapshot(Set&lt;WaitingItem&gt; waitingList, List&lt;BlockedItem&gt; blockedProjects, List&lt;BuildableItem&gt; buildables,
<b class="fc">&nbsp;                        List&lt;BuildableItem&gt; pendings) {</b>
<b class="fc">&nbsp;            this.waitingList = new LinkedHashSet&lt;&gt;(waitingList);</b>
<b class="fc">&nbsp;            this.blockedProjects = new ArrayList&lt;&gt;(blockedProjects);</b>
<b class="fc">&nbsp;            this.buildables = new ArrayList&lt;&gt;(buildables);</b>
<b class="fc">&nbsp;            this.pendings = new ArrayList&lt;&gt;(pendings);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;Queue.Snapshot{waitingList=&quot; + waitingList + &quot;;blockedProjects=&quot; + blockedProjects + &quot;;buildables=&quot; + buildables + &quot;;pendings=&quot; + pendings + &quot;}&quot;;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class LockedRunnable implements Runnable  {
&nbsp;        private final Runnable delegate;
&nbsp;
<b class="nc">&nbsp;        private LockedRunnable(Runnable delegate) {</b>
<b class="nc">&nbsp;            this.delegate = delegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
<b class="nc">&nbsp;            withLock(delegate);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private class BuildableRunnable implements Runnable  {
&nbsp;        private final BuildableItem buildableItem;
&nbsp;
<b class="nc">&nbsp;        private BuildableRunnable(BuildableItem p) {</b>
<b class="nc">&nbsp;            this.buildableItem = p;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            //the flyweighttask enters the buildables queue and will ask Jenkins to provision a node
<b class="nc">&nbsp;            buildableItem.enter(Queue.this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class LockedJUCCallable&lt;V&gt; implements java.util.concurrent.Callable&lt;V&gt; {
&nbsp;        private final java.util.concurrent.Callable&lt;V&gt; delegate;
&nbsp;
<b class="nc">&nbsp;        private LockedJUCCallable(java.util.concurrent.Callable&lt;V&gt; delegate) {</b>
<b class="nc">&nbsp;            this.delegate = delegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public V call() throws Exception {
<b class="nc">&nbsp;            return withLock(delegate);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class LockedHRCallable&lt;V, T extends Throwable&gt; implements hudson.remoting.Callable&lt;V, T&gt; {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private final hudson.remoting.Callable&lt;V, T&gt; delegate;
&nbsp;
<b class="nc">&nbsp;        private LockedHRCallable(hudson.remoting.Callable&lt;V, T&gt; delegate) {</b>
<b class="nc">&nbsp;            this.delegate = delegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public V call() throws T {
<b class="nc">&nbsp;            return withLock(delegate);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void checkRoles(RoleChecker checker) throws SecurityException {
<b class="nc">&nbsp;            delegate.checkRoles(checker);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @CLIResolver
&nbsp;    public static Queue getInstance() {
<b class="nc">&nbsp;        return Jenkins.get().getQueue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Restores the queue content during the start up.
&nbsp;     */
&nbsp;    @Initializer(after = JOB_CONFIG_ADAPTED)
&nbsp;    public static void init(Jenkins h) {
<b class="nc">&nbsp;        Queue queue = h.getQueue();</b>
<b class="nc">&nbsp;        Item[] items = queue.getItems();</b>
<b class="nc">&nbsp;        if (items.length &gt; 0) {</b>
<b class="nc">&nbsp;            LOGGER.warning(() -&gt; &quot;Loading queue will discard previously scheduled items: &quot; + Arrays.toString(items));</b>
&nbsp;        }
<b class="nc">&nbsp;        queue.load();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Schedule {@link Queue#save()} call for near future once items change. Ignore all changes until the time the save
&nbsp;     * takes place.
&nbsp;     *
&nbsp;     * Once queue is restored after a crash, items stages might not be accurate until the next #maintain() - this is not
&nbsp;     * a problem as the items will be reshuffled first and then scheduled during the next maintainance cycle.
&nbsp;     *
&nbsp;     * Implementation note: Queue.load() calls QueueListener hooks for every item deserialized that can hammer the persistance
&nbsp;     * on load. The problem is avoided by delaying the actual save for the time long enough for queue to load so the save
&nbsp;     * operations will collapse into one. Also, items are persisted as buildable or blocked in vast majority of cases and
&nbsp;     * those stages does not trigger the save here.
&nbsp;     */
&nbsp;    @Extension
&nbsp;    @Restricted(NoExternalUse.class)
<b class="nc">&nbsp;    public static final class Saver extends QueueListener implements Runnable {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * All negative values will disable periodic saving.
&nbsp;         */
&nbsp;        @VisibleForTesting
<b class="nc">&nbsp;        /*package*/ static /*final*/ int DELAY_SECONDS = SystemProperties.getInteger(&quot;hudson.model.Queue.Saver.DELAY_SECONDS&quot;, 60);</b>
&nbsp;
<b class="nc">&nbsp;        private final Object lock = new Object();</b>
&nbsp;        @GuardedBy(&quot;lock&quot;)
&nbsp;        private Future&lt;?&gt; nextSave;
&nbsp;
&nbsp;        @Override
&nbsp;        public void onEnterWaiting(WaitingItem wi) {
<b class="nc">&nbsp;            push();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onLeft(Queue.LeftItem li) {
<b class="nc">&nbsp;            push();</b>
&nbsp;        }
&nbsp;
&nbsp;        private void push() {
<b class="nc">&nbsp;            if (DELAY_SECONDS &lt; 0) return;</b>
&nbsp;
<b class="nc">&nbsp;            synchronized (lock) {</b>
&nbsp;                // Can be done or canceled in case of a bug or external intervention - do not allow it to hang there forever
<b class="nc">&nbsp;                if (nextSave != null &amp;&amp; !(nextSave.isDone() || nextSave.isCancelled())) return;</b>
<b class="nc">&nbsp;                nextSave = Timer.get().schedule(this, DELAY_SECONDS, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void run() {
&nbsp;            try {
<b class="nc">&nbsp;                Jenkins j = Jenkins.getInstanceOrNull();</b>
<b class="nc">&nbsp;                if (j != null) {</b>
<b class="nc">&nbsp;                    j.getQueue().save();</b>
&nbsp;                }
&nbsp;            } finally {
<b class="nc">&nbsp;                synchronized (lock) {</b>
<b class="nc">&nbsp;                    nextSave = null;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @VisibleForTesting @Restricted(NoExternalUse.class)
&nbsp;        /*package*/ @NonNull Future&lt;?&gt; getNextSave() {
<b class="nc">&nbsp;            synchronized (lock) {</b>
<b class="nc">&nbsp;                return nextSave == null</b>
<b class="nc">&nbsp;                        ? Futures.precomputed(null)</b>
<b class="nc">&nbsp;                        : nextSave</b>
&nbsp;                ;
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
