


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Executor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">hudson.model</a>
</div>

<h1>Coverage Summary for Class: Executor (hudson.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Executor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/295)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Executor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Executor$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/323)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi, Brian Westrich, Red Hat, Inc., Stephen Connolly, Tom Huybrechts
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package hudson.model;
&nbsp;
&nbsp;import static hudson.model.queue.Executables.getParentOf;
&nbsp;import static java.util.logging.Level.FINE;
&nbsp;import static java.util.logging.Level.FINER;
&nbsp;import static java.util.logging.Level.SEVERE;
&nbsp;import static java.util.logging.Level.WARNING;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import hudson.FilePath;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Util;
&nbsp;import hudson.model.Queue.Executable;
&nbsp;import hudson.model.queue.SubTask;
&nbsp;import hudson.model.queue.WorkUnit;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.util.InterceptingProxy;
&nbsp;import java.io.IOException;
&nbsp;import java.io.PrintWriter;
&nbsp;import java.io.StringWriter;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Vector;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.locks.ReadWriteLock;
&nbsp;import java.util.concurrent.locks.ReentrantReadWriteLock;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import javax.servlet.ServletException;
&nbsp;import jenkins.model.CauseOfInterruption;
&nbsp;import jenkins.model.CauseOfInterruption.UserInterruption;
&nbsp;import jenkins.model.InterruptedBuildAction;
&nbsp;import jenkins.model.Jenkins;
&nbsp;import jenkins.model.queue.AsynchronousExecution;
&nbsp;import jenkins.security.QueueItemAuthenticatorConfiguration;
&nbsp;import jenkins.security.QueueItemAuthenticatorDescriptor;
&nbsp;import net.jcip.annotations.GuardedBy;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.springframework.security.access.AccessDeniedException;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;
&nbsp;/**
&nbsp; * Thread that executes builds.
&nbsp; * Since 1.536, {@link Executor}s start threads on-demand.
&nbsp; * &lt;p&gt;Callers should use {@link #isActive()} instead of {@link #isAlive()}.
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
&nbsp;@ExportedBean
&nbsp;public class Executor extends Thread implements ModelObject {
&nbsp;    protected final @NonNull Computer owner;
&nbsp;    private final Queue queue;
<b class="nc">&nbsp;    private final ReadWriteLock lock = new ReentrantReadWriteLock();</b>
&nbsp;    private static final int DEFAULT_ESTIMATED_DURATION = -1;
&nbsp;
&nbsp;    @GuardedBy(&quot;lock&quot;)
&nbsp;    private long startTime;
&nbsp;    /**
&nbsp;     * Used to track when a job was last executed.
&nbsp;     */
<b class="nc">&nbsp;    private final long creationTime = System.currentTimeMillis();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Executor number that identifies it among other executors for the same {@link Computer}.
&nbsp;     */
&nbsp;    private int number;
&nbsp;    /**
&nbsp;     * {@link hudson.model.Queue.Executable} being executed right now, or null if the executor is idle.
&nbsp;     */
&nbsp;    @GuardedBy(&quot;lock&quot;)
&nbsp;    private Queue.Executable executable;
&nbsp;
&nbsp;    /**
&nbsp;     * Calculation of estimated duration needs some time, so, it&#39;s better to cache it once executable is known
&nbsp;     */
<b class="nc">&nbsp;    private long executableEstimatedDuration = DEFAULT_ESTIMATED_DURATION;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Used to mark that the execution is continuing asynchronously even though {@link Executor} as {@link Thread}
&nbsp;     * has finished.
&nbsp;     */
&nbsp;    @GuardedBy(&quot;lock&quot;)
&nbsp;    private AsynchronousExecution asynchronousExecution;
&nbsp;
&nbsp;    /**
&nbsp;     * When {@link Queue} allocates a work for this executor, this field is set
&nbsp;     * and the executor is {@linkplain Thread#start() started}.
&nbsp;     */
&nbsp;    @GuardedBy(&quot;lock&quot;)
&nbsp;    private WorkUnit workUnit;
&nbsp;
&nbsp;    @GuardedBy(&quot;lock&quot;)
&nbsp;    private boolean started;
&nbsp;
&nbsp;    /**
&nbsp;     * When the executor is interrupted, we allow the code that interrupted the thread to override the
&nbsp;     * result code it prefers.
&nbsp;     */
&nbsp;    @GuardedBy(&quot;lock&quot;)
&nbsp;    private Result interruptStatus;
&nbsp;
&nbsp;    /**
&nbsp;     * Cause of interruption. Access needs to be synchronized.
&nbsp;     */
<b class="nc">&nbsp;    @GuardedBy(&quot;lock&quot;)</b>
&nbsp;    private final List&lt;CauseOfInterruption&gt; causes = new Vector&lt;&gt;();
&nbsp;
&nbsp;    public Executor(@NonNull Computer owner, int n) {
<b class="nc">&nbsp;        super(&quot;Executor #&quot; + n + &quot; for &quot; + owner.getDisplayName());</b>
<b class="nc">&nbsp;        this.owner = owner;</b>
<b class="nc">&nbsp;        this.queue = Jenkins.get().getQueue();</b>
<b class="nc">&nbsp;        this.number = n;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void interrupt() {
<b class="nc">&nbsp;        if (Thread.currentThread() == this) {</b>
&nbsp;            // If you catch an InterruptedException the &quot;correct&quot; options are limited to one of two choices:
&nbsp;            //   1. Propagate the exception;
&nbsp;            //   2. Restore the Thread.currentThread().interrupted() flag
&nbsp;            // The JVM locking support assumes such behaviour.
&nbsp;            // Evil Jenkins overrides the interrupt() method so that when a different thread interrupts this thread
&nbsp;            // we abort the build.
&nbsp;            // but that causes JENKINS-28690 style deadlocks when the correctly written code does
&nbsp;            //
&nbsp;            // try {
&nbsp;            //   ... some long running thing ...
&nbsp;            // } catch (InterruptedException e) {
&nbsp;            //   ... some tidy up
&nbsp;            //   // restore interrupted flag
&nbsp;            //   Thread.currentThread().interrupted();
&nbsp;            // }
&nbsp;            //
&nbsp;            // What about why we do not set the Result.ABORTED on this branch?
&nbsp;            // That is a good question to ask, the answer is that the only time a thread should be restoring
&nbsp;            // its own interrupted flag is when that thread has already been interrupted by another thread
&nbsp;            // as such we should assume that the result has already been applied. If that assumption were
&nbsp;            // incorrect, then the Run.execute&#39;s catch (InterruptedException) block will either set the result
&nbsp;            // or have been escaped - in which case the result of the run has been sealed anyway so it does not
&nbsp;            // matter.
<b class="nc">&nbsp;            super.interrupt();</b>
&nbsp;        } else {
<b class="nc">&nbsp;            interrupt(Result.ABORTED);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void interruptForShutdown() {
<b class="nc">&nbsp;        interrupt(Result.ABORTED, true);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Interrupt the execution,
&nbsp;     * but instead of marking the build as aborted, mark it as specified result.
&nbsp;     *
&nbsp;     * @since 1.417
&nbsp;     */
&nbsp;
&nbsp;    public void interrupt(Result result) {
<b class="nc">&nbsp;        interrupt(result, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void interrupt(Result result, boolean forShutdown) {
<b class="nc">&nbsp;        Authentication a = Jenkins.getAuthentication2();</b>
<b class="nc">&nbsp;        if (a.equals(ACL.SYSTEM2))</b>
<b class="nc">&nbsp;            interrupt(result, forShutdown, new CauseOfInterruption[0]);</b>
&nbsp;        else {
&nbsp;            // worth recording who did it
&nbsp;            // avoid using User.get() to avoid deadlock.
<b class="nc">&nbsp;            interrupt(result, forShutdown, new UserInterruption(a.getName()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Interrupt the execution. Mark the cause and the status accordingly.
&nbsp;     */
&nbsp;    public void interrupt(Result result, CauseOfInterruption... causes) {
<b class="nc">&nbsp;        interrupt(result, false, causes);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void interrupt(Result result, boolean forShutdown, CauseOfInterruption... causes) {
<b class="nc">&nbsp;        if (LOGGER.isLoggable(FINE))</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, String.format(&quot;%s is interrupted(%s): %s&quot;, getDisplayName(), result, Arrays.stream(causes).map(Object::toString).collect(Collectors.joining(&quot;,&quot;))), new InterruptedException());</b>
&nbsp;
<b class="nc">&nbsp;        lock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (!started) {</b>
&nbsp;                // not yet started, so simply dispose this
<b class="nc">&nbsp;                owner.removeExecutor(this);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            interruptStatus = result;</b>
&nbsp;
<b class="nc">&nbsp;            for (CauseOfInterruption c : causes) {</b>
<b class="nc">&nbsp;                if (!this.causes.contains(c))</b>
<b class="nc">&nbsp;                    this.causes.add(c);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (asynchronousExecution != null) {</b>
<b class="nc">&nbsp;                asynchronousExecution.interrupt(forShutdown);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                super.interrupt();</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Result abortResult() {
&nbsp;        // this method is almost always called as a result of the current thread being interrupted
&nbsp;        // as a result we need to clean the interrupt flag so that the lock&#39;s lock method doesn&#39;t
&nbsp;        // get confused and think it was interrupted while awaiting the lock
<b class="nc">&nbsp;        Thread.interrupted();</b>
&nbsp;        // we need to use a write lock as we may be repeatedly interrupted while processing and
&nbsp;        // we need the same lock as used in void interrupt(Result,boolean,CauseOfInterruption...)
&nbsp;        // JENKINS-28690
<b class="nc">&nbsp;        lock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            Result r = interruptStatus;</b>
<b class="nc">&nbsp;            if (r == null) r =</b>
&nbsp;                    Result.ABORTED; // this is when we programmatically throw InterruptedException instead of calling the interrupt method.
&nbsp;
<b class="nc">&nbsp;            return r;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * report cause of interruption and record it to the build, if available.
&nbsp;     *
&nbsp;     * @since 1.425
&nbsp;     */
&nbsp;    public void recordCauseOfInterruption(Run&lt;?, ?&gt; build, TaskListener listener) {
&nbsp;        List&lt;CauseOfInterruption&gt; r;
&nbsp;
&nbsp;        // atomically get&amp;clear causes.
<b class="nc">&nbsp;        lock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (causes.isEmpty())   return;</b>
<b class="nc">&nbsp;            r = new ArrayList&lt;&gt;(causes);</b>
<b class="nc">&nbsp;            causes.clear();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        build.addAction(new InterruptedBuildAction(r));</b>
<b class="nc">&nbsp;        for (CauseOfInterruption c : r)</b>
<b class="nc">&nbsp;            c.print(listener);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * There are some cases where an executor is started but the node is removed or goes off-line before we are ready
&nbsp;     * to start executing the assigned work unit. This method is called to clear the assigned work unit so that
&nbsp;     * the {@link Queue#maintain()} method can return the item to the buildable state.
&nbsp;     *
&nbsp;     * Note: once we create the {@link Executable} we cannot unwind the state and the build will have to end up being
&nbsp;     * marked as a failure.
&nbsp;     */
&nbsp;    private void resetWorkUnit(String reason) {
<b class="nc">&nbsp;        StringWriter writer = new StringWriter();</b>
<b class="nc">&nbsp;        try (PrintWriter pw = new PrintWriter(writer)) {</b>
<b class="nc">&nbsp;            pw.printf(&quot;%s grabbed %s from queue but %s %s. &quot;, getName(), workUnit, owner.getDisplayName(), reason);</b>
<b class="nc">&nbsp;            if (owner.getTerminatedBy().isEmpty()) {</b>
<b class="nc">&nbsp;                pw.print(&quot;No termination trace available.&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                pw.println(&quot;Termination trace follows:&quot;);</b>
<b class="nc">&nbsp;                for (Computer.TerminationRequest request : owner.getTerminatedBy()) {</b>
<b class="nc">&nbsp;                    Functions.printStackTrace(request, pw);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        LOGGER.log(WARNING, writer.toString());</b>
<b class="nc">&nbsp;        lock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (executable != null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot reset the work unit after the executable has been created&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            workUnit = null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void run() {
<b class="nc">&nbsp;        if (!owner.isOnline()) {</b>
<b class="nc">&nbsp;            resetWorkUnit(&quot;went off-line before the task&#39;s worker thread started&quot;);</b>
<b class="nc">&nbsp;            owner.removeExecutor(this);</b>
<b class="nc">&nbsp;            queue.scheduleMaintenance();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (owner.getNode() == null) {</b>
<b class="nc">&nbsp;            resetWorkUnit(&quot;was removed before the task&#39;s worker thread started&quot;);</b>
<b class="nc">&nbsp;            owner.removeExecutor(this);</b>
<b class="nc">&nbsp;            queue.scheduleMaintenance();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        final WorkUnit workUnit;
<b class="nc">&nbsp;        lock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            startTime = System.currentTimeMillis();</b>
<b class="nc">&nbsp;            workUnit = this.workUnit;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
&nbsp;            SubTask task;
&nbsp;            // transition from idle to building.
&nbsp;            // perform this state change as an atomic operation wrt other queue operations
<b class="nc">&nbsp;            task = Queue.withLock(new Callable&lt;&gt;() {</b>
&nbsp;                @Override
&nbsp;                public SubTask call() throws Exception {
<b class="nc">&nbsp;                    if (!owner.isOnline()) {</b>
<b class="nc">&nbsp;                        resetWorkUnit(&quot;went off-line before the task&#39;s worker thread was ready to execute&quot;);</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (owner.getNode() == null) {</b>
<b class="nc">&nbsp;                        resetWorkUnit(&quot;was removed before the task&#39;s worker thread was ready to execute&quot;);</b>
<b class="nc">&nbsp;                        return null;</b>
&nbsp;                    }
&nbsp;                    // after this point we cannot unwind the assignment of the work unit, if the owner
&nbsp;                    // is removed or goes off-line then the build will just have to fail.
<b class="nc">&nbsp;                    workUnit.setExecutor(Executor.this);</b>
<b class="nc">&nbsp;                    queue.onStartExecuting(Executor.this);</b>
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(FINE))</b>
<b class="nc">&nbsp;                        LOGGER.log(FINE, getName() + &quot; grabbed &quot; + workUnit + &quot; from queue&quot;);</b>
<b class="nc">&nbsp;                    SubTask task = workUnit.work;</b>
<b class="nc">&nbsp;                    Executable executable = task.createExecutable();</b>
<b class="nc">&nbsp;                    if (executable == null) {</b>
<b class="nc">&nbsp;                        String displayName = task instanceof Queue.Task ? ((Queue.Task) task).getFullDisplayName() : task.getDisplayName();</b>
<b class="nc">&nbsp;                        LOGGER.log(WARNING, &quot;{0} cannot be run (for example because it is disabled)&quot;, displayName);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    lock.writeLock().lock();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Executor.this.executable = executable;</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        lock.writeLock().unlock();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    workUnit.setExecutable(executable);</b>
<b class="nc">&nbsp;                    return task;</b>
&nbsp;                }
&nbsp;            });
&nbsp;            Executable executable;
<b class="nc">&nbsp;            lock.readLock().lock();</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (this.workUnit == null) {</b>
&nbsp;                    // we called resetWorkUnit, so bail. Outer finally will remove this and schedule queue maintenance
&nbsp;                    return;
&nbsp;                }
<b class="nc">&nbsp;                executable = this.executable;</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                lock.readLock().unlock();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (LOGGER.isLoggable(FINE))</b>
<b class="nc">&nbsp;                LOGGER.log(FINE, getName() + &quot; is going to execute &quot; + executable);</b>
&nbsp;
<b class="nc">&nbsp;            Throwable problems = null;</b>
&nbsp;            try {
<b class="nc">&nbsp;                workUnit.context.synchronizeStart();</b>
&nbsp;
&nbsp;                // this code handles the behavior of null Executables returned
&nbsp;                // by tasks. In such case Jenkins starts the workUnit in order
&nbsp;                // to report results to console outputs.
<b class="nc">&nbsp;                if (executable == null) {</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                executableEstimatedDuration = executable.getEstimatedDuration();</b>
&nbsp;
<b class="nc">&nbsp;                if (executable instanceof Actionable) {</b>
<b class="nc">&nbsp;                    if (LOGGER.isLoggable(Level.FINER)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(</b>
&nbsp;                                FINER,
&nbsp;                                &quot;when running {0} from {1} we are copying {2} actions whereas the item currently has {3}&quot;,
&nbsp;                                new Object[] {
&nbsp;                                    executable,
&nbsp;                                    workUnit.context.item,
&nbsp;                                    workUnit.context.actions,
<b class="nc">&nbsp;                                    workUnit.context.item.getAllActions(),</b>
&nbsp;                                });
&nbsp;                    }
<b class="nc">&nbsp;                    for (Action action : workUnit.context.actions) {</b>
<b class="nc">&nbsp;                        ((Actionable) executable).addAction(action);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                setName(getName() + &quot; : executing &quot; + executable);</b>
<b class="nc">&nbsp;                Authentication auth = workUnit.context.item.authenticate2();</b>
<b class="nc">&nbsp;                LOGGER.log(FINE, &quot;{0} is now executing {1} as {2}&quot;, new Object[] {getName(), executable, auth});</b>
<b class="nc">&nbsp;                if (LOGGER.isLoggable(FINE) &amp;&amp; auth.equals(ACL.SYSTEM2)) { // i.e., unspecified</b>
<b class="nc">&nbsp;                    if (QueueItemAuthenticatorDescriptor.all().isEmpty()) {</b>
<b class="nc">&nbsp;                        LOGGER.fine(&quot;no QueueItemAuthenticator implementations installed&quot;);</b>
<b class="nc">&nbsp;                    } else if (QueueItemAuthenticatorConfiguration.get().getAuthenticators().isEmpty()) {</b>
<b class="nc">&nbsp;                        LOGGER.fine(&quot;no QueueItemAuthenticator implementations configured&quot;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        LOGGER.log(FINE, &quot;some QueueItemAuthenticator implementations configured but neglected to authenticate {0}&quot;, executable);</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                try (ACLContext context = ACL.as2(auth)) {</b>
<b class="nc">&nbsp;                    queue.execute(executable, task);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (AsynchronousExecution x) {</b>
<b class="nc">&nbsp;                lock.writeLock().lock();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    x.setExecutorWithoutCompleting(this);</b>
<b class="nc">&nbsp;                    this.asynchronousExecution = x;</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    lock.writeLock().unlock();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                x.maybeComplete();</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                problems = e;</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                boolean needFinish1;</b>
<b class="nc">&nbsp;                lock.readLock().lock();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    needFinish1 = asynchronousExecution == null;</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    lock.readLock().unlock();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (needFinish1) {</b>
<b class="nc">&nbsp;                    finish1(problems);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, getName() + &quot; interrupted&quot;, e);</b>
&nbsp;            // die peacefully
<b class="nc">&nbsp;        } catch (Exception | Error e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, getName() + &quot;: Unexpected executor death&quot;, e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            if (asynchronousExecution == null) {</b>
<b class="nc">&nbsp;                finish2();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void finish1(@CheckForNull Throwable problems) {
<b class="nc">&nbsp;        if (problems != null) {</b>
&nbsp;            // for some reason the executor died. this is really
&nbsp;            // a bug in the code, but we don&#39;t want the executor to die,
&nbsp;            // so just leave some info and go on to build other things
<b class="nc">&nbsp;            LOGGER.log(Level.SEVERE, &quot;Executor threw an exception&quot;, problems);</b>
<b class="nc">&nbsp;            workUnit.context.abort(problems);</b>
&nbsp;        }
<b class="nc">&nbsp;       long time = System.currentTimeMillis() - startTime;</b>
<b class="nc">&nbsp;        LOGGER.log(FINE, &quot;{0} completed {1} in {2}ms&quot;, new Object[]{getName(), executable, time});</b>
&nbsp;        try {
<b class="nc">&nbsp;            workUnit.context.synchronizeEnd(this, executable, problems, time);</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;            workUnit.context.abort(e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            workUnit.setExecutor(null);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void finish2() {
<b class="nc">&nbsp;        for (RuntimeException e1 : owner.getTerminatedBy()) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, String.format(&quot;%s termination trace&quot;, getName()), e1);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        owner.removeExecutor(this);</b>
<b class="nc">&nbsp;        if (this instanceof OneOffExecutor) {</b>
<b class="nc">&nbsp;            owner.remove((OneOffExecutor) this);</b>
&nbsp;        }
<b class="nc">&nbsp;        executableEstimatedDuration = DEFAULT_ESTIMATED_DURATION;</b>
<b class="nc">&nbsp;        queue.scheduleMaintenance();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void completedAsynchronous(@CheckForNull Throwable error) {
&nbsp;        try {
<b class="nc">&nbsp;            finish1(error);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            finish2();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        asynchronousExecution = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current build this executor is running.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      null if the executor is idle.
&nbsp;     */
&nbsp;    public @CheckForNull Queue.Executable getCurrentExecutable() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return executable;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Same as {@link #getCurrentExecutable} but checks {@link Item#READ}.
&nbsp;     */
&nbsp;    @Exported(name = &quot;currentExecutable&quot;)
&nbsp;    @Restricted(DoNotUse.class) // for exporting only
&nbsp;    public Queue.Executable getCurrentExecutableForApi() {
<b class="nc">&nbsp;        Executable candidate = getCurrentExecutable();</b>
<b class="nc">&nbsp;        return candidate instanceof AccessControlled &amp;&amp; ((AccessControlled) candidate).hasPermission(Item.READ) ? candidate : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns causes of interruption.
&nbsp;     *
&nbsp;     * @return Unmodifiable collection of causes of interruption.
&nbsp;     * @since  1.617
&nbsp;     */
&nbsp;    public @NonNull Collection&lt;CauseOfInterruption&gt; getCausesOfInterruption() {
<b class="nc">&nbsp;        return Collections.unmodifiableCollection(causes);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the current {@link WorkUnit} (of {@link #getCurrentExecutable() the current executable})
&nbsp;     * that this executor is running.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      null if the executor is idle.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public WorkUnit getCurrentWorkUnit() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return workUnit;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If {@linkplain #getCurrentExecutable() current executable} is {@link AbstractBuild},
&nbsp;     * return the workspace that this executor is using, or null if the build hasn&#39;t gotten
&nbsp;     * to that point yet.
&nbsp;     */
&nbsp;    public FilePath getCurrentWorkspace() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (executable == null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (executable instanceof AbstractBuild) {</b>
<b class="nc">&nbsp;                AbstractBuild ab = (AbstractBuild) executable;</b>
<b class="nc">&nbsp;                return ab.getWorkspace();</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Human readable name of the Jenkins executor. For the Java thread name use {@link #getName()}.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="nc">&nbsp;        return &quot;Executor #&quot; + getNumber();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the executor number that uniquely identifies it among
&nbsp;     * other {@link Executor}s for the same computer.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      a sequential number starting from 0.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public int getNumber() {
<b class="nc">&nbsp;        return number;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this {@link Executor} is ready for action.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isIdle() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return workUnit == null &amp;&amp; executable == null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The opposite of {@link #isIdle()} &amp;mdash; the executor is doing some work.
&nbsp;     */
&nbsp;    public boolean isBusy() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return workUnit != null || executable != null;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if executor is ready to accept tasks.
&nbsp;     * This method becomes the critical one since 1.536, which introduces the
&nbsp;     * on-demand creation of executor threads. Callers should use
&nbsp;     * this method instead of {@link #isAlive()}, which would be incorrect for
&nbsp;     * non-started threads or running {@link AsynchronousExecution}.
&nbsp;     * @return true if the executor is available for tasks (usually true)
&nbsp;     * @since 1.536
&nbsp;     */
&nbsp;    public boolean isActive() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return !started || asynchronousExecution != null || isAlive();</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If currently running in asynchronous mode, returns that handle.
&nbsp;     * @since 1.607
&nbsp;     */
&nbsp;    public @CheckForNull AsynchronousExecution getAsynchronousExecution() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return asynchronousExecution;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If this executor is running an {@link AsynchronousExecution} and that execution wants to hide the display
&nbsp;     * cell for the executor (because there is another executor displaying the job progress and we don&#39;t want to
&nbsp;     * confuse the user) then this method will return {@code false} to indicate to {@code executors.jelly} that
&nbsp;     * the executor cell should be hidden.
&nbsp;     *
&nbsp;     * @return {@code true} iff the {@code executorCell.jelly} for this {@link Executor} should be displayed in
&nbsp;     *         {@code executors.jelly}.
&nbsp;     * @since 1.607
&nbsp;     * @see AsynchronousExecution#displayCell()
&nbsp;     */
&nbsp;    public boolean isDisplayCell() {
<b class="nc">&nbsp;        AsynchronousExecution asynchronousExecution = getAsynchronousExecution();</b>
<b class="nc">&nbsp;        return asynchronousExecution == null || asynchronousExecution.displayCell();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if this executor is waiting for a task to execute.
&nbsp;     */
&nbsp;    public boolean isParking() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return !started;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated no longer used
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public @CheckForNull Throwable getCauseOfDeath() {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the progress of the current build in the number between 0-100.
&nbsp;     *
&nbsp;     * @return -1
&nbsp;     *      if it&#39;s impossible to estimate the progress.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public int getProgress() {
<b class="nc">&nbsp;        long d = executableEstimatedDuration;</b>
<b class="nc">&nbsp;        if (d &lt;= 0) {</b>
<b class="nc">&nbsp;            return DEFAULT_ESTIMATED_DURATION;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int num = (int) (getElapsedTime() * 100 / d);</b>
<b class="nc">&nbsp;        if (num &gt;= 100) {</b>
<b class="nc">&nbsp;            num = 99;</b>
&nbsp;        }
<b class="nc">&nbsp;        return num;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the current build is likely stuck.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is a heuristics based approach, but if the build is suspiciously taking for a long time,
&nbsp;     * this method returns true.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isLikelyStuck() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (executable == null) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        long elapsed = getElapsedTime();</b>
<b class="nc">&nbsp;        long d = executableEstimatedDuration;</b>
<b class="nc">&nbsp;        if (d &gt;= 0) {</b>
&nbsp;            // if it&#39;s taking 10 times longer than ETA, consider it stuck
<b class="nc">&nbsp;            return d * 10 &lt; elapsed;</b>
&nbsp;        } else {
&nbsp;            // if no ETA is available, a build taking longer than a day is considered stuck
<b class="nc">&nbsp;            return TimeUnit.MILLISECONDS.toHours(elapsed) &gt; 24;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public long getElapsedTime() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return System.currentTimeMillis() - startTime;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the number of milli-seconds the currently executing job spent in the queue
&nbsp;     * waiting for an available executor. This excludes the quiet period time of the job.
&nbsp;     * @since 1.440
&nbsp;     */
&nbsp;    public long getTimeSpentInQueue() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return startTime - workUnit.context.item.buildableStartMilliseconds;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the string that says how long since this build has started.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      string like &quot;3 minutes&quot; &quot;1 day&quot; etc.
&nbsp;     */
&nbsp;    public String getTimestampString() {
<b class="nc">&nbsp;        return Util.getTimeSpanString(getElapsedTime());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes a human-readable text that shows the expected remaining time
&nbsp;     * until the build completes.
&nbsp;     */
&nbsp;    public String getEstimatedRemainingTime() {
<b class="nc">&nbsp;        long d = executableEstimatedDuration;</b>
<b class="nc">&nbsp;        if (d &lt; 0) {</b>
<b class="nc">&nbsp;            return Messages.Executor_NotAvailable();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long eta = d - getElapsedTime();</b>
<b class="nc">&nbsp;        if (eta &lt;= 0) {</b>
<b class="nc">&nbsp;            return Messages.Executor_NotAvailable();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return Util.getTimeSpanString(eta);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The same as {@link #getEstimatedRemainingTime()} but return
&nbsp;     * it as a number of milli-seconds.
&nbsp;     */
&nbsp;    public long getEstimatedRemainingTimeMillis() {
<b class="nc">&nbsp;        long d = executableEstimatedDuration;</b>
<b class="nc">&nbsp;        if (d &lt; 0) {</b>
<b class="nc">&nbsp;            return DEFAULT_ESTIMATED_DURATION;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        long eta = d - getElapsedTime();</b>
<b class="nc">&nbsp;        if (eta &lt;= 0) {</b>
<b class="nc">&nbsp;            return DEFAULT_ESTIMATED_DURATION;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return eta;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Can&#39;t start executor like you normally start a thread.
&nbsp;     *
&nbsp;     * @see #start(WorkUnit)
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void start() {
<b class="nc">&nbsp;        throw new UnsupportedOperationException();</b>
&nbsp;    }
&nbsp;
&nbsp;    /*protected*/ void start(WorkUnit task) {
<b class="nc">&nbsp;        lock.writeLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            this.workUnit = task;</b>
<b class="nc">&nbsp;            super.start();</b>
<b class="nc">&nbsp;            started = true;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.489
&nbsp;     *      Use {@link #doStop()} or {@link #doStopBuild(String)}.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @Deprecated
&nbsp;    public void doStop(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        doStop().generateResponse(req, rsp, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Stops the current build.&lt;br&gt;
&nbsp;     * You can use {@link #doStopBuild(String)} instead to ensure what will be
&nbsp;     * interrupted is actually what you want to interrupt.
&nbsp;     *
&nbsp;     * @since 1.489
&nbsp;     * @see #doStopBuild(String)
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doStop() {
<b class="nc">&nbsp;        return doStopBuild(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Stops the current build, if matching the specified external id
&nbsp;     * (or no id is specified, or the current {@link Executable} is not a {@link Run}).
&nbsp;     *
&nbsp;     * @param runExtId
&nbsp;     *      if not null, the externalizable id ({@link Run#getExternalizableId()})
&nbsp;     *      of the build the user expects to interrupt
&nbsp;     * @since 2.209
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public HttpResponse doStopBuild(@CheckForNull @QueryParameter(fixEmpty = true) String runExtId) {
<b class="nc">&nbsp;        lock.writeLock().lock(); // need write lock as interrupt will change the field</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (executable != null) {</b>
<b class="nc">&nbsp;                if (runExtId == null || runExtId.isEmpty() || ! (executable instanceof Run)</b>
<b class="nc">&nbsp;                        || (runExtId.equals(((Run&lt;?, ?&gt;) executable).getExternalizableId()))) {</b>
<b class="nc">&nbsp;                    final Queue.Task ownerTask = getParentOf(executable).getOwnerTask();</b>
<b class="nc">&nbsp;                    boolean canAbort = ownerTask.hasAbortPermission();</b>
<b class="nc">&nbsp;                    if (canAbort &amp;&amp; ownerTask instanceof AccessControlled) {</b>
<b class="nc">&nbsp;                        if (!((AccessControlled) ownerTask).hasPermission(Item.READ)) {</b>
&nbsp;                            // pretend the build does not exist
<b class="nc">&nbsp;                            return HttpResponses.forwardToPreviousPage();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    ownerTask.checkAbortPermission();</b>
<b class="nc">&nbsp;                    interrupt();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.writeLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return HttpResponses.forwardToPreviousPage();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated now a no-op
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public HttpResponse doYank() {
<b class="nc">&nbsp;        return HttpResponses.redirectViaContextPath(&quot;/&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the current user has a permission to stop this build.
&nbsp;     */
&nbsp;    public boolean hasStopPermission() {
<b class="nc">&nbsp;        lock.readLock().lock();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return executable != null &amp;&amp; getParentOf(executable).getOwnerTask().hasAbortPermission();</b>
<b class="nc">&nbsp;        } catch (RuntimeException ex) {</b>
<b class="nc">&nbsp;            if (!(ex instanceof AccessDeniedException)) {</b>
&nbsp;                // Prevents UI from exploding in the case of unexpected runtime exceptions
<b class="nc">&nbsp;                LOGGER.log(WARNING, &quot;Unhandled exception&quot;, ex);</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            lock.readLock().unlock();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public @NonNull Computer getOwner() {
<b class="nc">&nbsp;        return owner;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns when this executor started or should start being idle.
&nbsp;     */
&nbsp;    public long getIdleStartMilliseconds() {
<b class="nc">&nbsp;        if (isIdle())</b>
<b class="nc">&nbsp;            return Math.max(creationTime, owner.getConnectTime());</b>
&nbsp;        else {
<b class="nc">&nbsp;            return Math.max(startTime + Math.max(0, executableEstimatedDuration), System.currentTimeMillis() + 15000);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exposes the executor to the remote API.
&nbsp;     */
&nbsp;    public Api getApi() {
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a proxy object that executes the callee in the context that impersonates
&nbsp;     * this executor. Useful to export an object to a remote channel.
&nbsp;     */
&nbsp;    public &lt;T&gt; T newImpersonatingProxy(Class&lt;T&gt; type, T core) {
<b class="nc">&nbsp;        return new InterceptingProxy() {</b>
&nbsp;            @Override
&nbsp;            protected Object call(Object o, Method m, Object[] args) throws Throwable {
<b class="nc">&nbsp;                final Executor old = IMPERSONATION.get();</b>
<b class="nc">&nbsp;                IMPERSONATION.set(Executor.this);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return m.invoke(o, args);</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    IMPERSONATION.set(old);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }.wrap(type, core);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the executor of the current thread or null if current thread is not an executor.
&nbsp;     */
&nbsp;    public static @CheckForNull Executor currentExecutor() {
<b class="nc">&nbsp;        Thread t = Thread.currentThread();</b>
<b class="nc">&nbsp;        if (t instanceof Executor) return (Executor) t;</b>
<b class="nc">&nbsp;        return IMPERSONATION.get();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds the executor currently running a given process.
&nbsp;     * @param executable a possibly running executable
&nbsp;     * @return the executor (possibly a {@link OneOffExecutor}) whose {@link Executor#getCurrentExecutable} matches that,
&nbsp;     *          or null if it could not be found (for example because the execution has already completed)
&nbsp;     * @since 1.607
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public static Executor of(Executable executable) {
<b class="nc">&nbsp;        Jenkins jenkins = Jenkins.getInstanceOrNull(); // TODO confirm safe to assume non-null and use getInstance()</b>
<b class="nc">&nbsp;        if (jenkins == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Computer computer : jenkins.getComputers()) {</b>
<b class="nc">&nbsp;            for (Executor executor : computer.getAllExecutors()) {</b>
<b class="nc">&nbsp;                if (executor.getCurrentExecutable() == executable) {</b>
<b class="nc">&nbsp;                    return executor;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated call {@link Executable#getEstimatedDuration} directly
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static long getEstimatedDurationFor(Executable e) {
<b class="nc">&nbsp;        return e == null ? DEFAULT_ESTIMATED_DURATION : e.getEstimatedDuration();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Mechanism to allow threads (in particular the channel request handling threads) to
&nbsp;     * run on behalf of {@link Executor}.
&nbsp;     */
<b class="nc">&nbsp;    private static final ThreadLocal&lt;Executor&gt; IMPERSONATION = new ThreadLocal&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Executor.class.getName());</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
