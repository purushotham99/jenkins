


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Jenkins</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">jenkins.model</a>
</div>

<h1>Coverage Summary for Class: Jenkins (jenkins.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Jenkins</td>
<td class="coverageStat">
  <span class="percent">
    3.4%
  </span>
  <span class="absValue">
    (11/325)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7%
  </span>
  <span class="absValue">
    (113/1617)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Jenkins$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$19</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$20</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$21</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$22</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$ClockDifferenceCallable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$CloudList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$DescriptorImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$EnforceSlaveAgentPortAdministrativeMonitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$JenkinsHolder</td>
  </tr>
  <tr>
    <td class="name">Jenkins$JenkinsJVMAccess</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$MasterComputer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$MasterRestartNotifyier</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$MasterRestartNotifyier$RestartCause</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Jenkins$QuietDownInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    3.1%
  </span>
  <span class="absValue">
    (13/426)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.3%
  </span>
  <span class="absValue">
    (115/1837)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * The MIT License
&nbsp; *
&nbsp; * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,
&nbsp; * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,
&nbsp; * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,
&nbsp; * Yahoo!, Inc.
&nbsp; *
&nbsp; * Permission is hereby granted, free of charge, to any person obtaining a copy
&nbsp; * of this software and associated documentation files (the &quot;Software&quot;), to deal
&nbsp; * in the Software without restriction, including without limitation the rights
&nbsp; * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&nbsp; * copies of the Software, and to permit persons to whom the Software is
&nbsp; * furnished to do so, subject to the following conditions:
&nbsp; *
&nbsp; * The above copyright notice and this permission notice shall be included in
&nbsp; * all copies or substantial portions of the Software.
&nbsp; *
&nbsp; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&nbsp; * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&nbsp; * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&nbsp; * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&nbsp; * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&nbsp; * THE SOFTWARE.
&nbsp; */
&nbsp;
&nbsp;package jenkins.model;
&nbsp;
&nbsp;import static hudson.Util.fixEmpty;
&nbsp;import static hudson.Util.fixNull;
&nbsp;import static hudson.init.InitMilestone.COMPLETED;
&nbsp;import static hudson.init.InitMilestone.EXTENSIONS_AUGMENTED;
&nbsp;import static hudson.init.InitMilestone.JOB_CONFIG_ADAPTED;
&nbsp;import static hudson.init.InitMilestone.JOB_LOADED;
&nbsp;import static hudson.init.InitMilestone.PLUGINS_PREPARED;
&nbsp;import static hudson.init.InitMilestone.SYSTEM_CONFIG_LOADED;
&nbsp;import static java.util.logging.Level.FINE;
&nbsp;import static java.util.logging.Level.INFO;
&nbsp;import static java.util.logging.Level.SEVERE;
&nbsp;import static java.util.logging.Level.WARNING;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
&nbsp;import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;
&nbsp;
&nbsp;import com.google.common.annotations.VisibleForTesting;
&nbsp;import com.google.inject.Inject;
&nbsp;import com.google.inject.Injector;
&nbsp;import com.thoughtworks.xstream.XStream;
&nbsp;import edu.umd.cs.findbugs.annotations.CheckForNull;
&nbsp;import edu.umd.cs.findbugs.annotations.NonNull;
&nbsp;import edu.umd.cs.findbugs.annotations.Nullable;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import hudson.BulkChange;
&nbsp;import hudson.DescriptorExtensionList;
&nbsp;import hudson.Extension;
&nbsp;import hudson.ExtensionComponent;
&nbsp;import hudson.ExtensionFinder;
&nbsp;import hudson.ExtensionList;
&nbsp;import hudson.ExtensionPoint;
&nbsp;import hudson.FilePath;
&nbsp;import hudson.Functions;
&nbsp;import hudson.Launcher;
&nbsp;import hudson.Launcher.LocalLauncher;
&nbsp;import hudson.Lookup;
&nbsp;import hudson.Main;
&nbsp;import hudson.Plugin;
&nbsp;import hudson.PluginManager;
&nbsp;import hudson.PluginWrapper;
&nbsp;import hudson.ProxyConfiguration;
&nbsp;import hudson.RestrictedSince;
&nbsp;import hudson.TcpSlaveAgentListener;
&nbsp;import hudson.Util;
&nbsp;import hudson.WebAppMain;
&nbsp;import hudson.XmlFile;
&nbsp;import hudson.cli.declarative.CLIMethod;
&nbsp;import hudson.cli.declarative.CLIResolver;
&nbsp;import hudson.init.InitMilestone;
&nbsp;import hudson.init.InitStrategy;
&nbsp;import hudson.init.Initializer;
&nbsp;import hudson.init.TermMilestone;
&nbsp;import hudson.init.TerminatorFinder;
&nbsp;import hudson.lifecycle.Lifecycle;
&nbsp;import hudson.lifecycle.RestartNotSupportedException;
&nbsp;import hudson.logging.LogRecorderManager;
&nbsp;import hudson.markup.EscapedMarkupFormatter;
&nbsp;import hudson.markup.MarkupFormatter;
&nbsp;import hudson.model.AbstractCIBase;
&nbsp;import hudson.model.AbstractProject;
&nbsp;import hudson.model.Action;
&nbsp;import hudson.model.AdministrativeMonitor;
&nbsp;import hudson.model.AllView;
&nbsp;import hudson.model.Api;
&nbsp;import hudson.model.Computer;
&nbsp;import hudson.model.ComputerSet;
&nbsp;import hudson.model.DependencyGraph;
&nbsp;import hudson.model.Describable;
&nbsp;import hudson.model.Descriptor;
&nbsp;import hudson.model.Descriptor.FormException;
&nbsp;import hudson.model.DescriptorByNameOwner;
&nbsp;import hudson.model.DirectoryBrowserSupport;
&nbsp;import hudson.model.Failure;
&nbsp;import hudson.model.Fingerprint;
&nbsp;import hudson.model.FingerprintCleanupThread;
&nbsp;import hudson.model.FingerprintMap;
&nbsp;import hudson.model.Hudson;
&nbsp;import hudson.model.Item;
&nbsp;import hudson.model.ItemGroup;
&nbsp;import hudson.model.ItemGroupMixIn;
&nbsp;import hudson.model.Items;
&nbsp;import hudson.model.JDK;
&nbsp;import hudson.model.Job;
&nbsp;import hudson.model.JobPropertyDescriptor;
&nbsp;import hudson.model.Label;
&nbsp;import hudson.model.ListView;
&nbsp;import hudson.model.LoadBalancer;
&nbsp;import hudson.model.LoadStatistics;
&nbsp;import hudson.model.ManageJenkinsAction;
&nbsp;import hudson.model.ManagementLink;
&nbsp;import hudson.model.Messages;
&nbsp;import hudson.model.ModifiableViewGroup;
&nbsp;import hudson.model.NoFingerprintMatch;
&nbsp;import hudson.model.Node;
&nbsp;import hudson.model.OverallLoadStatistics;
&nbsp;import hudson.model.PaneStatusProperties;
&nbsp;import hudson.model.Project;
&nbsp;import hudson.model.Queue;
&nbsp;import hudson.model.Queue.FlyweightTask;
&nbsp;import hudson.model.RestartListener;
&nbsp;import hudson.model.RootAction;
&nbsp;import hudson.model.Slave;
&nbsp;import hudson.model.TaskListener;
&nbsp;import hudson.model.TopLevelItem;
&nbsp;import hudson.model.TopLevelItemDescriptor;
&nbsp;import hudson.model.UnprotectedRootAction;
&nbsp;import hudson.model.UpdateCenter;
&nbsp;import hudson.model.User;
&nbsp;import hudson.model.View;
&nbsp;import hudson.model.ViewGroupMixIn;
&nbsp;import hudson.model.WorkspaceCleanupThread;
&nbsp;import hudson.model.labels.LabelAtom;
&nbsp;import hudson.model.listeners.ItemListener;
&nbsp;import hudson.model.listeners.SCMListener;
&nbsp;import hudson.model.listeners.SaveableListener;
&nbsp;import hudson.remoting.Callable;
&nbsp;import hudson.remoting.LocalChannel;
&nbsp;import hudson.remoting.VirtualChannel;
&nbsp;import hudson.scm.RepositoryBrowser;
&nbsp;import hudson.scm.SCM;
&nbsp;import hudson.search.CollectionSearchIndex;
&nbsp;import hudson.search.SearchIndexBuilder;
&nbsp;import hudson.search.SearchItem;
&nbsp;import hudson.security.ACL;
&nbsp;import hudson.security.ACLContext;
&nbsp;import hudson.security.AccessControlled;
&nbsp;import hudson.security.AuthorizationStrategy;
&nbsp;import hudson.security.BasicAuthenticationFilter;
&nbsp;import hudson.security.FederatedLoginService;
&nbsp;import hudson.security.HudsonFilter;
&nbsp;import hudson.security.LegacyAuthorizationStrategy;
&nbsp;import hudson.security.LegacySecurityRealm;
&nbsp;import hudson.security.Permission;
&nbsp;import hudson.security.PermissionGroup;
&nbsp;import hudson.security.PermissionScope;
&nbsp;import hudson.security.SecurityMode;
&nbsp;import hudson.security.SecurityRealm;
&nbsp;import hudson.security.csrf.CrumbIssuer;
&nbsp;import hudson.security.csrf.GlobalCrumbIssuerConfiguration;
&nbsp;import hudson.slaves.Cloud;
&nbsp;import hudson.slaves.ComputerListener;
&nbsp;import hudson.slaves.DumbSlave;
&nbsp;import hudson.slaves.NodeDescriptor;
&nbsp;import hudson.slaves.NodeList;
&nbsp;import hudson.slaves.NodeProperty;
&nbsp;import hudson.slaves.NodePropertyDescriptor;
&nbsp;import hudson.slaves.NodeProvisioner;
&nbsp;import hudson.slaves.OfflineCause;
&nbsp;import hudson.slaves.RetentionStrategy;
&nbsp;import hudson.tasks.BuildWrapper;
&nbsp;import hudson.tasks.Builder;
&nbsp;import hudson.tasks.Publisher;
&nbsp;import hudson.triggers.SafeTimerTask;
&nbsp;import hudson.triggers.Trigger;
&nbsp;import hudson.triggers.TriggerDescriptor;
&nbsp;import hudson.util.AdministrativeError;
&nbsp;import hudson.util.ClockDifference;
&nbsp;import hudson.util.CopyOnWriteList;
&nbsp;import hudson.util.CopyOnWriteMap;
&nbsp;import hudson.util.DaemonThreadFactory;
&nbsp;import hudson.util.DescribableList;
&nbsp;import hudson.util.FormApply;
&nbsp;import hudson.util.FormValidation;
&nbsp;import hudson.util.Futures;
&nbsp;import hudson.util.HudsonIsLoading;
&nbsp;import hudson.util.HudsonIsRestarting;
&nbsp;import hudson.util.Iterators;
&nbsp;import hudson.util.JenkinsReloadFailed;
&nbsp;import hudson.util.LogTaskListener;
&nbsp;import hudson.util.MultipartFormDataParser;
&nbsp;import hudson.util.NamingThreadFactory;
&nbsp;import hudson.util.PluginServletFilter;
&nbsp;import hudson.util.QuotedStringTokenizer;
&nbsp;import hudson.util.RemotingDiagnostics;
&nbsp;import hudson.util.RemotingDiagnostics.HeapDump;
&nbsp;import hudson.util.TextFile;
&nbsp;import hudson.util.VersionNumber;
&nbsp;import hudson.util.XStream2;
&nbsp;import hudson.views.DefaultMyViewsTabBar;
&nbsp;import hudson.views.DefaultViewsTabBar;
&nbsp;import hudson.views.MyViewsTabBar;
&nbsp;import hudson.views.ViewsTabBar;
&nbsp;import hudson.widgets.Widget;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InterruptedIOException;
&nbsp;import java.io.PrintWriter;
&nbsp;import java.net.BindException;
&nbsp;import java.net.HttpURLConnection;
&nbsp;import java.net.URL;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.security.SecureRandom;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Properties;
&nbsp;import java.util.Set;
&nbsp;import java.util.StringTokenizer;
&nbsp;import java.util.TimerTask;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.concurrent.CompletableFuture;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.CopyOnWriteArrayList;
&nbsp;import java.util.concurrent.CountDownLatch;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.LinkedBlockingQueue;
&nbsp;import java.util.concurrent.ThreadPoolExecutor;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.TimeoutException;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.logging.Level;
&nbsp;import java.util.logging.LogRecord;
&nbsp;import java.util.logging.Logger;
&nbsp;import java.util.stream.Collectors;
&nbsp;import javax.crypto.SecretKey;
&nbsp;import javax.servlet.RequestDispatcher;
&nbsp;import javax.servlet.ServletContext;
&nbsp;import javax.servlet.ServletException;
&nbsp;import javax.servlet.http.Cookie;
&nbsp;import javax.servlet.http.HttpServletResponse;
&nbsp;import jenkins.AgentProtocol;
&nbsp;import jenkins.ErrorAttributeFilter;
&nbsp;import jenkins.ExtensionComponentSet;
&nbsp;import jenkins.ExtensionRefreshException;
&nbsp;import jenkins.InitReactorRunner;
&nbsp;import jenkins.agents.CloudSet;
&nbsp;import jenkins.diagnostics.URICheckEncodingMonitor;
&nbsp;import jenkins.install.InstallState;
&nbsp;import jenkins.install.SetupWizard;
&nbsp;import jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;
&nbsp;import jenkins.security.ClassFilterImpl;
&nbsp;import jenkins.security.ConfidentialKey;
&nbsp;import jenkins.security.ConfidentialStore;
&nbsp;import jenkins.security.MasterToSlaveCallable;
&nbsp;import jenkins.security.RedactSecretJsonInErrorMessageSanitizer;
&nbsp;import jenkins.security.ResourceDomainConfiguration;
&nbsp;import jenkins.security.SecurityListener;
&nbsp;import jenkins.security.stapler.DoActionFilter;
&nbsp;import jenkins.security.stapler.StaplerDispatchValidator;
&nbsp;import jenkins.security.stapler.StaplerDispatchable;
&nbsp;import jenkins.security.stapler.StaplerFilteredActionListener;
&nbsp;import jenkins.security.stapler.TypedFilter;
&nbsp;import jenkins.slaves.WorkspaceLocator;
&nbsp;import jenkins.util.JenkinsJVM;
&nbsp;import jenkins.util.Listeners;
&nbsp;import jenkins.util.SystemProperties;
&nbsp;import jenkins.util.Timer;
&nbsp;import jenkins.util.io.FileBoolean;
&nbsp;import jenkins.util.io.OnMaster;
&nbsp;import jenkins.util.xml.XMLUtils;
&nbsp;import net.jcip.annotations.GuardedBy;
&nbsp;import net.sf.json.JSONObject;
&nbsp;import org.apache.commons.jelly.JellyException;
&nbsp;import org.apache.commons.jelly.Script;
&nbsp;import org.apache.commons.logging.LogFactory;
&nbsp;import org.jvnet.hudson.reactor.Executable;
&nbsp;import org.jvnet.hudson.reactor.Milestone;
&nbsp;import org.jvnet.hudson.reactor.Reactor;
&nbsp;import org.jvnet.hudson.reactor.ReactorException;
&nbsp;import org.jvnet.hudson.reactor.ReactorListener;
&nbsp;import org.jvnet.hudson.reactor.Task;
&nbsp;import org.jvnet.hudson.reactor.TaskBuilder;
&nbsp;import org.jvnet.hudson.reactor.TaskGraphBuilder;
&nbsp;import org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;
&nbsp;import org.kohsuke.accmod.Restricted;
&nbsp;import org.kohsuke.accmod.restrictions.Beta;
&nbsp;import org.kohsuke.accmod.restrictions.DoNotUse;
&nbsp;import org.kohsuke.accmod.restrictions.NoExternalUse;
&nbsp;import org.kohsuke.args4j.Argument;
&nbsp;import org.kohsuke.stapler.HttpRedirect;
&nbsp;import org.kohsuke.stapler.HttpResponse;
&nbsp;import org.kohsuke.stapler.HttpResponses;
&nbsp;import org.kohsuke.stapler.MetaClass;
&nbsp;import org.kohsuke.stapler.QueryParameter;
&nbsp;import org.kohsuke.stapler.Stapler;
&nbsp;import org.kohsuke.stapler.StaplerFallback;
&nbsp;import org.kohsuke.stapler.StaplerProxy;
&nbsp;import org.kohsuke.stapler.StaplerRequest;
&nbsp;import org.kohsuke.stapler.StaplerResponse;
&nbsp;import org.kohsuke.stapler.WebApp;
&nbsp;import org.kohsuke.stapler.WebMethod;
&nbsp;import org.kohsuke.stapler.export.Exported;
&nbsp;import org.kohsuke.stapler.export.ExportedBean;
&nbsp;import org.kohsuke.stapler.framework.adjunct.AdjunctManager;
&nbsp;import org.kohsuke.stapler.interceptor.RequirePOST;
&nbsp;import org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;
&nbsp;import org.kohsuke.stapler.jelly.JellyRequestDispatcher;
&nbsp;import org.kohsuke.stapler.verb.POST;
&nbsp;import org.springframework.security.access.AccessDeniedException;
&nbsp;import org.springframework.security.authentication.AnonymousAuthenticationToken;
&nbsp;import org.springframework.security.core.Authentication;
&nbsp;import org.springframework.security.core.authority.SimpleGrantedAuthority;
&nbsp;import org.springframework.security.core.context.SecurityContextHolder;
&nbsp;import org.xml.sax.InputSource;
&nbsp;
&nbsp;/**
&nbsp; * Root object of the system.
&nbsp; *
&nbsp; * @author Kohsuke Kawaguchi
&nbsp; */
<b class="fc">&nbsp;@ExportedBean</b>
&nbsp;public class Jenkins extends AbstractCIBase implements DirectlyModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback,
&nbsp;        ModifiableViewGroup, AccessControlled, DescriptorByNameOwner,
&nbsp;        ModelObjectWithContextMenu, ModelObjectWithChildren, OnMaster, Loadable {
&nbsp;    private final transient Queue queue;
&nbsp;
&nbsp;    // flag indicating if we have loaded the jenkins configuration or not yet.
<b class="nc">&nbsp;    private transient volatile boolean configLoaded = false;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Stores various objects scoped to {@link Jenkins}.
&nbsp;     */
<b class="nc">&nbsp;    public final transient Lookup lookup = new Lookup();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * We update this field to the current version of Jenkins whenever we save {@code config.xml}.
&nbsp;     * This can be used to detect when an upgrade happens from one version to next.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Since this field is introduced starting 1.301, &quot;1.0&quot; is used to represent every version
&nbsp;     * up to 1.300. This value may also include non-standard versions like &quot;1.301-SNAPSHOT&quot; or
&nbsp;     * &quot;?&quot;, etc., so parsing needs to be done with a care.
&nbsp;     *
&nbsp;     * @since 1.301
&nbsp;     */
&nbsp;    // this field needs to be at the very top so that other components can look at this value even during unmarshalling
<b class="nc">&nbsp;    private String version = &quot;1.0&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The Jenkins instance startup type i.e. NEW, UPGRADE etc
&nbsp;     */
&nbsp;    private transient String installStateName;
&nbsp;
&nbsp;    @Deprecated
&nbsp;    private InstallState installState;
&nbsp;
&nbsp;    /**
&nbsp;     * If we&#39;re in the process of an initial setup,
&nbsp;     * this will be set
&nbsp;     */
&nbsp;    private transient SetupWizard setupWizard;
&nbsp;
&nbsp;    /**
&nbsp;     * Number of executors of the built-in node.
&nbsp;     */
<b class="nc">&nbsp;    private int numExecutors = 2;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Job allocation strategy.
&nbsp;     */
<b class="nc">&nbsp;    private Mode mode = Mode.NORMAL;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * False to enable anyone to do anything.
&nbsp;     * Left as a field so that we can still read old data that uses this flag.
&nbsp;     *
&nbsp;     * @see #authorizationStrategy
&nbsp;     * @see #securityRealm
&nbsp;     */
&nbsp;    private Boolean useSecurity;
&nbsp;
&nbsp;    /**
&nbsp;     * Controls how the
&nbsp;     * &lt;a href=&quot;http://en.wikipedia.org/wiki/Authorization&quot;&gt;authorization&lt;/a&gt;
&nbsp;     * is handled in Jenkins.
&nbsp;     * &lt;p&gt;
&nbsp;     * This ultimately controls who has access to what.
&nbsp;     *
&nbsp;     * Never null.
&nbsp;     */
<b class="nc">&nbsp;    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Controls a part of the
&nbsp;     * &lt;a href=&quot;http://en.wikipedia.org/wiki/Authentication&quot;&gt;authentication&lt;/a&gt;
&nbsp;     * handling in Jenkins.
&nbsp;     * &lt;p&gt;
&nbsp;     * Intuitively, this corresponds to the user database.
&nbsp;     *
&nbsp;     * See {@link HudsonFilter} for the concrete authentication protocol.
&nbsp;     *
&nbsp;     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to
&nbsp;     * update this field.
&nbsp;     *
&nbsp;     * @see #getSecurity()
&nbsp;     * @see #setSecurityRealm(SecurityRealm)
&nbsp;     */
<b class="nc">&nbsp;    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Disables the &quot;Keep me signed in&quot; option in the standard login screen.
&nbsp;     *
&nbsp;     * @since 1.534
&nbsp;     */
&nbsp;    private volatile boolean disableRememberMe;
&nbsp;
&nbsp;    /**
&nbsp;     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?
&nbsp;     */
<b class="nc">&nbsp;    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Root directory for the workspaces.
&nbsp;     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.
&nbsp;     * @see #getWorkspaceFor(TopLevelItem)
&nbsp;     */
<b class="nc">&nbsp;    private String workspaceDir = OLD_DEFAULT_WORKSPACES_DIR;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Root directory for the builds.
&nbsp;     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.
&nbsp;     * @see #getBuildDirFor(Job)
&nbsp;     */
<b class="nc">&nbsp;    private String buildsDir = DEFAULT_BUILDS_DIR;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Message displayed in the top page.
&nbsp;     */
&nbsp;    private String systemMessage;
&nbsp;
&nbsp;    private MarkupFormatter markupFormatter;
&nbsp;
&nbsp;    /**
&nbsp;     * Root directory of the system.
&nbsp;     */
&nbsp;    public final transient File root;
&nbsp;
&nbsp;    /**
&nbsp;     * Where are we in the initialization?
&nbsp;     */
<b class="nc">&nbsp;    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * All {@link Item}s keyed by their {@link Item#getName() name}s.
&nbsp;     */
<b class="nc">&nbsp;    /*package*/ final transient Map&lt;String, TopLevelItem&gt; items = new CopyOnWriteMap.Tree&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The sole instance.
&nbsp;     */
&nbsp;    private static Jenkins theInstance;
&nbsp;
&nbsp;    @CheckForNull
&nbsp;    private transient volatile QuietDownInfo quietDownInfo;
&nbsp;
&nbsp;    private transient volatile boolean terminating;
&nbsp;    @GuardedBy(&quot;Jenkins.class&quot;)
&nbsp;    private transient boolean cleanUpStarted;
&nbsp;
&nbsp;    /**
&nbsp;     * Use this to know during startup if this is a fresh one, aka first-time, startup, or a later one.
&nbsp;     * A file will be created at the very end of the Jenkins initialization process.
&nbsp;     * I.e. if the file is present, that means this is *NOT* a fresh startup.
&nbsp;     *
&nbsp;     * {@code
&nbsp;     *     STARTUP_MARKER_FILE.get(); // returns false if we are on a fresh startup. True for next startups.
&nbsp;     * }
&nbsp;     */
&nbsp;    private static transient FileBoolean STARTUP_MARKER_FILE;
&nbsp;
<b class="nc">&nbsp;    private volatile List&lt;JDK&gt; jdks = new ArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    private transient volatile DependencyGraph dependencyGraph;
&nbsp;    private transient Future&lt;DependencyGraph&gt; scheduledFutureDependencyGraph;
&nbsp;    private transient Future&lt;DependencyGraph&gt; calculatingFutureDependencyGraph;
<b class="nc">&nbsp;    private transient Object dependencyGraphLock = new Object();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Currently active Views tab bar.
&nbsp;     */
<b class="nc">&nbsp;    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Currently active My Views tab bar.
&nbsp;     */
<b class="nc">&nbsp;    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.
&nbsp;     */
<b class="nc">&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)</b>
&nbsp;    private final transient Map&lt;Class, ExtensionList&gt; extensionLists = new ConcurrentHashMap&lt;&gt;();
&nbsp;
&nbsp;    /**
&nbsp;     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.
&nbsp;     */
<b class="nc">&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;)</b>
&nbsp;    private final transient Map&lt;Class, DescriptorExtensionList&gt; descriptorLists = new ConcurrentHashMap&lt;&gt;();
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Computer}s in this Jenkins system. Read-only.
&nbsp;     */
<b class="nc">&nbsp;    protected final transient ConcurrentMap&lt;Node, Computer&gt; computers = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Active {@link Cloud}s.
&nbsp;     */
<b class="nc">&nbsp;    public final Hudson.CloudList clouds = new Hudson.CloudList(this);</b>
&nbsp;
&nbsp;    public static class CloudList extends DescribableList&lt;Cloud, Descriptor&lt;Cloud&gt;&gt; {
&nbsp;        public CloudList(Jenkins h) {
<b class="nc">&nbsp;            super(h);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public CloudList() {// needed for XStream deserialization</b>
&nbsp;        }
&nbsp;
&nbsp;        public Cloud getByName(String name) {
<b class="nc">&nbsp;            for (Cloud c : this)</b>
<b class="nc">&nbsp;                if (c.name.equals(name))</b>
<b class="nc">&nbsp;                    return c;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onModified() throws IOException {
<b class="nc">&nbsp;            super.onModified();</b>
<b class="nc">&nbsp;            Jenkins.get().trimLabels();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Legacy store of the set of installed cluster nodes.
&nbsp;     * @deprecated in favour of {@link Nodes}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    protected transient volatile NodeList slaves;
&nbsp;
&nbsp;    /**
&nbsp;     * The holder of the set of installed cluster nodes.
&nbsp;     *
&nbsp;     * @since 1.607
&nbsp;     */
<b class="nc">&nbsp;    private final transient Nodes nodes = new Nodes(this);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Quiet period.
&nbsp;     *
&nbsp;     * This is {@link Integer} so that we can initialize it to &#39;5&#39; for upgrading users.
&nbsp;     */
&nbsp;    /*package*/ Integer quietPeriod;
&nbsp;
&nbsp;    /**
&nbsp;     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}
&nbsp;     */
&nbsp;    /*package*/ int scmCheckoutRetryCount;
&nbsp;
&nbsp;    /**
&nbsp;     * {@link View}s.
&nbsp;     */
<b class="nc">&nbsp;    private final CopyOnWriteArrayList&lt;View&gt; views = new CopyOnWriteArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Name of the primary view.
&nbsp;     * &lt;p&gt;
&nbsp;     * Start with null, so that we can upgrade pre-1.269 data well.
&nbsp;     * @since 1.269
&nbsp;     */
&nbsp;    private volatile String primaryView;
&nbsp;
<b class="nc">&nbsp;    private final transient ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {</b>
&nbsp;        @Override
<b class="nc">&nbsp;        protected List&lt;View&gt; views() { return views; }</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        protected String primaryView() { return primaryView; }</b>
&nbsp;
&nbsp;        @Override
<b class="nc">&nbsp;        protected void primaryView(String name) { primaryView = name; }</b>
&nbsp;    };
&nbsp;
&nbsp;
<b class="nc">&nbsp;    private final transient FingerprintMap fingerprintMap = new FingerprintMap();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Loaded plugins.
&nbsp;     */
&nbsp;    public final transient PluginManager pluginManager;
&nbsp;
&nbsp;    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;
&nbsp;
<b class="nc">&nbsp;    private final transient Object tcpSlaveAgentListenerLock = new Object();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * List of registered {@link SCMListener}s.
&nbsp;     */
<b class="nc">&nbsp;    private final transient CopyOnWriteList&lt;SCMListener&gt; scmListeners = new CopyOnWriteList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * TCP agent port.
&nbsp;     * 0 for random, -1 to disable.
&nbsp;     */
<b class="nc">&nbsp;    private int slaveAgentPort = getSlaveAgentPortInitialValue(0);</b>
&nbsp;
&nbsp;    private static int getSlaveAgentPortInitialValue(int def) {
<b class="nc">&nbsp;        return SystemProperties.getInteger(Jenkins.class.getName() + &quot;.slaveAgentPort&quot;, def);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If -Djenkins.model.Jenkins.slaveAgentPort is defined, enforce it on every start instead of only the first one.
&nbsp;     */
<b class="fc">&nbsp;    private static final boolean SLAVE_AGENT_PORT_ENFORCE = SystemProperties.getBoolean(Jenkins.class.getName() + &quot;.slaveAgentPortEnforce&quot;, false);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The TCP agent protocols that are explicitly disabled (we store the disabled ones so that newer protocols
&nbsp;     * are enabled by default). Will be {@code null} instead of empty to simplify XML format.
&nbsp;     *
&nbsp;     * @since 2.16
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    @GuardedBy(&quot;this&quot;)
&nbsp;    private List&lt;String&gt; disabledAgentProtocols;
&nbsp;    /**
&nbsp;     * @deprecated Just a temporary buffer for XSTream migration code from JENKINS-39465, do not use
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    private transient String[] _disabledAgentProtocols;
&nbsp;
&nbsp;    /**
&nbsp;     * The TCP agent protocols that are {@link AgentProtocol#isOptIn()} and explicitly enabled.
&nbsp;     * Will be {@code null} instead of empty to simplify XML format.
&nbsp;     *
&nbsp;     * @since 2.16
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    @GuardedBy(&quot;this&quot;)
&nbsp;    private List&lt;String&gt; enabledAgentProtocols;
&nbsp;    /**
&nbsp;     * @deprecated Just a temporary buffer for XSTream migration code from JENKINS-39465, do not use
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    private transient String[] _enabledAgentProtocols;
&nbsp;
&nbsp;    /**
&nbsp;     * The TCP agent protocols that are enabled. Built from {@link #disabledAgentProtocols} and
&nbsp;     * {@link #enabledAgentProtocols}.
&nbsp;     *
&nbsp;     * @since 2.16
&nbsp;     * @see #setAgentProtocols(Set)
&nbsp;     * @see #getAgentProtocols()
&nbsp;     */
&nbsp;    @GuardedBy(&quot;this&quot;)
&nbsp;    private transient Set&lt;String&gt; agentProtocols;
&nbsp;
&nbsp;    /**
&nbsp;     * Whitespace-separated labels assigned to the built-in node as a {@link Node}.
&nbsp;     */
<b class="nc">&nbsp;    private String label = &quot;&quot;;</b>
&nbsp;
<b class="fc">&nbsp;    private static /* non-final for Groovy */ String nodeNameAndSelfLabelOverride = SystemProperties.getString(Jenkins.class.getName() + &quot;.nodeNameAndSelfLabelOverride&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link hudson.security.csrf.CrumbIssuer}
&nbsp;     */
<b class="nc">&nbsp;    private volatile CrumbIssuer crumbIssuer = GlobalCrumbIssuerConfiguration.createDefaultCrumbIssuer();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * All labels known to Jenkins. This allows us to reuse the same label instances
&nbsp;     * as much as possible, even though that&#39;s not a strict requirement.
&nbsp;     */
<b class="nc">&nbsp;    private final transient ConcurrentHashMap&lt;String, Label&gt; labels = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Load statistics of the entire system.
&nbsp;     *
&nbsp;     * This includes every executor and every job in the system.
&nbsp;     */
<b class="nc">&nbsp;    @Exported</b>
&nbsp;    public final transient OverallLoadStatistics overallLoad = new OverallLoadStatistics();
&nbsp;
&nbsp;    /**
&nbsp;     * Load statistics of the free roaming jobs and agents.
&nbsp;     *
&nbsp;     * This includes all executors on {@link hudson.model.Node.Mode#NORMAL} nodes and jobs that do not have any assigned nodes.
&nbsp;     *
&nbsp;     * @since 1.467
&nbsp;     */
<b class="nc">&nbsp;    @Exported</b>
&nbsp;    public final transient LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();
&nbsp;
&nbsp;    /**
&nbsp;     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.
&nbsp;     * @since 1.467
&nbsp;     */
<b class="nc">&nbsp;    public final transient NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null, unlabeledLoad);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated as of 1.467
&nbsp;     *      Use {@link #unlabeledNodeProvisioner}.
&nbsp;     *      This was broken because it was tracking all the executors in the system, but it was only tracking
&nbsp;     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive
&nbsp;     *      agents and free-roaming jobs in the queue.
&nbsp;     */
<b class="nc">&nbsp;    @Restricted(NoExternalUse.class)</b>
&nbsp;    @Deprecated
&nbsp;    public final transient NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;
&nbsp;
&nbsp;
&nbsp;    public final transient ServletContext servletContext;
&nbsp;
&nbsp;    /**
&nbsp;     * Transient action list. Useful for adding navigation items to the navigation bar
&nbsp;     * on the left.
&nbsp;     */
<b class="nc">&nbsp;    private final transient List&lt;Action&gt; actions = new CopyOnWriteArrayList&lt;&gt;();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * List of built-in node-specific node properties
&nbsp;     */
<b class="nc">&nbsp;    private DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; nodeProperties = new DescribableList&lt;&gt;(this);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * List of global properties
&nbsp;     */
<b class="nc">&nbsp;    private DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; globalNodeProperties = new DescribableList&lt;&gt;(this);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link AdministrativeMonitor}s installed on this system.
&nbsp;     *
&nbsp;     * @see AdministrativeMonitor
&nbsp;     */
<b class="nc">&nbsp;    public final transient List&lt;AdministrativeMonitor&gt; administrativeMonitors = getExtensionList(AdministrativeMonitor.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Widgets on Jenkins.
&nbsp;     */
<b class="nc">&nbsp;    private final transient List&lt;Widget&gt; widgets = getExtensionList(Widget.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@link AdjunctManager}
&nbsp;     */
&nbsp;    private final transient AdjunctManager adjuncts;
&nbsp;
&nbsp;    /**
&nbsp;     * Code that handles {@link ItemGroup} work.
&nbsp;     */
<b class="nc">&nbsp;    private final transient ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this, this) {</b>
&nbsp;        @Override
&nbsp;        protected void add(TopLevelItem item) {
<b class="nc">&nbsp;            items.put(item.getName(), item);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected File getRootDirFor(String name) {
<b class="nc">&nbsp;            return Jenkins.this.getRootDirFor(name);</b>
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Hook for a test harness to intercept Jenkins.get()
&nbsp;     *
&nbsp;     * Do not use in the production code as the signature may change.
&nbsp;     */
&nbsp;    public interface JenkinsHolder {
&nbsp;        @CheckForNull Jenkins getInstance();
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static JenkinsHolder HOLDER = new JenkinsHolder() {</b>
&nbsp;        @Override
&nbsp;        public @CheckForNull Jenkins getInstance() {
<b class="fc">&nbsp;            return theInstance;</b>
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Jenkins} singleton.
&nbsp;     * @return {@link Jenkins} instance
&nbsp;     * @throws IllegalStateException for the reasons that {@link #getInstanceOrNull} might return null
&nbsp;     * @since 2.98
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public static Jenkins get() throws IllegalStateException {
<b class="fc">&nbsp;        Jenkins instance = getInstanceOrNull();</b>
<b class="fc">&nbsp;        if (instance == null) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Jenkins.instance is missing. Read the documentation of Jenkins.getInstanceOrNull to see what you are doing wrong.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return instance;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated This is a verbose historical alias for {@link #get}.
&nbsp;     * @since 1.590
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    @NonNull
&nbsp;    public static Jenkins getActiveInstance() throws IllegalStateException {
<b class="nc">&nbsp;        return get();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Jenkins} singleton.
&nbsp;     * {@link #get} is what you normally want.
&nbsp;     * &lt;p&gt;In certain rare cases you may have code that is intended to run before Jenkins starts or while Jenkins is being shut down.
&nbsp;     * For those rare cases use this method.
&nbsp;     * &lt;p&gt;In other cases you may have code that might end up running on a remote JVM and not on the Jenkins controller or built-in node.
&nbsp;     * For those cases you really should rewrite your code so that when the {@link Callable} is sent over the remoting channel
&nbsp;     * it can do whatever it needs without ever referring to {@link Jenkins};
&nbsp;     * for example, gather any information you need on the controller side before constructing the callable.
&nbsp;     * If you must do a runtime check whether you are in the controller or agent, use {@link JenkinsJVM} rather than this method,
&nbsp;     * as merely loading the {@link Jenkins} class file into an agent JVM can cause linkage errors under some conditions.
&nbsp;     * @return The instance. Null if the {@link Jenkins} service has not been started, or was already shut down,
&nbsp;     *         or we are running on an unrelated JVM, typically an agent.
&nbsp;     * @since 1.653
&nbsp;     */
&nbsp;    @CLIResolver
&nbsp;    @CheckForNull
&nbsp;    public static Jenkins getInstanceOrNull() {
<b class="fc">&nbsp;        return HOLDER.getInstance();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated This is a historical alias for {@link #getInstanceOrNull} but with ambiguous nullability. Use {@link #get} in typical cases.
&nbsp;     */
&nbsp;    @Nullable
&nbsp;    @Deprecated
&nbsp;    public static Jenkins getInstance() {
<b class="nc">&nbsp;        return getInstanceOrNull();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Secret key generated once and used for a long time, beyond
&nbsp;     * container start/stop. Persisted outside {@code config.xml} to avoid
&nbsp;     * accidental exposure.
&nbsp;     */
&nbsp;    private final transient String secretKey;
&nbsp;
<b class="nc">&nbsp;    private final transient UpdateCenter updateCenter = UpdateCenter.createUpdateCenter(null);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * True if the user opted out from the statistics tracking. We&#39;ll never send anything if this is true.
&nbsp;     */
&nbsp;    private Boolean noUsageStatistics;
&nbsp;
&nbsp;    /**
&nbsp;     * If this is false, no migration is needed to reconfigure the built-in node (formerly &#39;master&#39;, now &#39;built-in&#39;).
&nbsp;     * Otherwise, {@link BuiltInNodeMigration} will show up.
&nbsp;     */
&nbsp;    // See #readResolve for null -&gt; true transition and #save for null -&gt; false transition
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    /* package-private */ Boolean nodeRenameMigrationNeeded;
&nbsp;
&nbsp;    /**
&nbsp;     * HTTP proxy configuration.
&nbsp;     */
&nbsp;    public transient volatile ProxyConfiguration proxy;
&nbsp;
&nbsp;    /**
&nbsp;     * Bound to &quot;/log&quot;.
&nbsp;     */
<b class="nc">&nbsp;    private transient LogRecorderManager log = new LogRecorderManager();</b>
&nbsp;
&nbsp;
&nbsp;    private final transient boolean oldJenkinsJVM;
&nbsp;
&nbsp;    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {
<b class="nc">&nbsp;        this(root, context, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param pluginManager
&nbsp;     *      If non-null, use existing plugin manager.  create a new one.
&nbsp;     */
&nbsp;    @SuppressFBWarnings({
&nbsp;        &quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot;, // Trigger.timer
&nbsp;        &quot;DM_EXIT&quot; // Exit is wanted here
&nbsp;    })
<b class="nc">&nbsp;    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {</b>
<b class="nc">&nbsp;        oldJenkinsJVM = JenkinsJVM.isJenkinsJVM(); // capture to restore in cleanUp()</b>
<b class="nc">&nbsp;        JenkinsJVMAccess._setJenkinsJVM(true); // set it for unit tests as they will not have gone through WebAppMain</b>
<b class="nc">&nbsp;        long start = System.currentTimeMillis();</b>
<b class="nc">&nbsp;        STARTUP_MARKER_FILE = new FileBoolean(new File(root, &quot;.lastStarted&quot;));</b>
&nbsp;        // As Jenkins is starting, grant this process full control
<b class="nc">&nbsp;        try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;            this.root = root;</b>
<b class="nc">&nbsp;            this.servletContext = context;</b>
<b class="nc">&nbsp;            computeVersion(context);</b>
<b class="nc">&nbsp;            if (theInstance != null)</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;second instance&quot;);</b>
<b class="nc">&nbsp;            theInstance = this;</b>
&nbsp;
<b class="nc">&nbsp;            if (!new File(root, &quot;jobs&quot;).exists()) {</b>
&nbsp;                // if this is a fresh install, use more modern default layout that&#39;s consistent with agents
<b class="nc">&nbsp;                workspaceDir = DEFAULT_WORKSPACES_DIR;</b>
&nbsp;            }
&nbsp;
&nbsp;            // doing this early allows InitStrategy to set environment upfront
<b class="nc">&nbsp;            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());</b>
&nbsp;
<b class="nc">&nbsp;            Trigger.timer = new java.util.Timer(&quot;Jenkins cron thread&quot;);</b>
<b class="nc">&nbsp;            queue = new Queue(LoadBalancer.CONSISTENT_HASH);</b>
<b class="nc">&nbsp;            labelAtomSet = Collections.unmodifiableSet(Label.parse(label));</b>
&nbsp;            try {
<b class="nc">&nbsp;                dependencyGraph = DependencyGraph.EMPTY;</b>
<b class="nc">&nbsp;            } catch (InternalError e) {</b>
<b class="nc">&nbsp;                if (e.getMessage().contains(&quot;window server&quot;)) {</b>
<b class="nc">&nbsp;                    throw new Error(&quot;Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option&quot;, e);</b>
&nbsp;                }
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // get or create the secret
<b class="nc">&nbsp;            TextFile secretFile = new TextFile(new File(getRootDir(), &quot;secret.key&quot;));</b>
<b class="nc">&nbsp;            if (secretFile.exists()) {</b>
<b class="nc">&nbsp;                secretKey = secretFile.readTrim();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                byte[] random = new byte[32];</b>
<b class="nc">&nbsp;                RANDOM.nextBytes(random);</b>
<b class="nc">&nbsp;                secretKey = Util.toHexString(random);</b>
<b class="nc">&nbsp;                secretFile.write(secretKey);</b>
&nbsp;
&nbsp;                // this marker indicates that the secret.key is generated by the version of Jenkins post SECURITY-49.
&nbsp;                // this indicates that there&#39;s no need to rewrite secrets on disk
<b class="nc">&nbsp;                new FileBoolean(new File(root, &quot;secret.key.not-so-secret&quot;)).on();</b>
&nbsp;            }
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                proxy = ProxyConfiguration.load();</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to load proxy configuration&quot;, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (pluginManager == null)</b>
<b class="nc">&nbsp;                pluginManager = PluginManager.createDefault(this);</b>
<b class="nc">&nbsp;            this.pluginManager = pluginManager;</b>
<b class="nc">&nbsp;            WebApp webApp = WebApp.get(servletContext);</b>
&nbsp;            // JSON binding needs to be able to see all the classes from all the plugins
<b class="nc">&nbsp;            webApp.setClassLoader(pluginManager.uberClassLoader);</b>
<b class="nc">&nbsp;            webApp.setJsonInErrorMessageSanitizer(RedactSecretJsonInErrorMessageSanitizer.INSTANCE);</b>
&nbsp;
<b class="nc">&nbsp;            TypedFilter typedFilter = new TypedFilter();</b>
<b class="nc">&nbsp;            webApp.setFilterForGetMethods(typedFilter);</b>
<b class="nc">&nbsp;            webApp.setFilterForFields(typedFilter);</b>
<b class="nc">&nbsp;            webApp.setFilterForDoActions(new DoActionFilter());</b>
&nbsp;
<b class="nc">&nbsp;            StaplerFilteredActionListener actionListener = new StaplerFilteredActionListener();</b>
<b class="nc">&nbsp;            webApp.setFilteredGetterTriggerListener(actionListener);</b>
<b class="nc">&nbsp;            webApp.setFilteredDoActionTriggerListener(actionListener);</b>
<b class="nc">&nbsp;            webApp.setFilteredFieldTriggerListener(actionListener);</b>
&nbsp;
<b class="nc">&nbsp;            webApp.setDispatchValidator(new StaplerDispatchValidator());</b>
<b class="nc">&nbsp;            webApp.setFilteredDispatchTriggerListener(actionListener);</b>
&nbsp;
<b class="nc">&nbsp;            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader, &quot;adjuncts/&quot; + SESSION_HASH, TimeUnit.DAYS.toMillis(365));</b>
&nbsp;
<b class="nc">&nbsp;            ClassFilterImpl.register();</b>
&nbsp;
&nbsp;            // initialization consists of ...
<b class="nc">&nbsp;            executeReactor(is,</b>
<b class="nc">&nbsp;                    pluginManager.initTasks(is),    // loading and preparing plugins</b>
<b class="nc">&nbsp;                    loadTasks(),                    // load jobs</b>
<b class="nc">&nbsp;                    InitMilestone.ordering()        // forced ordering among key milestones</b>
&nbsp;            );
&nbsp;
&nbsp;            // Ensure we reached the final initialization state. Log the error otherwise
<b class="nc">&nbsp;            if (initLevel != InitMilestone.COMPLETED) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Jenkins initialization has not reached the COMPLETED initialization milestone after the startup. &quot; +</b>
&nbsp;                                &quot;Current state: {0}. &quot; +
&nbsp;                                &quot;It may cause undefined incorrect behavior in Jenkins plugin relying on this state. &quot; +
&nbsp;                                &quot;It is likely an issue with the Initialization task graph. &quot; +
&nbsp;                                &quot;Example: usage of @Initializer(after = InitMilestone.COMPLETED) in a plugin (JENKINS-37759). &quot; +
&nbsp;                                &quot;Please create a bug in Jenkins bugtracker. &quot;,
&nbsp;                        initLevel);
&nbsp;            }
&nbsp;
&nbsp;
<b class="nc">&nbsp;            if (KILL_AFTER_LOAD)</b>
&nbsp;                // TODO cleanUp?
<b class="nc">&nbsp;                System.exit(0);</b>
<b class="nc">&nbsp;            save();</b>
&nbsp;
<b class="nc">&nbsp;            launchTcpSlaveAgentListener();</b>
&nbsp;
<b class="nc">&nbsp;            Timer.get().scheduleAtFixedRate(new SafeTimerTask() {</b>
&nbsp;                @Override
&nbsp;                protected void doRun() throws Exception {
<b class="nc">&nbsp;                    trimLabels();</b>
&nbsp;                }
<b class="nc">&nbsp;            }, TimeUnit.MINUTES.toMillis(5), TimeUnit.MINUTES.toMillis(5), TimeUnit.MILLISECONDS);</b>
&nbsp;
<b class="nc">&nbsp;            updateComputerList();</b>
&nbsp;
&nbsp;            { // built-in node is online now, its instance must always exist
<b class="nc">&nbsp;                final Computer c = toComputer();</b>
<b class="nc">&nbsp;                if (c != null) {</b>
<b class="nc">&nbsp;                    for (ComputerListener cl : ComputerListener.all()) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            cl.onOnline(c, new LogTaskListener(LOGGER, INFO));</b>
<b class="nc">&nbsp;                        } catch (Exception e) {</b>
&nbsp;                            // Per Javadoc log exceptions but still go online.
&nbsp;                            // NOTE: this does not include Errors, which indicate a fatal problem
<b class="nc">&nbsp;                            LOGGER.log(WARNING, String.format(&quot;Exception in onOnline() for the computer listener %s on the built-in node&quot;,</b>
<b class="nc">&nbsp;                                    cl.getClass()), e);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            for (ItemListener l : ItemListener.all()) {</b>
<b class="nc">&nbsp;                long itemListenerStart = System.currentTimeMillis();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    l.onLoaded();</b>
<b class="nc">&nbsp;                } catch (RuntimeException x) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (LOG_STARTUP_PERFORMANCE)</b>
<b class="nc">&nbsp;                    LOGGER.info(String.format(&quot;Took %dms for item listener %s startup&quot;,</b>
<b class="nc">&nbsp;                            System.currentTimeMillis() - itemListenerStart, l.getClass().getName()));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (LOG_STARTUP_PERFORMANCE)</b>
<b class="nc">&nbsp;                LOGGER.info(String.format(&quot;Took %dms for complete Jenkins startup&quot;,</b>
<b class="nc">&nbsp;                        System.currentTimeMillis() - start));</b>
&nbsp;
<b class="nc">&nbsp;            STARTUP_MARKER_FILE.on();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Maintains backwards compatibility. Invoked by XStream when this object is de-serialized.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    protected Object readResolve() {
<b class="nc">&nbsp;        if (jdks == null) {</b>
<b class="nc">&nbsp;            jdks = new ArrayList&lt;&gt;();</b>
&nbsp;        }
<b class="nc">&nbsp;        if (SLAVE_AGENT_PORT_ENFORCE) {</b>
<b class="nc">&nbsp;            slaveAgentPort = getSlaveAgentPortInitialValue(slaveAgentPort);</b>
&nbsp;        }
<b class="nc">&nbsp;        synchronized (this) {</b>
<b class="nc">&nbsp;            if (disabledAgentProtocols == null &amp;&amp; _disabledAgentProtocols != null) {</b>
<b class="nc">&nbsp;                disabledAgentProtocols = Arrays.asList(_disabledAgentProtocols);</b>
<b class="nc">&nbsp;                _disabledAgentProtocols = null;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (enabledAgentProtocols == null &amp;&amp; _enabledAgentProtocols != null) {</b>
<b class="nc">&nbsp;                enabledAgentProtocols = Arrays.asList(_enabledAgentProtocols);</b>
<b class="nc">&nbsp;                _enabledAgentProtocols = null;</b>
&nbsp;            }
&nbsp;            // Invalidate the protocols cache after the reload
<b class="nc">&nbsp;            agentProtocols = null;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // no longer persisted
<b class="nc">&nbsp;        installStateName = null;</b>
&nbsp;
<b class="nc">&nbsp;        if (nodeRenameMigrationNeeded == null) {</b>
&nbsp;            /* deserializing without a value set means we need to migrate */
<b class="nc">&nbsp;            nodeRenameMigrationNeeded = true;</b>
&nbsp;        }
<b class="nc">&nbsp;        _setLabelString(label);</b>
&nbsp;
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieve the proxy configuration.
&nbsp;     *
&nbsp;     * @return the proxy configuration
&nbsp;     * @since 2.205
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public ProxyConfiguration getProxy() {
<b class="nc">&nbsp;        return proxy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the proxy configuration.
&nbsp;     *
&nbsp;     * @param proxy the proxy to set
&nbsp;     * @since 2.205
&nbsp;     */
&nbsp;    public void setProxy(@CheckForNull ProxyConfiguration proxy) {
<b class="nc">&nbsp;        this.proxy = proxy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the Jenkins {@link jenkins.install.InstallState install state}.
&nbsp;     * @return The Jenkins {@link jenkins.install.InstallState install state}.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public InstallState getInstallState() {
<b class="nc">&nbsp;        if (installState != null) {</b>
<b class="nc">&nbsp;            installStateName = installState.name();</b>
<b class="nc">&nbsp;            installState = null;</b>
&nbsp;        }
<b class="nc">&nbsp;        InstallState is = installStateName != null ? InstallState.valueOf(installStateName) : InstallState.UNKNOWN;</b>
<b class="nc">&nbsp;        return is != null ? is : InstallState.UNKNOWN;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Update the current install state. This will invoke state.initializeState()
&nbsp;     * when the state has been transitioned.
&nbsp;     */
&nbsp;    public void setInstallState(@NonNull InstallState newState) {
<b class="nc">&nbsp;        String prior = installStateName;</b>
<b class="nc">&nbsp;        installStateName = newState.name();</b>
<b class="nc">&nbsp;        LOGGER.log(Main.isDevelopmentMode ? Level.INFO : Level.FINE, &quot;Install state transitioning from: {0} to: {1}&quot;, new Object[] { prior, installStateName });</b>
<b class="nc">&nbsp;        if (!installStateName.equals(prior)) {</b>
<b class="nc">&nbsp;            getSetupWizard().onInstallStateUpdate(newState);</b>
<b class="nc">&nbsp;            newState.initializeState();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes a reactor.
&nbsp;     *
&nbsp;     * @param is
&nbsp;     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Jenkins.
&nbsp;     */
&nbsp;    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {
<b class="nc">&nbsp;        Reactor reactor = new Reactor(builders) {</b>
&nbsp;            /**
&nbsp;             * Sets the thread name to the task for better diagnostics.
&nbsp;             */
&nbsp;            @Override
&nbsp;            protected void runTask(Task task) throws Exception {
<b class="nc">&nbsp;                if (is != null &amp;&amp; is.skipInitTask(task))  return;</b>
&nbsp;
<b class="nc">&nbsp;                String taskName = InitReactorRunner.getDisplayName(task);</b>
&nbsp;
<b class="nc">&nbsp;                Thread t = Thread.currentThread();</b>
<b class="nc">&nbsp;                String name = t.getName();</b>
<b class="nc">&nbsp;                if (taskName != null)</b>
<b class="nc">&nbsp;                    t.setName(taskName);</b>
<b class="nc">&nbsp;                try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) { // full access in the initialization thread</b>
<b class="nc">&nbsp;                    long start = System.currentTimeMillis();</b>
<b class="nc">&nbsp;                    super.runTask(task);</b>
<b class="nc">&nbsp;                    if (LOG_STARTUP_PERFORMANCE)</b>
<b class="nc">&nbsp;                        LOGGER.info(String.format(&quot;Took %dms for %s by %s&quot;,</b>
<b class="nc">&nbsp;                                System.currentTimeMillis() - start, taskName, name));</b>
<b class="nc">&nbsp;                } catch (Exception | Error x) {</b>
<b class="nc">&nbsp;                    if (containsLinkageError(x)) {</b>
<b class="nc">&nbsp;                        LOGGER.log(Level.WARNING, taskName + &quot; failed perhaps due to plugin dependency issues&quot;, x);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw x;</b>
&nbsp;                    }
&nbsp;                } finally {
<b class="nc">&nbsp;                    t.setName(name);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            private boolean containsLinkageError(Throwable x) {
<b class="nc">&nbsp;                if (x instanceof LinkageError) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;                Throwable x2 = x.getCause();</b>
<b class="nc">&nbsp;                return x2 != null &amp;&amp; containsLinkageError(x2);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
<b class="nc">&nbsp;        new InitReactorRunner() {</b>
&nbsp;            @Override
&nbsp;            protected void onInitMilestoneAttained(InitMilestone milestone) {
<b class="nc">&nbsp;                initLevel = milestone;</b>
<b class="nc">&nbsp;                getLifecycle().onExtendTimeout(EXTEND_TIMEOUT_SECONDS, TimeUnit.SECONDS);</b>
<b class="nc">&nbsp;                if (milestone == PLUGINS_PREPARED) {</b>
&nbsp;                    // set up Guice to enable injection as early as possible
&nbsp;                    // before this milestone, ExtensionList.ensureLoaded() won&#39;t actually try to locate instances
<b class="nc">&nbsp;                    ExtensionList.lookup(ExtensionFinder.class).getComponents();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }.run(reactor);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    public TcpSlaveAgentListener getTcpSlaveAgentListener() {
<b class="nc">&nbsp;        return tcpSlaveAgentListener;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes {@link AdjunctManager} URL-bound.
&nbsp;     * The dummy parameter allows us to use different URLs for the same adjunct,
&nbsp;     * for proper cache handling.
&nbsp;     */
&nbsp;    public AdjunctManager getAdjuncts(String dummy) {
<b class="nc">&nbsp;        return adjuncts;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    public int getSlaveAgentPort() {
<b class="nc">&nbsp;        return slaveAgentPort;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 2.24
&nbsp;     */
&nbsp;    public boolean isSlaveAgentPortEnforced() {
<b class="nc">&nbsp;        return Jenkins.SLAVE_AGENT_PORT_ENFORCE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param port
&nbsp;     *      0 to indicate random available TCP port. -1 to disable this service.
&nbsp;     */
&nbsp;    public void setSlaveAgentPort(int port) throws IOException {
<b class="nc">&nbsp;        if (SLAVE_AGENT_PORT_ENFORCE) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;setSlaveAgentPort({0}) call ignored because system property {1} is true&quot;, new String[] { Integer.toString(port), Jenkins.class.getName() + &quot;.slaveAgentPortEnforce&quot; });</b>
&nbsp;        } else {
<b class="nc">&nbsp;            forceSetSlaveAgentPort(port);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void forceSetSlaveAgentPort(int port) throws IOException {
<b class="nc">&nbsp;        this.slaveAgentPort = port;</b>
<b class="nc">&nbsp;        launchTcpSlaveAgentListener();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the enabled agent protocols.
&nbsp;     *
&nbsp;     * @return the enabled agent protocols.
&nbsp;     * @since 2.16
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public synchronized Set&lt;String&gt; getAgentProtocols() {
<b class="nc">&nbsp;        if (agentProtocols == null) {</b>
<b class="nc">&nbsp;            Set&lt;String&gt; result = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;            Set&lt;String&gt; disabled = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (String p : Util.fixNull(disabledAgentProtocols)) {</b>
<b class="nc">&nbsp;                disabled.add(p.trim());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Set&lt;String&gt; enabled = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;            for (String p : Util.fixNull(enabledAgentProtocols)) {</b>
<b class="nc">&nbsp;                enabled.add(p.trim());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            for (AgentProtocol p : AgentProtocol.all()) {</b>
<b class="nc">&nbsp;                String name = p.getName();</b>
<b class="nc">&nbsp;                if (name != null &amp;&amp; (p.isRequired()</b>
<b class="nc">&nbsp;                        || (!disabled.contains(name) &amp;&amp; (!p.isOptIn() || enabled.contains(name))))) {</b>
<b class="nc">&nbsp;                    result.add(name);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            /*
&nbsp;             * An empty result is almost never valid, but it can happen due to JENKINS-70206. Since we know the result
&nbsp;             * is likely incorrect, at least decline to cache it so that a correct result can be computed later on
&nbsp;             * rather than continuing to deliver the incorrect result indefinitely.
&nbsp;             */
<b class="nc">&nbsp;            if (!result.isEmpty()) {</b>
<b class="nc">&nbsp;                agentProtocols = result;</b>
&nbsp;            }
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
<b class="nc">&nbsp;        return agentProtocols;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the enabled agent protocols.
&nbsp;     *
&nbsp;     * @param protocols the enabled agent protocols.
&nbsp;     * @since 2.16
&nbsp;     */
&nbsp;    public synchronized void setAgentProtocols(@NonNull Set&lt;String&gt; protocols) {
<b class="nc">&nbsp;        Set&lt;String&gt; disabled = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;        Set&lt;String&gt; enabled = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (AgentProtocol p : AgentProtocol.all()) {</b>
<b class="nc">&nbsp;            String name = p.getName();</b>
<b class="nc">&nbsp;            if (name != null &amp;&amp; !p.isRequired()) {</b>
&nbsp;                // we want to record the protocols where the admin has made a conscious decision
&nbsp;                // thus, if a protocol is opt-in, we record the admin enabling it
&nbsp;                // if a protocol is opt-out, we record the admin disabling it
&nbsp;                // We should not transition rapidly from opt-in -&gt; opt-out -&gt; opt-in
&nbsp;                // the scenario we want to have work is:
&nbsp;                // 1. We introduce a new protocol, it starts off as opt-in. Some admins decide to test and opt-in
&nbsp;                // 2. We decide that the protocol is ready for general use. It gets marked as opt-out. Any admins
&nbsp;                //    that took part in early testing now have their config switched to not mention the new protocol
&nbsp;                //    at all when they save their config as the protocol is now opt-out. Any admins that want to
&nbsp;                //    disable it can do so and will have their preference recorded.
&nbsp;                // 3. We decide that the protocol needs to be retired. It gets switched back to opt-in. At this point
&nbsp;                //    the initial opt-in admins, assuming they visited an upgrade to a controller with step 2, will
&nbsp;                //    have the protocol disabled for them. This is what we want. If they didn&#39;t upgrade to a controller
&nbsp;                //    with step 2, well there is not much we can do to differentiate them from somebody who is upgrading
&nbsp;                //    from a previous step 3 controller and had needed to keep the protocol turned on.
&nbsp;                //
&nbsp;                // What we should never do is flip-flop: opt-in -&gt; opt-out -&gt; opt-in -&gt; opt-out as that will basically
&nbsp;                // clear any preference that an admin has set, but this should be ok as we only ever will be
&nbsp;                // adding new protocols and retiring old ones.
<b class="nc">&nbsp;                if (p.isOptIn()) {</b>
<b class="nc">&nbsp;                    if (protocols.contains(name)) {</b>
<b class="nc">&nbsp;                        enabled.add(name);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    if (!protocols.contains(name)) {</b>
<b class="nc">&nbsp;                        disabled.add(name);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        disabledAgentProtocols = disabled.isEmpty() ? null : new ArrayList&lt;&gt;(disabled);</b>
<b class="nc">&nbsp;        enabledAgentProtocols = enabled.isEmpty() ? null : new ArrayList&lt;&gt;(enabled);</b>
<b class="nc">&nbsp;        agentProtocols = null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void launchTcpSlaveAgentListener() throws IOException {
<b class="nc">&nbsp;        synchronized (tcpSlaveAgentListenerLock) {</b>
&nbsp;            // shutdown previous agent if the port has changed
<b class="nc">&nbsp;            if (tcpSlaveAgentListener != null &amp;&amp; tcpSlaveAgentListener.configuredPort != slaveAgentPort) {</b>
<b class="nc">&nbsp;                tcpSlaveAgentListener.shutdown();</b>
<b class="nc">&nbsp;                tcpSlaveAgentListener = null;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (slaveAgentPort != -1 &amp;&amp; tcpSlaveAgentListener == null) {</b>
<b class="nc">&nbsp;                final String administrativeMonitorId = getClass().getName() + &quot;.tcpBind&quot;;</b>
&nbsp;                try {
<b class="nc">&nbsp;                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);</b>
&nbsp;                    // remove previous monitor in case of previous error
<b class="nc">&nbsp;                    AdministrativeMonitor toBeRemoved = null;</b>
<b class="nc">&nbsp;                    ExtensionList&lt;AdministrativeMonitor&gt; all = AdministrativeMonitor.all();</b>
<b class="nc">&nbsp;                    for (AdministrativeMonitor am : all) {</b>
<b class="nc">&nbsp;                        if (administrativeMonitorId.equals(am.id)) {</b>
<b class="nc">&nbsp;                            toBeRemoved = am;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    all.remove(toBeRemoved);</b>
<b class="nc">&nbsp;                } catch (BindException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, String.format(&quot;Failed to listen to incoming agent connections through port %s. Change the port number&quot;, slaveAgentPort), e);</b>
<b class="nc">&nbsp;                    new AdministrativeError(administrativeMonitorId,</b>
&nbsp;                            &quot;Failed to listen to incoming agent connections&quot;,
&nbsp;                            &quot;Failed to listen to incoming agent connections. &lt;a href=&#39;configureSecurity&#39;&gt;Change the inbound TCP port number&lt;/a&gt; to solve the problem.&quot;, e);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Extension
&nbsp;    @Restricted(NoExternalUse.class)
<b class="nc">&nbsp;    public static class EnforceSlaveAgentPortAdministrativeMonitor extends AdministrativeMonitor {</b>
&nbsp;        @Inject
&nbsp;        Jenkins j;
&nbsp;
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return jenkins.model.Messages.EnforceSlaveAgentPortAdministrativeMonitor_displayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getSystemPropertyName() {
<b class="nc">&nbsp;            return Jenkins.class.getName() + &quot;.slaveAgentPort&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getExpectedPort() {
<b class="nc">&nbsp;            int slaveAgentPort = j.slaveAgentPort;</b>
<b class="nc">&nbsp;            return Jenkins.getSlaveAgentPortInitialValue(slaveAgentPort);</b>
&nbsp;        }
&nbsp;
&nbsp;        @RequirePOST
&nbsp;        public void doAct(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;            j.forceSetSlaveAgentPort(getExpectedPort());</b>
<b class="nc">&nbsp;            rsp.sendRedirect2(req.getContextPath() + &quot;/manage&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isActivated() {
<b class="nc">&nbsp;            int slaveAgentPort = Jenkins.get().slaveAgentPort;</b>
<b class="nc">&nbsp;            return SLAVE_AGENT_PORT_ENFORCE &amp;&amp; slaveAgentPort != Jenkins.getSlaveAgentPortInitialValue(slaveAgentPort);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setNodeName(String name) {
<b class="nc">&nbsp;        throw new UnsupportedOperationException(); // not allowed</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getNodeDescription() {
<b class="nc">&nbsp;        return Messages.Hudson_NodeDescription();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Exported
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;        return systemMessage;</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    public PluginManager getPluginManager() {
<b class="nc">&nbsp;        return pluginManager;</b>
&nbsp;    }
&nbsp;
&nbsp;    public UpdateCenter getUpdateCenter() {
<b class="nc">&nbsp;        return updateCenter;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If usage statistics has been disabled
&nbsp;     *
&nbsp;     * @since 2.226
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public Boolean isNoUsageStatistics() {
<b class="nc">&nbsp;        return noUsageStatistics;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If usage statistics are being collected
&nbsp;     *
&nbsp;     * @return {@code true} if usage statistics should be collected.
&nbsp;     *                Defaults to {@code true} when {@link #noUsageStatistics} is not set.
&nbsp;     */
&nbsp;    public boolean isUsageStatisticsCollected() {
<b class="nc">&nbsp;        return noUsageStatistics == null || !noUsageStatistics;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the noUsageStatistics flag
&nbsp;     *
&nbsp;     */
&nbsp;    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {
<b class="nc">&nbsp;        this.noUsageStatistics = noUsageStatistics;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    public View.People getPeople() {
<b class="nc">&nbsp;        return new View.People(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.484
&nbsp;     */
&nbsp;    public View.AsynchPeople getAsynchPeople() {
<b class="nc">&nbsp;        return new View.AsynchPeople(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does this {@link View} has any associated user information recorded?
&nbsp;     * @deprecated Potentially very expensive call; do not use from Jelly views.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public boolean hasPeople() {
<b class="nc">&nbsp;        return View.People.isApplicable(items.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    public Api getApi() {
&nbsp;        /* Do not show &quot;REST API&quot; link in footer when on 404 error page */
<b class="nc">&nbsp;        final StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="nc">&nbsp;        if (req != null) {</b>
<b class="nc">&nbsp;            final Object attribute = req.getAttribute(&quot;javax.servlet.error.message&quot;);</b>
<b class="nc">&nbsp;            if (attribute != null) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new Api(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a secret key that survives across container start/stop.
&nbsp;     * &lt;p&gt;
&nbsp;     * This value is useful for implementing some of the security features.
&nbsp;     *
&nbsp;     * @deprecated
&nbsp;     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.
&nbsp;     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public String getSecretKey() {
<b class="nc">&nbsp;        return secretKey;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.
&nbsp;     * @since 1.308
&nbsp;     * @deprecated
&nbsp;     *       See {@link #getSecretKey()}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public SecretKey getSecretKeyAsAES128() {
<b class="nc">&nbsp;        return Util.toAes128Key(secretKey);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the unique identifier of this Jenkins that has been historically used to identify
&nbsp;     * this Jenkins to the outside world.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This form of identifier is weak in that it can be impersonated by others. See
&nbsp;     * &lt;a href=&quot;https://github.com/jenkinsci/instance-identity-plugin&quot;&gt;the Instance Identity plugin&lt;/a&gt; for more modern form of instance ID
&nbsp;     * that can be challenged and verified.
&nbsp;     *
&nbsp;     * @since 1.498
&nbsp;     */
&nbsp;    public String getLegacyInstanceId() {
<b class="nc">&nbsp;        return Util.getDigestOf(getSecretKey());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the SCM descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;SCM&gt; getScm(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, SCM.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;RepositoryBrowser&lt;?&gt;&gt; getRepositoryBrowser(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, RepositoryBrowser.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the builder descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;Builder&gt; getBuilder(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, Builder.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;BuildWrapper&gt; getBuildWrapper(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, BuildWrapper.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the publisher descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;Publisher&gt; getPublisher(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, Publisher.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the trigger descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public TriggerDescriptor getTrigger(String shortClassName) {
<b class="nc">&nbsp;        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;RetentionStrategy&lt;?&gt;&gt; getRetentionStrategy(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, RetentionStrategy.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public JobPropertyDescriptor getJobProperty(String shortClassName) {
&nbsp;        // combining these two lines triggers javac bug. See issue JENKINS-610
<b class="nc">&nbsp;        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());</b>
<b class="nc">&nbsp;        return (JobPropertyDescriptor) d;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated
&nbsp;     *      UI method. Not meant to be used programmatically.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public ComputerSet getComputer() {
<b class="nc">&nbsp;        return new ComputerSet();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only there to bind to /cloud/ URL. Otherwise /cloud/new gets resolved to getCloud(&quot;new&quot;) by stapler which is not what we want.
&nbsp;     */
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    public CloudSet getCloud() {
<b class="nc">&nbsp;        return new CloudSet();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exposes {@link Descriptor} by its name to URL.
&nbsp;     *
&nbsp;     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that
&nbsp;     * this just doesn&#39;t scale.
&nbsp;     *
&nbsp;     * @param id
&nbsp;     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)
&nbsp;     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;rawtypes&quot;) // too late to fix
&nbsp;    public Descriptor getDescriptor(String id) {
&nbsp;        // legacy descriptors that are registered manually doesn&#39;t show up in getExtensionList, so check them explicitly.
<b class="nc">&nbsp;        Iterable&lt;Descriptor&gt; descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());</b>
<b class="nc">&nbsp;        for (Descriptor d : descriptors) {</b>
<b class="nc">&nbsp;            if (d.getId().equals(id)) {</b>
<b class="nc">&nbsp;                return d;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        Descriptor candidate = null;</b>
<b class="nc">&nbsp;        for (Descriptor d : descriptors) {</b>
<b class="nc">&nbsp;            String name = d.getId();</b>
<b class="nc">&nbsp;            if (name.substring(name.lastIndexOf(&#39;.&#39;) + 1).equals(id)) {</b>
<b class="nc">&nbsp;                if (candidate == null) {</b>
<b class="nc">&nbsp;                    candidate = d;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(id + &quot; is ambiguous; matches both &quot; + name + &quot; and &quot; + candidate.getId());</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return candidate;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Alias for {@link #getDescriptor(String)}.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Descriptor getDescriptorByName(String id) {
<b class="nc">&nbsp;        return getDescriptor(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.
&nbsp;     * &lt;p&gt;
&nbsp;     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},
&nbsp;     * you&#39;ll get the same instance that this method returns.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public Descriptor getDescriptor(Class&lt;? extends Describable&gt; type) {
<b class="nc">&nbsp;        for (Descriptor d : getExtensionList(Descriptor.class))</b>
<b class="nc">&nbsp;            if (d.clazz == type)</b>
<b class="nc">&nbsp;                return d;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Works just like {@link #getDescriptor(Class)} but don&#39;t take no for an answer.
&nbsp;     *
&nbsp;     * @throws AssertionError
&nbsp;     *      If the descriptor is missing.
&nbsp;     * @since 1.326
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public Descriptor getDescriptorOrDie(Class&lt;? extends Describable&gt; type) {
<b class="nc">&nbsp;        Descriptor d = getDescriptor(type);</b>
<b class="nc">&nbsp;        if (d == null)</b>
<b class="nc">&nbsp;            throw new AssertionError(type + &quot; is missing its descriptor&quot;);</b>
<b class="nc">&nbsp;        return d;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Descriptor} instance in the current Jenkins by its type.
&nbsp;     */
&nbsp;    public &lt;T extends Descriptor&gt; T getDescriptorByType(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        for (Descriptor d : getExtensionList(Descriptor.class))</b>
<b class="nc">&nbsp;            if (d.getClass() == type)</b>
<b class="nc">&nbsp;                return type.cast(d);</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.
&nbsp;     */
&nbsp;    public Descriptor&lt;SecurityRealm&gt; getSecurityRealms(String shortClassName) {
<b class="nc">&nbsp;        return findDescriptor(shortClassName, SecurityRealm.all());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Finds a descriptor that has the specified name.
&nbsp;     */
&nbsp;    private &lt;T extends Describable&lt;T&gt;&gt;
&nbsp;    Descriptor&lt;T&gt; findDescriptor(String shortClassName, Collection&lt;? extends Descriptor&lt;T&gt;&gt; descriptors) {
<b class="nc">&nbsp;        String name = &#39;.&#39; + shortClassName;</b>
<b class="nc">&nbsp;        for (Descriptor&lt;T&gt; d : descriptors) {</b>
<b class="nc">&nbsp;            if (d.clazz.getName().endsWith(name))</b>
<b class="nc">&nbsp;                return d;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void updateNewComputer(Node n) {
<b class="nc">&nbsp;        updateNewComputer(n, AUTOMATIC_AGENT_LAUNCH);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void updateComputerList() {
<b class="nc">&nbsp;        updateComputerList(AUTOMATIC_AGENT_LAUNCH);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated Use {@link SCMListener#all} instead. */
&nbsp;    @Deprecated
&nbsp;    public CopyOnWriteList&lt;SCMListener&gt; getSCMListeners() {
<b class="nc">&nbsp;        return scmListeners;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the plugin object from its short name.
&nbsp;     * This allows URL {@code hudson/plugin/ID} to be served by the views
&nbsp;     * of the plugin class.
&nbsp;     * @param shortName Short name of the plugin
&nbsp;     * @return The plugin singleton or {@code null} if for some reason the plugin is not loaded.
&nbsp;     *         The fact the plugin is loaded does not mean it is enabled and fully initialized for the current Jenkins session.
&nbsp;     *         Use {@link Plugin#getWrapper()} and then {@link PluginWrapper#isActive()} to check it.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public Plugin getPlugin(String shortName) {
<b class="nc">&nbsp;        PluginWrapper p = pluginManager.getPlugin(shortName);</b>
<b class="nc">&nbsp;        if (p == null)     return null;</b>
<b class="nc">&nbsp;        return p.getPlugin();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the plugin object from its class.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This allows easy storage of plugin information in the plugin singleton without
&nbsp;     * every plugin reimplementing the singleton pattern.
&nbsp;     *
&nbsp;     * @param &lt;P&gt; Class of the plugin
&nbsp;     * @param clazz The plugin class (beware class-loader fun, this will probably only work
&nbsp;     * from within the jpi that defines the plugin class, it may or may not work in other cases)
&nbsp;     * @return The plugin singleton or {@code null} if for some reason the plugin is not loaded.
&nbsp;     *         The fact the plugin is loaded does not mean it is enabled and fully initialized for the current Jenkins session.
&nbsp;     *         Use {@link Plugin#getWrapper()} and then {@link PluginWrapper#isActive()} to check it.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    @CheckForNull
&nbsp;    public &lt;P extends Plugin&gt; P getPlugin(Class&lt;P&gt; clazz) {
<b class="nc">&nbsp;        PluginWrapper p = pluginManager.getPlugin(clazz);</b>
<b class="nc">&nbsp;        if (p == null)     return null;</b>
<b class="nc">&nbsp;        return (P) p.getPlugin();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the plugin objects from their super-class.
&nbsp;     *
&nbsp;     * @param clazz The plugin class (beware class-loader fun)
&nbsp;     *
&nbsp;     * @return The plugin instances.
&nbsp;     */
&nbsp;    public &lt;P extends Plugin&gt; List&lt;P&gt; getPlugins(Class&lt;P&gt; clazz) {
<b class="nc">&nbsp;        List&lt;P&gt; result = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (PluginWrapper w : pluginManager.getPlugins(clazz)) {</b>
<b class="nc">&nbsp;            result.add((P) w.getPlugin());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return Collections.unmodifiableList(result);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Synonym for {@link #getDescription}.
&nbsp;     */
&nbsp;    public String getSystemMessage() {
<b class="nc">&nbsp;        return systemMessage;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the markup formatter used in the system.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      never null.
&nbsp;     * @since 1.391
&nbsp;     */
&nbsp;    public @NonNull MarkupFormatter getMarkupFormatter() {
<b class="nc">&nbsp;        MarkupFormatter f = markupFormatter;</b>
<b class="nc">&nbsp;        return f != null ? f : new EscapedMarkupFormatter();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the markup formatter used in the system globally.
&nbsp;     *
&nbsp;     * @since 1.391
&nbsp;     */
&nbsp;    public void setMarkupFormatter(MarkupFormatter f) {
<b class="nc">&nbsp;        this.markupFormatter = f;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the system message.
&nbsp;     */
&nbsp;    public void setSystemMessage(String message) throws IOException {
<b class="nc">&nbsp;        this.systemMessage = message;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    @StaplerDispatchable
&nbsp;    public FederatedLoginService getFederatedLoginService(String name) {
<b class="nc">&nbsp;        for (FederatedLoginService fls : FederatedLoginService.all()) {</b>
<b class="nc">&nbsp;            if (fls.getUrlName().equals(name))</b>
<b class="nc">&nbsp;                return fls;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;FederatedLoginService&gt; getFederatedLoginServices() {
<b class="nc">&nbsp;        return FederatedLoginService.all();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Launcher createLauncher(TaskListener listener) {
<b class="nc">&nbsp;        return new LocalLauncher(listener).decorateFor(this);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    @Override
&nbsp;    public String getFullName() {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getFullDisplayName() {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the transient {@link Action}s associated with the top page.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Adding {@link Action} is primarily useful for plugins to contribute
&nbsp;     * an item to the navigation bar of the top page. See existing {@link Action}
&nbsp;     * implementation for it affects the GUI.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like
&nbsp;     * {@code Jenkins.get().getActions().add(...)}.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      Live list where the changes can be made. Can be empty but never null.
&nbsp;     * @since 1.172
&nbsp;     */
&nbsp;    public List&lt;Action&gt; getActions() {
<b class="nc">&nbsp;        return actions;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets just the immediate children of {@link Jenkins}.
&nbsp;     *
&nbsp;     * @see #getAllItems(Class)
&nbsp;     */
&nbsp;    @Override
&nbsp;    @Exported(name = &quot;jobs&quot;)
&nbsp;    public List&lt;TopLevelItem&gt; getItems() {
<b class="nc">&nbsp;        return getItems(t -&gt; true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets just the immediate children of {@link Jenkins} based on supplied predicate.
&nbsp;     *
&nbsp;     * @see #getAllItems(Class)
&nbsp;     * @since 2.221
&nbsp;     */
&nbsp;    @Override
&nbsp;    public List&lt;TopLevelItem&gt; getItems(Predicate&lt;TopLevelItem&gt; pred) {
<b class="nc">&nbsp;        List&lt;TopLevelItem&gt; viewableItems = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (TopLevelItem item : items.values()) {</b>
<b class="nc">&nbsp;            if (pred.test(item) &amp;&amp; item.hasPermission(Item.READ))</b>
<b class="nc">&nbsp;                viewableItems.add(item);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return viewableItems;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is efficient, as it doesn&#39;t involve any copying.
&nbsp;     *
&nbsp;     * @since 1.296
&nbsp;     */
&nbsp;    public Map&lt;String, TopLevelItem&gt; getItemMap() {
<b class="nc">&nbsp;        return Collections.unmodifiableMap(items);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets just the immediate children of {@link Jenkins} but of the given type.
&nbsp;     */
&nbsp;    public &lt;T&gt; List&lt;T&gt; getItems(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        List&lt;T&gt; r = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (TopLevelItem i : getItems(type::isInstance)) {</b>
<b class="nc">&nbsp;             r.add(type.cast(i));</b>
<b class="nc">&nbsp;         }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a list of simple top-level projects.
&nbsp;     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.
&nbsp;     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},
&nbsp;     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.
&nbsp;     * (That will also consider the caller&#39;s permissions.)
&nbsp;     * If you really want to get just {@link Project}s at top level, ignoring permissions,
&nbsp;     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public List&lt;Project&gt; getProjects() {
<b class="nc">&nbsp;        return Util.createSubList(items.values(), Project.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the names of all the {@link Job}s.
&nbsp;     */
&nbsp;    public Collection&lt;String&gt; getJobNames() {
<b class="nc">&nbsp;        List&lt;String&gt; names = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Job j : allItems(Job.class))</b>
<b class="nc">&nbsp;            names.add(j.getFullName());</b>
<b class="nc">&nbsp;        names.sort(String.CASE_INSENSITIVE_ORDER);</b>
<b class="nc">&nbsp;        return names;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Action&gt; getViewActions() {
<b class="nc">&nbsp;        return getActions();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the names of all the {@link TopLevelItem}s.
&nbsp;     */
&nbsp;    public Collection&lt;String&gt; getTopLevelItemNames() {
<b class="nc">&nbsp;        List&lt;String&gt; names = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (TopLevelItem j : items.values())</b>
<b class="nc">&nbsp;            names.add(j.getName());</b>
<b class="nc">&nbsp;        return names;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a view by the specified name.
&nbsp;     * The method iterates through {@link hudson.model.ViewGroup}s if required.
&nbsp;     * @param name Name of the view
&nbsp;     * @return View instance or {@code null} if it is missing
&nbsp;     */
&nbsp;    @Override
&nbsp;    @CheckForNull
&nbsp;    public View getView(@CheckForNull String name) {
<b class="nc">&nbsp;        return viewGroupMixIn.getView(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the read-only list of all {@link View}s.
&nbsp;     */
&nbsp;    @Override
&nbsp;    @Exported
&nbsp;    public Collection&lt;View&gt; getViews() {
<b class="nc">&nbsp;        return viewGroupMixIn.getViews();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void addView(@NonNull View v) throws IOException {
<b class="nc">&nbsp;        viewGroupMixIn.addView(v);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Completely replaces views.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This operation is NOT provided as an atomic operation, but rather
&nbsp;     * the sole purpose of this is to define a setter for this to help
&nbsp;     * introspecting code, such as system-config-dsl plugin
&nbsp;     */
&nbsp;    // even if we want to offer this atomic operation, CopyOnWriteArrayList
&nbsp;    // offers no such operation
&nbsp;    public void setViews(Collection&lt;View&gt; views) throws IOException {
<b class="nc">&nbsp;        try (BulkChange bc = new BulkChange(this)) {</b>
<b class="nc">&nbsp;            this.views.clear();</b>
<b class="nc">&nbsp;            for (View v : views) {</b>
<b class="nc">&nbsp;                addView(v);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            bc.commit();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean canDelete(View view) {
<b class="nc">&nbsp;        return viewGroupMixIn.canDelete(view);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public synchronized void deleteView(View view) throws IOException {
<b class="nc">&nbsp;        viewGroupMixIn.deleteView(view);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void onViewRenamed(View view, String oldName, String newName) {
<b class="nc">&nbsp;        viewGroupMixIn.onViewRenamed(view, oldName, newName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the primary {@link View} that renders the top-page of Jenkins.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @Override
&nbsp;    public View getPrimaryView() {
<b class="nc">&nbsp;        return viewGroupMixIn.getPrimaryView();</b>
&nbsp;     }
&nbsp;
&nbsp;    public void setPrimaryView(@NonNull View v) {
<b class="nc">&nbsp;        this.primaryView = v.getViewName();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ViewsTabBar getViewsTabBar() {
<b class="nc">&nbsp;        return viewsTabBar;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setViewsTabBar(ViewsTabBar viewsTabBar) {
<b class="nc">&nbsp;        this.viewsTabBar = viewsTabBar;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Jenkins getItemGroup() {
<b class="nc">&nbsp;        return this;</b>
&nbsp;   }
&nbsp;
&nbsp;    public MyViewsTabBar getMyViewsTabBar() {
<b class="nc">&nbsp;        return myViewsTabBar;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {
<b class="nc">&nbsp;        this.myViewsTabBar = myViewsTabBar;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the current running Jenkins is upgraded from a version earlier than the specified version.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method continues to return true until the system configuration is saved, at which point
&nbsp;     * {@link #version} will be overwritten and Jenkins forgets the upgrade history.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * To handle SNAPSHOTS correctly, pass in &quot;1.N.*&quot; to test if it&#39;s upgrading from the version
&nbsp;     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check
&nbsp;     * if the installation upgraded from pre-1.301, pass in &quot;1.300.*&quot;
&nbsp;     *
&nbsp;     * @since 1.301
&nbsp;     */
&nbsp;    public boolean isUpgradedFromBefore(VersionNumber v) {
&nbsp;        try {
<b class="nc">&nbsp;            return new VersionNumber(version).isOlderThan(v);</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
&nbsp;            // fail to parse this version number
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the read-only list of all {@link Computer}s.
&nbsp;     */
&nbsp;    public Computer[] getComputers() {
<b class="nc">&nbsp;        return computers.values().stream().sorted(Comparator.comparing(Computer::getName)).toArray(Computer[]::new);</b>
&nbsp;    }
&nbsp;
&nbsp;    @CLIResolver
&nbsp;    public @CheckForNull Computer getComputer(@Argument(required = true, metaVar = &quot;NAME&quot;, usage = &quot;Node name&quot;) @NonNull String name) {
<b class="nc">&nbsp;        if (name.equals(&quot;(built-in)&quot;)</b>
<b class="nc">&nbsp;                || name.equals(&quot;(master)&quot;)) // backwards compatibility for URLs</b>
<b class="nc">&nbsp;            name = &quot;&quot;;</b>
&nbsp;
<b class="nc">&nbsp;        for (Computer c : computers.values()) {</b>
<b class="nc">&nbsp;            if (c.getName().equals(name))</b>
<b class="nc">&nbsp;                return c;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the label that exists on this system by the name.
&nbsp;     *
&nbsp;     * @return null if name is null.
&nbsp;     * @see Label#parseExpression(String) (String)
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public Label getLabel(String expr) {
<b class="nc">&nbsp;        if (expr == null)  return null;</b>
<b class="nc">&nbsp;        expr = QuotedStringTokenizer.unquote(expr);</b>
&nbsp;        while (true) {
<b class="nc">&nbsp;            Label l = labels.get(expr);</b>
<b class="nc">&nbsp;            if (l != null)</b>
<b class="nc">&nbsp;                return l;</b>
&nbsp;
&nbsp;            // non-existent
&nbsp;            try {
&nbsp;                // For the record, this method creates temporary labels but there is a periodic task
&nbsp;                // calling &quot;trimLabels&quot; to remove unused labels running every 5 minutes.
<b class="nc">&nbsp;                labels.putIfAbsent(expr, Label.parseExpression(expr));</b>
<b class="nc">&nbsp;            } catch (IllegalArgumentException e) {</b>
&nbsp;                // laxly accept it as a single label atom for backward compatibility
<b class="nc">&nbsp;                return getLabelAtom(expr);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the label atom of the given name.
&nbsp;     * @return non-null iff name is non-null
&nbsp;     */
&nbsp;    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {
<b class="nc">&nbsp;        if (name == null)  return null;</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            Label l = labels.get(name);</b>
<b class="nc">&nbsp;            if (l != null)</b>
<b class="nc">&nbsp;                return (LabelAtom) l;</b>
&nbsp;
&nbsp;            // non-existent
<b class="nc">&nbsp;            LabelAtom la = new LabelAtom(name);</b>
&nbsp;            // For the record, this method creates temporary labels but there is a periodic task
&nbsp;            // calling &quot;trimLabels&quot; to remove unused labels running every 5 minutes.
<b class="nc">&nbsp;            if (labels.putIfAbsent(name, la) == null)</b>
<b class="nc">&nbsp;                la.load();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the label atom of the given name, only if it already exists.
&nbsp;     * @return non-null if the label atom already exists.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public @Nullable LabelAtom tryGetLabelAtom(@NonNull String name) {
<b class="nc">&nbsp;        Label label = labels.get(name);</b>
<b class="nc">&nbsp;        if (label instanceof LabelAtom) {</b>
<b class="nc">&nbsp;            return (LabelAtom) label;</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Gets all the active labels in the current system.
&nbsp;     */
&nbsp;    public Set&lt;Label&gt; getLabels() {
<b class="nc">&nbsp;        Set&lt;Label&gt; r = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Label l : labels.values()) {</b>
<b class="nc">&nbsp;            if (!l.isEmpty())</b>
<b class="nc">&nbsp;                r.add(l);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    private transient Set&lt;LabelAtom&gt; labelAtomSet;
&nbsp;
&nbsp;    @Override
&nbsp;    protected Set&lt;LabelAtom&gt; getLabelAtomSet() {
<b class="nc">&nbsp;        return labelAtomSet;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;LabelAtom&gt; getLabelAtoms() {
<b class="nc">&nbsp;        Set&lt;LabelAtom&gt; r = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Label l : labels.values()) {</b>
<b class="nc">&nbsp;            if (!l.isEmpty() &amp;&amp; l instanceof LabelAtom)</b>
<b class="nc">&nbsp;                r.add((LabelAtom) l);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Queue getQueue() {
<b class="nc">&nbsp;        return queue;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getDisplayName() {
<b class="nc">&nbsp;        return Messages.Hudson_DisplayName();</b>
&nbsp;    }
&nbsp;
&nbsp;    public List&lt;JDK&gt; getJDKs() {
<b class="nc">&nbsp;        return jdks;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Replaces all JDK installations with those from the given collection.
&nbsp;     *
&nbsp;     * Use {@link hudson.model.JDK.DescriptorImpl#setInstallations(JDK...)} to
&nbsp;     * set JDK installations from external code.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void setJDKs(Collection&lt;? extends JDK&gt; jdks) {
<b class="nc">&nbsp;        this.jdks = new ArrayList&lt;&gt;(jdks);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the JDK installation of the given name, or returns null.
&nbsp;     */
&nbsp;    public JDK getJDK(String name) {
<b class="nc">&nbsp;        if (name == null) {</b>
&nbsp;            // if only one JDK is configured, &quot;default JDK&quot; should mean that JDK.
<b class="nc">&nbsp;            List&lt;JDK&gt; jdks = getJDKs();</b>
<b class="nc">&nbsp;            if (jdks.size() == 1)  return jdks.get(0);</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        for (JDK j : getJDKs()) {</b>
<b class="nc">&nbsp;            if (j.getName().equals(name))</b>
<b class="nc">&nbsp;                return j;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the agent node of the give name, hooked under this Jenkins.
&nbsp;     */
&nbsp;    public @CheckForNull Node getNode(String name) {
<b class="nc">&nbsp;        return nodes.getNode(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.
&nbsp;     */
&nbsp;    public Cloud getCloud(String name) {
<b class="nc">&nbsp;        return clouds.getByName(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected ConcurrentMap&lt;Node, Computer&gt; getComputerMap() {
<b class="nc">&nbsp;        return computers;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which
&nbsp;     * represents the built-in node (in other words, this only returns agents).
&nbsp;     */
&nbsp;    @Override
&nbsp;    @NonNull
&nbsp;    public List&lt;Node&gt; getNodes() {
<b class="nc">&nbsp;        return nodes.getNodes();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the {@link Nodes} object that handles maintaining individual {@link Node}s.
&nbsp;     * @return The Nodes object.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Nodes getNodesObject() {
&nbsp;        // TODO replace this with something better when we properly expose Nodes.
<b class="nc">&nbsp;        return nodes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds one more {@link Node} to Jenkins.
&nbsp;     * If a node of the same name already exists then that node will be replaced.
&nbsp;     */
&nbsp;    public void addNode(Node n) throws IOException {
<b class="nc">&nbsp;        nodes.addNode(n);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Removes a {@link Node} from Jenkins.
&nbsp;     */
&nbsp;    public void removeNode(@NonNull Node n) throws IOException {
<b class="nc">&nbsp;        nodes.removeNode(n);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Saves an existing {@link Node} on disk, called by {@link Node#save()}. This method is preferred in those cases
&nbsp;     * where you need to determine atomically that the node being saved is actually in the list of nodes.
&nbsp;     *
&nbsp;     * @param n the node to be updated.
&nbsp;     * @return {@code true}, if the node was updated. {@code false}, if the node was not in the list of nodes.
&nbsp;     * @throws IOException if the node could not be persisted.
&nbsp;     * @see Nodes#updateNode
&nbsp;     * @since 1.634
&nbsp;     */
&nbsp;    public boolean updateNode(Node n) throws IOException {
<b class="nc">&nbsp;        return nodes.updateNode(n);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setNodes(final List&lt;? extends Node&gt; n) throws IOException {
<b class="nc">&nbsp;        nodes.setNodes(n);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; getNodeProperties() {
<b class="nc">&nbsp;        return nodeProperties;</b>
&nbsp;    }
&nbsp;
&nbsp;    public DescribableList&lt;NodeProperty&lt;?&gt;, NodePropertyDescriptor&gt; getGlobalNodeProperties() {
<b class="nc">&nbsp;        return globalNodeProperties;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resets all labels and remove invalid ones.
&nbsp;     *
&nbsp;     * This should be called when the assumptions behind label cache computation changes,
&nbsp;     * but we also call this periodically to self-heal any data out-of-sync issue.
&nbsp;     */
&nbsp;    /*package*/ void trimLabels() {
<b class="nc">&nbsp;        trimLabels((Set) null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reset labels and remove invalid ones for the given nodes.
&nbsp;     * @param nodes the nodes taken as reference to update labels
&nbsp;     */
&nbsp;    void trimLabels(Node... nodes) {
<b class="nc">&nbsp;        Set&lt;LabelAtom&gt; includedLabels = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        Arrays.stream(nodes).filter(Objects::nonNull).forEach(n -&gt; includedLabels.addAll(n.getAssignedLabels()));</b>
<b class="nc">&nbsp;        trimLabels(includedLabels);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reset labels and remove invalid ones for the given nodes.
&nbsp;     * @param includedLabels the labels taken as reference to update labels. If {@code null}, all labels are considered.
&nbsp;     */
&nbsp;    private void trimLabels(@CheckForNull Set&lt;LabelAtom&gt; includedLabels) {
<b class="nc">&nbsp;        Set&lt;Set&lt;LabelAtom&gt;&gt; nodeLabels = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        nodeLabels.add(this.getAssignedLabels());</b>
<b class="nc">&nbsp;        this.getNodes().forEach(n -&gt; nodeLabels.add(n.getAssignedLabels()));</b>
<b class="nc">&nbsp;        for (Iterator&lt;Label&gt; itr = labels.values().iterator(); itr.hasNext();) {</b>
<b class="nc">&nbsp;            Label l = itr.next();</b>
<b class="nc">&nbsp;            if (includedLabels == null || includedLabels.contains(l) || l.matches(includedLabels)) {</b>
<b class="nc">&nbsp;                if (nodeLabels.stream().anyMatch(l::matches) || !l.getClouds().isEmpty()) {</b>
&nbsp;                    // there is at least one static agent or one cloud that currently claims it can handle the label.
&nbsp;                    // if the cloud has been removed, or its labels updated such that it can not handle this, this is handle in later calls
&nbsp;                    // resetLabel will remove the agents, and clouds from the label, and they will be repopulated later.
&nbsp;                    // not checking `cloud.canProvision()` here prevents a potential call that will only be repeated later
<b class="nc">&nbsp;                    resetLabel(l);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    itr.remove();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Binds {@link AdministrativeMonitor}s to URL.
&nbsp;     * @param id Monitor ID
&nbsp;     * @return The requested monitor or {@code null} if it does not exist
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public AdministrativeMonitor getAdministrativeMonitor(String id) {
<b class="nc">&nbsp;        for (AdministrativeMonitor m : administrativeMonitors)</b>
<b class="nc">&nbsp;            if (m.id.equals(id))</b>
<b class="nc">&nbsp;                return m;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the enabled and activated administrative monitors accessible to the current user.
&nbsp;     *
&nbsp;     * @since 2.64
&nbsp;     */
&nbsp;    public List&lt;AdministrativeMonitor&gt; getActiveAdministrativeMonitors() {
<b class="nc">&nbsp;        if (!Jenkins.get().hasPermission(SYSTEM_READ)) {</b>
<b class="nc">&nbsp;            return Collections.emptyList();</b>
&nbsp;        }
<b class="nc">&nbsp;        return administrativeMonitors.stream().filter(m -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                return Jenkins.get().hasPermission(m.getRequiredPermission()) &amp;&amp; m.isEnabled() &amp;&amp; m.isActivated();</b>
<b class="nc">&nbsp;            } catch (Throwable x) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }).collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public NodeDescriptor getDescriptor() {
<b class="nc">&nbsp;        return DescriptorImpl.INSTANCE;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static final class DescriptorImpl extends NodeDescriptor {</b>
&nbsp;        @Extension
<b class="nc">&nbsp;        public static final DescriptorImpl INSTANCE = new DescriptorImpl();</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInstantiable() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public FormValidation doCheckNumExecutors(@QueryParameter String value) {
<b class="nc">&nbsp;            return FormValidation.validateNonNegativeInteger(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx
&nbsp;        public Object getDynamic(String token) {
<b class="nc">&nbsp;            return Jenkins.get().getDescriptor(token);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the system default quiet period.
&nbsp;     */
&nbsp;    public int getQuietPeriod() {
<b class="nc">&nbsp;        return quietPeriod != null ? quietPeriod : 5;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the global quiet period.
&nbsp;     *
&nbsp;     * @param quietPeriod
&nbsp;     *      null to the default value.
&nbsp;     */
&nbsp;    public void setQuietPeriod(Integer quietPeriod) throws IOException {
<b class="nc">&nbsp;        this.quietPeriod = quietPeriod;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the global SCM check out retry count.
&nbsp;     */
&nbsp;    public int getScmCheckoutRetryCount() {
<b class="nc">&nbsp;        return scmCheckoutRetryCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {
<b class="nc">&nbsp;        this.scmCheckoutRetryCount = scmCheckoutRetryCount;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getSearchUrl() {
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public SearchIndexBuilder makeSearchIndex() {
<b class="nc">&nbsp;        SearchIndexBuilder builder = super.makeSearchIndex();</b>
<b class="nc">&nbsp;        if (hasPermission(ADMINISTER)) {</b>
<b class="nc">&nbsp;                builder.add(&quot;configure&quot;, &quot;config&quot;, &quot;configure&quot;)</b>
<b class="nc">&nbsp;                    .add(&quot;manage&quot;)</b>
<b class="nc">&nbsp;                    .add(&quot;log&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        builder.add(new CollectionSearchIndex&lt;TopLevelItem&gt;() {</b>
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }</b>
&nbsp;
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected Collection&lt;TopLevelItem&gt; all() { return getAllItems(TopLevelItem.class); }</b>
&nbsp;
&nbsp;                    @NonNull
&nbsp;                    @Override
&nbsp;                    protected Iterable&lt;TopLevelItem&gt; allAsIterable() {
<b class="nc">&nbsp;                        return allItems(TopLevelItem.class);</b>
&nbsp;                    }
&nbsp;                })
<b class="nc">&nbsp;                .add(getPrimaryView().makeSearchIndex())</b>
<b class="nc">&nbsp;                .add(new CollectionSearchIndex() { // for computers</b>
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected Computer get(String key) { return getComputer(key); }</b>
&nbsp;
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected Collection&lt;Computer&gt; all() { return computers.values(); }</b>
&nbsp;                })
<b class="nc">&nbsp;                .add(new CollectionSearchIndex() { // for users</b>
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected User get(String key) { return User.get(key, false); }</b>
&nbsp;
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected Collection&lt;User&gt; all() { return User.getAll(); }</b>
&nbsp;                })
<b class="nc">&nbsp;                .add(new CollectionSearchIndex() { // for views</b>
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected View get(String key) { return getView(key); }</b>
&nbsp;
&nbsp;                    @Override
<b class="nc">&nbsp;                    protected Collection&lt;View&gt; all() { return getAllViews(); }</b>
&nbsp;                });
<b class="nc">&nbsp;        return builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getUrlChildPrefix() {
<b class="nc">&nbsp;        return &quot;job&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the absolute URL of Jenkins, such as {@code http://localhost/jenkins/}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This method first tries to use the manually configured value, then
&nbsp;     * fall back to {@link #getRootUrlFromRequest}.
&nbsp;     * It is done in this order so that it can work correctly even in the face
&nbsp;     * of a reverse proxy.
&nbsp;     *
&nbsp;     * @return {@code null} if this parameter is not configured by the user and the calling thread is not in an HTTP request;
&nbsp;     *                      otherwise the returned URL will always have the trailing {@code /}
&nbsp;     * @throws IllegalStateException {@link JenkinsLocationConfiguration} cannot be retrieved.
&nbsp;     *                      Jenkins instance may be not ready, or there is an extension loading glitch.
&nbsp;     * @since 1.66
&nbsp;     * @see &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML&quot;&gt;Hyperlinks in HTML&lt;/a&gt;
&nbsp;     */
&nbsp;    public @Nullable String getRootUrl() throws IllegalStateException {
<b class="fc">&nbsp;        final JenkinsLocationConfiguration config = JenkinsLocationConfiguration.get();</b>
<b class="fc">&nbsp;        String url = config.getUrl();</b>
<b class="fc">&nbsp;        if (url != null) {</b>
<b class="fc">&nbsp;            return Util.ensureEndsWith(url, &quot;/&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="fc">&nbsp;        if (req != null)</b>
<b class="fc">&nbsp;            return getRootUrlFromRequest();</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Exported alias for {@link JenkinsLocationConfiguration#getUrl}. */
&nbsp;    @Exported(name = &quot;url&quot;)
&nbsp;    @Restricted(DoNotUse.class)
&nbsp;    @CheckForNull
&nbsp;    public String getConfiguredRootUrl() {
<b class="nc">&nbsp;        JenkinsLocationConfiguration config = JenkinsLocationConfiguration.get();</b>
<b class="nc">&nbsp;        return config.getUrl();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Is Jenkins running in HTTPS?
&nbsp;     *
&nbsp;     * Note that we can&#39;t really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated
&nbsp;     * in the reverse proxy.
&nbsp;     */
&nbsp;    public boolean isRootUrlSecure() {
<b class="nc">&nbsp;        String url = getRootUrl();</b>
<b class="nc">&nbsp;        return url != null &amp;&amp; url.startsWith(&quot;https&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the absolute URL of Jenkins top page, such as {@code http://localhost/jenkins/}.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Unlike {@link #getRootUrl()}, which uses the manually configured value,
&nbsp;     * this one uses the current request to reconstruct the URL. The benefit is
&nbsp;     * that this is immune to the configuration mistake (users often fail to set the root URL
&nbsp;     * correctly, especially when a migration is involved), but the downside
&nbsp;     * is that unless you are processing a request, this method doesn&#39;t work.
&nbsp;     *
&nbsp;     * &lt;p&gt;Please note that this will not work in all cases if Jenkins is running behind a
&nbsp;     * reverse proxy which has not been fully configured.
&nbsp;     * Specifically the {@code Host} and {@code X-Forwarded-Proto} headers must be set.
&nbsp;     * &lt;a href=&quot;https://www.jenkins.io/doc/book/system-administration/reverse-proxy-configuration-apache/&quot;&gt;Reverse proxy - Apache&lt;/a&gt;
&nbsp;     * shows some examples of configuration.
&nbsp;     * @since 1.263
&nbsp;     */
&nbsp;    public @NonNull String getRootUrlFromRequest() {
<b class="fc">&nbsp;        StaplerRequest req = Stapler.getCurrentRequest();</b>
<b class="fc">&nbsp;        if (req == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;cannot call getRootUrlFromRequest from outside a request handling thread&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        StringBuilder buf = new StringBuilder();</b>
<b class="fc">&nbsp;        String scheme = getXForwardedHeader(req, &quot;X-Forwarded-Proto&quot;, req.getScheme());</b>
<b class="fc">&nbsp;        buf.append(scheme).append(&quot;://&quot;);</b>
<b class="fc">&nbsp;        String host = getXForwardedHeader(req, &quot;X-Forwarded-Host&quot;, req.getServerName());</b>
<b class="fc">&nbsp;        int index = host.lastIndexOf(&#39;:&#39;);</b>
<b class="fc">&nbsp;        int port = req.getServerPort();</b>
<b class="fc">&nbsp;        if (index == -1) {</b>
&nbsp;            // Almost everyone else except Nginx put the host and port in separate headers
<b class="fc">&nbsp;            buf.append(host);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            if (host.startsWith(&quot;[&quot;) &amp;&amp; host.endsWith(&quot;]&quot;)) {</b>
&nbsp;                // support IPv6 address
<b class="fc">&nbsp;                buf.append(host);</b>
&nbsp;            } else {
&nbsp;                // Nginx uses the same spec as for the Host header, i.e. hostname:port
<b class="fc">&nbsp;                buf.append(host, 0, index);</b>
<b class="fc">&nbsp;                if (index + 1 &lt; host.length()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        port = Integer.parseInt(host.substring(index + 1));</b>
<b class="nc">&nbsp;                    } catch (NumberFormatException e) {</b>
&nbsp;                        // ignore
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;                // but if a user has configured Nginx with an X-Forwarded-Port, that will win out.
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        String forwardedPort = getXForwardedHeader(req, &quot;X-Forwarded-Port&quot;, null);</b>
<b class="fc">&nbsp;        if (forwardedPort != null) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                port = Integer.parseInt(forwardedPort);</b>
<b class="nc">&nbsp;            } catch (NumberFormatException e) {</b>
&nbsp;                // ignore
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        if (port != (&quot;https&quot;.equals(scheme) ? 443 : 80)) {</b>
<b class="fc">&nbsp;            buf.append(&#39;:&#39;).append(port);</b>
&nbsp;        }
<b class="fc">&nbsp;        buf.append(req.getContextPath()).append(&#39;/&#39;);</b>
<b class="fc">&nbsp;        return buf.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the originating &quot;X-Forwarded-...&quot; header from the request. If there are multiple headers the originating
&nbsp;     * header is the first header. If the originating header contains a comma separated list, the originating entry
&nbsp;     * is the first one.
&nbsp;     * @param req the request
&nbsp;     * @param header the header name
&nbsp;     * @param defaultValue the value to return if the header is absent.
&nbsp;     * @return the originating entry of the header or the default value if the header was not present.
&nbsp;     */
&nbsp;    private static String getXForwardedHeader(StaplerRequest req, String header, String defaultValue) {
<b class="fc">&nbsp;        String value = req.getHeader(header);</b>
<b class="fc">&nbsp;        if (value != null) {</b>
<b class="fc">&nbsp;            int index = value.indexOf(&#39;,&#39;);</b>
<b class="fc">&nbsp;            return index == -1 ? value.trim() : value.substring(0, index).trim();</b>
&nbsp;        }
<b class="fc">&nbsp;        return defaultValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public File getRootDir() {
<b class="nc">&nbsp;        return root;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public FilePath getWorkspaceFor(TopLevelItem item) {
<b class="nc">&nbsp;        for (WorkspaceLocator l : WorkspaceLocator.all()) {</b>
<b class="nc">&nbsp;            FilePath workspace = l.locate(item, this);</b>
<b class="nc">&nbsp;            if (workspace != null) {</b>
<b class="nc">&nbsp;                return workspace;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return new FilePath(expandVariablesForDirectory(workspaceDir, item));</b>
&nbsp;    }
&nbsp;
&nbsp;    public File getBuildDirFor(Job job) {
<b class="nc">&nbsp;        return expandVariablesForDirectory(buildsDir, job);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If the configured buildsDir has it&#39;s default value or has been changed.
&nbsp;     *
&nbsp;     * @return true if default value.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public boolean isDefaultBuildDir() {
<b class="nc">&nbsp;        return DEFAULT_BUILDS_DIR.equals(buildsDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    boolean isDefaultWorkspaceDir() {
<b class="nc">&nbsp;        return OLD_DEFAULT_WORKSPACES_DIR.equals(workspaceDir) || DEFAULT_WORKSPACES_DIR.equals(workspaceDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    private File expandVariablesForDirectory(String base, Item item) {
<b class="nc">&nbsp;        return new File(expandVariablesForDirectory(base, item.getFullName(), item.getRootDir().getPath()));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static String expandVariablesForDirectory(String base, String itemFullName, String itemRootDir) {
<b class="nc">&nbsp;        Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        properties.put(&quot;JENKINS_HOME&quot;, Jenkins.get().getRootDir().getPath());</b>
<b class="nc">&nbsp;        properties.put(&quot;ITEM_ROOTDIR&quot;, itemRootDir);</b>
<b class="nc">&nbsp;        properties.put(&quot;ITEM_FULLNAME&quot;, itemFullName); // legacy, deprecated</b>
<b class="nc">&nbsp;        properties.put(&quot;ITEM_FULL_NAME&quot;, itemFullName.replace(&#39;:&#39;, &#39;$&#39;)); // safe, see JENKINS-12251</b>
<b class="nc">&nbsp;        return Util.replaceMacro(base, Collections.unmodifiableMap(properties));</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public String getRawWorkspaceDir() {
<b class="nc">&nbsp;        return workspaceDir;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getRawBuildsDir() {
<b class="nc">&nbsp;        return buildsDir;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void setRawBuildsDir(String buildsDir) {
<b class="nc">&nbsp;        this.buildsDir = buildsDir;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public @NonNull FilePath getRootPath() {
<b class="nc">&nbsp;        return new FilePath(getRootDir());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public FilePath createPath(String absolutePath) {
<b class="nc">&nbsp;        return new FilePath((VirtualChannel) null, absolutePath);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ClockDifference getClockDifference() {
<b class="nc">&nbsp;        return ClockDifference.ZERO;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Callable&lt;ClockDifference, IOException&gt; getClockDifferenceCallable() {
<b class="nc">&nbsp;        return new ClockDifferenceCallable();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static class ClockDifferenceCallable extends MasterToSlaveCallable&lt;ClockDifference, IOException&gt; {</b>
&nbsp;        @Override
&nbsp;        public ClockDifference call() throws IOException {
<b class="nc">&nbsp;            return new ClockDifference(0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For binding {@link LogRecorderManager} to &quot;/log&quot;.
&nbsp;     * Everything below here is admin-only, so do the check here.
&nbsp;     */
&nbsp;    public LogRecorderManager getLog() {
<b class="nc">&nbsp;        checkPermission(SYSTEM_READ);</b>
<b class="nc">&nbsp;        return log;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the LogRecorderManager.
&nbsp;     *
&nbsp;     * @param log the LogRecorderManager to set
&nbsp;     * @since 2.323
&nbsp;     */
&nbsp;    public void setLog(LogRecorderManager log) {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
<b class="nc">&nbsp;        this.log = log;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A convenience method to check if there&#39;s some security
&nbsp;     * restrictions in place.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isUseSecurity() {
<b class="nc">&nbsp;        return securityRealm != SecurityRealm.NO_AUTHENTICATION || authorizationStrategy != AuthorizationStrategy.UNSECURED;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isUseProjectNamingStrategy() {
<b class="nc">&nbsp;        return projectNamingStrategy != ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If true, all the POST requests to Jenkins would have to have crumb in it to protect
&nbsp;     * Jenkins from CSRF vulnerabilities.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isUseCrumbs() {
<b class="nc">&nbsp;        return crumbIssuer != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the constant that captures the three basic security modes in Jenkins.
&nbsp;     */
&nbsp;    public SecurityMode getSecurity() {
&nbsp;        // fix the variable so that this code works under concurrent modification to securityRealm.
<b class="nc">&nbsp;        SecurityRealm realm = securityRealm;</b>
&nbsp;
<b class="nc">&nbsp;        if (realm == SecurityRealm.NO_AUTHENTICATION)</b>
<b class="nc">&nbsp;            return SecurityMode.UNSECURED;</b>
<b class="nc">&nbsp;        if (realm instanceof LegacySecurityRealm)</b>
<b class="nc">&nbsp;            return SecurityMode.LEGACY;</b>
<b class="nc">&nbsp;        return SecurityMode.SECURED;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     *      never null.
&nbsp;     */
&nbsp;    public SecurityRealm getSecurityRealm() {
<b class="nc">&nbsp;        return securityRealm;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets a security realm.
&nbsp;     * @param securityRealm Security realm to set.
&nbsp;     *                      If {@code null}, {@link SecurityRealm#NO_AUTHENTICATION} will be set.
&nbsp;     */
&nbsp;    public void setSecurityRealm(@CheckForNull SecurityRealm securityRealm) {
<b class="nc">&nbsp;        if (securityRealm == null)</b>
<b class="nc">&nbsp;            securityRealm = SecurityRealm.NO_AUTHENTICATION;</b>
<b class="nc">&nbsp;        this.useSecurity = true;</b>
<b class="nc">&nbsp;        IdStrategy oldUserIdStrategy = this.securityRealm == null</b>
<b class="nc">&nbsp;                ? securityRealm.getUserIdStrategy() // don&#39;t trigger rekey on Jenkins load</b>
<b class="nc">&nbsp;                : this.securityRealm.getUserIdStrategy();</b>
<b class="nc">&nbsp;        this.securityRealm = securityRealm;</b>
<b class="nc">&nbsp;        resetFilter(securityRealm, oldUserIdStrategy);</b>
<b class="nc">&nbsp;        saveQuietly();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reset the filters and proxies for the new {@link SecurityRealm}.
&nbsp;     * @param securityRealm The new security realm
&nbsp;     * @param oldUserIdStrategy The old user id strategy if there was one. Can trigger a rekey if the new user id strategy is different.
&nbsp;     */
&nbsp;    private void resetFilter(@CheckForNull SecurityRealm securityRealm, @CheckForNull IdStrategy oldUserIdStrategy) {
&nbsp;        try {
<b class="nc">&nbsp;            HudsonFilter filter = HudsonFilter.get(servletContext);</b>
<b class="nc">&nbsp;            if (filter == null) {</b>
&nbsp;                // Fix for JENKINS-3069: This filter is not necessarily initialized before the servlets.
&nbsp;                // when HudsonFilter does come back, it&#39;ll initialize itself.
<b class="nc">&nbsp;                LOGGER.fine(&quot;HudsonFilter has not yet been initialized: Can&#39;t perform security setup for now&quot;);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                LOGGER.fine(&quot;HudsonFilter has been previously initialized: Setting security up&quot;);</b>
<b class="nc">&nbsp;                filter.reset(securityRealm);</b>
<b class="nc">&nbsp;                LOGGER.fine(&quot;Security is now fully set up&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (oldUserIdStrategy != null &amp;&amp; this.securityRealm != null &amp;&amp; !oldUserIdStrategy.equals(this.securityRealm.getUserIdStrategy())) {</b>
<b class="nc">&nbsp;                User.rekey();</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (ServletException e) {</b>
&nbsp;            // for binary compatibility, this method cannot throw a checked exception
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to configure filter&quot;, e) {};</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets a new authorization strategy.
&nbsp;     * @param a Authorization strategy to set.
&nbsp;     *          If {@code null}, {@link AuthorizationStrategy#UNSECURED} will be set
&nbsp;     */
&nbsp;    public void setAuthorizationStrategy(@CheckForNull AuthorizationStrategy a) {
<b class="nc">&nbsp;        if (a == null)</b>
<b class="nc">&nbsp;            a = AuthorizationStrategy.UNSECURED;</b>
<b class="nc">&nbsp;        useSecurity = true;</b>
<b class="nc">&nbsp;        authorizationStrategy = a;</b>
<b class="nc">&nbsp;        saveQuietly();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isDisableRememberMe() {
<b class="nc">&nbsp;        return disableRememberMe;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setDisableRememberMe(boolean disableRememberMe) {
<b class="nc">&nbsp;        this.disableRememberMe = disableRememberMe;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void disableSecurity() {
<b class="nc">&nbsp;        useSecurity = null;</b>
<b class="nc">&nbsp;        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);</b>
<b class="nc">&nbsp;        authorizationStrategy = AuthorizationStrategy.UNSECURED;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {
<b class="nc">&nbsp;        if (ns == null) {</b>
<b class="nc">&nbsp;            ns = ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;</b>
&nbsp;        }
<b class="nc">&nbsp;        projectNamingStrategy = ns;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Lifecycle getLifecycle() {
<b class="nc">&nbsp;        return Lifecycle.get();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the dependency injection container that hosts all the extension implementations and other
&nbsp;     * components in Jenkins.
&nbsp;     *
&nbsp;     * @since 1.433
&nbsp;     */
&nbsp;    public @CheckForNull Injector getInjector() {
<b class="nc">&nbsp;        return lookup(Injector.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.
&nbsp;     *
&nbsp;     * @param extensionType
&nbsp;     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype
&nbsp;     *      but that&#39;s not a hard requirement.
&nbsp;     * @return
&nbsp;     *      Can be an empty list but never null.
&nbsp;     * @see ExtensionList#lookup
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; ExtensionList&lt;T&gt; getExtensionList(Class&lt;T&gt; extensionType) {
<b class="nc">&nbsp;        ExtensionList&lt;T&gt; extensionList = extensionLists.get(extensionType);</b>
<b class="nc">&nbsp;        return extensionList != null ? extensionList : extensionLists.computeIfAbsent(extensionType, key -&gt; ExtensionList.create(this, key));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Used to bind {@link ExtensionList}s to URLs.
&nbsp;     *
&nbsp;     * @since 1.349
&nbsp;     */
&nbsp;    @StaplerDispatchable
&nbsp;    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {
<b class="nc">&nbsp;        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given
&nbsp;     * kind of {@link Describable}.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      Can be an empty list but never null.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public @NonNull &lt;T extends Describable&lt;T&gt;, D extends Descriptor&lt;T&gt;&gt; DescriptorExtensionList&lt;T, D&gt; getDescriptorList(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        return descriptorLists.computeIfAbsent(type, key -&gt; DescriptorExtensionList.createDescriptorList(this, key));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.
&nbsp;     *
&nbsp;     * Exposed only for {@link PluginManager#dynamicLoad(File)}.
&nbsp;     */
&nbsp;    public void refreshExtensions() throws ExtensionRefreshException {
<b class="nc">&nbsp;        ExtensionList&lt;ExtensionFinder&gt; finders = getExtensionList(ExtensionFinder.class);</b>
<b class="nc">&nbsp;        for (ExtensionFinder ef : finders) {</b>
<b class="nc">&nbsp;            if (!ef.isRefreshable())</b>
<b class="nc">&nbsp;                throw new ExtensionRefreshException(ef + &quot; doesn&#39;t support refresh&quot;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;ExtensionComponentSet&gt; fragments = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (ExtensionFinder ef : finders) {</b>
<b class="nc">&nbsp;            fragments.add(ef.refresh());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();</b>
&nbsp;
&nbsp;        // if we find a new ExtensionFinder, we need it to list up all the extension points as well
<b class="nc">&nbsp;        List&lt;ExtensionComponent&lt;ExtensionFinder&gt;&gt; newFinders = new ArrayList&lt;&gt;(delta.find(ExtensionFinder.class));</b>
<b class="nc">&nbsp;        while (!newFinders.isEmpty()) {</b>
<b class="nc">&nbsp;            ExtensionFinder f = newFinders.remove(newFinders.size() - 1).getInstance();</b>
&nbsp;
<b class="nc">&nbsp;            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();</b>
<b class="nc">&nbsp;            newFinders.addAll(ecs.find(ExtensionFinder.class));</b>
<b class="nc">&nbsp;            delta = ExtensionComponentSet.union(delta, ecs);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (ExtensionList el : extensionLists.values()) {</b>
<b class="nc">&nbsp;            el.refresh(delta);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (ExtensionList el : descriptorLists.values()) {</b>
<b class="nc">&nbsp;            el.refresh(delta);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?
<b class="nc">&nbsp;        for (ExtensionComponent&lt;RootAction&gt; ea : delta.find(RootAction.class)) {</b>
<b class="nc">&nbsp;            Action a = ea.getInstance();</b>
<b class="nc">&nbsp;            if (!actions.contains(a)) actions.add(a);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the root {@link ACL}.
&nbsp;     *
&nbsp;     * @see AuthorizationStrategy#getRootACL()
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public ACL getACL() {
<b class="nc">&nbsp;        return authorizationStrategy.getRootACL();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return
&nbsp;     *      never null.
&nbsp;     */
&nbsp;    public AuthorizationStrategy getAuthorizationStrategy() {
<b class="nc">&nbsp;        return authorizationStrategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The strategy used to check the project names.
&nbsp;     * @return never {@code null}
&nbsp;     */
&nbsp;    public ProjectNamingStrategy getProjectNamingStrategy() {
<b class="nc">&nbsp;        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if Jenkins is quieting down.
&nbsp;     * &lt;p&gt;
&nbsp;     * No further jobs will be executed unless it
&nbsp;     * can be finished while other current pending builds
&nbsp;     * are still in progress.
&nbsp;     */
&nbsp;    @Exported
&nbsp;    public boolean isQuietingDown() {
<b class="nc">&nbsp;        return quietDownInfo != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns if the quietingDown is a safe restart.
&nbsp;     * @since 2.414
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @NonNull
&nbsp;    public boolean isPreparingSafeRestart() {
<b class="nc">&nbsp;        QuietDownInfo quietDownInfo = this.quietDownInfo;</b>
<b class="nc">&nbsp;        if (quietDownInfo != null) {</b>
<b class="nc">&nbsp;            return quietDownInfo.isSafeRestart();</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns quiet down reason if it was indicated.
&nbsp;     * @return
&nbsp;     *      Reason if it was indicated. null otherwise
&nbsp;     *      @since 2.267
&nbsp;     */
&nbsp;    @Exported
&nbsp;    @CheckForNull
&nbsp;    public String getQuietDownReason() {
<b class="nc">&nbsp;        final QuietDownInfo info = quietDownInfo;</b>
<b class="nc">&nbsp;        return info != null ? info.message : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns true if the container initiated the termination of the web application.
&nbsp;     */
&nbsp;    public boolean isTerminating() {
<b class="nc">&nbsp;        return terminating;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the initialization milestone that we&#39;ve already reached.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      {@link InitMilestone#STARTED} even if the initialization hasn&#39;t been started, so that this method
&nbsp;     *      never returns null.
&nbsp;     */
&nbsp;    public InitMilestone getInitLevel() {
<b class="nc">&nbsp;        return initLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets a number of executors.
&nbsp;     * @param n Number of executors
&nbsp;     * @throws IOException Failed to save the configuration
&nbsp;     * @throws IllegalArgumentException Negative value has been passed
&nbsp;     */
&nbsp;    public void setNumExecutors(/* @javax.annotation.Nonnegative*/ int n) throws IOException, IllegalArgumentException {
<b class="nc">&nbsp;        if (n &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Incorrect field \&quot;# of executors\&quot;: &quot; + n + &quot;. It should be a non-negative number.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (this.numExecutors != n) {</b>
<b class="nc">&nbsp;            this.numExecutors = n;</b>
<b class="nc">&nbsp;            updateComputerList();</b>
<b class="nc">&nbsp;            save();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}.
&nbsp;     *
&nbsp;     * Note that the look up is case-insensitive.
&nbsp;     */
&nbsp;    @Override public TopLevelItem getItem(String name) throws AccessDeniedException {
<b class="nc">&nbsp;        if (name == null)    return null;</b>
<b class="nc">&nbsp;        TopLevelItem item = items.get(name);</b>
<b class="nc">&nbsp;        if (item == null)</b>
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        if (!item.hasPermission(Item.READ)) {</b>
<b class="nc">&nbsp;            if (item.hasPermission(Item.DISCOVER)) {</b>
<b class="nc">&nbsp;                throw new AccessDeniedException(&quot;Please login to access job &quot; + name);</b>
&nbsp;            }
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        return item;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the item by its path name from the given context
&nbsp;     *
&nbsp;     * &lt;p&gt;&lt;strong&gt;Path Names:&lt;/strong&gt;
&nbsp;     * If the name starts from &#39;/&#39;, like &quot;/foo/bar/zot&quot;, then it&#39;s interpreted as absolute.
&nbsp;     * Otherwise, the name should be something like &quot;foo/bar&quot; and it&#39;s interpreted like
&nbsp;     * relative path name in the file system is, against the given context.
&nbsp;     *
&nbsp;     * &lt;p&gt;For compatibility, as a fallback when nothing else matches, a simple path
&nbsp;     * like {@code foo/bar} can also be treated with {@link #getItemByFullName}.
&nbsp;     *
&nbsp;     * @param context
&nbsp;     *      null is interpreted as {@link Jenkins}. Base &#39;directory&#39; of the interpretation.
&nbsp;     * @since 1.406
&nbsp;     */
&nbsp;    public Item getItem(String pathName, ItemGroup context) {
<b class="nc">&nbsp;        if (context == null)  context = this;</b>
<b class="nc">&nbsp;        if (pathName == null) return null;</b>
&nbsp;
<b class="nc">&nbsp;        if (pathName.startsWith(&quot;/&quot;))   // absolute</b>
<b class="nc">&nbsp;            return getItemByFullName(pathName);</b>
&nbsp;
<b class="nc">&nbsp;        Object/*Item|ItemGroup*/ ctx = context;</b>
&nbsp;
<b class="nc">&nbsp;        StringTokenizer tokens = new StringTokenizer(pathName, &quot;/&quot;);</b>
<b class="nc">&nbsp;        while (tokens.hasMoreTokens()) {</b>
<b class="nc">&nbsp;            String s = tokens.nextToken();</b>
<b class="nc">&nbsp;            if (s.equals(&quot;..&quot;)) {</b>
<b class="nc">&nbsp;                if (ctx instanceof Item) {</b>
<b class="nc">&nbsp;                    ctx = ((Item) ctx).getParent();</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                ctx = null;    // can&#39;t go up further</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (s.equals(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (ctx instanceof ItemGroup) {</b>
<b class="nc">&nbsp;                ItemGroup g = (ItemGroup) ctx;</b>
<b class="nc">&nbsp;                Item i = g.getItem(s);</b>
<b class="nc">&nbsp;                if (i == null || !i.hasPermission(Item.READ)) { // TODO consider DISCOVER</b>
<b class="nc">&nbsp;                    ctx = null;    // can&#39;t go up further</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;                ctx = i;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        if (ctx instanceof Item)</b>
<b class="nc">&nbsp;            return (Item) ctx;</b>
&nbsp;
&nbsp;        // fall back to the classic interpretation
<b class="nc">&nbsp;        return getItemByFullName(pathName);</b>
&nbsp;    }
&nbsp;
&nbsp;    public final Item getItem(String pathName, Item context) {
<b class="nc">&nbsp;        return getItem(pathName, context != null ? context.getParent() : null);</b>
&nbsp;    }
&nbsp;
&nbsp;    public final &lt;T extends Item&gt; T getItem(String pathName, ItemGroup context, @NonNull Class&lt;T&gt; type) {
<b class="nc">&nbsp;        Item r = getItem(pathName, context);</b>
<b class="nc">&nbsp;        if (type.isInstance(r))</b>
<b class="nc">&nbsp;            return type.cast(r);</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    public final &lt;T extends Item&gt; T getItem(String pathName, Item context, Class&lt;T&gt; type) {
<b class="nc">&nbsp;        return getItem(pathName, context != null ? context.getParent() : null, type);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public File getRootDirFor(TopLevelItem child) {
<b class="nc">&nbsp;        return getRootDirFor(child.getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    private File getRootDirFor(String name) {
<b class="nc">&nbsp;        return new File(new File(getRootDir(), &quot;jobs&quot;), name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Item} object by its full name.
&nbsp;     * Full names are like path names, where each name of {@link Item} is
&nbsp;     * combined by &#39;/&#39;.
&nbsp;     *
&nbsp;     * @return
&nbsp;     *      null if either such {@link Item} doesn&#39;t exist under the given full name,
&nbsp;     *      or it exists but it&#39;s no an instance of the given type.
&nbsp;     * @throws AccessDeniedException as per {@link ItemGroup#getItem}
&nbsp;     */
&nbsp;    public @CheckForNull &lt;T extends Item&gt; T getItemByFullName(@NonNull String fullName, Class&lt;T&gt; type) throws AccessDeniedException {
<b class="nc">&nbsp;        StringTokenizer tokens = new StringTokenizer(fullName, &quot;/&quot;);</b>
<b class="nc">&nbsp;        ItemGroup parent = this;</b>
&nbsp;
<b class="nc">&nbsp;        if (!tokens.hasMoreTokens()) return null;    // for example, empty full name.</b>
&nbsp;
&nbsp;        while (true) {
<b class="nc">&nbsp;            Item item = parent.getItem(tokens.nextToken());</b>
<b class="nc">&nbsp;            if (!tokens.hasMoreTokens()) {</b>
<b class="nc">&nbsp;                if (type.isInstance(item))</b>
<b class="nc">&nbsp;                    return type.cast(item);</b>
&nbsp;                else
<b class="nc">&nbsp;                    return null;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (!(item instanceof ItemGroup))</b>
<b class="nc">&nbsp;                return null;    // this item can&#39;t have any children</b>
&nbsp;
<b class="nc">&nbsp;            if (!item.hasPermission(Item.READ))</b>
<b class="nc">&nbsp;                return null; // TODO consider DISCOVER</b>
&nbsp;
<b class="nc">&nbsp;            parent = (ItemGroup) item;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public @CheckForNull Item getItemByFullName(String fullName) {
<b class="nc">&nbsp;        return getItemByFullName(fullName, Item.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the user of the given name.
&nbsp;     *
&nbsp;     * @return the user of the given name (which may or may not be an id), if that person exists; else null
&nbsp;     * @see User#get(String,boolean)
&nbsp;     * @see User#getById(String, boolean)
&nbsp;     */
&nbsp;    public @CheckForNull User getUser(String name) {
<b class="nc">&nbsp;        return User.get(name, User.ALLOW_USER_CREATION_VIA_URL &amp;&amp; hasPermission(ADMINISTER));</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    public synchronized TopLevelItem createProject(@NonNull TopLevelItemDescriptor type, @NonNull String name) throws IOException {
<b class="nc">&nbsp;        return createProject(type, name, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public synchronized TopLevelItem createProject(@NonNull TopLevelItemDescriptor type, @NonNull String name, boolean notify) throws IOException {
<b class="nc">&nbsp;        return itemGroupMixIn.createProject(type, name, notify);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Overwrites the existing item by new one.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This is a short cut for deleting an existing job and adding a new one.
&nbsp;     */
&nbsp;    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {
<b class="nc">&nbsp;        String name = item.getName();</b>
<b class="nc">&nbsp;        TopLevelItem old = items.get(name);</b>
<b class="nc">&nbsp;        if (old == item)  return; // noop</b>
&nbsp;
<b class="nc">&nbsp;        checkPermission(Item.CREATE);</b>
<b class="nc">&nbsp;        if (old != null)</b>
<b class="nc">&nbsp;            old.delete();</b>
<b class="nc">&nbsp;        items.put(name, item);</b>
<b class="nc">&nbsp;        ItemListener.fireOnCreated(item);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new job.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This version infers the descriptor from the type of the top-level item.
&nbsp;     *
&nbsp;     * @throws IllegalArgumentException
&nbsp;     *      if the project of the given name already exists.
&nbsp;     */
&nbsp;    @NonNull
&nbsp;    public synchronized &lt;T extends TopLevelItem&gt; T createProject(@NonNull Class&lt;T&gt; type, @NonNull String name) throws IOException {
<b class="nc">&nbsp;        return type.cast(createProject((TopLevelItemDescriptor) getDescriptorOrDie(type), name));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called by {@link Job#renameTo(String)} to update relevant data structure.
&nbsp;     * assumed to be synchronized on Jenkins by the caller.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {
<b class="nc">&nbsp;        items.remove(oldName);</b>
<b class="nc">&nbsp;        items.put(newName, job);</b>
&nbsp;
&nbsp;        // For compatibility with old views:
<b class="nc">&nbsp;        for (View v : views)</b>
<b class="nc">&nbsp;            v.onJobRenamed(job, oldName, newName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void onDeleted(TopLevelItem item) throws IOException {
<b class="nc">&nbsp;        ItemListener.fireOnDeleted(item);</b>
&nbsp;
<b class="nc">&nbsp;        items.remove(item.getName());</b>
&nbsp;        // For compatibility with old views:
<b class="nc">&nbsp;        for (View v : views)</b>
<b class="nc">&nbsp;            v.onJobRenamed(item, item.getName(), null);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public boolean canAdd(TopLevelItem item) {
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public synchronized &lt;I extends TopLevelItem&gt; I add(I item, String name) throws IOException, IllegalArgumentException {
<b class="nc">&nbsp;        if (items.containsKey(name)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;already an item &#39;&quot; + name + &quot;&#39;&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        items.put(name, item);</b>
<b class="nc">&nbsp;        return item;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override public void remove(TopLevelItem item) throws IOException, IllegalArgumentException {
<b class="nc">&nbsp;        items.remove(item.getName());</b>
&nbsp;    }
&nbsp;
&nbsp;    public FingerprintMap getFingerprintMap() {
<b class="nc">&nbsp;        return fingerprintMap;</b>
&nbsp;    }
&nbsp;
&nbsp;    // if no finger print matches, display &quot;not found page&quot;.
&nbsp;    @StaplerDispatchable
&nbsp;    public Object getFingerprint(String md5sum) throws IOException {
<b class="nc">&nbsp;        Fingerprint r = fingerprintMap.get(md5sum);</b>
<b class="nc">&nbsp;        if (r == null)     return new NoFingerprintMatch(md5sum);</b>
<b class="nc">&nbsp;        else            return r;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a {@link Fingerprint} object if it exists.
&nbsp;     * Otherwise null.
&nbsp;     */
&nbsp;    public Fingerprint _getFingerprint(String md5sum) throws IOException {
<b class="nc">&nbsp;        return fingerprintMap.get(md5sum);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The file we save our configuration.
&nbsp;     */
&nbsp;    private XmlFile getConfigFile() {
<b class="nc">&nbsp;        return new XmlFile(XSTREAM, new File(root, &quot;config.xml&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int getNumExecutors() {
<b class="nc">&nbsp;        return numExecutors;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Mode getMode() {
<b class="nc">&nbsp;        return mode;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setMode(Mode m) throws IOException {
<b class="nc">&nbsp;        this.mode = m;</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getLabelString() {
<b class="nc">&nbsp;        return fixNull(label).trim();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void setLabelString(String label) throws IOException {
<b class="nc">&nbsp;        _setLabelString(label);</b>
<b class="nc">&nbsp;        save();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _setLabelString(String label) {
<b class="nc">&nbsp;        this.label = label;</b>
<b class="nc">&nbsp;        if (Jenkins.getInstanceOrNull() != null) { // avoid on unit tests</b>
<b class="nc">&nbsp;            this.labelAtomSet = Collections.unmodifiableSet(Label.parse(label));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @NonNull
&nbsp;    @Override
&nbsp;    public LabelAtom getSelfLabel() {
<b class="nc">&nbsp;        if (nodeNameAndSelfLabelOverride != null) {</b>
<b class="nc">&nbsp;            return getLabelAtom(nodeNameAndSelfLabelOverride);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (getRenameMigrationDone()) {</b>
<b class="nc">&nbsp;            return getLabelAtom(&quot;built-in&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return getLabelAtom(&quot;master&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /* package */ boolean getRenameMigrationDone() {
<b class="nc">&nbsp;        if (nodeRenameMigrationNeeded == null) {</b>
&nbsp;            /* This is exceptionally unlikely to occur since we replace &#39;null&#39; with &#39;true&#39; on save */
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        return !nodeRenameMigrationNeeded;</b>
&nbsp;    }
&nbsp;
&nbsp;    /* package */ void performRenameMigration() throws IOException {
<b class="nc">&nbsp;        this.nodeRenameMigrationNeeded = false;</b>
<b class="nc">&nbsp;        this.save();</b>
<b class="nc">&nbsp;        this.trimLabels();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @NonNull
&nbsp;    public Computer createComputer() {
<b class="nc">&nbsp;        return new Hudson.MasterComputer();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void load() throws IOException {
<b class="nc">&nbsp;        XmlFile cfg = getConfigFile();</b>
<b class="nc">&nbsp;        if (cfg.exists()) {</b>
&nbsp;            // reset some data that may not exist in the disk file
&nbsp;            // so that we can take a proper compensation action later.
<b class="nc">&nbsp;            primaryView = null;</b>
<b class="nc">&nbsp;            views.clear();</b>
&nbsp;
&nbsp;            // load from disk
<b class="nc">&nbsp;            cfg.unmarshal(Jenkins.this);</b>
&nbsp;        }
&nbsp;        // initialize views by inserting the default view if necessary
&nbsp;        // this is both for clean Jenkins and for backward compatibility.
<b class="nc">&nbsp;        if (views.isEmpty() || primaryView == null) {</b>
<b class="nc">&nbsp;            View v = new AllView(AllView.DEFAULT_VIEW_NAME);</b>
<b class="nc">&nbsp;            setViewOwner(v);</b>
<b class="nc">&nbsp;            views.add(0, v);</b>
<b class="nc">&nbsp;            primaryView = v.getViewName();</b>
&nbsp;        }
<b class="nc">&nbsp;        primaryView = AllView.migrateLegacyPrimaryAllViewLocalizedName(views, primaryView);</b>
<b class="nc">&nbsp;        configLoaded = true;</b>
&nbsp;        try {
<b class="nc">&nbsp;            checkRawBuildsDir(buildsDir);</b>
<b class="nc">&nbsp;            setBuildsAndWorkspacesDir();</b>
<b class="nc">&nbsp;            resetFilter(securityRealm, null);</b>
<b class="nc">&nbsp;        } catch (InvalidBuildsDir invalidBuildsDir) {</b>
<b class="nc">&nbsp;            throw new IOException(invalidBuildsDir);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void setBuildsAndWorkspacesDir() throws IOException, InvalidBuildsDir {
<b class="nc">&nbsp;        boolean mustSave = false;</b>
<b class="nc">&nbsp;        String newBuildsDir = SystemProperties.getString(BUILDS_DIR_PROP);</b>
<b class="nc">&nbsp;        boolean freshStartup = STARTUP_MARKER_FILE.isOff();</b>
<b class="nc">&nbsp;        if (newBuildsDir != null &amp;&amp; !buildsDir.equals(newBuildsDir)) {</b>
&nbsp;
<b class="nc">&nbsp;            checkRawBuildsDir(newBuildsDir);</b>
<b class="nc">&nbsp;            Level level = freshStartup ? Level.INFO : Level.WARNING;</b>
<b class="nc">&nbsp;            LOGGER.log(level, &quot;Changing builds directories from {0} to {1}. Beware that no automated data migration will occur.&quot;,</b>
&nbsp;                       new String[]{buildsDir, newBuildsDir});
<b class="nc">&nbsp;            buildsDir = newBuildsDir;</b>
<b class="nc">&nbsp;            mustSave = true;</b>
<b class="nc">&nbsp;        } else if (!isDefaultBuildDir()) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.INFO, &quot;Using non default builds directories: {0}.&quot;, buildsDir);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        String newWorkspacesDir = SystemProperties.getString(WORKSPACES_DIR_PROP);</b>
<b class="nc">&nbsp;        if (newWorkspacesDir != null &amp;&amp; !workspaceDir.equals(newWorkspacesDir)) {</b>
<b class="nc">&nbsp;            Level level = freshStartup ? Level.INFO : Level.WARNING;</b>
<b class="nc">&nbsp;            LOGGER.log(level, &quot;Changing workspaces directories from {0} to {1}. Beware that no automated data migration will occur.&quot;,</b>
&nbsp;                       new String[]{workspaceDir, newWorkspacesDir});
<b class="nc">&nbsp;            workspaceDir = newWorkspacesDir;</b>
<b class="nc">&nbsp;            mustSave = true;</b>
<b class="nc">&nbsp;        } else if (!isDefaultWorkspaceDir()) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.INFO, &quot;Using non default workspaces directories: {0}.&quot;, workspaceDir);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (mustSave) {</b>
<b class="nc">&nbsp;            save();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the correctness of the newBuildsDirValue for use as {@link #buildsDir}.
&nbsp;     * @param newBuildsDirValue the candidate newBuildsDirValue for updating {@link #buildsDir}.
&nbsp;     */
&nbsp;    @VisibleForTesting
&nbsp;    /*private*/ static void checkRawBuildsDir(String newBuildsDirValue) throws InvalidBuildsDir {
&nbsp;
&nbsp;        // do essentially what expandVariablesForDirectory does, without an Item
<b class="nc">&nbsp;        String replacedValue = expandVariablesForDirectory(newBuildsDirValue,</b>
&nbsp;                                                           &quot;doCheckRawBuildsDir-Marker:foo&quot;,
<b class="nc">&nbsp;                                                           Jenkins.get().getRootDir().getPath() + &quot;/jobs/doCheckRawBuildsDir-Marker$foo&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        File replacedFile = new File(replacedValue);</b>
<b class="nc">&nbsp;        if (!replacedFile.isAbsolute()) {</b>
<b class="nc">&nbsp;            throw new InvalidBuildsDir(newBuildsDirValue + &quot; does not resolve to an absolute path&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (!replacedValue.contains(&quot;doCheckRawBuildsDir-Marker&quot;)) {</b>
<b class="nc">&nbsp;            throw new InvalidBuildsDir(newBuildsDirValue + &quot; does not contain ${ITEM_FULL_NAME} or ${ITEM_ROOTDIR}, cannot distinguish between projects&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (replacedValue.contains(&quot;doCheckRawBuildsDir-Marker:foo&quot;)) {</b>
&nbsp;            // make sure platform can handle colon
&nbsp;            try {
<b class="nc">&nbsp;                File tmp = File.createTempFile(&quot;Jenkins-doCheckRawBuildsDir&quot;, &quot;foo:bar&quot;);</b>
<b class="nc">&nbsp;                Files.delete(tmp.toPath());</b>
<b class="nc">&nbsp;            } catch (IOException | InvalidPathException e) {</b>
<b class="nc">&nbsp;                throw (InvalidBuildsDir) new InvalidBuildsDir(newBuildsDirValue +  &quot; contains ${ITEM_FULLNAME} but your system does not support it (JENKINS-12251). Use ${ITEM_FULL_NAME} instead&quot;).initCause(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        File d = new File(replacedValue);</b>
<b class="nc">&nbsp;        if (!d.isDirectory()) {</b>
&nbsp;            // if dir does not exist (almost guaranteed) need to make sure nearest existing ancestor can be written to
<b class="nc">&nbsp;            d = d.getParentFile();</b>
<b class="nc">&nbsp;            while (!d.exists()) {</b>
<b class="nc">&nbsp;                d = d.getParentFile();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!d.canWrite()) {</b>
<b class="nc">&nbsp;                throw new InvalidBuildsDir(newBuildsDirValue +  &quot; does not exist and probably cannot be created&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private synchronized TaskBuilder loadTasks() throws IOException {
<b class="nc">&nbsp;        File projectsDir = new File(root, &quot;jobs&quot;);</b>
<b class="nc">&nbsp;        if (!projectsDir.getCanonicalFile().isDirectory() &amp;&amp; !projectsDir.mkdirs()) {</b>
<b class="nc">&nbsp;            if (projectsDir.exists())</b>
<b class="nc">&nbsp;                throw new IOException(projectsDir + &quot; is not a directory&quot;);</b>
<b class="nc">&nbsp;            throw new IOException(&quot;Unable to create &quot; + projectsDir + &quot;\nPermission issue? Please create this directory manually.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        File[] subdirs = projectsDir.listFiles();</b>
&nbsp;
<b class="nc">&nbsp;        final Set&lt;String&gt; loadedNames = Collections.synchronizedSet(new HashSet&lt;&gt;());</b>
&nbsp;
<b class="nc">&nbsp;        TaskGraphBuilder g = new TaskGraphBuilder();</b>
<b class="nc">&nbsp;        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(SYSTEM_CONFIG_LOADED).add(&quot;Loading global config&quot;, new Executable() {</b>
&nbsp;            @Override
&nbsp;            public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                load();</b>
&nbsp;                // if we are loading old data that doesn&#39;t have this field
<b class="nc">&nbsp;                if (slaves != null &amp;&amp; !slaves.isEmpty() &amp;&amp; nodes.isLegacy()) {</b>
<b class="nc">&nbsp;                    nodes.setNodes(slaves);</b>
<b class="nc">&nbsp;                    slaves = null;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    nodes.load();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                clouds.setOwner(Jenkins.this);</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        List&lt;Handle&gt; loadJobs = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for (final File subdir : subdirs) {</b>
<b class="nc">&nbsp;            loadJobs.add(g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(&quot;Loading item &quot; + subdir.getName(), new Executable() {</b>
&nbsp;                @Override
&nbsp;                public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                    if (!Items.getConfigFile(subdir).exists()) {</b>
&nbsp;                        //Does not have job config file, so it is not a jenkins job hence skip it
&nbsp;                        return;
&nbsp;                    }
<b class="nc">&nbsp;                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);</b>
<b class="nc">&nbsp;                    items.put(item.getName(), item);</b>
<b class="nc">&nbsp;                    loadedNames.add(item.getName());</b>
&nbsp;                }
&nbsp;            }));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        g.requires(loadJobs.toArray(new Handle[0])).attains(JOB_LOADED).add(&quot;Cleaning up obsolete items deleted from the disk&quot;, new Executable() {</b>
&nbsp;            @Override
&nbsp;            public void run(Reactor reactor) {
&nbsp;                // anything we didn&#39;t load from disk, throw them away.
&nbsp;                // doing this after loading from disk allows newly loaded items
&nbsp;                // to inspect what already existed in memory (in case of reloading)
&nbsp;
&nbsp;                // retainAll doesn&#39;t work well because of CopyOnWriteMap implementation, so remove one by one
&nbsp;                // hopefully there shouldn&#39;t be too many of them.
<b class="nc">&nbsp;                for (String name : items.keySet()) {</b>
<b class="nc">&nbsp;                    if (!loadedNames.contains(name))</b>
<b class="nc">&nbsp;                        items.remove(name);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        g.requires(JOB_CONFIG_ADAPTED).attains(COMPLETED).add(&quot;Finalizing set up&quot;, new Executable() {</b>
&nbsp;            @Override
&nbsp;            public void run(Reactor session) throws Exception {
<b class="nc">&nbsp;                rebuildDependencyGraph();</b>
&nbsp;
&nbsp;                { // recompute label objects - populates the labels mapping.
<b class="nc">&nbsp;                    for (Node slave : nodes.getNodes())</b>
&nbsp;                        // Note that not all labels are visible until the agents have connected.
<b class="nc">&nbsp;                        slave.getAssignedLabels();</b>
<b class="nc">&nbsp;                    getAssignedLabels();</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (useSecurity != null &amp;&amp; !useSecurity) {</b>
&nbsp;                    // forced reset to the unsecure mode.
&nbsp;                    // this works as an escape hatch for people who locked themselves out.
<b class="nc">&nbsp;                    authorizationStrategy = AuthorizationStrategy.UNSECURED;</b>
<b class="nc">&nbsp;                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);</b>
&nbsp;                } else {
&nbsp;                    // read in old data that doesn&#39;t have the security field set
<b class="nc">&nbsp;                    if (authorizationStrategy == null) {</b>
<b class="nc">&nbsp;                        if (useSecurity == null)</b>
<b class="nc">&nbsp;                            authorizationStrategy = AuthorizationStrategy.UNSECURED;</b>
&nbsp;                        else
<b class="nc">&nbsp;                            authorizationStrategy = new LegacyAuthorizationStrategy();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (securityRealm == null) {</b>
<b class="nc">&nbsp;                        if (useSecurity == null)</b>
<b class="nc">&nbsp;                            setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);</b>
&nbsp;                        else
<b class="nc">&nbsp;                            setSecurityRealm(new LegacySecurityRealm());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Allow the disabling system property to interfere here
<b class="nc">&nbsp;                setCrumbIssuer(getCrumbIssuer());</b>
&nbsp;
&nbsp;                // auto register root actions
<b class="nc">&nbsp;                for (Action a : getExtensionList(RootAction.class))</b>
<b class="nc">&nbsp;                    if (!actions.contains(a)) actions.add(a);</b>
&nbsp;
<b class="nc">&nbsp;                setupWizard = ExtensionList.lookupSingleton(SetupWizard.class);</b>
<b class="nc">&nbsp;                getInstallState().initializeState();</b>
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        return g;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Save the settings to a file.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public synchronized void save() throws IOException {
<b class="nc">&nbsp;        InitMilestone currentMilestone = initLevel;</b>
&nbsp;
<b class="nc">&nbsp;        if (!configLoaded) {</b>
&nbsp;            // someone is trying to save the config before all extensions are loaded (and possibly after as the task
&nbsp;            // may run in parallel with other tasks.  OMG...!!! this is generally very bad and can lead to dataloss
<b class="nc">&nbsp;            LOGGER.log(Level.SEVERE,</b>
&nbsp;                       &quot;An attempt to save Jenkins&#39;&#39; global configuration before it has been loaded has been &quot;
&nbsp;                       + &quot;made during milestone &quot; + currentMilestone
&nbsp;                       + &quot;.  This is indicative of a bug in the caller and may lead to full or partial loss of &quot;
&nbsp;                       + &quot;configuration.&quot;,
&nbsp;                       new IllegalStateException(&quot;call trace&quot;));
&nbsp;            // at this point we may want to terminate but the save may be called from a different thread and we
&nbsp;            // can not call System.halt() because we could be running in a container :(
&nbsp;            // for now just deny the save (the data will be replaced when we do load anyway
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;An attempt to save the global configuration was made before it was loaded&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (BulkChange.contains(this)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        if (currentMilestone == InitMilestone.COMPLETED) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, &quot;setting version {0} to {1}&quot;, new Object[] {version, VERSION});</b>
<b class="nc">&nbsp;            version = VERSION;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            LOGGER.log(FINE, &quot;refusing to set version {0} to {1} during {2}&quot;, new Object[] {version, VERSION, currentMilestone});</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (nodeRenameMigrationNeeded == null) {</b>
&nbsp;            /*
&nbsp;            If we initialized this object bypassing #readResolve, i.e. a new instance,
&nbsp;            we need to persist this value, otherwise on restart we&#39;d flag this as migration needed.
&nbsp;             */
<b class="nc">&nbsp;            nodeRenameMigrationNeeded = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        getConfigFile().write(this);</b>
<b class="nc">&nbsp;        SaveableListener.fireOnChange(this, getConfigFile());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void saveQuietly() {
&nbsp;        try {
<b class="nc">&nbsp;            save();</b>
<b class="nc">&nbsp;        } catch (IOException x) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, null, x);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called to shut down the system.
&nbsp;     */
&nbsp;    public void cleanUp() {
<b class="nc">&nbsp;        if (theInstance != this &amp;&amp; theInstance != null) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.WARNING, &quot;This instance is no longer the singleton, ignoring cleanUp()&quot;);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        synchronized (Jenkins.class) {</b>
<b class="nc">&nbsp;            if (cleanUpStarted) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Jenkins.cleanUp() already started, ignoring repeated cleanUp()&quot;);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;            cleanUpStarted = true;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;        try {
<b class="nc">&nbsp;            getLifecycle().onStatusUpdate(&quot;Stopping Jenkins&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            final List&lt;Throwable&gt; errors = new ArrayList&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;            fireBeforeShutdown(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpRunTerminators(errors);</b>
&nbsp;
<b class="nc">&nbsp;            terminating = true;</b>
&nbsp;
<b class="nc">&nbsp;            final Set&lt;Future&lt;?&gt;&gt; pending = _cleanUpDisconnectComputers(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpCancelDependencyGraphCalculation();</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpInterruptReloadThread(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpShutdownTriggers(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpShutdownTimer(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpShutdownTcpSlaveAgent(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpShutdownPluginManager(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpPersistQueue(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpShutdownThreadPoolForLoad(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpAwaitDisconnects(errors, pending);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpPluginServletFilters(errors);</b>
&nbsp;
<b class="nc">&nbsp;            _cleanUpReleaseAllLoggers(errors);</b>
&nbsp;
<b class="nc">&nbsp;            getLifecycle().onStatusUpdate(&quot;Jenkins stopped&quot;);</b>
&nbsp;
<b class="nc">&nbsp;            if (!errors.isEmpty()) {</b>
<b class="nc">&nbsp;                StringBuilder message = new StringBuilder(&quot;Unexpected issues encountered during cleanUp: &quot;);</b>
<b class="nc">&nbsp;                Iterator&lt;Throwable&gt; iterator = errors.iterator();</b>
<b class="nc">&nbsp;                message.append(iterator.next().getMessage());</b>
<b class="nc">&nbsp;                while (iterator.hasNext()) {</b>
<b class="nc">&nbsp;                    message.append(&quot;; &quot;);</b>
<b class="nc">&nbsp;                    message.append(iterator.next().getMessage());</b>
&nbsp;                }
<b class="nc">&nbsp;                iterator = errors.iterator();</b>
<b class="nc">&nbsp;                RuntimeException exception = new RuntimeException(message.toString(), iterator.next());</b>
<b class="nc">&nbsp;                while (iterator.hasNext()) {</b>
<b class="nc">&nbsp;                    exception.addSuppressed(iterator.next());</b>
&nbsp;                }
<b class="nc">&nbsp;                throw exception;</b>
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            theInstance = null;</b>
<b class="nc">&nbsp;            if (JenkinsJVM.isJenkinsJVM()) {</b>
<b class="nc">&nbsp;                JenkinsJVMAccess._setJenkinsJVM(oldJenkinsJVM);</b>
&nbsp;            }
<b class="nc">&nbsp;            ClassFilterImpl.unregister();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void fireBeforeShutdown(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Notifying termination&quot;);</b>
<b class="nc">&nbsp;        for (ItemListener l : ItemListener.all()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                l.onBeforeShutdown();</b>
<b class="nc">&nbsp;            } catch (OutOfMemoryError e) {</b>
&nbsp;                // we should just propagate this, no point trying to log
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (LinkageError e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, e, () -&gt; &quot;ItemListener &quot; + l + &quot;: &quot; + e.getMessage());</b>
&nbsp;                // safe to ignore and continue for this one
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, e, () -&gt; &quot;ItemListener &quot; + l + &quot;: &quot; + e.getMessage());</b>
&nbsp;                // save for later
<b class="nc">&nbsp;                errors.add(e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpRunTerminators(List&lt;Throwable&gt; errors) {
&nbsp;        try {
<b class="nc">&nbsp;            final TerminatorFinder tf = new TerminatorFinder(</b>
<b class="nc">&nbsp;                    pluginManager != null ? pluginManager.uberClassLoader : Thread.currentThread().getContextClassLoader());</b>
<b class="nc">&nbsp;            new Reactor(tf).execute(Runnable::run, new ReactorListener() {</b>
<b class="nc">&nbsp;                final Level level = Level.parse(SystemProperties.getString(Jenkins.class.getName() + &quot;.&quot; + &quot;termLogLevel&quot;, &quot;FINE&quot;));</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void onTaskStarted(Task t) {
<b class="nc">&nbsp;                    LOGGER.log(level, &quot;Started {0}&quot;, InitReactorRunner.getDisplayName(t));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onTaskCompleted(Task t) {
<b class="nc">&nbsp;                    LOGGER.log(level, &quot;Completed {0}&quot;, InitReactorRunner.getDisplayName(t));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onTaskFailed(Task t, Throwable err, boolean fatal) {
<b class="nc">&nbsp;                    LOGGER.log(SEVERE, err, () -&gt; &quot;Failed &quot; + InitReactorRunner.getDisplayName(t));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onAttained(Milestone milestone) {
<b class="nc">&nbsp;                    Level lv = level;</b>
<b class="nc">&nbsp;                    String s = &quot;Attained &quot; + milestone.toString();</b>
<b class="nc">&nbsp;                    if (milestone instanceof TermMilestone &amp;&amp; !Main.isUnitTest) {</b>
<b class="nc">&nbsp;                        lv = Level.INFO; // noteworthy milestones --- at least while we debug problems further</b>
<b class="nc">&nbsp;                        s = milestone.toString();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    LOGGER.log(lv, s);</b>
&nbsp;                }
&nbsp;            });
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to execute termination&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to execute termination&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private Set&lt;Future&lt;?&gt;&gt; _cleanUpDisconnectComputers(final List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Main.isUnitTest ? Level.FINE : Level.INFO, &quot;Starting node disconnection&quot;);</b>
<b class="nc">&nbsp;        final Set&lt;Future&lt;?&gt;&gt; pending = new HashSet&lt;&gt;();</b>
&nbsp;        // JENKINS-28840 we know we will be interrupting all the Computers so get the Queue lock once for all
<b class="nc">&nbsp;        Queue.withLock(() -&gt; {</b>
<b class="nc">&nbsp;            for (Computer c : computers.values()) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    c.interrupt();</b>
<b class="nc">&nbsp;                    killComputer(c);</b>
<b class="nc">&nbsp;                    pending.add(c.disconnect(null));</b>
<b class="nc">&nbsp;                } catch (OutOfMemoryError e) {</b>
&nbsp;                    // we should just propagate this, no point trying to log
<b class="nc">&nbsp;                    throw e;</b>
<b class="nc">&nbsp;                } catch (LinkageError e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, e, () -&gt; &quot;Could not disconnect &quot; + c + &quot;: &quot; + e.getMessage());</b>
&nbsp;                    // safe to ignore and continue for this one
<b class="nc">&nbsp;                } catch (Throwable e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, e, () -&gt; &quot;Could not disconnect &quot; + c + &quot;: &quot; + e.getMessage());</b>
&nbsp;                    // save for later
<b class="nc">&nbsp;                    errors.add(e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        });
<b class="nc">&nbsp;        return pending;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpInterruptReloadThread(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Interrupting reload thread&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            interruptReloadThread();</b>
<b class="nc">&nbsp;        } catch (SecurityException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;Not permitted to interrupt reload thread&quot;, e);</b>
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to interrupt reload thread&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to interrupt reload thread&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpShutdownTriggers(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Shutting down triggers&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            final java.util.Timer timer = Trigger.timer;</b>
<b class="nc">&nbsp;            if (timer != null) {</b>
<b class="nc">&nbsp;                final CountDownLatch latch = new CountDownLatch(1);</b>
<b class="nc">&nbsp;                timer.schedule(new TimerTask() {</b>
&nbsp;                    @Override
&nbsp;                    public void run() {
<b class="nc">&nbsp;                        timer.cancel();</b>
<b class="nc">&nbsp;                        latch.countDown();</b>
&nbsp;                    }
&nbsp;                }, 0);
<b class="nc">&nbsp;                if (latch.await(10, TimeUnit.SECONDS)) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.FINE, &quot;Triggers shut down successfully&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    timer.cancel();</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.INFO, &quot;Gave up waiting for triggers to finish running&quot;);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            Trigger.timer = null;</b>
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to shut down triggers&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to shut down triggers&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpShutdownTimer(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Shutting down timer&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            Timer.shutdown();</b>
<b class="nc">&nbsp;        } catch (SecurityException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;Not permitted to shut down Timer&quot;, e);</b>
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to shut down Timer&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to shut down Timer&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpShutdownTcpSlaveAgent(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        if (tcpSlaveAgentListener != null) {</b>
<b class="nc">&nbsp;            LOGGER.log(FINE, &quot;Shutting down TCP/IP agent listener&quot;);</b>
&nbsp;            try {
<b class="nc">&nbsp;                tcpSlaveAgentListener.shutdown();</b>
<b class="nc">&nbsp;            } catch (OutOfMemoryError e) {</b>
&nbsp;                // we should just propagate this, no point trying to log
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (LinkageError e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to shut down TCP/IP agent listener&quot;, e);</b>
&nbsp;                // safe to ignore and continue for this one
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to shut down TCP/IP agent listener&quot;, e);</b>
&nbsp;                // save for later
<b class="nc">&nbsp;                errors.add(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpShutdownPluginManager(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        if (pluginManager != null) { // be defensive. there could be some ugly timing related issues</b>
<b class="nc">&nbsp;            LOGGER.log(Main.isUnitTest ? Level.FINE : Level.INFO, &quot;Stopping plugin manager&quot;);</b>
&nbsp;            try {
<b class="nc">&nbsp;                pluginManager.stop();</b>
<b class="nc">&nbsp;            } catch (OutOfMemoryError e) {</b>
&nbsp;                // we should just propagate this, no point trying to log
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (LinkageError e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to stop plugin manager&quot;, e);</b>
&nbsp;                // safe to ignore and continue for this one
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to stop plugin manager&quot;, e);</b>
&nbsp;                // save for later
<b class="nc">&nbsp;                errors.add(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpPersistQueue(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        if (getRootDir().exists()) {</b>
&nbsp;            // if we are aborting because we failed to create JENKINS_HOME,
&nbsp;            // don&#39;t try to save. JENKINS-536
<b class="nc">&nbsp;            LOGGER.log(Main.isUnitTest ? Level.FINE : Level.INFO, &quot;Persisting build queue&quot;);</b>
&nbsp;            try {
<b class="nc">&nbsp;                getQueue().save();</b>
<b class="nc">&nbsp;            } catch (OutOfMemoryError e) {</b>
&nbsp;                // we should just propagate this, no point trying to log
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (LinkageError e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to persist build queue&quot;, e);</b>
&nbsp;                // safe to ignore and continue for this one
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(SEVERE, &quot;Failed to persist build queue&quot;, e);</b>
&nbsp;                // save for later
<b class="nc">&nbsp;                errors.add(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpShutdownThreadPoolForLoad(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(FINE, &quot;Shutting down Jenkins load thread pool&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            threadPoolForLoad.shutdown();</b>
<b class="nc">&nbsp;        } catch (SecurityException e) {</b>
<b class="nc">&nbsp;            LOGGER.log(WARNING, &quot;Not permitted to shut down Jenkins load thread pool&quot;, e);</b>
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to shut down Jenkins load thread pool&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to shut down Jenkins load thread pool&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpAwaitDisconnects(List&lt;Throwable&gt; errors, Set&lt;Future&lt;?&gt;&gt; pending) {
<b class="nc">&nbsp;        if (!pending.isEmpty()) {</b>
<b class="nc">&nbsp;            LOGGER.log(Main.isUnitTest ? Level.FINE : Level.INFO, &quot;Waiting for node disconnection completion&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Future&lt;?&gt; f : pending) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn&#39;t complete in time, we fail the test</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                break;  // someone wants us to die now. quick!</b>
<b class="nc">&nbsp;            } catch (ExecutionException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to shut down remote computer connection cleanly&quot;, e);</b>
<b class="nc">&nbsp;            } catch (TimeoutException e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to shut down remote computer connection within 10 seconds&quot;, e);</b>
<b class="nc">&nbsp;            } catch (OutOfMemoryError e) {</b>
&nbsp;                // we should just propagate this, no point trying to log
<b class="nc">&nbsp;                throw e;</b>
<b class="nc">&nbsp;            } catch (LinkageError e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.WARNING, &quot;Failed to shut down remote computer connection&quot;, e);</b>
<b class="nc">&nbsp;            } catch (Throwable e) {</b>
<b class="nc">&nbsp;                LOGGER.log(Level.SEVERE, &quot;Unexpected error while waiting for remote computer connection disconnect&quot;, e);</b>
<b class="nc">&nbsp;                errors.add(e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpPluginServletFilters(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Stopping filters&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            PluginServletFilter.cleanUp();</b>
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to stop filters&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to stop filters&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpReleaseAllLoggers(List&lt;Throwable&gt; errors) {
<b class="nc">&nbsp;        LOGGER.log(Level.FINE, &quot;Releasing all loggers&quot;);</b>
&nbsp;        try {
<b class="nc">&nbsp;            LogFactory.releaseAll();</b>
<b class="nc">&nbsp;        } catch (OutOfMemoryError e) {</b>
&nbsp;            // we should just propagate this, no point trying to log
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        } catch (LinkageError e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to release all loggers&quot;, e);</b>
&nbsp;            // safe to ignore and continue for this one
<b class="nc">&nbsp;        } catch (Throwable e) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to release all loggers&quot;, e);</b>
&nbsp;            // save for later
<b class="nc">&nbsp;            errors.add(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void _cleanUpCancelDependencyGraphCalculation() {
<b class="nc">&nbsp;        synchronized (dependencyGraphLock) {</b>
<b class="nc">&nbsp;            LOGGER.log(Level.FINE, &quot;Canceling internal dependency graph calculation&quot;);</b>
<b class="nc">&nbsp;            if (scheduledFutureDependencyGraph != null &amp;&amp; !scheduledFutureDependencyGraph.isDone()) {</b>
<b class="nc">&nbsp;                scheduledFutureDependencyGraph.cancel(true);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (calculatingFutureDependencyGraph != null &amp;&amp; !calculatingFutureDependencyGraph.isDone()) {</b>
<b class="nc">&nbsp;                calculatingFutureDependencyGraph.cancel(true);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Object getDynamic(String token) {
<b class="nc">&nbsp;        for (Action a : getActions()) {</b>
<b class="nc">&nbsp;            String url = a.getUrlName();</b>
<b class="nc">&nbsp;            if (url == null)  continue;</b>
<b class="nc">&nbsp;            if (url.equals(token) || url.equals(&#39;/&#39; + token))</b>
<b class="nc">&nbsp;                return a;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        for (Action a : getManagementLinks())</b>
<b class="nc">&nbsp;            if (Objects.equals(a.getUrlName(), token))</b>
<b class="nc">&nbsp;                return a;</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;//
&nbsp;//
&nbsp;// actions
&nbsp;//
&nbsp;//
&nbsp;    /**
&nbsp;     * Accepts submission from the configuration page.
&nbsp;     */
&nbsp;    @POST
&nbsp;    public synchronized void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;        try (BulkChange bc = new BulkChange(this)) {</b>
<b class="nc">&nbsp;            checkPermission(MANAGE);</b>
&nbsp;
<b class="nc">&nbsp;            JSONObject json = req.getSubmittedForm();</b>
&nbsp;
<b class="nc">&nbsp;            systemMessage = Util.nullify(req.getParameter(&quot;system_message&quot;));</b>
&nbsp;
<b class="nc">&nbsp;            boolean result = true;</b>
<b class="nc">&nbsp;            for (Descriptor&lt;?&gt; d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())</b>
<b class="nc">&nbsp;                result &amp;= configureDescriptor(req, json, d);</b>
&nbsp;
<b class="nc">&nbsp;            save();</b>
<b class="nc">&nbsp;            updateComputerList();</b>
<b class="nc">&nbsp;            if (result)</b>
<b class="nc">&nbsp;                FormApply.success(req.getContextPath() + &#39;/&#39;).generateResponse(req, rsp, null);</b>
&nbsp;            else
<b class="nc">&nbsp;                FormApply.success(&quot;configure&quot;).generateResponse(req, rsp, null);    // back to config</b>
&nbsp;
<b class="nc">&nbsp;            bc.commit();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link CrumbIssuer} currently in use.
&nbsp;     *
&nbsp;     * @return null if none is in use.
&nbsp;     */
&nbsp;    @CheckForNull
&nbsp;    public CrumbIssuer getCrumbIssuer() {
<b class="nc">&nbsp;        return GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION ? null : crumbIssuer;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setCrumbIssuer(CrumbIssuer issuer) {
<b class="nc">&nbsp;        crumbIssuer = issuer;</b>
&nbsp;    }
&nbsp;
&nbsp;    public synchronized void doTestPost(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        rsp.sendRedirect(&quot;foo&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor&lt;?&gt; d) throws FormException {
&nbsp;        // collapse the structure to remain backward compatible with the JSON structure before 1.
<b class="nc">&nbsp;        String name = d.getJsonSafeClassName();</b>
<b class="nc">&nbsp;        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn&#39;t have the property, the method returns invalid null object.</b>
<b class="nc">&nbsp;        json.putAll(js);</b>
<b class="nc">&nbsp;        return d.configure(req, js);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts submission from the node configuration page.
&nbsp;     */
&nbsp;    @POST
&nbsp;    public synchronized void doConfigExecutorsSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;        try (BulkChange bc = new BulkChange(this)) {</b>
<b class="nc">&nbsp;            JSONObject json = req.getSubmittedForm();</b>
&nbsp;
<b class="nc">&nbsp;            ExtensionList.lookupSingleton(MasterBuildConfiguration.class).configure(req, json);</b>
&nbsp;
<b class="nc">&nbsp;            getNodeProperties().rebuild(req, json.optJSONObject(&quot;nodeProperties&quot;), NodeProperty.all());</b>
&nbsp;
<b class="nc">&nbsp;            bc.commit();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        updateComputerList();</b>
&nbsp;
<b class="nc">&nbsp;        rsp.sendRedirect(req.getContextPath() + &#39;/&#39; + toComputer().getUrl());  // back to the computer page</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Accepts the new description.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized void doSubmitDescription(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        getPrimaryView().doSubmitDescription(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    public synchronized HttpRedirect doQuietDown() {
&nbsp;        try {
<b class="nc">&nbsp;            return doQuietDown(false, 0, null);</b>
<b class="nc">&nbsp;        } catch (IOException | InterruptedException e) {</b>
<b class="nc">&nbsp;            throw new AssertionError(e); // impossible</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Quiet down Jenkins - preparation for a restart
&nbsp;     * Presented for compatibility.
&nbsp;     *
&nbsp;     * @param block Block until the system really quiets down and no builds are running
&nbsp;     * @param timeout If non-zero, only block up to the specified number of milliseconds
&nbsp;     * @deprecated since 2.267; use {@link #doQuietDown(boolean, int, String, boolean)} instead.
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public synchronized HttpRedirect doQuietDown(boolean block, int timeout) {
&nbsp;        try {
<b class="nc">&nbsp;            return doQuietDown(block, timeout, null);</b>
<b class="nc">&nbsp;        } catch (IOException | InterruptedException e) {</b>
<b class="nc">&nbsp;            throw new AssertionError(e); // impossible</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Quiet down Jenkins - preparation for a restart
&nbsp;     *
&nbsp;     * @param block Block until the system really quiets down and no builds are running
&nbsp;     * @param timeout If non-zero, only block up to the specified number of milliseconds
&nbsp;     * @param message Quiet reason that will be visible to user
&nbsp;     * @deprecated use {@link #doQuietDown(boolean, int, String, boolean)} instead.
&nbsp;     */
&nbsp;    @Deprecated(since = &quot;2.414&quot;)
&nbsp;    public HttpRedirect doQuietDown(boolean block,
&nbsp;                                    int timeout,
&nbsp;                                    @CheckForNull String message) throws InterruptedException, IOException {
&nbsp;
<b class="nc">&nbsp;        return doQuietDown(block, timeout, message, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Quiet down Jenkins - preparation for a restart
&nbsp;     *
&nbsp;     * @param block Block until the system really quiets down and no builds are running
&nbsp;     * @param timeout If non-zero, only block up to the specified number of milliseconds
&nbsp;     * @param message Quiet reason that will be visible to user
&nbsp;     * @param safeRestart If the quietDown is for a safeRestart
&nbsp;     * @since 2.414
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public HttpRedirect doQuietDown(@QueryParameter boolean block,
&nbsp;                                    @QueryParameter int timeout,
&nbsp;                                    @QueryParameter @CheckForNull String message,
&nbsp;                                    @QueryParameter boolean safeRestart) throws InterruptedException, IOException {
<b class="nc">&nbsp;        synchronized (this) {</b>
<b class="nc">&nbsp;            checkPermission(MANAGE);</b>
<b class="nc">&nbsp;            quietDownInfo = new QuietDownInfo(message, safeRestart);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (block) {</b>
<b class="nc">&nbsp;            long waitUntil = timeout;</b>
<b class="nc">&nbsp;            if (timeout &gt; 0) waitUntil += System.currentTimeMillis();</b>
<b class="nc">&nbsp;            while (isQuietingDown()</b>
<b class="nc">&nbsp;                   &amp;&amp; (timeout &lt;= 0 || System.currentTimeMillis() &lt; waitUntil)</b>
<b class="nc">&nbsp;                   &amp;&amp; !RestartListener.isAllReady()) {</b>
<b class="nc">&nbsp;                TimeUnit.SECONDS.sleep(1);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new HttpRedirect(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Cancel previous quiet down Jenkins - preparation for a restart
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized HttpRedirect doCancelQuietDown() {
<b class="nc">&nbsp;        checkPermission(MANAGE);</b>
<b class="nc">&nbsp;        quietDownInfo = null;</b>
<b class="nc">&nbsp;        getQueue().scheduleMaintenance();</b>
<b class="nc">&nbsp;        return new HttpRedirect(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public HttpResponse doToggleCollapse() throws ServletException, IOException {
<b class="nc">&nbsp;        final StaplerRequest request = Stapler.getCurrentRequest();</b>
<b class="nc">&nbsp;        final String paneId = request.getParameter(&quot;paneId&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        PaneStatusProperties.forCurrentUser().toggleCollapsed(paneId);</b>
&nbsp;
<b class="nc">&nbsp;        return HttpResponses.forwardToPreviousPage();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Backward compatibility. Redirect to the thread dump.
&nbsp;     */
&nbsp;    // TODO annotate @GET once baseline includes Stapler version XXX
&nbsp;    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        rsp.sendRedirect2(&quot;threadDump&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains the thread dump of all agents (including the controller/built-in node.)
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Since this is for diagnostics, it has a built-in precautionary measure against hang agents.
&nbsp;     */
&nbsp;    public Map&lt;String, Map&lt;String, String&gt;&gt; getAllThreadDumps() throws IOException, InterruptedException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
&nbsp;
&nbsp;        // issue the requests all at once
<b class="nc">&nbsp;        Map&lt;String, Future&lt;Map&lt;String, String&gt;&gt;&gt; future = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        for (Computer c : getComputers()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.info(&quot;Failed to get thread dump for node &quot; + c.getName() + &quot;: &quot; + e.getMessage());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (toComputer() == null) {</b>
<b class="nc">&nbsp;            future.put(&quot;master&quot;, RemotingDiagnostics.getThreadDumpAsync(FilePath.localChannel)); // TODO(terminology) Built-in node? Controller? How is this used?</b>
&nbsp;        }
&nbsp;
&nbsp;        // if the result isn&#39;t available in 5 sec, ignore that.
&nbsp;        // this is a precaution against hang nodes
<b class="nc">&nbsp;        long endTime = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(5);</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;String, Map&lt;String, String&gt;&gt; r = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Map.Entry&lt;String, Future&lt;Map&lt;String, String&gt;&gt;&gt; e : future.entrySet()) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                r.put(e.getKey(), e.getValue().get(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS));</b>
<b class="nc">&nbsp;            } catch (Exception x) {</b>
<b class="nc">&nbsp;                r.put(e.getKey(), Map.of(&quot;Failed to retrieve thread dump&quot;, Functions.printThrowable(x)));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return Collections.unmodifiableSortedMap(new TreeMap&lt;&gt;(r));</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    @RequirePOST
&nbsp;    public synchronized TopLevelItem doCreateItem(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        return itemGroupMixIn.createTopLevelItem(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.319
&nbsp;     */
&nbsp;    @Override
&nbsp;    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {
<b class="nc">&nbsp;        return itemGroupMixIn.createProjectFromXML(name, xml);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    @Override
&nbsp;    public &lt;T extends TopLevelItem&gt; T copy(T src, String name) throws IOException {
<b class="nc">&nbsp;        return itemGroupMixIn.copy(src, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    // a little more convenient overloading that assumes the caller gives us the right type
&nbsp;    // (or else it will fail with ClassCastException)
&nbsp;    public &lt;T extends AbstractProject&lt;?, ?&gt;&gt; T copy(T src, String name) throws IOException {
<b class="nc">&nbsp;        return (T) copy((TopLevelItem) src, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    @POST
&nbsp;    public synchronized void doCreateView(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;        checkPermission(View.CREATE);</b>
<b class="nc">&nbsp;        addView(View.create(req, rsp, this));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if the given name is suitable as a name
&nbsp;     * for job, view, etc.
&nbsp;     *
&nbsp;     * @throws Failure
&nbsp;     *      if the given name is not good
&nbsp;     */
&nbsp;    public static void checkGoodName(String name) throws Failure {
<b class="fc">&nbsp;        if (name == null || name.isEmpty())</b>
<b class="nc">&nbsp;            throw new Failure(Messages.Hudson_NoName());</b>
&nbsp;
<b class="fc">&nbsp;        if (&quot;.&quot;.equals(name.trim()))</b>
<b class="nc">&nbsp;            throw new Failure(Messages.Jenkins_NotAllowedName(&quot;.&quot;));</b>
<b class="fc">&nbsp;        if (&quot;..&quot;.equals(name.trim()))</b>
<b class="nc">&nbsp;            throw new Failure(Messages.Jenkins_NotAllowedName(&quot;..&quot;));</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; name.length(); i++) {</b>
<b class="fc">&nbsp;            char ch = name.charAt(i);</b>
<b class="fc">&nbsp;            if (Character.isISOControl(ch)) {</b>
<b class="nc">&nbsp;                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));</b>
&nbsp;            }
<b class="fc">&nbsp;            if (&quot;?*/\\%!@#$^&amp;|&lt;&gt;[]:;&quot;.indexOf(ch) != -1)</b>
<b class="nc">&nbsp;                throw new Failure(Messages.Hudson_UnsafeChar(ch));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (SystemProperties.getBoolean(NAME_VALIDATION_REJECTS_TRAILING_DOT_PROP, true)) {</b>
&nbsp;            // SECURITY-2424 on Windows the trailing dot can be used to create ambiguity
<b class="fc">&nbsp;            if (name.trim().endsWith(&quot;.&quot;)) {</b>
<b class="fc">&nbsp;                throw new Failure(Messages.Hudson_TrailingDot());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // looks good
&nbsp;    }
&nbsp;
&nbsp;    private static String toPrintableName(String name) {
<b class="nc">&nbsp;        StringBuilder printableName = new StringBuilder();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; name.length(); i++) {</b>
<b class="nc">&nbsp;            char ch = name.charAt(i);</b>
<b class="nc">&nbsp;            if (Character.isISOControl(ch))</b>
<b class="nc">&nbsp;                printableName.append(&quot;\\u&quot;).append((int) ch).append(&#39;;&#39;);</b>
&nbsp;            else
<b class="nc">&nbsp;                printableName.append(ch);</b>
&nbsp;        }
<b class="nc">&nbsp;        return printableName.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the user was successfully authenticated.
&nbsp;     *
&nbsp;     * @see BasicAuthenticationFilter
&nbsp;     */
&nbsp;    public void doSecured(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
&nbsp;        // TODO fire something in SecurityListener? (seems to be used only for REST calls when LegacySecurityRealm is active)
&nbsp;
<b class="nc">&nbsp;        if (req.getUserPrincipal() == null) {</b>
&nbsp;            // authentication must have failed
<b class="nc">&nbsp;            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // the user is now authenticated, so send him back to the target
<b class="nc">&nbsp;        String path = req.getContextPath() + req.getOriginalRestOfPath();</b>
<b class="nc">&nbsp;        String q = req.getQueryString();</b>
<b class="nc">&nbsp;        if (q != null)</b>
<b class="nc">&nbsp;            path += &#39;?&#39; + q;</b>
&nbsp;
<b class="nc">&nbsp;        rsp.sendRedirect2(path);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called once the user logs in. Just forward to the top page.
&nbsp;     * Used only by {@link LegacySecurityRealm}.
&nbsp;     */
&nbsp;    public void doLoginEntry(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        if (req.getUserPrincipal() == null) {</b>
<b class="nc">&nbsp;            rsp.sendRedirect2(&quot;noPrincipal&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // TODO fire something in SecurityListener?
&nbsp;
<b class="nc">&nbsp;        String from = req.getParameter(&quot;from&quot;);</b>
<b class="nc">&nbsp;        if (from != null &amp;&amp; from.startsWith(&quot;/&quot;) &amp;&amp; !from.equals(&quot;/loginError&quot;)) {</b>
<b class="nc">&nbsp;            rsp.sendRedirect2(from);    // I&#39;m bit uncomfortable letting users redirected to other sites, make sure the URL falls into this domain</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        /* TODO unclear what the Spring Security equivalent is; check AbstractAuthenticationProcessingFilter, SavedRequest
&nbsp;        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);
&nbsp;        if (url!=null) {
&nbsp;            // if the login redirect is initiated by Acegi
&nbsp;            // this should send the user back to where s/he was from.
&nbsp;            rsp.sendRedirect2(url);
&nbsp;            return;
&nbsp;        }
&nbsp;        */
&nbsp;
<b class="nc">&nbsp;        rsp.sendRedirect2(&quot;.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Logs out the user.
&nbsp;     */
&nbsp;    public void doLogout(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        String user = getAuthentication2().getName();</b>
<b class="nc">&nbsp;        securityRealm.doLogout(req, rsp);</b>
<b class="nc">&nbsp;        SecurityListener.fireLoggedOut(user);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Serves jar files for inbound agents.
&nbsp;     */
&nbsp;    public Slave.JnlpJar getJnlpJars(String fileName) {
<b class="nc">&nbsp;        return new Slave.JnlpJar(fileName);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {
<b class="nc">&nbsp;        return new Slave.JnlpJar(req.getRestOfPath().substring(1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reloads the configuration.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public synchronized HttpResponse doReload() throws IOException {
<b class="nc">&nbsp;        checkPermission(MANAGE);</b>
<b class="nc">&nbsp;        getLifecycle().onReload(getAuthentication2().getName(), null);</b>
&nbsp;
&nbsp;        // engage &quot;loading ...&quot; UI and then run the actual task in a separate thread
<b class="nc">&nbsp;        WebApp.get(servletContext).setApp(new HudsonIsLoading());</b>
&nbsp;
<b class="nc">&nbsp;        new Thread(&quot;Jenkins config reload thread&quot;) {</b>
&nbsp;            @Override
&nbsp;            public void run() {
<b class="nc">&nbsp;                try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                    reload();</b>
<b class="nc">&nbsp;                    getLifecycle().onReady();</b>
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(SEVERE, &quot;Failed to reload Jenkins config&quot;, e);</b>
<b class="nc">&nbsp;                    new JenkinsReloadFailed(e).publish(servletContext, root);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }.start();</b>
&nbsp;
<b class="nc">&nbsp;        return HttpResponses.redirectViaContextPath(&quot;/&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reloads the configuration synchronously.
&nbsp;     * Beware that this calls neither {@link ItemListener#onLoaded} nor {@link Initializer}s.
&nbsp;     */
&nbsp;    public void reload() throws IOException, InterruptedException, ReactorException {
<b class="nc">&nbsp;        queue.save();</b>
<b class="nc">&nbsp;        executeReactor(null, loadTasks());</b>
&nbsp;
&nbsp;        // Ensure we reached the final initialization state. Log the error otherwise
<b class="nc">&nbsp;        if (initLevel != InitMilestone.COMPLETED) {</b>
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Jenkins initialization has not reached the COMPLETED initialization milestone after the configuration reload. &quot; +</b>
&nbsp;                            &quot;Current state: {0}. &quot; +
&nbsp;                            &quot;It may cause undefined incorrect behavior in Jenkins plugin relying on this state. &quot; +
&nbsp;                            &quot;It is likely an issue with the Initialization task graph. &quot; +
&nbsp;                            &quot;Example: usage of @Initializer(after = InitMilestone.COMPLETED) in a plugin (JENKINS-37759). &quot; +
&nbsp;                            &quot;Please create a bug in Jenkins bugtracker.&quot;,
&nbsp;                    initLevel);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        User.reload();</b>
<b class="nc">&nbsp;        queue.load();</b>
<b class="nc">&nbsp;        WebApp.get(servletContext).setApp(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Do a finger-print check.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doDoFingerprintCheck(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
&nbsp;        // Parse the request
<b class="nc">&nbsp;        try (MultipartFormDataParser p = new MultipartFormDataParser(req, 10)) {</b>
<b class="nc">&nbsp;            if (isUseCrumbs() &amp;&amp; !getCrumbIssuer().validateCrumb(req, p)) {</b>
&nbsp;                // TODO investigate whether this check can be removed
<b class="nc">&nbsp;                rsp.sendError(HttpServletResponse.SC_FORBIDDEN, &quot;No crumb found&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            rsp.sendRedirect2(req.getContextPath() + &quot;/fingerprint/&quot; +</b>
<b class="nc">&nbsp;                Util.getDigestOf(p.getFileItem(&quot;name&quot;).getInputStream()) + &#39;/&#39;);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For debugging. Expose URL to perform GC.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    @SuppressFBWarnings(value = &quot;DM_GC&quot;, justification = &quot;for debugging&quot;)
&nbsp;    public void doGc(StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        checkPermission(Jenkins.ADMINISTER);</b>
<b class="nc">&nbsp;        System.gc();</b>
<b class="nc">&nbsp;        rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/plain&quot;);</b>
<b class="nc">&nbsp;        rsp.getWriter().println(&quot;GCed&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * End point that intentionally throws an exception to test the error behaviour.
&nbsp;     * @since 1.467
&nbsp;     */
&nbsp;    @StaplerDispatchable
&nbsp;    public void doException() {
<b class="nc">&nbsp;        throw new RuntimeException();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {
<b class="nc">&nbsp;        ContextMenu menu = new ContextMenu().from(this, request, response);</b>
<b class="nc">&nbsp;        for (MenuItem i : menu.items) {</b>
<b class="nc">&nbsp;            if (i.url.equals(request.getContextPath() + &quot;/manage&quot;)) {</b>
&nbsp;                // add &quot;Manage Jenkins&quot; subitems
<b class="nc">&nbsp;                i.subMenu = new ContextMenu().from(ExtensionList.lookupSingleton(ManageJenkinsAction.class), request, response, &quot;index&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return menu;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {
<b class="nc">&nbsp;        ContextMenu menu = new ContextMenu();</b>
<b class="nc">&nbsp;        for (View view : getViews()) {</b>
<b class="nc">&nbsp;            menu.add(view.getViewUrl(), view.getDisplayName());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return menu;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtains the heap dump.
&nbsp;     */
&nbsp;    public HeapDump getHeapDump() throws IOException {
<b class="nc">&nbsp;        return new HeapDump(this, FilePath.localChannel);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Simulates OutOfMemoryError.
&nbsp;     * Useful to make sure OutOfMemoryHeapDump setting.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;MismatchedQueryAndUpdateOfCollection&quot;)
&nbsp;    @RequirePOST
&nbsp;    public void doSimulateOutOfMemory() throws IOException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;        System.out.println(&quot;Creating artificial OutOfMemoryError situation&quot;);</b>
<b class="nc">&nbsp;        List&lt;Object&gt; args = new ArrayList&lt;&gt;();</b>
&nbsp;        //noinspection InfiniteLoopStatement
&nbsp;        while (true)
<b class="nc">&nbsp;            args.add(new byte[1024 * 1024]);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Binds /userContent/... to $JENKINS_HOME/userContent.
&nbsp;     */
&nbsp;    public DirectoryBrowserSupport doUserContent() {
<b class="nc">&nbsp;        return new DirectoryBrowserSupport(this, getRootPath().child(&quot;userContent&quot;), &quot;User content&quot;, &quot;folder.png&quot;, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Perform a restart of Jenkins, if we can.
&nbsp;     *
&nbsp;     * This first replaces &quot;app&quot; to {@link HudsonIsRestarting}
&nbsp;     */
&nbsp;    @CLIMethod(name = &quot;restart&quot;)
&nbsp;    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {
<b class="nc">&nbsp;        checkPermission(MANAGE);</b>
<b class="nc">&nbsp;        if (req != null &amp;&amp; req.getMethod().equals(&quot;GET&quot;)) {</b>
<b class="nc">&nbsp;            req.getView(this, &quot;_restart.jelly&quot;).forward(req, rsp);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (req == null || req.getMethod().equals(&quot;POST&quot;)) {</b>
<b class="nc">&nbsp;            restart();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (rsp != null) {</b>
<b class="nc">&nbsp;            rsp.sendRedirect2(&quot;.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Serve a custom 404 error page, configured in web.xml.
&nbsp;     */
&nbsp;    @WebMethod(name = &quot;404&quot;)
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public void generateNotFoundResponse(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {
<b class="nc">&nbsp;        if (ResourceDomainConfiguration.isResourceRequest(req)) {</b>
<b class="nc">&nbsp;            rsp.forward(this, &quot;_404_simple&quot;, req);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            final Object attribute = req.getAttribute(ErrorAttributeFilter.USER_ATTRIBUTE);</b>
<b class="nc">&nbsp;            if (attribute instanceof Authentication) {</b>
<b class="nc">&nbsp;                try (ACLContext unused = ACL.as2((Authentication) attribute)) {</b>
<b class="nc">&nbsp;                    rsp.forward(this, &quot;_404&quot;, req);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="nc">&nbsp;                rsp.forward(this, &quot;_404&quot;, req);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Queues up a safe restart of Jenkins.
&nbsp;     * Builds that cannot continue while the controller is not running have to finish or pause before it can proceed.
&nbsp;     * No new builds will be started. No new jobs are accepted.
&nbsp;     *
&nbsp;     * @deprecated use {@link #doSafeRestart(StaplerRequest, String)} instead.
&nbsp;     *
&nbsp;     */
&nbsp;    @Deprecated(since = &quot;2.414&quot;)
&nbsp;    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {
<b class="nc">&nbsp;        return doSafeRestart(req, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Queues up a safe restart of Jenkins. Jobs have to finish or pause before it can proceed. No new jobs are accepted.
&nbsp;     *
&nbsp;     * @since 2.414
&nbsp;     */
&nbsp;    public HttpResponse doSafeRestart(StaplerRequest req, @QueryParameter(&quot;message&quot;) String message) throws IOException, ServletException, RestartNotSupportedException {
<b class="nc">&nbsp;        checkPermission(MANAGE);</b>
<b class="nc">&nbsp;        if (req != null &amp;&amp; req.getMethod().equals(&quot;GET&quot;)) {</b>
<b class="nc">&nbsp;            return HttpResponses.forwardToView(this, &quot;_safeRestart.jelly&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (req != null &amp;&amp; req.getParameter(&quot;cancel&quot;) != null) {</b>
<b class="nc">&nbsp;            return doCancelQuietDown();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (req == null || req.getMethod().equals(&quot;POST&quot;)) {</b>
<b class="nc">&nbsp;            safeRestart(message);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return HttpResponses.redirectToDot();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static Lifecycle restartableLifecycle() throws RestartNotSupportedException {
<b class="nc">&nbsp;        if (Main.isUnitTest) {</b>
<b class="nc">&nbsp;            throw new RestartNotSupportedException(&quot;Restarting the controller JVM is not supported in JenkinsRule-based tests&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        Lifecycle lifecycle = Lifecycle.get();</b>
<b class="nc">&nbsp;        lifecycle.verifyRestartable();</b>
<b class="nc">&nbsp;        return lifecycle;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs a restart.
&nbsp;     */
&nbsp;    public void restart() throws RestartNotSupportedException {
<b class="nc">&nbsp;        final Lifecycle lifecycle = restartableLifecycle();</b>
<b class="nc">&nbsp;        servletContext.setAttribute(&quot;app&quot;, new HudsonIsRestarting());</b>
&nbsp;
<b class="nc">&nbsp;        new Thread(&quot;restart thread&quot;) {</b>
<b class="nc">&nbsp;            final String exitUser = getAuthentication2().getName();</b>
&nbsp;            @Override
&nbsp;            public void run() {
<b class="nc">&nbsp;                try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
&nbsp;                    // give some time for the browser to load the &quot;reloading&quot; page
<b class="nc">&nbsp;                    lifecycle.onStatusUpdate(&quot;Restart in 5 seconds&quot;);</b>
<b class="nc">&nbsp;                    Thread.sleep(TimeUnit.SECONDS.toMillis(5));</b>
<b class="nc">&nbsp;                    lifecycle.onStop(exitUser, null);</b>
<b class="nc">&nbsp;                    Listeners.notify(RestartListener.class, true, RestartListener::onRestart);</b>
<b class="nc">&nbsp;                    lifecycle.restart();</b>
<b class="nc">&nbsp;                } catch (InterruptedException | InterruptedIOException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Interrupted while trying to restart Jenkins&quot;, e);</b>
<b class="nc">&nbsp;                    Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to restart Jenkins&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }.start();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Queues up a restart to be performed once there are no builds currently running.
&nbsp;     * @since 1.332
&nbsp;     * @deprecated use {@link #safeRestart(String)} instead.
&nbsp;     */
&nbsp;    @Deprecated(since = &quot;2.414&quot;)
&nbsp;    public void safeRestart() throws RestartNotSupportedException {
<b class="nc">&nbsp;        safeRestart(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Queues up a restart to be performed once there are no builds currently running.
&nbsp;     * @param message the message to show to users in the shutdown banner.
&nbsp;     * @since 2.414
&nbsp;     */
&nbsp;    public void safeRestart(String message) throws RestartNotSupportedException {
<b class="nc">&nbsp;        final Lifecycle lifecycle = restartableLifecycle();</b>
&nbsp;        // Quiet down so that we won&#39;t launch new builds.
<b class="nc">&nbsp;        quietDownInfo = new QuietDownInfo(message, true);</b>
&nbsp;
<b class="nc">&nbsp;        new Thread(&quot;safe-restart thread&quot;) {</b>
<b class="nc">&nbsp;            final String exitUser = getAuthentication2().getName();</b>
&nbsp;            @Override
&nbsp;            public void run() {
<b class="nc">&nbsp;                try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
&nbsp;
&nbsp;                    // Wait &#39;til we have no active executors.
<b class="nc">&nbsp;                    doQuietDown(true, 0, message, true);</b>
&nbsp;                    // Make sure isQuietingDown is still true.
<b class="nc">&nbsp;                    if (isQuietingDown()) {</b>
<b class="nc">&nbsp;                        servletContext.setAttribute(&quot;app&quot;, new HudsonIsRestarting(true));</b>
&nbsp;                        // give some time for the browser to load the &quot;reloading&quot; page
<b class="nc">&nbsp;                        lifecycle.onStatusUpdate(&quot;Restart in 10 seconds&quot;);</b>
<b class="nc">&nbsp;                        Thread.sleep(TimeUnit.SECONDS.toMillis(10));</b>
<b class="nc">&nbsp;                        lifecycle.onStop(exitUser, null);</b>
<b class="nc">&nbsp;                        Listeners.notify(RestartListener.class, true, RestartListener::onRestart);</b>
<b class="nc">&nbsp;                        lifecycle.restart();</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        lifecycle.onStatusUpdate(&quot;Safe-restart mode cancelled&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Throwable e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to restart Jenkins&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }.start();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Extension @Restricted(NoExternalUse.class)
<b class="nc">&nbsp;    public static class MasterRestartNotifyier extends RestartListener {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void onRestart() {
<b class="nc">&nbsp;            Computer computer = Jenkins.get().toComputer();</b>
<b class="nc">&nbsp;            if (computer == null) return;</b>
<b class="nc">&nbsp;            RestartCause cause = new RestartCause();</b>
<b class="nc">&nbsp;            Listeners.notify(ComputerListener.class, true, l -&gt; l.onOffline(computer, cause));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isReadyToRestart() throws IOException, InterruptedException {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static class RestartCause extends OfflineCause.SimpleOfflineCause {
&nbsp;            protected RestartCause() {
<b class="nc">&nbsp;                super(Messages._Jenkins_IsRestarting());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shutdown the system.
&nbsp;     * @since 1.161
&nbsp;     */
&nbsp;    @CLIMethod(name = &quot;shutdown&quot;)
&nbsp;    @RequirePOST
&nbsp;    public void doExit(StaplerRequest req, StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
<b class="nc">&nbsp;        final String exitUser = getAuthentication2().getName();</b>
<b class="nc">&nbsp;        final String exitAddr = req != null ? req.getRemoteAddr() : null;</b>
<b class="nc">&nbsp;        if (rsp != null) {</b>
<b class="nc">&nbsp;            rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;            rsp.setContentType(&quot;text/plain&quot;);</b>
<b class="nc">&nbsp;            try (PrintWriter w = rsp.getWriter()) {</b>
<b class="nc">&nbsp;                w.println(&quot;Shutting down&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        new Thread(&quot;exit thread&quot;) {</b>
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;DM_EXIT&quot;, justification = &quot;Exit is really intended.&quot;)
&nbsp;            public void run() {
<b class="nc">&nbsp;                try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                    getLifecycle().onStop(exitUser, exitAddr);</b>
&nbsp;
<b class="nc">&nbsp;                    cleanUp();</b>
<b class="nc">&nbsp;                    System.exit(0);</b>
<b class="nc">&nbsp;                } catch (Throwable e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to shut down Jenkins&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }.start();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shutdown the system safely.
&nbsp;     * @since 1.332
&nbsp;     */
&nbsp;    @CLIMethod(name = &quot;safe-shutdown&quot;)
&nbsp;    @RequirePOST
&nbsp;    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
<b class="nc">&nbsp;        quietDownInfo = new QuietDownInfo();</b>
<b class="nc">&nbsp;        final String exitUser = getAuthentication2().getName();</b>
<b class="nc">&nbsp;        final String exitAddr = req != null ? req.getRemoteAddr() : null;</b>
<b class="nc">&nbsp;        new Thread(&quot;safe-exit thread&quot;) {</b>
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;DM_EXIT&quot;, justification = &quot;Exit is really intended.&quot;)
&nbsp;            public void run() {
<b class="nc">&nbsp;                try (ACLContext ctx = ACL.as2(ACL.SYSTEM2)) {</b>
<b class="nc">&nbsp;                    getLifecycle().onStop(exitUser, exitAddr);</b>
&nbsp;                    // Wait &#39;til we have no active executors.
<b class="nc">&nbsp;                    doQuietDown(true, 0, null);</b>
&nbsp;                    // Make sure isQuietingDown is still true.
<b class="nc">&nbsp;                    if (isQuietingDown()) {</b>
<b class="nc">&nbsp;                        cleanUp();</b>
<b class="nc">&nbsp;                        System.exit(0);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    LOGGER.log(Level.WARNING, &quot;Failed to shut down Jenkins&quot;, e);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }.start();</b>
&nbsp;
<b class="nc">&nbsp;        return HttpResponses.plainText(&quot;Shutting down as soon as all jobs are complete&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Authentication} object that represents the user
&nbsp;     * associated with the current request.
&nbsp;     * @since 2.266
&nbsp;     */
&nbsp;    public static @NonNull Authentication getAuthentication2() {
<b class="fc">&nbsp;        Authentication a = SecurityContextHolder.getContext().getAuthentication();</b>
&nbsp;        // on Tomcat while serving the login page, this is null despite the fact
&nbsp;        // that we have filters. Looking at the stack trace, Tomcat doesn&#39;t seem to
&nbsp;        // run the request through filters when this is the login request.
&nbsp;        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html
<b class="fc">&nbsp;        if (a == null)</b>
<b class="fc">&nbsp;            a = ANONYMOUS2;</b>
<b class="fc">&nbsp;        return a;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated use {@link #getAuthentication2}
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public static @NonNull org.acegisecurity.Authentication getAuthentication() {
<b class="fc">&nbsp;        return org.acegisecurity.Authentication.fromSpring(getAuthentication2());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * For system diagnostics.
&nbsp;     * Run arbitrary Groovy script.
&nbsp;     */
&nbsp;    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        _doScript(req, rsp, req.getView(this, &quot;_script.jelly&quot;), FilePath.localChannel, getACL());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Run arbitrary Groovy script and return result as plain text.
&nbsp;     */
&nbsp;    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        _doScript(req, rsp, req.getView(this, &quot;_scriptText.jelly&quot;), FilePath.localChannel, getACL());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @since 1.509.1
&nbsp;     */
&nbsp;    public static void _doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view, VirtualChannel channel, ACL acl) throws IOException, ServletException {
&nbsp;        // ability to run arbitrary script is dangerous
<b class="nc">&nbsp;        acl.checkPermission(ADMINISTER);</b>
&nbsp;
<b class="nc">&nbsp;        String text = req.getParameter(&quot;script&quot;);</b>
<b class="nc">&nbsp;        if (text != null) {</b>
<b class="nc">&nbsp;            if (!&quot;POST&quot;.equals(req.getMethod())) {</b>
<b class="nc">&nbsp;                throw HttpResponses.error(HttpURLConnection.HTTP_BAD_METHOD, &quot;requires POST&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (channel == null) {</b>
<b class="nc">&nbsp;                throw HttpResponses.error(HttpURLConnection.HTTP_NOT_FOUND, &quot;Node is offline&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            try {
<b class="nc">&nbsp;                req.setAttribute(&quot;output&quot;,</b>
<b class="nc">&nbsp;                        RemotingDiagnostics.executeGroovy(text, channel));</b>
<b class="nc">&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;                Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                throw new ServletException(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        view.forward(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Evaluates the Jelly script submitted by the client.
&nbsp;     *
&nbsp;     * This is useful for system administration as well as unit testing.
&nbsp;     */
&nbsp;    @RequirePOST
&nbsp;    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
<b class="nc">&nbsp;        req.getWebApp().getDispatchValidator().allowDispatch(req, rsp);</b>
&nbsp;        try {
<b class="nc">&nbsp;            MetaClass mc = req.getWebApp().getMetaClass(getClass());</b>
<b class="nc">&nbsp;            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));</b>
<b class="nc">&nbsp;            new JellyRequestDispatcher(this, script).forward(req, rsp);</b>
<b class="nc">&nbsp;        } catch (JellyException e) {</b>
<b class="nc">&nbsp;            throw new ServletException(e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sign up for the user account.
&nbsp;     */
&nbsp;    public void doSignup(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        if (getSecurityRealm().allowsSignup()) {</b>
<b class="nc">&nbsp;            req.getView(getSecurityRealm(), &quot;signup.jelly&quot;).forward(req, rsp);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        req.getView(SecurityRealm.class, &quot;signup.jelly&quot;).forward(req, rsp);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Changes the icon size by changing the cookie
&nbsp;     */
&nbsp;    public void doIconSize(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        String qs = req.getQueryString();</b>
<b class="nc">&nbsp;        if (qs == null)</b>
<b class="nc">&nbsp;            throw new ServletException();</b>
<b class="nc">&nbsp;        Cookie cookie = new Cookie(&quot;iconSize&quot;, Functions.validateIconSize(qs));</b>
<b class="nc">&nbsp;        cookie.setMaxAge(/* ~4 mo. */9999999); // JENKINS-762</b>
<b class="nc">&nbsp;        cookie.setSecure(req.isSecure());</b>
<b class="nc">&nbsp;        cookie.setHttpOnly(true);</b>
<b class="nc">&nbsp;        rsp.addCookie(cookie);</b>
<b class="nc">&nbsp;        String ref = req.getHeader(&quot;Referer&quot;);</b>
<b class="nc">&nbsp;        if (ref == null)   ref = &quot;.&quot;;</b>
<b class="nc">&nbsp;        rsp.sendRedirect2(ref);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
<b class="nc">&nbsp;        FingerprintCleanupThread.invoke();</b>
<b class="nc">&nbsp;        rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/plain&quot;);</b>
<b class="nc">&nbsp;        rsp.getWriter().println(&quot;Invoked&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @RequirePOST
&nbsp;    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {
<b class="nc">&nbsp;        checkPermission(ADMINISTER);</b>
<b class="nc">&nbsp;        WorkspaceCleanupThread.invoke();</b>
<b class="nc">&nbsp;        rsp.setStatus(HttpServletResponse.SC_OK);</b>
<b class="nc">&nbsp;        rsp.setContentType(&quot;text/plain&quot;);</b>
<b class="nc">&nbsp;        rsp.getWriter().println(&quot;Invoked&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If the user chose the default JDK, make sure we got &#39;java&#39; in PATH.
&nbsp;     */
&nbsp;    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {
<b class="nc">&nbsp;        if (!JDK.isDefaultName(value))</b>
&nbsp;            // assume the user configured named ones properly in system config ---
&nbsp;            // or else system config should have reported form field validation errors.
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;
&nbsp;        // default JDK selected. Does such java really exist?
<b class="nc">&nbsp;        if (JDK.isDefaultJDKValid(Jenkins.this))</b>
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        else
<b class="nc">&nbsp;            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a top-level view with the given name exists and
&nbsp;     * make sure that the name is good as a view name.
&nbsp;     */
&nbsp;    public FormValidation doCheckViewName(@QueryParameter String value) {
<b class="nc">&nbsp;        checkPermission(View.CREATE);</b>
&nbsp;
<b class="nc">&nbsp;        String name = fixEmpty(value);</b>
<b class="nc">&nbsp;        if (name == null)</b>
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;
&nbsp;        // already exists?
<b class="nc">&nbsp;        if (getView(name) != null)</b>
<b class="nc">&nbsp;            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(name));</b>
&nbsp;
&nbsp;        // good view name?
&nbsp;        try {
<b class="nc">&nbsp;            checkGoodName(name);</b>
<b class="nc">&nbsp;        } catch (Failure e) {</b>
<b class="nc">&nbsp;            return FormValidation.error(e.getMessage());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return FormValidation.ok();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a top-level view with the given name exists.
&nbsp;     * @deprecated 1.512
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public FormValidation doViewExistsCheck(@QueryParameter String value) {
<b class="nc">&nbsp;        checkPermission(View.CREATE);</b>
&nbsp;
<b class="nc">&nbsp;        String view = fixEmpty(value);</b>
<b class="nc">&nbsp;        if (view == null) return FormValidation.ok();</b>
&nbsp;
<b class="nc">&nbsp;        if (getView(view) == null)</b>
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        else
<b class="nc">&nbsp;            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Serves static resources placed along with Jelly view files.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method can serve a lot of files, so care needs to be taken
&nbsp;     * to make this method secure. It&#39;s not clear to me what&#39;s the best
&nbsp;     * strategy here, though the current implementation is based on
&nbsp;     * file extensions.
&nbsp;     */
&nbsp;    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;        String path = req.getRestOfPath();</b>
&nbsp;        // cut off the &quot;...&quot; portion of /resources/.../path/to/file
&nbsp;        // as this is only used to make path unique (which in turn
&nbsp;        // allows us to set a long expiration date
<b class="nc">&nbsp;        path = path.substring(path.indexOf(&#39;/&#39;, 1) + 1);</b>
&nbsp;
<b class="nc">&nbsp;        int idx = path.lastIndexOf(&#39;.&#39;);</b>
<b class="nc">&nbsp;        String extension = path.substring(idx + 1);</b>
<b class="nc">&nbsp;        if (ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {</b>
<b class="nc">&nbsp;            URL url = pluginManager.uberClassLoader.getResource(path);</b>
<b class="nc">&nbsp;            if (url != null) {</b>
<b class="nc">&nbsp;                long expires = MetaClass.NO_CACHE ? 0 : TimeUnit.DAYS.toMillis(365);</b>
<b class="nc">&nbsp;                rsp.serveFile(req, url, expires);</b>
&nbsp;                return;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.
&nbsp;     * This set is mutable to allow plugins to add additional extensions.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_MUTABLE_COLLECTION_PKGPROTECT&quot;, justification = &quot;mutable to allow plugins to add additional extensions&quot;)
<b class="fc">&nbsp;    public static final Set&lt;String&gt; ALLOWED_RESOURCE_EXTENSIONS = new HashSet&lt;&gt;(Arrays.asList(</b>
<b class="fc">&nbsp;            &quot;js|css|jpeg|jpg|png|gif|html|htm&quot;.split(&quot;\\|&quot;)</b>
&nbsp;    ));
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if container uses UTF-8 to decode URLs. See
&nbsp;     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n
&nbsp;     * @deprecated use {@link URICheckEncodingMonitor#doCheckURIEncoding(StaplerRequest)}
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @RestrictedSince(&quot;2.37&quot;)
&nbsp;    @Deprecated
&nbsp;    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {
<b class="nc">&nbsp;        return ExtensionList.lookupSingleton(URICheckEncodingMonitor.class).doCheckURIEncoding(request);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Does not check when system default encoding is &quot;ISO-8859-1&quot;.
&nbsp;     * @deprecated use {@link URICheckEncodingMonitor#isCheckEnabled()}
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @RestrictedSince(&quot;2.37&quot;)
&nbsp;    @Deprecated
&nbsp;    public static boolean isCheckURIEncodingEnabled() {
<b class="nc">&nbsp;        return ExtensionList.lookupSingleton(URICheckEncodingMonitor.class).isCheckEnabled();</b>
&nbsp;    }
&nbsp;
&nbsp;    public Future&lt;DependencyGraph&gt; getFutureDependencyGraph() {
<b class="nc">&nbsp;        synchronized (dependencyGraphLock) {</b>
&nbsp;            // Scheduled future will be the most recent one --&gt; Return
<b class="nc">&nbsp;            if (scheduledFutureDependencyGraph != null) {</b>
<b class="nc">&nbsp;                return scheduledFutureDependencyGraph;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Calculating future will be the most recent one --&gt; Return
<b class="nc">&nbsp;            if (calculatingFutureDependencyGraph != null) {</b>
<b class="nc">&nbsp;                return calculatingFutureDependencyGraph;</b>
&nbsp;            }
&nbsp;
&nbsp;            // No scheduled or calculating future --&gt; Already completed dependency graph is the most recent one
<b class="nc">&nbsp;            return CompletableFuture.completedFuture(dependencyGraph);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebuilds the dependency map.
&nbsp;     */
&nbsp;    public void rebuildDependencyGraph() {
<b class="nc">&nbsp;        DependencyGraph graph = new DependencyGraph();</b>
<b class="nc">&nbsp;        graph.build();</b>
&nbsp;        // volatile acts a as a memory barrier here and therefore guarantees
&nbsp;        // that graph is fully build, before it&#39;s visible to other threads
<b class="nc">&nbsp;        dependencyGraph = graph;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebuilds the dependency map asynchronously.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * This would keep the UI thread more responsive and helps avoid the deadlocks,
&nbsp;     * as dependency graph recomputation tends to touch a lot of other things.
&nbsp;     *
&nbsp;     * @since 1.522
&nbsp;     */
&nbsp;    public Future&lt;DependencyGraph&gt; rebuildDependencyGraphAsync() {
<b class="nc">&nbsp;        synchronized (dependencyGraphLock) {</b>
&nbsp;            // Collect calls to this method to avoid unnecessary calculation of the dependency graph
<b class="nc">&nbsp;            if (scheduledFutureDependencyGraph != null) {</b>
<b class="nc">&nbsp;                return scheduledFutureDependencyGraph;</b>
&nbsp;            }
&nbsp;            // Schedule new calculation
<b class="nc">&nbsp;            return scheduledFutureDependencyGraph = scheduleCalculationOfFutureDependencyGraph(500, TimeUnit.MILLISECONDS);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private Future&lt;DependencyGraph&gt; scheduleCalculationOfFutureDependencyGraph(int delay, TimeUnit unit) {
<b class="nc">&nbsp;        return Timer.get().schedule(() -&gt; {</b>
&nbsp;            // Wait for the currently running calculation to finish without blocking rebuildDependencyGraphAsync()
<b class="nc">&nbsp;            Future&lt;DependencyGraph&gt; temp = null;</b>
<b class="nc">&nbsp;            synchronized (dependencyGraphLock) {</b>
<b class="nc">&nbsp;                if (calculatingFutureDependencyGraph != null) {</b>
<b class="nc">&nbsp;                    temp = calculatingFutureDependencyGraph;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (temp != null) {</b>
<b class="nc">&nbsp;                temp.get();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            synchronized (dependencyGraphLock) {</b>
&nbsp;                // Scheduled future becomes the currently calculating future
<b class="nc">&nbsp;                calculatingFutureDependencyGraph = scheduledFutureDependencyGraph;</b>
<b class="nc">&nbsp;                scheduledFutureDependencyGraph = null;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            rebuildDependencyGraph();</b>
&nbsp;
<b class="nc">&nbsp;            synchronized (dependencyGraphLock) {</b>
<b class="nc">&nbsp;                calculatingFutureDependencyGraph = null;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return dependencyGraph;</b>
&nbsp;        }, delay, unit);
&nbsp;    }
&nbsp;
&nbsp;    public DependencyGraph getDependencyGraph() {
<b class="nc">&nbsp;        return dependencyGraph;</b>
&nbsp;    }
&nbsp;
&nbsp;    // for Jelly
&nbsp;    public List&lt;ManagementLink&gt; getManagementLinks() {
<b class="nc">&nbsp;        return ManagementLink.all();</b>
&nbsp;    }
&nbsp;
&nbsp;    // for Jelly
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public Map&lt;ManagementLink.Category, List&lt;ManagementLink&gt;&gt; getCategorizedManagementLinks() {
<b class="nc">&nbsp;        Map&lt;ManagementLink.Category, List&lt;ManagementLink&gt;&gt; byCategory = new TreeMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (ManagementLink link : ManagementLink.all()) {</b>
<b class="nc">&nbsp;            if (link.getIconFileName() == null) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!Jenkins.get().hasPermission(link.getRequiredPermission())) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            byCategory.computeIfAbsent(link.getCategory(), c -&gt; new ArrayList&lt;&gt;()).add(link);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return byCategory;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * If set, a currently active setup wizard - e.g. installation
&nbsp;     *
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public SetupWizard getSetupWizard() {
<b class="nc">&nbsp;        return setupWizard;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exposes the current user to {@code /me} URL.
&nbsp;     */
&nbsp;    public User getMe() {
<b class="nc">&nbsp;        User u = User.current();</b>
<b class="nc">&nbsp;        if (u == null)</b>
<b class="nc">&nbsp;            throw new AccessDeniedException(&quot;/me is not available when not logged in&quot;);</b>
<b class="nc">&nbsp;        return u;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the {@link Widget}s registered on this object.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Plugins who wish to contribute boxes on the side panel can add widgets
&nbsp;     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.
&nbsp;     */
&nbsp;    @StaplerDispatchable // some plugins use this to add views to widgets
&nbsp;    public List&lt;Widget&gt; getWidgets() {
<b class="nc">&nbsp;        return widgets;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Object getTarget() {
&nbsp;        try {
<b class="nc">&nbsp;            checkPermission(READ);</b>
<b class="nc">&nbsp;        } catch (AccessDeniedException e) {</b>
<b class="nc">&nbsp;            if (!isSubjectToMandatoryReadPermissionCheck(Stapler.getCurrentRequest().getRestOfPath())) {</b>
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            throw e;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Test a path to see if it is subject to mandatory read permission checks by container-managed security
&nbsp;     * @param restOfPath the URI, excluding the Jenkins root URI and query string
&nbsp;     * @return true if the path is subject to mandatory read permission checks
&nbsp;     * @since 2.37
&nbsp;     */
&nbsp;    public boolean isSubjectToMandatoryReadPermissionCheck(String restOfPath) {
<b class="nc">&nbsp;        for (String name : ALWAYS_READABLE_PATHS) {</b>
<b class="nc">&nbsp;            if (restOfPath.startsWith(&quot;/&quot; + name + &quot;/&quot;) || restOfPath.equals(&quot;/&quot; + name)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        for (String name : getUnprotectedRootActions()) {</b>
<b class="nc">&nbsp;            if (restOfPath.startsWith(&quot;/&quot; + name + &quot;/&quot;) || restOfPath.equals(&quot;/&quot; + name)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        // TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access
<b class="nc">&nbsp;        if ((isAgentJnlpPath(restOfPath, &quot;jenkins&quot;) || isAgentJnlpPath(restOfPath, &quot;slave&quot;))</b>
<b class="nc">&nbsp;            &amp;&amp; &quot;true&quot;.equals(Stapler.getCurrentRequest().getParameter(&quot;encrypt&quot;))) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isAgentJnlpPath(String restOfPath, String prefix) {
<b class="nc">&nbsp;        return restOfPath.matches(&quot;(/manage)?/computer/[^/]+/&quot; + prefix + &quot;-agent[.]jnlp&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets a list of unprotected root actions.
&nbsp;     * These URL prefixes should be exempted from access control checks by container-managed security.
&nbsp;     * Ideally would be synchronized with {@link #getTarget}.
&nbsp;     * @return a list of {@linkplain Action#getUrlName URL names}
&nbsp;     * @since 1.495
&nbsp;     */
&nbsp;    public Collection&lt;String&gt; getUnprotectedRootActions() {
<b class="nc">&nbsp;        Set&lt;String&gt; names = new TreeSet&lt;&gt;();</b>
<b class="nc">&nbsp;        names.add(&quot;jnlpJars&quot;); // TODO cleaner to refactor doJnlpJars into a URA (see also JENKINS-44100)</b>
&nbsp;        // TODO consider caching (expiring cache when actions changes)
<b class="nc">&nbsp;        for (Action a : getActions()) {</b>
<b class="nc">&nbsp;            if (a instanceof UnprotectedRootAction) {</b>
<b class="nc">&nbsp;                String url = a.getUrlName();</b>
<b class="nc">&nbsp;                if (url == null) continue;</b>
<b class="nc">&nbsp;                names.add(url);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return names;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Fallback to the primary view.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public View getStaplerFallback() {
<b class="nc">&nbsp;        return getPrimaryView();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method checks all existing jobs to see if displayName is
&nbsp;     * unique. It does not check the displayName against the displayName of the
&nbsp;     * job that the user is configuring though to prevent a validation warning
&nbsp;     * if the user sets the displayName to what it currently is.
&nbsp;     */
&nbsp;    boolean isDisplayNameUnique(String displayName, String currentJobName) {
<b class="nc">&nbsp;        Collection&lt;TopLevelItem&gt; itemCollection = items.values();</b>
&nbsp;
&nbsp;        // if there are a lot of projects, we&#39;ll have to store their
&nbsp;        // display names in a HashSet or something for a quick check
<b class="nc">&nbsp;        for (TopLevelItem item : itemCollection) {</b>
<b class="nc">&nbsp;            if (item.getName().equals(currentJobName)) {</b>
&nbsp;                // we won&#39;t compare the candidate displayName against the current
&nbsp;                // item. This is to prevent an validation warning if the user
&nbsp;                // sets the displayName to what the existing display name is
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="nc">&nbsp;            else if (displayName.equals(item.getDisplayName())) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * True if there is no item in Jenkins that has this name
&nbsp;     * @param name The name to test
&nbsp;     * @param currentJobName The name of the job that the user is configuring
&nbsp;     */
&nbsp;    boolean isNameUnique(String name, String currentJobName) {
<b class="nc">&nbsp;        Item item = getItem(name);</b>
&nbsp;
<b class="nc">&nbsp;        if (null == item) {</b>
&nbsp;            // the candidate name didn&#39;t return any items so the name is unique
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        else if (item.getName().equals(currentJobName)) {</b>
&nbsp;            // the candidate name returned an item, but the item is the item
&nbsp;            // that the user is configuring so this is ok
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;        else {
&nbsp;            // the candidate name returned an item, so it is not unique
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks to see if the candidate displayName collides with any
&nbsp;     * existing display names or project names
&nbsp;     * @param displayName The display name to test
&nbsp;     * @param jobName The name of the job the user is configuring
&nbsp;     */
&nbsp;    public FormValidation doCheckDisplayName(@QueryParameter String displayName,
&nbsp;            @QueryParameter String jobName) {
<b class="nc">&nbsp;        displayName = displayName.trim();</b>
&nbsp;
<b class="nc">&nbsp;        LOGGER.fine(() -&gt; &quot;Current job name is &quot; + jobName);</b>
&nbsp;
<b class="nc">&nbsp;        if (!isNameUnique(displayName, jobName)) {</b>
<b class="nc">&nbsp;            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));</b>
&nbsp;        }
<b class="nc">&nbsp;        else if (!isDisplayNameUnique(displayName, jobName)) {</b>
<b class="nc">&nbsp;            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));</b>
&nbsp;        }
&nbsp;        else {
<b class="nc">&nbsp;            return FormValidation.ok();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class MasterComputer extends Computer {
&nbsp;        protected MasterComputer() {
<b class="nc">&nbsp;            super(Jenkins.get());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns &quot;&quot; to match with {@link Jenkins#getNodeName()}.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return &quot;&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isConnecting() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @NonNull
&nbsp;        @Override
&nbsp;        public String getDisplayName() {
<b class="nc">&nbsp;            return Messages.Hudson_Computer_DisplayName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getCaption() {
<b class="nc">&nbsp;            return Messages.Hudson_Computer_Caption();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String getUrl() {
<b class="nc">&nbsp;            return &quot;computer/(built-in)/&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public RetentionStrategy getRetentionStrategy() {
<b class="nc">&nbsp;            return RetentionStrategy.NOOP;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Will always keep this guy alive so that it can function as a fallback to
&nbsp;         * execute {@link FlyweightTask}s. See JENKINS-7291.
&nbsp;         */
&nbsp;        @Override
&nbsp;        protected boolean isAlive() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Boolean isUnix() {
<b class="nc">&nbsp;            return !Functions.isWindows();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Report an error.
&nbsp;         */
&nbsp;        @Override
&nbsp;        public HttpResponse doDoDelete() throws IOException {
<b class="nc">&nbsp;            throw HttpResponses.status(SC_BAD_REQUEST);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @POST
&nbsp;        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {
<b class="nc">&nbsp;            Jenkins.get().doConfigExecutorsSubmit(req, rsp);</b>
&nbsp;        }
&nbsp;
&nbsp;        @WebMethod(name = &quot;config.xml&quot;)
&nbsp;        @Override
&nbsp;        public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
<b class="nc">&nbsp;            throw HttpResponses.status(SC_BAD_REQUEST);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean hasPermission(Permission permission) {
&nbsp;            // no one should be allowed to delete the master.
&nbsp;            // this hides the &quot;delete&quot; link from the /computer/(master) page.
<b class="nc">&nbsp;            if (permission == Computer.DELETE)</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            // Configuration of master node requires ADMINISTER permission
<b class="nc">&nbsp;            return super.hasPermission(permission == Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public VirtualChannel getChannel() {
<b class="nc">&nbsp;            return FilePath.localChannel;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public Charset getDefaultCharset() {
<b class="nc">&nbsp;            return Charset.defaultCharset();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public List&lt;LogRecord&gt; getLogRecords() throws IOException, InterruptedException {
<b class="nc">&nbsp;            return logRecords;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @RequirePOST
&nbsp;        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
&nbsp;            // this computer never returns null from channel, so
&nbsp;            // this method shall never be invoked.
<b class="nc">&nbsp;            rsp.sendError(SC_NOT_FOUND);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Future&lt;?&gt; _connect(boolean forceReconnect) {
<b class="nc">&nbsp;            return Futures.precomputed(null);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@link LocalChannel} instance that can be used to execute programs locally.
&nbsp;         *
&nbsp;         * @deprecated as of 1.558
&nbsp;         *      Use {@link FilePath#localChannel}
&nbsp;         */
&nbsp;        @Deprecated
<b class="nc">&nbsp;        public static final LocalChannel localChannel = FilePath.localChannel;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shortcut for {@code Jenkins.getInstanceOrNull()?.lookup.get(type)}
&nbsp;     */
&nbsp;    public static @CheckForNull &lt;T&gt; T lookup(Class&lt;T&gt; type) {
<b class="nc">&nbsp;        Jenkins j = Jenkins.getInstanceOrNull();</b>
<b class="nc">&nbsp;        return j != null ? j.lookup.get(type) : null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Live view of recent {@link LogRecord}s produced by Jenkins.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_CANNOT_BE_FINAL&quot;, justification = &quot;cannot be made immutable without breaking compatibility&quot;)
<b class="fc">&nbsp;    public static List&lt;LogRecord&gt; logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Thread-safe reusable {@link XStream}.
&nbsp;     */
&nbsp;    public static final XStream XSTREAM;
&nbsp;
&nbsp;    /**
&nbsp;     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.
&nbsp;     */
&nbsp;    public static final XStream2 XSTREAM2;
&nbsp;
<b class="fc">&nbsp;    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Thread pool used to load configuration in parallel, to improve the start up time.
&nbsp;     * &lt;p&gt;
&nbsp;     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.
&nbsp;     */
<b class="nc">&nbsp;    /*package*/ final transient ExecutorService threadPoolForLoad = new ThreadPoolExecutor(</b>
&nbsp;        TWICE_CPU_NUM, TWICE_CPU_NUM,
&nbsp;        5L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(), new NamingThreadFactory(new DaemonThreadFactory(), &quot;Jenkins load&quot;));
&nbsp;
&nbsp;
&nbsp;    private static void computeVersion(ServletContext context) {
&nbsp;        // set the version
<b class="nc">&nbsp;        Properties props = new Properties();</b>
<b class="nc">&nbsp;        try (InputStream is = Jenkins.class.getResourceAsStream(&quot;jenkins-version.properties&quot;)) {</b>
<b class="nc">&nbsp;            if (is != null)</b>
<b class="nc">&nbsp;                props.load(is);</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            e.printStackTrace(); // if the version properties is missing, that&#39;s OK.</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        String ver = props.getProperty(&quot;version&quot;);</b>
<b class="nc">&nbsp;        if (ver == null)   ver = UNCOMPUTED_VERSION;</b>
<b class="nc">&nbsp;        if (Main.isDevelopmentMode &amp;&amp; &quot;${project.version}&quot;.equals(ver)) {</b>
&nbsp;            // in dev mode, unable to get version (ahem Eclipse)
&nbsp;            try {
<b class="nc">&nbsp;                File dir = new File(&quot;.&quot;).getAbsoluteFile();</b>
<b class="nc">&nbsp;                while (dir != null) {</b>
<b class="nc">&nbsp;                    File pom = new File(dir, &quot;pom.xml&quot;);</b>
<b class="nc">&nbsp;                    if (pom.exists() &amp;&amp; &quot;pom&quot;.equals(XMLUtils.getValue(&quot;/project/artifactId&quot;, pom))) {</b>
<b class="nc">&nbsp;                        pom =  pom.getCanonicalFile();</b>
<b class="nc">&nbsp;                        LOGGER.info(&quot;Reading version from: &quot; + pom.getAbsolutePath());</b>
<b class="nc">&nbsp;                        ver = XMLUtils.getValue(&quot;/project/version&quot;, pom);</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    dir = dir.getParentFile();</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                LOGGER.info(&quot;Jenkins is in dev mode, using version: &quot; + ver);</b>
<b class="nc">&nbsp;            } catch (Exception e) {</b>
<b class="nc">&nbsp;                LOGGER.log(WARNING, e, () -&gt; &quot;Unable to read Jenkins version: &quot; + e.getMessage());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        VERSION = ver;</b>
<b class="nc">&nbsp;        context.setAttribute(&quot;version&quot;, ver);</b>
&nbsp;
<b class="nc">&nbsp;        CHANGELOG_URL = props.getProperty(&quot;changelog.url&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);</b>
<b class="nc">&nbsp;        SESSION_HASH = Util.getDigestOf(ver + System.currentTimeMillis()).substring(0, 8);</b>
&nbsp;
<b class="nc">&nbsp;        if (ver.equals(UNCOMPUTED_VERSION) || SystemProperties.getBoolean(&quot;hudson.script.noCache&quot;))</b>
<b class="nc">&nbsp;            RESOURCE_PATH = &quot;&quot;;</b>
&nbsp;        else
<b class="nc">&nbsp;            RESOURCE_PATH = &quot;/static/&quot; + SESSION_HASH;</b>
&nbsp;
<b class="nc">&nbsp;        VIEW_RESOURCE_PATH = &quot;/resources/&quot; + SESSION_HASH;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The version number before it is &quot;computed&quot; (by a call to computeVersion()).
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static final String UNCOMPUTED_VERSION = &quot;?&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Version number of this Jenkins.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_CANNOT_BE_FINAL&quot;, justification = &quot;cannot be made immutable without breaking compatibility&quot;)
<b class="fc">&nbsp;    public static String VERSION = UNCOMPUTED_VERSION;</b>
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public static String CHANGELOG_URL;
&nbsp;
&nbsp;    /**
&nbsp;     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it&#39;s not parseable as a version number
&nbsp;     * (such as when Jenkins is run with {@code mvn jetty:run})
&nbsp;     */
&nbsp;    public @CheckForNull static VersionNumber getVersion() {
<b class="fc">&nbsp;        return toVersion(VERSION);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the stored version of Jenkins, as stored by
&nbsp;     * {@link #doConfigSubmit(org.kohsuke.stapler.StaplerRequest, org.kohsuke.stapler.StaplerResponse)}.
&nbsp;     * &lt;p&gt;
&nbsp;     * Parses the version into {@link VersionNumber}, or null if it&#39;s not parseable as a version number
&nbsp;     * (such as when Jenkins is run with {@code mvn jetty:run})
&nbsp;     * @since 2.0
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public @CheckForNull static VersionNumber getStoredVersion() {
<b class="nc">&nbsp;        return toVersion(Jenkins.get().version);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses a version string into {@link VersionNumber}, or null if it&#39;s not parseable as a version number
&nbsp;     * (such as when Jenkins is run with {@code mvn jetty:run})
&nbsp;     */
&nbsp;    private static @CheckForNull VersionNumber toVersion(@CheckForNull String versionString) {
<b class="fc">&nbsp;        if (versionString == null) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            return new VersionNumber(versionString);</b>
<b class="nc">&nbsp;        } catch (NumberFormatException e) {</b>
&nbsp;            try {
&nbsp;                // for non-released version of Jenkins, this looks like &quot;1.345 (private-foobar), so try to approximate.
<b class="nc">&nbsp;                int idx = versionString.indexOf(&#39; &#39;);</b>
<b class="nc">&nbsp;                if (idx &gt; 0) {</b>
<b class="nc">&nbsp;                    return new VersionNumber(versionString.substring(0, idx));</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (NumberFormatException ignored) {</b>
&nbsp;                // fall through
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            // totally unparseable
<b class="nc">&nbsp;            return null;</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
&nbsp;            // totally unparseable
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    public boolean shouldShowStackTrace() {
&nbsp;        // Used by oops.jelly
<b class="nc">&nbsp;        return Boolean.getBoolean(Jenkins.class.getName() + &quot;.SHOW_STACK_TRACE&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hash of {@link #VERSION}.
&nbsp;     */
&nbsp;    public static String VERSION_HASH;
&nbsp;
&nbsp;    /**
&nbsp;     * Unique random token that identifies the current session.
&nbsp;     * Used to make {@link #RESOURCE_PATH} unique so that we can set long &quot;Expires&quot; header.
&nbsp;     *
&nbsp;     * We used to use {@link #VERSION_HASH}, but making this session local allows us to
&nbsp;     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_CANNOT_BE_FINAL&quot;, justification = &quot;cannot be made immutable without breaking compatibility&quot;)
&nbsp;    public static String SESSION_HASH;
&nbsp;
&nbsp;    /**
&nbsp;     * Prefix to static resources like images and javascripts in the war file.
&nbsp;     * Either &quot;&quot; or strings like &quot;/static/VERSION&quot;, which avoids Jenkins to pick up
&nbsp;     * stale cache when the user upgrades to a different version.
&nbsp;     * &lt;p&gt;
&nbsp;     * Value computed in {@link WebAppMain}.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_CANNOT_BE_FINAL&quot;, justification = &quot;cannot be made immutable without breaking compatibility&quot;)
<b class="fc">&nbsp;    public static String RESOURCE_PATH = &quot;&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Prefix to resources alongside view scripts.
&nbsp;     * Strings like &quot;/resources/VERSION&quot;, which avoids Jenkins to pick up
&nbsp;     * stale cache when the user upgrades to a different version.
&nbsp;     * &lt;p&gt;
&nbsp;     * Value computed in {@link WebAppMain}.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_CANNOT_BE_FINAL&quot;, justification = &quot;cannot be made immutable without breaking compatibility&quot;)
<b class="fc">&nbsp;    public static String VIEW_RESOURCE_PATH = &quot;/resources/TBD&quot;;</b>
&nbsp;
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static boolean PARALLEL_LOAD = SystemProperties.getBoolean(Jenkins.class.getName() + &quot;.&quot; + &quot;parallelLoad&quot;, true);</b>
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static boolean KILL_AFTER_LOAD = SystemProperties.getBoolean(Jenkins.class.getName() + &quot;.&quot; + &quot;killAfterLoad&quot;, false);</b>
&nbsp;    /**
&nbsp;     * @deprecated No longer used.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static boolean FLYWEIGHT_SUPPORT = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Tentative switch to activate the concurrent build behavior.
&nbsp;     * When we merge this back to the trunk, this allows us to keep
&nbsp;     * this feature hidden for a while until we iron out the kinks.
&nbsp;     * @see AbstractProject#isConcurrentBuild()
&nbsp;     * @deprecated as of 1.464
&nbsp;     *      This flag will have no effect.
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static boolean CONCURRENT_BUILD = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Switch to enable people to use a shorter workspace name.
&nbsp;     */
<b class="fc">&nbsp;    private static final String WORKSPACE_DIRNAME = SystemProperties.getString(Jenkins.class.getName() + &quot;.&quot; + &quot;workspaceDirName&quot;, &quot;workspace&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Name of the system property escape hatch for SECURITY-2424. It allows to have back the legacy (and vulnerable)
&nbsp;     * behavior allowing a &quot;good name&quot; to end with a dot. This could be used to exploit two names colliding in the file
&nbsp;     * system to extract information. The files ending with a dot are only a problem on Windows.
&nbsp;     *
&nbsp;     * The default value is true.
&nbsp;     *
&nbsp;     * For detailed documentation: &lt;a href=&quot;https://docs.microsoft.com/en-us/troubleshoot/windows-client/shell-experience/file-folder-name-whitespace-characters&quot;&gt;Support for Whitespace characters in File and Folder names for Windows&lt;/a&gt;
&nbsp;     * @see #checkGoodName(String)
&nbsp;     */
&nbsp;    @Restricted(NoExternalUse.class)
<b class="fc">&nbsp;    public static final String NAME_VALIDATION_REJECTS_TRAILING_DOT_PROP = Jenkins.class.getName() + &quot;.&quot; + &quot;nameValidationRejectsTrailingDot&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Default value of job&#39;s builds dir.
&nbsp;     * @see #getRawBuildsDir()
&nbsp;     */
&nbsp;    private static final String DEFAULT_BUILDS_DIR = &quot;${ITEM_ROOTDIR}/builds&quot;;
&nbsp;    /**
&nbsp;     * Old layout for workspaces.
&nbsp;     * @see #DEFAULT_WORKSPACES_DIR
&nbsp;     */
<b class="fc">&nbsp;    private static final String OLD_DEFAULT_WORKSPACES_DIR = &quot;${ITEM_ROOTDIR}/&quot; + WORKSPACE_DIRNAME;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Default value for the workspace&#39;s directories layout.
&nbsp;     * @see #workspaceDir
&nbsp;     */
&nbsp;    private static final String DEFAULT_WORKSPACES_DIR = &quot;${JENKINS_HOME}/workspace/${ITEM_FULL_NAME}&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * System property name to set {@link #buildsDir}.
&nbsp;     * @see #getRawBuildsDir()
&nbsp;     */
<b class="fc">&nbsp;    static final String BUILDS_DIR_PROP = Jenkins.class.getName() + &quot;.buildsDir&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * System property name to set {@link #workspaceDir}.
&nbsp;     * @see #getRawWorkspaceDir()
&nbsp;     */
<b class="fc">&nbsp;    static final String WORKSPACES_DIR_PROP = Jenkins.class.getName() + &quot;.workspacesDir&quot;;</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Automatically try to launch an agent when Jenkins is initialized or a new agent computer is created.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static boolean AUTOMATIC_AGENT_LAUNCH = SystemProperties.getBoolean(Jenkins.class.getName() + &quot;.automaticAgentLaunch&quot;, true);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The amount of time by which to extend the startup notification timeout as each initialization milestone is attained.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;MS_SHOULD_BE_FINAL&quot;, justification = &quot;for script console&quot;)
<b class="fc">&nbsp;    public static /* not final */ int EXTEND_TIMEOUT_SECONDS = SystemProperties.getInteger(Jenkins.class.getName() + &quot;.extendTimeoutSeconds&quot;, 15);</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());</b>
<b class="fc">&nbsp;    private static final SecureRandom RANDOM = new SecureRandom();</b>
&nbsp;
<b class="fc">&nbsp;    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;</b>
<b class="fc">&nbsp;    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This permission grants access to parts of the Jenkins system configuration.
&nbsp;     *
&nbsp;     * &lt;p&gt;Only features that won&#39;t have an impact on Jenkins&#39; overall security and stability should have their
&nbsp;     * permission requirement lowered from {@link #ADMINISTER} to {@code MANAGE}.
&nbsp;     * For example, many scripting and code execution features (e.g., configuring master agents, paths to tools on master, etc.)
&nbsp;     * are unsafe to make available to users with only this permission,
&nbsp;     * as they could be used to bypass permission enforcement and elevate permissions.&lt;/p&gt;
&nbsp;     *
&nbsp;     * &lt;p&gt;This permission is disabled by default and support for it considered experimental.
&nbsp;     * Administrators can set the system property {@code jenkins.security.ManagePermission} to enable it.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @since 2.222
&nbsp;     */
&nbsp;    @Restricted(Beta.class)
<b class="fc">&nbsp;    public static final Permission MANAGE = new Permission(PERMISSIONS, &quot;Manage&quot;,</b>
<b class="fc">&nbsp;            Messages._Jenkins_Manage_Description(),</b>
&nbsp;            ADMINISTER,
<b class="fc">&nbsp;            SystemProperties.getBoolean(&quot;jenkins.security.ManagePermission&quot;),</b>
&nbsp;            new PermissionScope[]{PermissionScope.JENKINS});
&nbsp;
&nbsp;    /**
&nbsp;     * Allows read-only access to large parts of the system configuration.
&nbsp;     *
&nbsp;     * When combined with {@link #MANAGE}, it is expected that everything is shown as if only {@link #SYSTEM_READ} was granted,
&nbsp;     * but that only options editable by users with {@link #MANAGE} are editable.
&nbsp;     */
<b class="fc">&nbsp;    public static final Permission SYSTEM_READ = new Permission(PERMISSIONS, &quot;SystemRead&quot;,</b>
<b class="fc">&nbsp;            Messages._Jenkins_SystemRead_Description(),</b>
&nbsp;            ADMINISTER,
<b class="fc">&nbsp;            SystemProperties.getBoolean(&quot;jenkins.security.SystemReadPermission&quot;),</b>
&nbsp;            new PermissionScope[]{PermissionScope.JENKINS});
&nbsp;
&nbsp;    @Restricted(NoExternalUse.class) // called by jelly
<b class="fc">&nbsp;    public static final Permission[] MANAGE_AND_SYSTEM_READ =</b>
&nbsp;            new Permission[] { MANAGE, SYSTEM_READ };
&nbsp;
<b class="fc">&nbsp;    public static final Permission READ = new Permission(PERMISSIONS, &quot;Read&quot;, Messages._Hudson_ReadPermission_Description(), Permission.READ, PermissionScope.JENKINS);</b>
&nbsp;    /** @deprecated in Jenkins 2.222 use {@link Jenkins#ADMINISTER} instead */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, &quot;RunScripts&quot;, Messages._Hudson_RunScriptsPermission_Description(), ADMINISTER, PermissionScope.JENKINS);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Urls that are always visible without READ permission.
&nbsp;     *
&nbsp;     * &lt;p&gt;See also:{@link #getUnprotectedRootActions}.
&nbsp;     */
<b class="fc">&nbsp;    private static final Set&lt;String&gt; ALWAYS_READABLE_PATHS = new HashSet&lt;&gt;(Arrays.asList(</b>
&nbsp;        &quot;404&quot;, // Web method
&nbsp;        &quot;_404&quot;, // .jelly
&nbsp;        &quot;_404_simple&quot;, // .jelly
&nbsp;        &quot;login&quot;, // .jelly
&nbsp;        &quot;loginError&quot;, // .jelly
&nbsp;        &quot;logout&quot;, // #doLogout
&nbsp;        &quot;accessDenied&quot;, // .jelly
&nbsp;        &quot;adjuncts&quot;, // #getAdjuncts
&nbsp;        &quot;error&quot;, // AbstractModelObject/error.jelly
&nbsp;        &quot;oops&quot;, // .jelly
&nbsp;        &quot;signup&quot;, // #doSignup
&nbsp;        &quot;tcpSlaveAgentListener&quot;, // #getTcpSlaveAgentListener
&nbsp;        &quot;federatedLoginService&quot;, // #getFederatedLoginService
&nbsp;        &quot;securityRealm&quot; // #getSecurityRealm
&nbsp;    ));
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        final String paths = SystemProperties.getString(Jenkins.class.getName() + &quot;.additionalReadablePaths&quot;);</b>
<b class="fc">&nbsp;        if (paths != null) {</b>
<b class="nc">&nbsp;            LOGGER.info(() -&gt; &quot;SECURITY-2047 override: Adding the following paths to ALWAYS_READABLE_PATHS: &quot; + paths);</b>
<b class="nc">&nbsp;            ALWAYS_READABLE_PATHS.addAll(Arrays.stream(paths.split(&quot;,&quot;)).map(String::trim).collect(Collectors.toSet()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@link Authentication} object that represents the anonymous user.
&nbsp;     * Because Spring Security creates its own {@link AnonymousAuthenticationToken} instances, the code must not
&nbsp;     * expect the singleton semantics. This is just a convenient instance.
&nbsp;     *
&nbsp;     * @since 2.266
&nbsp;     */
<b class="fc">&nbsp;    public static final Authentication ANONYMOUS2 =</b>
&nbsp;            new AnonymousAuthenticationToken(
&nbsp;                    &quot;anonymous&quot;,
&nbsp;                    &quot;anonymous&quot;,
<b class="fc">&nbsp;                    Set.of(new SimpleGrantedAuthority(&quot;anonymous&quot;)));</b>
&nbsp;
&nbsp;    /**
&nbsp;     * @deprecated use {@link #ANONYMOUS2}
&nbsp;     * @since 1.343
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    public static final org.acegisecurity.Authentication ANONYMOUS =</b>
&nbsp;            new org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken(
&nbsp;                    &quot;anonymous&quot;,
&nbsp;                    &quot;anonymous&quot;,
&nbsp;                    new org.acegisecurity.GrantedAuthority[] {
&nbsp;                        new org.acegisecurity.GrantedAuthorityImpl(&quot;anonymous&quot;),
&nbsp;                    });
&nbsp;
&nbsp;    static {
&nbsp;        try {
<b class="fc">&nbsp;            XSTREAM = XSTREAM2 = new XStream2();</b>
&nbsp;
<b class="fc">&nbsp;            XSTREAM.alias(&quot;jenkins&quot;, Jenkins.class);</b>
<b class="fc">&nbsp;            XSTREAM.alias(&quot;slave&quot;, DumbSlave.class);</b>
<b class="fc">&nbsp;            XSTREAM.alias(&quot;jdk&quot;, JDK.class);</b>
&nbsp;            // for backward compatibility with &lt;1.75, recognize the tag name &quot;view&quot; as well.
<b class="fc">&nbsp;            XSTREAM.alias(&quot;view&quot;, ListView.class);</b>
<b class="fc">&nbsp;            XSTREAM.alias(&quot;listView&quot;, ListView.class);</b>
<b class="fc">&nbsp;            XSTREAM.addImplicitArray(Jenkins.class, &quot;_disabledAgentProtocols&quot;, &quot;disabledAgentProtocol&quot;);</b>
<b class="fc">&nbsp;            XSTREAM.addImplicitArray(Jenkins.class, &quot;_enabledAgentProtocols&quot;, &quot;enabledAgentProtocol&quot;);</b>
<b class="fc">&nbsp;            XSTREAM2.addCriticalField(Jenkins.class, &quot;securityRealm&quot;);</b>
<b class="fc">&nbsp;            XSTREAM2.addCriticalField(Jenkins.class, &quot;authorizationStrategy&quot;);</b>
&nbsp;            // this seems to be necessary to force registration of converter early enough
<b class="fc">&nbsp;            Mode.class.getEnumConstants();</b>
&nbsp;
&nbsp;            // double check that initialization order didn&#39;t do any harm
<b class="fc">&nbsp;            assert PERMISSIONS != null;</b>
<b class="fc">&nbsp;            assert ADMINISTER != null;</b>
&nbsp;
<b class="nc">&nbsp;        } catch (RuntimeException | Error e) {</b>
&nbsp;            // when loaded on an agent and this fails, subsequent NoClassDefFoundError will fail to chain the cause.
&nbsp;            // see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8051847
&nbsp;            // As we don&#39;t know where the first exception will go, let&#39;s also send this to logging so that
&nbsp;            // we have a known place to look at.
<b class="nc">&nbsp;            LOGGER.log(SEVERE, &quot;Failed to load Jenkins.class&quot;, e);</b>
<b class="nc">&nbsp;            throw e;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private static final class JenkinsJVMAccess extends JenkinsJVM {
&nbsp;        private static void _setJenkinsJVM(boolean jenkinsJVM) {
<b class="nc">&nbsp;            JenkinsJVM.setJenkinsJVM(jenkinsJVM);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class QuietDownInfo {
&nbsp;        @CheckForNull
&nbsp;        final String message;
&nbsp;
&nbsp;        private boolean safeRestart;
&nbsp;
&nbsp;        QuietDownInfo() {
<b class="nc">&nbsp;            this(null, false);</b>
&nbsp;        }
&nbsp;
&nbsp;        QuietDownInfo(final String message) {
<b class="nc">&nbsp;            this(message, false);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        QuietDownInfo(final String message, final boolean safeRestart) {</b>
<b class="nc">&nbsp;                this.message = message;</b>
<b class="nc">&nbsp;                this.safeRestart = safeRestart;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        boolean isSafeRestart() {
<b class="nc">&nbsp;            return safeRestart;</b>
&nbsp;        }
&nbsp;
&nbsp;        void setSafeRestart(boolean safeRestart) {
<b class="nc">&nbsp;            this.safeRestart = safeRestart;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-28 17:37</div>
</div>
</body>
</html>
